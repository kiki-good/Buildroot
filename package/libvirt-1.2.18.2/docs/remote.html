<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<!--
        This file is autogenerated from remote.html.in
        Do not edit this file. Changes will be lost.
      -->
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <link rel="stylesheet" type="text/css" href="main.css" />
    <link rel="SHORTCUT ICON" href="32favicon.png" />
    <title>libvirt: Remote support</title>
    <meta name="description" content="libvirt, virtualization, virtualization API" />
  </head>
  <body>
    <div id="header">
      <div id="headerLogo"></div>
      <div id="headerSearch">
        <form action="search.php" enctype="application/x-www-form-urlencoded" method="get"><div>
            <input id="query" name="query" type="text" size="12" value="" />
            <input id="submit" name="submit" type="submit" value="Search" />
          </div></form>
      </div>
    </div>
    <div id="body">
      <div id="menu">
        <ul class="l0"><li>
            <div>
              <a title="Front page of the libvirt website" class="inactive" href="index.html">Home</a>
            </div>
          </li><li>
            <div>
              <a title="Details of new features and bugs fixed in each release" class="inactive" href="news.html">News</a>
            </div>
          </li><li>
            <div>
              <a title="Applications known to use libvirt" class="inactive" href="apps.html">Applications</a>
            </div>
          </li><li>
            <div>
              <a title="Get the latest source releases, binary builds and get access to the source repository" class="inactive" href="downloads.html">Downloads</a>
            </div>
          </li><li>
            <div>
              <a title="Information for users, administrators and developers" class="active" href="docs.html">Documentation</a>
              <ul class="l1"><li>
                  <div>
                    <a title="How to compile libvirt" class="inactive" href="compiling.html">Compiling</a>
                  </div>
                </li><li>
                  <div>
                    <a title="Information about deploying and using libvirt" class="active" href="deployment.html">Deployment</a>
                    <ul class="l2"><li>
                        <div>
                          <a title="The URI formats used for connecting to libvirt" class="inactive" href="uri.html">URI format</a>
                        </div>
                      </li><li>
                        <div>
                          <span class="active">Remote access</span>
                        </div>
                      </li><li>
                        <div>
                          <a title="Configure authentication for the libvirt daemon" class="inactive" href="auth.html">Authentication</a>
                        </div>
                      </li><li>
                        <div>
                          <a title="Configure access control libvirt APIs" class="inactive" href="acl.html">Access control</a>
                        </div>
                      </li><li>
                        <div>
                          <a title="Migrating guests between machines" class="inactive" href="migration.html">Migration</a>
                        </div>
                      </li><li>
                        <div>
                          <a title="Access the libvirt daemon from a native Windows client" class="inactive" href="windows.html">Windows port</a>
                        </div>
                      </li><li>
                        <div>
                          <a title="The library and the daemon logging support" class="inactive" href="logging.html">Logging</a>
                        </div>
                      </li><li>
                        <div>
                          <a title="Audit trail logs for host operations" class="inactive" href="auditlog.html">Audit log</a>
                        </div>
                      </li><li>
                        <div>
                          <a title="Firewall and network filter configuration" class="inactive" href="firewall.html">Firewall</a>
                        </div>
                      </li><li>
                        <div>
                          <a title="Ensuring exclusive guest access to disks" class="inactive" href="locking.html">Disk locking</a>
                        </div>
                      </li><li>
                        <div>
                          <a title="Control groups integration" class="inactive" href="cgroups.html">CGroups</a>
                        </div>
                      </li><li>
                        <div>
                          <a title="Hooks for system specific management" class="inactive" href="hooks.html">Hooks</a>
                        </div>
                      </li></ul>
                  </div>
                </li><li>
                  <div>
                    <a title="Overview of the logical subsystems in the libvirt API" class="inactive" href="intro.html">Architecture</a>
                  </div>
                </li><li>
                  <div>
                    <a title="Description of the XML formats used in libvirt" class="inactive" href="format.html">XML format</a>
                  </div>
                </li><li>
                  <div>
                    <a title="Hypervisor specific driver information" class="inactive" href="drivers.html">Drivers</a>
                  </div>
                </li><li>
                  <div>
                    <a title="Reference manual for the C public API" class="inactive" href="html/index.html">API reference</a>
                  </div>
                </li><li>
                  <div>
                    <a title="Bindings of the libvirt API for other languages" class="inactive" href="bindings.html">Language bindings</a>
                  </div>
                </li><li>
                  <div>
                    <a title="Working on the internals of libvirt API, driver and daemon code" class="inactive" href="internals.html">Internals</a>
                  </div>
                </li><li>
                  <div>
                    <a title="A guide and reference for developing with libvirt" class="inactive" href="devguide.html">Development Guide</a>
                  </div>
                </li><li>
                  <div>
                    <a title="Command reference for virsh" class="inactive" href="virshcmdref.html">Virsh Commands</a>
                  </div>
                </li><li>
                  <div>
                    <a title="Project governance and code of conduct" class="inactive" href="governance.html">Governance</a>
                  </div>
                </li></ul>
            </div>
          </li><li>
            <div>
              <a title="User contributed content" class="inactive" href="http://wiki.libvirt.org">Wiki</a>
            </div>
          </li><li>
            <div>
              <a title="Frequently asked questions" class="inactive" href="http://wiki.libvirt.org/page/FAQ">FAQ</a>
            </div>
          </li><li>
            <div>
              <a title="How and where to report bugs and request features" class="inactive" href="bugs.html">Bug reports</a>
            </div>
          </li><li>
            <div>
              <a title="How to contact the developers via email and IRC" class="inactive" href="contact.html">Contact</a>
            </div>
          </li><li>
            <div>
              <a title="Available test suites for libvirt" class="inactive" href="testsuites.html">Test suites</a>
            </div>
          </li><li>
            <div>
              <a title="Miscellaneous links of interest related to libvirt" class="inactive" href="relatedlinks.html">Related Links</a>
            </div>
          </li><li>
            <div>
              <a title="Overview of all content on the website" class="inactive" href="sitemap.html">Sitemap</a>
            </div>
          </li></ul>
      </div>
      <div id="content">
        <h1>Remote support</h1>
        <p>
Libvirt allows you to access hypervisors running on remote
machines through authenticated and encrypted connections.
</p>
        <ul><li>
        <a href="#Remote_basic_usage" shape="rect">Basic usage</a>
      </li><li>
        <a href="#Remote_transports" shape="rect">Transports</a>
      </li><li>
        <a href="#Remote_URI_reference" shape="rect">Remote URIs</a>
        <ul><li>
            <a href="#Remote_URI_parameters" shape="rect">Extra parameters</a>
          </li></ul>
      </li><li>
        <a href="#Remote_certificates" shape="rect">Generating TLS certificates</a>
        <ul><li>
            <a href="#Remote_PKI" shape="rect">Public Key Infrastructure set up</a>
          </li><li>
            <a href="#Remote_TLS_background" shape="rect">Background to TLS certificates</a>
          </li><li>
            <a href="#Remote_TLS_CA" shape="rect">Setting up a Certificate Authority (CA)</a>
          </li><li>
            <a href="#Remote_TLS_server_certificates" shape="rect">Issuing server certificates</a>
          </li><li>
            <a href="#Remote_TLS_client_certificates" shape="rect">Issuing client certificates</a>
          </li><li>
            <a href="#Remote_TLS_troubleshooting" shape="rect">Troubleshooting TLS certificate problems</a>
          </li></ul>
      </li><li>
        <a href="#Remote_libvirtd_configuration" shape="rect">libvirtd configuration file</a>
      </li><li>
        <a href="#Remote_IPv6" shape="rect">IPv6 support</a>
      </li><li>
        <a href="#Remote_limitations" shape="rect">Limitations</a>
      </li></ul>
        <h3>
      <a name="Remote_basic_usage" shape="rect" id="Remote_basic_usage">Basic usage</a>
    <a class="headerlink" href="#Remote_basic_usage" title="Permalink to this headline">¶</a></h3>
        <p>
On the remote machine, <code>libvirtd</code> should be running in general.
See <a href="#Remote_libvirtd_configuration" shape="rect">the section
on configuring libvirtd</a> for more information.
</p>
        <p>
    Not all hypervisors supported by libvirt require a running
    <code>libvirtd</code>. If you want to connect to a VMware ESX/ESXi or
    GSX server then <code>libvirtd</code> is not necessary. See the
    <a href="drvesx.html" shape="rect">VMware ESX page</a> for details.
    </p>
        <p>
To tell libvirt that you want to access a remote resource,
you should supply a hostname in the normal <a href="uri.html" shape="rect">URI</a> that is passed
to <code>virConnectOpen</code> (or <code>virsh -c ...</code>).
For example, if you normally use <code>qemu:///system</code>
to access the system-wide QEMU daemon, then to access
the system-wide QEMU daemon on a remote machine called
<code>oirase</code> you would use <code>qemu://oirase/system</code>.
</p>
        <p>
The <a href="#Remote_URI_reference" shape="rect">section on remote URIs</a>
describes in more detail these remote URIs.
</p>
        <p>
From an API point of view, apart from the change in URI, the
API should behave the same.  For example, ordinary calls
are routed over the remote connection transparently, and
values or errors from the remote side are returned to you
as if they happened locally.  Some differences you may notice:
</p>
        <ul><li> Additional errors can be generated, specifically ones
relating to failures in the remote transport itself. </li><li> Remote calls are handled synchronously, so they will be
much slower than, say, direct hypervisor calls. </li></ul>
        <h3>
      <a name="Remote_transports" shape="rect" id="Remote_transports">Transports</a>
    <a class="headerlink" href="#Remote_transports" title="Permalink to this headline">¶</a></h3>
        <p>
Remote libvirt supports a range of transports:
</p>
        <dl><dt> tls </dt><dd><a href="http://en.wikipedia.org/wiki/Transport_Layer_Security" title="Transport Layer Security" shape="rect">TLS</a>
 1.0 (SSL 3.1) authenticated and encrypted TCP/IP socket, usually
 listening on a public port number.  To use this you will need to
 <a href="#Remote_certificates" title="Generating TLS certificates" shape="rect">generate client and
 server certificates</a>.
 The standard port is 16514.
 </dd><dt> unix </dt><dd> Unix domain socket.  Since this is only accessible on the
 local machine, it is not encrypted, and uses Unix permissions or
 SELinux for authentication.
 The standard socket names are
 <code>/var/run/libvirt/libvirt-sock</code> and
 <code>/var/run/libvirt/libvirt-sock-ro</code> (the latter
 for read-only connections).
 </dd><dt> ssh </dt><dd> Transported over an ordinary
 <a href="http://www.openssh.com/" title="OpenSSH homepage" shape="rect">ssh
 (secure shell)</a> connection.
 Requires <a href="http://netcat.sourceforge.net/" shape="rect">Netcat (nc)</a>
 installed and libvirtd should be running
 on the remote machine.  You should use some sort of
 ssh key management (eg.
 <a href="http://mah.everybody.org/docs/ssh" title="Using ssh-agent with ssh" shape="rect">ssh-agent</a>)
 otherwise programs which use
 this transport will stop to ask for a password. </dd><dt> ext </dt><dd> Any external program which can make a connection to the
 remote machine by means outside the scope of libvirt. </dd><dt> tcp </dt><dd> Unencrypted TCP/IP socket.  Not recommended for production
 use, this is normally disabled, but an administrator can enable
 it for testing or use over a trusted network.
 The standard port is 16509. </dd><dt> libssh2 </dt><dd> Transport over the SSH protocol using
      <a href="http://libssh2.org/" title="libssh2 homepage" shape="rect">libssh2</a> instead
of the OpenSSH binary. This transport uses the libvirt authentication callback for
all ssh authentication calls and therefore supports keyboard-interactive authentication
even with graphical management applications. As with the classic ssh transport
netcat is required on the remote side.</dd></dl>
        <p>
The default transport, if no other is specified, is <code>tls</code>.
</p>
        <h3>
      <a name="Remote_URI_reference" shape="rect" id="Remote_URI_reference">Remote URIs</a>
    <a class="headerlink" href="#Remote_URI_reference" title="Permalink to this headline">¶</a></h3>
        <p>
See also: <a href="uri.html" shape="rect">documentation on ordinary ("local") URIs</a>.
</p>
        <p>
Remote URIs have the general form ("[...]" meaning an optional part):
</p>
        <p><code>driver</code>[<code>+transport</code>]<code>://</code>[<code>username@</code>][<code>hostname</code>][<code>:port</code>]<code>/</code>[<code>path</code>][<code>?extraparameters</code>]
</p>
        <p>
Either the transport or the hostname must be given in order
to distinguish this from a local URI.
</p>
        <p>
Some examples:
</p>
        <ul><li><code>xen+ssh://rjones@towada/</code><br /> — Connect to a
remote Xen hypervisor on host <code>towada</code> using ssh transport and ssh
username <code>rjones</code>.
</li><li><code>xen://towada/</code><br /> — Connect to a
remote Xen hypervisor on host <code>towada</code> using TLS.
</li><li><code>xen://towada/?no_verify=1</code><br /> — Connect to a
remote Xen hypervisor on host <code>towada</code> using TLS.  Do not verify
the server's certificate.
</li><li><code>qemu+unix:///system?socket=/opt/libvirt/run/libvirt/libvirt-sock</code><br /> —
Connect to the local qemu instances over a non-standard
Unix socket (the full path to the Unix socket is
supplied explicitly in this case).
</li><li><code>test+tcp://localhost:5000/default</code><br /> —
Connect to a libvirtd daemon offering unencrypted TCP/IP connections
on localhost port 5000 and use the test driver with default
settings.
</li><li><code>qemu+libssh2://user@host/system?known_hosts=/home/user/.ssh/known_hosts</code><br /> —
Connect to a remote host using a ssh connection with the libssh2 driver
and use a different known_hosts file.</li></ul>
        <h4>
      <a name="Remote_URI_parameters" shape="rect" id="Remote_URI_parameters">Extra parameters</a>
    <a class="headerlink" href="#Remote_URI_parameters" title="Permalink to this headline">¶</a></h4>
        <p>
Extra parameters can be added to remote URIs as part
of the query string (the part following <q><code>?</code></q>).
Remote URIs understand the extra parameters shown below.
Any others are passed unmodified through to the back end.
Note that parameter values must be
<a href="http://xmlsoft.org/html/libxml-uri.html#xmlURIEscapeStr" shape="rect">URI-escaped</a>.
</p>
        <table class="top_table"><tr><th rowspan="1" colspan="1"> Name </th><th rowspan="1" colspan="1"> Transports </th><th rowspan="1" colspan="1"> Meaning </th></tr><tr><td rowspan="1" colspan="1">
          <code>name</code>
        </td><td rowspan="1" colspan="1">
          <i>any transport</i>
        </td><td rowspan="1" colspan="1">
  The name passed to the remote virConnectOpen function.  The
  name is normally formed by removing transport, hostname, port
  number, username and extra parameters from the remote URI, but in certain
  very complex cases it may be better to supply the name explicitly.
</td></tr><tr><td colspan="2" rowspan="1"></td><td rowspan="1" colspan="1"> Example: <code>name=qemu:///system</code> </td></tr><tr><td rowspan="1" colspan="1">
          <code>command</code>
        </td><td rowspan="1" colspan="1"> ssh, ext </td><td rowspan="1" colspan="1">
  The external command.  For ext transport this is required.
  For ssh the default is <code>ssh</code>.
  The PATH is searched for the command.
</td></tr><tr><td colspan="2" rowspan="1"></td><td rowspan="1" colspan="1"> Example: <code>command=/opt/openssh/bin/ssh</code> </td></tr><tr><td rowspan="1" colspan="1">
          <code>socket</code>
        </td><td rowspan="1" colspan="1"> unix, ssh, libssh2 </td><td rowspan="1" colspan="1">
  The path to the Unix domain socket, which overrides the
  compiled-in default.  For ssh transport, this is passed to
  the remote netcat command (see next).
</td></tr><tr><td colspan="2" rowspan="1"></td><td rowspan="1" colspan="1"> Example: <code>socket=/opt/libvirt/run/libvirt/libvirt-sock</code> </td></tr><tr><td rowspan="1" colspan="1">
          <code>netcat</code>
        </td><td rowspan="1" colspan="1"> ssh, libssh2 </td><td rowspan="1" colspan="1">
  The name of the netcat command on the remote machine.
  The default is <code>nc</code>.  For ssh transport, libvirt
  constructs an ssh command which looks like:

<pre xml:space="preserve"><i>command</i> -p <i>port</i> [-l <i>username</i>] <i>hostname</i> <i>netcat</i> -U <i>socket</i>
</pre>

  where <i>port</i>, <i>username</i>, <i>hostname</i> can be
  specified as part of the remote URI, and <i>command</i>, <i>netcat</i>
  and <i>socket</i> come from extra parameters (or
  sensible defaults).

</td></tr><tr><td colspan="2" rowspan="1"></td><td rowspan="1" colspan="1"> Example: <code>netcat=/opt/netcat/bin/nc</code> </td></tr><tr><td rowspan="1" colspan="1">
          <code>keyfile</code>
        </td><td rowspan="1" colspan="1"> ssh, libssh2 </td><td rowspan="1" colspan="1">
  The name of the private key file to use to authentication to the remote
  machine.  If this option is not used the default keys are used.
        </td></tr><tr><td colspan="2" rowspan="1"></td><td rowspan="1" colspan="1"> Example: <code>keyfile=/root/.ssh/example_key</code> </td></tr><tr><td rowspan="1" colspan="1">
          <code>no_verify</code>
        </td><td rowspan="1" colspan="1"> ssh, tls </td><td rowspan="1" colspan="1">
  SSH: If set to a non-zero value, this disables client's strict host key
  checking making it auto-accept new host keys.  Existing host keys will
  still be validated.
  <br />
  <br />
  TLS: If set to a non-zero value, this disables client checks of the
  server's certificate.  Note that to disable server checks of
  the client's certificate or IP address you must
  <a href="#Remote_libvirtd_configuration" shape="rect">change the libvirtd
  configuration</a>.
</td></tr><tr><td colspan="2" rowspan="1"></td><td rowspan="1" colspan="1"> Example: <code>no_verify=1</code> </td></tr><tr><td rowspan="1" colspan="1">
          <code>no_tty</code>
        </td><td rowspan="1" colspan="1"> ssh </td><td rowspan="1" colspan="1">
  If set to a non-zero value, this stops ssh from asking for
  a password if it cannot log in to the remote machine automatically
  (eg. using ssh-agent etc.).  Use this when you don't have access
  to a terminal - for example in graphical programs which use libvirt.
</td></tr><tr><td colspan="2" rowspan="1"></td><td rowspan="1" colspan="1"> Example: <code>no_tty=1</code> </td></tr><tr><td rowspan="1" colspan="1">
          <code>pkipath</code>
        </td><td rowspan="1" colspan="1"> tls</td><td rowspan="1" colspan="1">
          Specifies x509 certificates path for the client. If any of
          the CA certificate, client certificate, or client key is
          missing, the connection will fail with a fatal error.
        </td></tr><tr><td colspan="2" rowspan="1"></td><td rowspan="1" colspan="1"> Example: <code>pkipath=/tmp/pki/client</code> </td></tr><tr><td rowspan="1" colspan="1">
          <code>known_hosts</code>
        </td><td rowspan="1" colspan="1"> libssh2 </td><td rowspan="1" colspan="1">
  Path to the known_hosts file to verify the host key against. LibSSH2
  supports OpenSSH-style known_hosts files, although it does not support
  all key types, so using files created by the OpenSSH binary may result
  into truncating the known_hosts file. It's recommended to use the default
  known_hosts file is located in libvirt's client local configuration
  directory e.g.: ~/.config/libvirt/known_hosts. Note: Use absolute paths.
</td></tr><tr><td colspan="2" rowspan="1"></td><td rowspan="1" colspan="1"> Example: <code>known_hosts=/root/.ssh/known_hosts</code> </td></tr><tr><td rowspan="1" colspan="1">
          <code>sshauth</code>
        </td><td rowspan="1" colspan="1"> libssh2 </td><td rowspan="1" colspan="1">
  A comma separated list of authentication methods to use. Default (is
  "agent,privkey,keyboard-interactive". The order of the methods is preserved.
  Some methods may require additional parameters.
</td></tr><tr><td colspan="2" rowspan="1"></td><td rowspan="1" colspan="1"> Example: <code>sshauth=privkey,agent</code> </td></tr></table>
        <h3>
      <a name="Remote_certificates" shape="rect" id="Remote_certificates">Generating TLS certificates</a>
    <a class="headerlink" href="#Remote_certificates" title="Permalink to this headline">¶</a></h3>
        <h4>
      <a name="Remote_PKI" shape="rect" id="Remote_PKI">Public Key Infrastructure set up</a>
    <a class="headerlink" href="#Remote_PKI" title="Permalink to this headline">¶</a></h4>
        <p>
If you are unsure how to create TLS certificates, skip to the
next section.
</p>
        <table class="top_table"><tr><th rowspan="1" colspan="1"> Location </th><th rowspan="1" colspan="1"> Machine </th><th rowspan="1" colspan="1"> Description </th><th rowspan="1" colspan="1"> Required fields </th></tr><tr><td rowspan="1" colspan="1">
          <code>/etc/pki/CA/cacert.pem</code>
        </td><td rowspan="1" colspan="1"> Installed on all clients and servers </td><td rowspan="1" colspan="1"> CA's certificate (<a href="#Remote_TLS_CA" shape="rect">more info</a>)</td><td rowspan="1" colspan="1"> n/a </td></tr><tr><td rowspan="1" colspan="1">
          <code>/etc/pki/libvirt/ private/serverkey.pem</code>
        </td><td rowspan="1" colspan="1"> Installed on the server </td><td rowspan="1" colspan="1"> Server's private key (<a href="#Remote_TLS_server_certificates" shape="rect">more info</a>)</td><td rowspan="1" colspan="1"> n/a </td></tr><tr><td rowspan="1" colspan="1">
          <code>/etc/pki/libvirt/ servercert.pem</code>
        </td><td rowspan="1" colspan="1"> Installed on the server </td><td rowspan="1" colspan="1"> Server's certificate signed by the CA.
 (<a href="#Remote_TLS_server_certificates" shape="rect">more info</a>) </td><td rowspan="1" colspan="1"> CommonName (CN) must be the hostname of the server as it
  is seen by clients. </td></tr><tr><td rowspan="1" colspan="1">
          <code>/etc/pki/libvirt/ private/clientkey.pem</code>
        </td><td rowspan="1" colspan="1"> Installed on the client </td><td rowspan="1" colspan="1"> Client's private key. (<a href="#Remote_TLS_client_certificates" shape="rect">more info</a>) </td><td rowspan="1" colspan="1"> n/a </td></tr><tr><td rowspan="1" colspan="1">
          <code>/etc/pki/libvirt/ clientcert.pem</code>
        </td><td rowspan="1" colspan="1"> Installed on the client </td><td rowspan="1" colspan="1"> Client's certificate signed by the CA
  (<a href="#Remote_TLS_client_certificates" shape="rect">more info</a>) </td><td rowspan="1" colspan="1"> Distinguished Name (DN) can be checked against an access
  control list (<code>tls_allowed_dn_list</code>).
  </td></tr></table>
        <p>
      If 'pkipath' is specified in URI, then all the client
      certificates must be found in the path specified, otherwise the
      connection will fail with a fatal error. If 'pkipath' is not
      specified:
    </p>
        <ul><li> For a non-root user, libvirt tries to find the certificates
        in $HOME/.pki/libvirt. If the required CA certificate cannot
        be found, then the global default location
        (/etc/pki/CA/cacert.pem) will be used.
        Likewise, if either the client certificate
        or the client key cannot be found, then the global default
        locations (/etc/pki/libvirt/clientcert.pem,
        /etc/pki/libvirt/private/clientkey.pem) will be used.
      </li><li> For the root user, the global default locations will be used.</li></ul>
        <h4>
      <a name="Remote_TLS_background" shape="rect" id="Remote_TLS_background">Background to TLS certificates</a>
    <a class="headerlink" href="#Remote_TLS_background" title="Permalink to this headline">¶</a></h4>
        <p>
Libvirt supports TLS certificates for verifying the identity
of the server and clients.  There are two distinct checks involved:
</p>
        <ul><li> The client should know that it is connecting to the right
server.  Checking done by client by matching the certificate that
the server sends to the server's hostname.  May be disabled by adding
<code>?no_verify=1</code> to the
<a href="#Remote_URI_parameters" shape="rect">remote URI</a>.
</li><li> The server should know that only permitted clients are
connecting.  This can be done based on client's IP address, or on
client's IP address and client's certificate.  Checking done by the
server.  May be enabled and disabled in the <a href="#Remote_libvirtd_configuration" shape="rect">libvirtd.conf file</a>.
</li></ul>
        <p>
For full certificate checking you will need to have certificates
issued by a recognised <a href="http://en.wikipedia.org/wiki/Certificate_authority" shape="rect">Certificate
Authority (CA)</a> for your server(s) and all clients.  To avoid the
expense of getting certificates from a commercial CA, you can set up
your own CA and tell your server(s) and clients to trust certificates
issues by your own CA.  Follow the instructions in the next section.
</p>
        <p>
Be aware that the <a href="#Remote_libvirtd_configuration" shape="rect">default
configuration for libvirtd</a> allows any client to connect provided
they have a valid certificate issued by the CA for their own IP
address.  You may want to change this to make it less (or more)
permissive, depending on your needs.
</p>
        <h4>
      <a name="Remote_TLS_CA" shape="rect" id="Remote_TLS_CA">Setting up a Certificate Authority (CA)</a>
    <a class="headerlink" href="#Remote_TLS_CA" title="Permalink to this headline">¶</a></h4>
        <p>
You will need the <a href="http://www.gnu.org/software/gnutls/manual/html_node/Invoking-certtool.html" shape="rect">GnuTLS
certtool program documented here</a>.  In Fedora, it is in the
<code>gnutls-utils</code> package.
</p>
        <p>
Create a private key for your CA:
</p>
        <pre xml:space="preserve">
certtool --generate-privkey &gt; cakey.pem
</pre>
        <p>
and self-sign it by creating a file with the
signature details called
<code>ca.info</code> containing:
</p>
        <pre xml:space="preserve">
cn = <i>Name of your organization</i>
ca
cert_signing_key
</pre>
        <pre xml:space="preserve">
certtool --generate-self-signed --load-privkey cakey.pem \
  --template ca.info --outfile cacert.pem
</pre>
        <p>
(You can delete <code>ca.info</code> file now if you
want).
</p>
        <p>
Now you have two files which matter:
</p>
        <ul><li><code>cakey.pem</code> - Your CA's private key (keep this very secret!)
</li><li><code>cacert.pem</code> - Your CA's certificate (this is public).
</li></ul>
        <p><code>cacert.pem</code> has to be installed on clients and
server(s) to let them know that they can trust certificates issued by
your CA.
</p>
        <p>
The normal installation directory for <code>cacert.pem</code>
is <code>/etc/pki/CA/cacert.pem</code> on all clients and servers.
</p>
        <p>
To see the contents of this file, do:
</p>
        <pre xml:space="preserve"><b>certtool -i --infile cacert.pem</b>

X.509 certificate info:

Version: 3
Serial Number (hex): 00
Subject: CN=Red Hat Emerging Technologies
Issuer: CN=Red Hat Emerging Technologies
Signature Algorithm: RSA-SHA
Validity:
        Not Before: Mon Jun 18 16:22:18 2007
        Not After: Tue Jun 17 16:22:18 2008
<i>[etc]</i>
</pre>
        <p>
This is all that is required to set up your CA.  Keep the CA's private
key carefully as you will need it when you come to issue certificates
for your clients and servers.
</p>
        <h4>
      <a name="Remote_TLS_server_certificates" shape="rect" id="Remote_TLS_server_certificates">Issuing server certificates</a>
    <a class="headerlink" href="#Remote_TLS_server_certificates" title="Permalink to this headline">¶</a></h4>
        <p>
For each server (libvirtd) you need to issue a certificate
with the X.509 CommonName (CN) field set to the hostname
of the server.  The CN must match the hostname which
clients will be using to connect to the server.
</p>
        <p>
In the example below, clients will be connecting to the
server using a <a href="#Remote_URI_reference" shape="rect">URI</a> of
<code>xen://oirase/</code>, so the CN must be "<code>oirase</code>".
</p>
        <p>
Make a private key for the server:
</p>
        <pre xml:space="preserve">
certtool --generate-privkey &gt; serverkey.pem
</pre>
        <p>
and sign that key with the CA's private key by first
creating a template file called <code>server.info</code>
(only the CN field matters, which as explained above must
be the server's hostname):
</p>
        <pre xml:space="preserve">
organization = <i>Name of your organization</i>
cn = oirase
tls_www_server
encryption_key
signing_key
</pre>
        <p>
and sign:
</p>
        <pre xml:space="preserve">
certtool --generate-certificate --load-privkey serverkey.pem \
  --load-ca-certificate cacert.pem --load-ca-privkey cakey.pem \
  --template server.info --outfile servercert.pem
</pre>
        <p>
This gives two files:
</p>
        <ul><li><code>serverkey.pem</code> - The server's private key.
</li><li><code>servercert.pem</code> - The server's public key.
</li></ul>
        <p>
We can examine this certificate and its signature:
</p>
        <pre xml:space="preserve"><b>certtool -i --infile servercert.pem</b>
X.509 certificate info:

Version: 3
Serial Number (hex): 00
Subject: O=Red Hat Emerging Technologies,CN=oirase
Issuer: CN=Red Hat Emerging Technologies
Signature Algorithm: RSA-SHA
Validity:
        Not Before: Mon Jun 18 16:34:49 2007
        Not After: Tue Jun 17 16:34:49 2008
</pre>
        <p>
Note the "Issuer" CN is "Red Hat Emerging Technologies" (the CA) and
the "Subject" CN is "oirase" (the server).
</p>
        <p>
Finally we have two files to install:
</p>
        <ul><li><code>serverkey.pem</code> is
the server's private key which should be copied to the
server <i>only</i> as
<code>/etc/pki/libvirt/private/serverkey.pem</code>.
</li><li><code>servercert.pem</code> is the server's certificate
which can be installed on the server as
<code>/etc/pki/libvirt/servercert.pem</code>.
</li></ul>
        <h4>
      <a name="Remote_TLS_client_certificates" shape="rect" id="Remote_TLS_client_certificates">Issuing client certificates</a>
    <a class="headerlink" href="#Remote_TLS_client_certificates" title="Permalink to this headline">¶</a></h4>
        <p>
For each client (ie. any program linked with libvirt, such as
<a href="http://virt-manager.et.redhat.com/" shape="rect">virt-manager</a>)
you need to issue a certificate with the X.509 Distinguished Name (DN)
set to a suitable name.  You can decide this on a company / organisation
policy.  For example, I use:
</p>
        <pre xml:space="preserve">
C=GB,ST=London,L=London,O=Red Hat,CN=<i>name_of_client</i>
</pre>
        <p>
The process is the same as for
<a href="#Remote_TLS_server_certificates" shape="rect">setting up the
server certificate</a> so here we just briefly cover the
steps.
</p>
        <ol><li>
Make a private key:
<pre xml:space="preserve">
certtool --generate-privkey &gt; clientkey.pem
</pre>
</li><li>
Act as CA and sign the certificate.  Create client.info containing:
<pre xml:space="preserve">
country = GB
state = London
locality = London
organization = Red Hat
cn = client1
tls_www_client
encryption_key
signing_key
</pre>
and sign by doing:
<pre xml:space="preserve">
certtool --generate-certificate --load-privkey clientkey.pem \
  --load-ca-certificate cacert.pem --load-ca-privkey cakey.pem \
  --template client.info --outfile clientcert.pem
</pre>
</li><li>
Install the certificates on the client machine:
<pre xml:space="preserve">
cp clientkey.pem /etc/pki/libvirt/private/clientkey.pem
cp clientcert.pem /etc/pki/libvirt/clientcert.pem
</pre>
</li></ol>
        <h4>
      <a name="Remote_TLS_troubleshooting" shape="rect" id="Remote_TLS_troubleshooting">Troubleshooting TLS certificate problems</a>
    <a class="headerlink" href="#Remote_TLS_troubleshooting" title="Permalink to this headline">¶</a></h4>
        <dl><dt> failed to verify client's certificate </dt><dd>
        <p>
On the server side, run the libvirtd server with
the '--listen' and '--verbose' options while the
client is connecting.  The verbose log messages should
tell you enough to diagnose the problem.
</p>
      </dd></dl>
        <p> You can use the virt-pki-validate shell script
to analyze the setup on the client or server machines, preferably as root.
It will try to point out the possible problems and provide solutions to
fix the set up up to a point where you have secure remote access.</p>
        <h3>
      <a name="Remote_libvirtd_configuration" shape="rect" id="Remote_libvirtd_configuration">libvirtd configuration file</a>
    <a class="headerlink" href="#Remote_libvirtd_configuration" title="Permalink to this headline">¶</a></h3>
        <p>
Libvirtd (the remote daemon) is configured from a file called
<code>/etc/libvirt/libvirtd.conf</code>, or specified on
the command line using <code>-f filename</code> or
<code>--config filename</code>.
</p>
        <p>
This file should contain lines of the form below.
Blank lines and comments beginning with <code>#</code> are ignored.
</p>
        <pre xml:space="preserve">setting = value</pre>
        <p>The following settings, values and default are:</p>
        <table class="top_table"><tr><th rowspan="1" colspan="1"> Line </th><th rowspan="1" colspan="1"> Default </th><th rowspan="1" colspan="1"> Meaning </th></tr><tr><td rowspan="1" colspan="1"> listen_tls <i>[0|1]</i> </td><td rowspan="1" colspan="1"> 1 (on) </td><td rowspan="1" colspan="1">
  Listen for secure TLS connections on the public TCP/IP port.
  Note: it is also necessary to start the server in listening mode by
  running it with --listen or editing /etc/sysconfig/libvirtd by uncommenting the LIBVIRTD_ARGS="--listen" line
  to cause the server to come up in listening mode whenever it is started.
</td></tr><tr><td rowspan="1" colspan="1"> listen_tcp <i>[0|1]</i> </td><td rowspan="1" colspan="1"> 0 (off) </td><td rowspan="1" colspan="1">
  Listen for unencrypted TCP connections on the public TCP/IP port.
  Note: it is also necessary to start the server in listening mode.
</td></tr><tr><td rowspan="1" colspan="1"> tls_port <i>"service"</i> </td><td rowspan="1" colspan="1"> "16514" </td><td rowspan="1" colspan="1">
  The port number or service name to listen on for secure TLS connections.
</td></tr><tr><td rowspan="1" colspan="1"> tcp_port <i>"service"</i> </td><td rowspan="1" colspan="1"> "16509" </td><td rowspan="1" colspan="1">
  The port number or service name to listen on for unencrypted TCP connections.
</td></tr><tr><td rowspan="1" colspan="1"> mdns_adv <i>[0|1]</i> </td><td rowspan="1" colspan="1"> 0 (advertise with mDNS) </td><td rowspan="1" colspan="1">
  If set to 1 then the virtualization service will be advertised over
  mDNS to hosts on the local LAN segment.
</td></tr><tr><td rowspan="1" colspan="1"> mdns_name <i>"name"</i> </td><td rowspan="1" colspan="1"> "Virtualization Host HOSTNAME" </td><td rowspan="1" colspan="1">
  The name to advertise for this host with Avahi mDNS. The default
  includes the machine's short hostname. This must be unique to the
  local LAN segment.
</td></tr><tr><td rowspan="1" colspan="1"> unix_sock_group <i>"groupname"</i> </td><td rowspan="1" colspan="1"> "root" </td><td rowspan="1" colspan="1">
  The UNIX group to own the UNIX domain socket. If the socket permissions allow
  group access, then applications running under matching group can access the
  socket. Only valid if running as root
</td></tr><tr><td rowspan="1" colspan="1"> unix_sock_ro_perms <i>"octal-perms"</i> </td><td rowspan="1" colspan="1"> "0777" </td><td rowspan="1" colspan="1">
  The permissions for the UNIX domain socket for read-only client connections.
  The default allows any user to monitor domains.
</td></tr><tr><td rowspan="1" colspan="1"> unix_sock_rw_perms <i>"octal-perms"</i> </td><td rowspan="1" colspan="1"> "0700" </td><td rowspan="1" colspan="1">
  The permissions for the UNIX domain socket for read-write client connections.
  The default allows only root to manage domains.
</td></tr><tr><td rowspan="1" colspan="1"> tls_no_verify_certificate <i>[0|1]</i> </td><td rowspan="1" colspan="1"> 0 (certificates are verified) </td><td rowspan="1" colspan="1">
  If set to 1 then if a client certificate check fails, it is not an error.
</td></tr><tr><td rowspan="1" colspan="1"> tls_no_verify_address <i>[0|1]</i> </td><td rowspan="1" colspan="1"> 0 (addresses are verified) </td><td rowspan="1" colspan="1">
  If set to 1 then if a client IP address check fails, it is not an error.
</td></tr><tr><td rowspan="1" colspan="1"> key_file <i>"filename"</i> </td><td rowspan="1" colspan="1"> "/etc/pki/libvirt/ private/serverkey.pem" </td><td rowspan="1" colspan="1">
  Change the path used to find the server's private key.
  If you set this to an empty string, then no private key is loaded.
</td></tr><tr><td rowspan="1" colspan="1"> cert_file <i>"filename"</i> </td><td rowspan="1" colspan="1"> "/etc/pki/libvirt/ servercert.pem" </td><td rowspan="1" colspan="1">
  Change the path used to find the server's certificate.
  If you set this to an empty string, then no certificate is loaded.
</td></tr><tr><td rowspan="1" colspan="1"> ca_file <i>"filename"</i> </td><td rowspan="1" colspan="1"> "/etc/pki/CA/cacert.pem" </td><td rowspan="1" colspan="1">
  Change the path used to find the trusted CA certificate.
  If you set this to an empty string, then no trusted CA certificate is loaded.
</td></tr><tr><td rowspan="1" colspan="1"> crl_file <i>"filename"</i> </td><td rowspan="1" colspan="1"> (no CRL file is used) </td><td rowspan="1" colspan="1">
  Change the path used to find the CA certificate revocation list (CRL) file.
  If you set this to an empty string, then no CRL is loaded.
</td></tr><tr><td rowspan="1" colspan="1"> tls_allowed_dn_list ["DN1", "DN2"] </td><td rowspan="1" colspan="1"> (none - DNs are not checked) </td><td rowspan="1" colspan="1">
          <p>
  Enable an access control list of client certificate Distinguished
  Names (DNs) which can connect to the TLS port on this server.
  </p>
          <p>
  The default is that DNs are not checked.
  </p>
          <p>
  This list may contain wildcards such as <code>"C=GB,ST=London,L=London,O=Red Hat,CN=*"</code>
  See the POSIX <code>fnmatch</code> function for the format
  of the wildcards.
  </p>
          <p>
  Note that if this is an empty list, <i>no client can connect</i>.
  </p>
          <p>
  Note also that GnuTLS returns DNs without spaces
  after commas between the fields (and this is what we check against),
  but the <code>openssl x509</code> tool shows spaces.
</p>
        </td></tr></table>
        <h3>
      <a name="Remote_IPv6" shape="rect" id="Remote_IPv6">IPv6 support</a>
    <a class="headerlink" href="#Remote_IPv6" title="Permalink to this headline">¶</a></h3>
        <p>
The libvirtd service and libvirt remote client driver both use the
<code>getaddrinfo()</code> functions for name resolution and are
thus fully IPv6 enabled. ie, if a server has IPv6 address configured
the daemon will listen for incoming connections on both IPv4 and IPv6
protocols. If a client has an IPv6 address configured and the DNS
address resolved for a service is reachable over IPv6, then an IPv6
connection will be made, otherwise IPv4 will be used. In summary it
should just 'do the right thing(tm)'.
</p>
        <h3>
      <a name="Remote_limitations" shape="rect" id="Remote_limitations">Limitations</a>
    <a class="headerlink" href="#Remote_limitations" title="Permalink to this headline">¶</a></h3>
        <ul><li> Fine-grained authentication: libvirt in general,
but in particular the remote case should support more
fine-grained authentication for operations, rather than
just read-write/read-only as at present.
</li></ul>
        <p>
Please come and discuss these issues and more on <a href="https://www.redhat.com/mailman/listinfo/libvir-list" title="libvir-list mailing list" shape="rect">the mailing list</a>.
</p>
      </div>
    </div>
    <div id="footer">
      <p id="sponsor">
	    Sponsored by:<br /><a href="http://et.redhat.com/"><img src="et.png" alt="Project sponsored by Red Hat Emerging Technology" /></a></p>
    </div>
  </body>
</html>
