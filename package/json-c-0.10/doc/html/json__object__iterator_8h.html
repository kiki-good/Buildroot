<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>json-c: json_object_iterator.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.3 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>json_object_iterator.h File Reference</h1>
<p>json-c forces clients to use its private data structures for JSON Object iteration. This API corrects that by abstracting the private json-c details.  
<a href="#_details">More...</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structjson__object__iterator.html">json_object_iterator</a></td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structjson__object__iterator.html">json_object_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="json__object__iterator_8h.html#af30f56ca510d59da42e5592f9a436c10">json_object_iter_init_default</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structjson__object__iterator.html">json_object_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="json__object__iterator_8h.html#a925eb97b5aa5b64986a0f663f53cf0fa">json_object_iter_begin</a> (struct <a class="el" href="structjson__object.html">json_object</a> *obj)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structjson__object__iterator.html">json_object_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="json__object__iterator_8h.html#a1fa3784395fb14496e3f1a1633028fd4">json_object_iter_end</a> (const struct <a class="el" href="structjson__object.html">json_object</a> *obj)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="json__object__iterator_8h.html#aa98a310c340f6d9b4eeecb673aa5e240">json_object_iter_next</a> (struct <a class="el" href="structjson__object__iterator.html">json_object_iterator</a> *iter)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="json__object__iterator_8h.html#af17775b9b812a4206a84e4d3fb5774ab">json_object_iter_peek_name</a> (const struct <a class="el" href="structjson__object__iterator.html">json_object_iterator</a> *iter)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structjson__object.html">json_object</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="json__object__iterator_8h.html#a47b0af7f1722c10475dffd29efc0b89d">json_object_iter_peek_value</a> (const struct <a class="el" href="structjson__object__iterator.html">json_object_iterator</a> *iter)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="json__object_8h.html#a81f02022906fafc71eb9197049f07f73">json_bool</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="json__object__iterator_8h.html#a878ca25f72b339882aa2607ac938e79c">json_object_iter_equal</a> (const struct <a class="el" href="structjson__object__iterator.html">json_object_iterator</a> *iter1, const struct <a class="el" href="structjson__object__iterator.html">json_object_iterator</a> *iter2)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>json-c forces clients to use its private data structures for JSON Object iteration. This API corrects that by abstracting the private json-c details. </p>
<p>Copyright (c) 2009-2012 Hewlett-Packard Development Company, L.P.</p>
<p>This library is free software; you can redistribute it and/or modify it under the terms of the MIT license. See COPYING for details.</p>
<p>API attributes: <br/>
 * Thread-safe: NO<br/>
 * Reentrant: NO </p>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a925eb97b5aa5b64986a0f663f53cf0fa"></a><!-- doxytag: member="json_object_iterator.h::json_object_iter_begin" ref="a925eb97b5aa5b64986a0f663f53cf0fa" args="(struct json_object *obj)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structjson__object__iterator.html">json_object_iterator</a> json_object_iter_begin </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structjson__object.html">json_object</a> *&nbsp;</td>
          <td class="paramname"> <em>obj</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Retrieves an iterator to the first pair of the JSON Object.</p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>Any modification of the underlying pair invalidates all iterators to that pair.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>obj</em>&nbsp;</td><td>JSON Object instance (MUST be of type <a class="el" href="structjson__object.html">json_object</a>)</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="structjson__object__iterator.html">json_object_iterator</a> If the JSON Object has at least one pair, on return, the iterator refers to the first pair. If the JSON Object doesn't have any pairs, the returned iterator is equivalent to the "end" iterator for the same JSON Object instance.</dd></dl>
<div class="fragment"><pre class="fragment"> <span class="keyword">struct </span><a class="code" href="structjson__object__iterator.html">json_object_iterator</a> it;
 <span class="keyword">struct </span><a class="code" href="structjson__object__iterator.html">json_object_iterator</a> itEnd;
 <span class="keyword">struct </span><a class="code" href="structjson__object.html">json_object</a>* obj;

 obj = <a class="code" href="json__tokener_8h.html#abf031fdf1e5caab71e2225a99588c6bb">json_tokener_parse</a>(<span class="stringliteral">&quot;{&#39;first&#39;:&#39;george&#39;, &#39;age&#39;:100}&quot;</span>);
 it = <a class="code" href="json__object__iterator_8h.html#a925eb97b5aa5b64986a0f663f53cf0fa">json_object_iter_begin</a>(obj);
 itEnd = <a class="code" href="json__object__iterator_8h.html#a1fa3784395fb14496e3f1a1633028fd4">json_object_iter_end</a>(obj);

 <span class="keywordflow">while</span> (!<a class="code" href="json__object__iterator_8h.html#a878ca25f72b339882aa2607ac938e79c">json_object_iter_equal</a>(&amp;it, &amp;itEnd)) {
     printf(<span class="stringliteral">&quot;%s\n&quot;</span>,
            <a class="code" href="json__object__iterator_8h.html#af17775b9b812a4206a84e4d3fb5774ab">json_object_iter_peek_name</a>(&amp;it));
     <a class="code" href="json__object__iterator_8h.html#aa98a310c340f6d9b4eeecb673aa5e240">json_object_iter_next</a>(&amp;it);
 }
</pre></div> 
</div>
</div>
<a class="anchor" id="a1fa3784395fb14496e3f1a1633028fd4"></a><!-- doxytag: member="json_object_iterator.h::json_object_iter_end" ref="a1fa3784395fb14496e3f1a1633028fd4" args="(const struct json_object *obj)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structjson__object__iterator.html">json_object_iterator</a> json_object_iter_end </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structjson__object.html">json_object</a> *&nbsp;</td>
          <td class="paramname"> <em>obj</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Retrieves the iterator that represents the position beyond the last pair of the given JSON Object instance.</p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>Do NOT write code that assumes that the "end" iterator value is NULL, even if it is so in a particular instance of the implementation.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>The reason we do not (and MUST NOT) provide "json_object_iter_is_end(json_object_iterator* iter)" type of API is because it would limit the underlying representation of name/value containment (or force us to add additional, otherwise unnecessary, fields to the iterator structure). The "end" iterator and the equality test method, on the other hand, permit us to cleanly abstract pretty much any reasonable underlying representation without burdening the iterator structure with unnecessary data.</dd>
<dd>
For performance reasons, memorize the "end" iterator prior to any loop.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>obj</em>&nbsp;</td><td>JSON Object instance (MUST be of type <a class="el" href="structjson__object.html">json_object</a>)</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="structjson__object__iterator.html">json_object_iterator</a> On return, the iterator refers to the "end" of the Object instance's pairs (i.e., NOT the last pair, but "beyond the last
              pair" value) </dd></dl>

</div>
</div>
<a class="anchor" id="a878ca25f72b339882aa2607ac938e79c"></a><!-- doxytag: member="json_object_iterator.h::json_object_iter_equal" ref="a878ca25f72b339882aa2607ac938e79c" args="(const struct json_object_iterator *iter1, const struct json_object_iterator *iter2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="json__object_8h.html#a81f02022906fafc71eb9197049f07f73">json_bool</a> json_object_iter_equal </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structjson__object__iterator.html">json_object_iterator</a> *&nbsp;</td>
          <td class="paramname"> <em>iter1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structjson__object__iterator.html">json_object_iterator</a> *&nbsp;</td>
          <td class="paramname"> <em>iter2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Tests two iterators for equality. Typically used to test for end of iteration by comparing an iterator to the corresponding "end" iterator (that was derived from the same JSON Object instance).</p>
<dl class="note"><dt><b>Note:</b></dt><dd>The reason we do not (and MUST NOT) provide "json_object_iter_is_end(json_object_iterator* iter)" type of API is because it would limit the underlying representation of name/value containment (or force us to add additional, otherwise unnecessary, fields to the iterator structure). The equality test method, on the other hand, permits us to cleanly abstract pretty much any reasonable underlying representation.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>iter1</em>&nbsp;</td><td>Pointer to first valid, non-NULL iterator </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>iter2</em>&nbsp;</td><td>POinter to second valid, non-NULL iterator</td></tr>
  </table>
  </dd>
</dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>if a NULL iterator pointer or an uninitialized or invalid iterator, or iterators derived from different JSON Object instances are passed, bad things will happen!</dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>json_bool non-zero if iterators are equal (i.e., both reference the same name/value pair or are both at "end"); zero if they are not equal. </dd></dl>

</div>
</div>
<a class="anchor" id="af30f56ca510d59da42e5592f9a436c10"></a><!-- doxytag: member="json_object_iterator.h::json_object_iter_init_default" ref="af30f56ca510d59da42e5592f9a436c10" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structjson__object__iterator.html">json_object_iterator</a> json_object_iter_init_default </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Initializes an iterator structure to a "default" value that is convenient for initializing an iterator variable to a default state (e.g., initialization list in a class' constructor).</p>
<div class="fragment"><pre class="fragment"> <span class="keyword">struct </span><a class="code" href="structjson__object__iterator.html">json_object_iterator</a> iter = <a class="code" href="json__object__iterator_8h.html#af30f56ca510d59da42e5592f9a436c10">json_object_iter_init_default</a>();
 MyClass() : iter_(<a class="code" href="json__object__iterator_8h.html#af30f56ca510d59da42e5592f9a436c10">json_object_iter_init_default</a>())
</pre></div><dl class="note"><dt><b>Note:</b></dt><dd>The initialized value doesn't reference any specific pair, is considered an invalid iterator, and MUST NOT be passed to any json-c API that expects a valid iterator.</dd>
<dd>
User and internal code MUST NOT make any assumptions about and dependencies on the value of the "default" iterator value.</dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="structjson__object__iterator.html">json_object_iterator</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aa98a310c340f6d9b4eeecb673aa5e240"></a><!-- doxytag: member="json_object_iterator.h::json_object_iter_next" ref="aa98a310c340f6d9b4eeecb673aa5e240" args="(struct json_object_iterator *iter)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void json_object_iter_next </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structjson__object__iterator.html">json_object_iterator</a> *&nbsp;</td>
          <td class="paramname"> <em>iter</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns an iterator to the next pair, if any</p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>Any modification of the underlying pair invalidates all iterators to that pair.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>iter</em>&nbsp;</td><td>[IN/OUT] Pointer to iterator that references a name/value pair; MUST be a valid, non-end iterator. WARNING: bad things will happen if invalid or "end" iterator is passed. Upon return will contain the reference to the next pair if there is one; if there are no more pairs, will contain the "end" iterator value, which may be compared against the return value of <a class="el" href="json__object__iterator_8h.html#a1fa3784395fb14496e3f1a1633028fd4">json_object_iter_end()</a> for the same JSON Object instance. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af17775b9b812a4206a84e4d3fb5774ab"></a><!-- doxytag: member="json_object_iterator.h::json_object_iter_peek_name" ref="af17775b9b812a4206a84e4d3fb5774ab" args="(const struct json_object_iterator *iter)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* json_object_iter_peek_name </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structjson__object__iterator.html">json_object_iterator</a> *&nbsp;</td>
          <td class="paramname"> <em>iter</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns a const pointer to the name of the pair referenced by the given iterator.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>iter</em>&nbsp;</td><td>pointer to iterator that references a name/value pair; MUST be a valid, non-end iterator.</td></tr>
  </table>
  </dd>
</dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>bad things will happen if an invalid or "end" iterator is passed.</dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>const char* Pointer to the name of the referenced name/value pair. The name memory belongs to the name/value pair, will be freed when the pair is deleted or modified, and MUST NOT be modified or freed by the user. </dd></dl>

</div>
</div>
<a class="anchor" id="a47b0af7f1722c10475dffd29efc0b89d"></a><!-- doxytag: member="json_object_iterator.h::json_object_iter_peek_value" ref="a47b0af7f1722c10475dffd29efc0b89d" args="(const struct json_object_iterator *iter)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structjson__object.html">json_object</a>* json_object_iter_peek_value </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structjson__object__iterator.html">json_object_iterator</a> *&nbsp;</td>
          <td class="paramname"> <em>iter</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns a pointer to the json-c instance representing the value of the referenced name/value pair, without altering the instance's reference count.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>iter</em>&nbsp;</td><td>pointer to iterator that references a name/value pair; MUST be a valid, non-end iterator.</td></tr>
  </table>
  </dd>
</dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>bad things will happen if invalid or "end" iterator is passed.</dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>struct json_object* Pointer to the json-c value instance of the referenced name/value pair; the value's reference count is not changed by this function: if you plan to hold on to this json-c node, take a look at <a class="el" href="json__object_8h.html#acc3628d97c6308dc967006e4268c4e7f">json_object_get()</a> and <a class="el" href="json__object_8h.html#accc34b38e15e46357d64a0beed3d0150">json_object_put()</a>. IMPORTANT: json-c API represents the JSON Null value as a NULL <a class="el" href="structjson__object.html">json_object</a> instance pointer. </dd></dl>

</div>
</div>
</div>
<hr class="footer"/><address style="text-align: right;"><small>Generated on Sat Apr 28 15:52:47 2012 for json-c by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.3 </small></address>
</body>
</html>
