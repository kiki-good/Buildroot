From 6b9edc0c4a964143f8c9a730048088df66efa85f Mon Sep 17 00:00:00 2001
From: bilal <bilal@airties.com>
Date: Mon, 24 Jan 2011 17:10:21 +0200
Subject: [PATCH 02/26] Issue #16088

import wireless_tools.29

git-svn-id: http://svn.corp.airties.com/svn/atlantis/packages/devel/wireless_tools/wireless_tools.29@22574
---
 19-udev-ifrename.rules   |   13 +
 CHANGELOG.h              |  771 +++++++++++
 COPYING                  |  340 +++++
 DISTRIBUTIONS.txt        |  377 ++++++
 HOTPLUG.txt              | 1062 +++++++++++++++
 IFRENAME-VS-XXX.txt      |  141 ++
 INSTALL                  |  151 +++
 Makefile                 |  244 ++++
 PCMCIA.txt               |  160 +++
 README                   |  162 +++
 README.fr                |  162 +++
 awf_event.h              |   35 +
 cs/ifrename.8            |  158 +++
 cs/iftab.5               |  189 +++
 cs/iwconfig.8            |  535 ++++++++
 cs/iwevent.8             |  118 ++
 cs/iwgetid.8             |  118 ++
 cs/iwlist.8              |  120 ++
 cs/iwpriv.8              |  136 ++
 cs/iwspy.8               |  111 ++
 cs/wireless.7            |  129 ++
 fr/ifrename.8            |  147 +++
 fr/iftab.5               |  196 +++
 fr/iwconfig.8            |  569 ++++++++
 fr/iwevent.8             |  131 ++
 fr/iwgetid.8             |  136 ++
 fr/iwlist.8              |  145 +++
 fr/iwpriv.8              |  156 +++
 fr/iwspy.8               |  116 ++
 fr/wireless.7            |  145 +++
 ifrename.8               |  183 +++
 ifrename.c               | 2721 +++++++++++++++++++++++++++++++++++++++
 iftab.5                  |  313 +++++
 iwconfig.8               |  609 +++++++++
 iwconfig.c               | 1954 ++++++++++++++++++++++++++++
 iwevent.8                |  112 ++
 iwevent.c                |  903 +++++++++++++
 iwgetid.8                |  115 ++
 iwgetid.c                |  581 +++++++++
 iwlib.c                  | 3215 ++++++++++++++++++++++++++++++++++++++++++++++
 iwlib.h                  |  603 +++++++++
 iwlist.8                 |  151 +++
 iwlist.c                 | 2610 +++++++++++++++++++++++++++++++++++++
 iwmulticall.c            |  143 +++
 iwpriv.8                 |  118 ++
 iwpriv.c                 |  977 ++++++++++++++
 iwspy.8                  |  111 ++
 iwspy.c                  |  376 ++++++
 macaddr.c                |   54 +
 sample_enc.c             |  191 +++
 sample_pm.c              |  234 ++++
 sample_priv_addr.c       |  210 +++
 udev.import_devpath.diff |   39 +
 wireless.10.h            |  479 +++++++
 wireless.11.h            |  510 ++++++++
 wireless.12.h            |  570 ++++++++
 wireless.13.h            |  599 +++++++++
 wireless.14.h            |  669 ++++++++++
 wireless.15.h            |  698 ++++++++++
 wireless.16.h            |  733 +++++++++++
 wireless.17.h            |  773 +++++++++++
 wireless.18.h            | 1050 +++++++++++++++
 wireless.19.h            | 1069 +++++++++++++++
 wireless.20.h            | 1073 ++++++++++++++++
 wireless.21.h            | 1120 ++++++++++++++++
 wireless.22.h            | 1139 ++++++++++++++++
 wireless.7               |  128 ++
 67 files changed, 34106 insertions(+)
 create mode 100644 19-udev-ifrename.rules
 create mode 100644 CHANGELOG.h
 create mode 100644 COPYING
 create mode 100644 DISTRIBUTIONS.txt
 create mode 100644 HOTPLUG.txt
 create mode 100644 IFRENAME-VS-XXX.txt
 create mode 100644 INSTALL
 create mode 100644 Makefile
 create mode 100644 PCMCIA.txt
 create mode 100644 README
 create mode 100644 README.fr
 create mode 100644 awf_event.h
 create mode 100644 cs/ifrename.8
 create mode 100644 cs/iftab.5
 create mode 100644 cs/iwconfig.8
 create mode 100644 cs/iwevent.8
 create mode 100644 cs/iwgetid.8
 create mode 100644 cs/iwlist.8
 create mode 100644 cs/iwpriv.8
 create mode 100644 cs/iwspy.8
 create mode 100644 cs/wireless.7
 create mode 100644 fr/ifrename.8
 create mode 100644 fr/iftab.5
 create mode 100644 fr/iwconfig.8
 create mode 100644 fr/iwevent.8
 create mode 100644 fr/iwgetid.8
 create mode 100644 fr/iwlist.8
 create mode 100644 fr/iwpriv.8
 create mode 100644 fr/iwspy.8
 create mode 100644 fr/wireless.7
 create mode 100644 ifrename.8
 create mode 100644 ifrename.c
 create mode 100644 iftab.5
 create mode 100644 iwconfig.8
 create mode 100644 iwconfig.c
 create mode 100644 iwevent.8
 create mode 100644 iwevent.c
 create mode 100644 iwgetid.8
 create mode 100644 iwgetid.c
 create mode 100644 iwlib.c
 create mode 100644 iwlib.h
 create mode 100644 iwlist.8
 create mode 100644 iwlist.c
 create mode 100644 iwmulticall.c
 create mode 100644 iwpriv.8
 create mode 100644 iwpriv.c
 create mode 100644 iwspy.8
 create mode 100644 iwspy.c
 create mode 100644 macaddr.c
 create mode 100644 sample_enc.c
 create mode 100644 sample_pm.c
 create mode 100644 sample_priv_addr.c
 create mode 100644 udev.import_devpath.diff
 create mode 100644 wireless.10.h
 create mode 100644 wireless.11.h
 create mode 100644 wireless.12.h
 create mode 100644 wireless.13.h
 create mode 100644 wireless.14.h
 create mode 100644 wireless.15.h
 create mode 100644 wireless.16.h
 create mode 100644 wireless.17.h
 create mode 100644 wireless.18.h
 create mode 100644 wireless.19.h
 create mode 100644 wireless.20.h
 create mode 100644 wireless.21.h
 create mode 100644 wireless.22.h
 create mode 100644 wireless.7

diff --git a/19-udev-ifrename.rules b/19-udev-ifrename.rules
new file mode 100644
index 0000000..c8b319e
--- /dev/null
+++ b/19-udev-ifrename.rules
@@ -0,0 +1,13 @@
+# udev rules to properly integrate ifrename.
+# Renaming is done using /etc/iftab, with full ifrename functionality.
+# Require udev version 107 or later.
+# Please double check the path to ifrename, and make sure its available
+# when udev runs (i.e. on boot partition).
+
+# Enable this rule to test with udevtest.
+#ENV{UDEV_LOG}=="6", SUBSYSTEM=="net", ACTION=="add", IMPORT="/sbin/ifrename -D -V -u -i %k", NAME:="%k"
+
+# Main ifrename rule.
+# If interface is found in /etc/iftab, subsequent rename rules are bypassed.
+# If interface is not found in /etc/iftab, subsequent rename rules applies.
+SUBSYSTEM=="net", ACTION=="add", IMPORT="/sbin/ifrename -u -i %k", NAME:="%k"
diff --git a/CHANGELOG.h b/CHANGELOG.h
new file mode 100644
index 0000000..2084760
--- /dev/null
+++ b/CHANGELOG.h
@@ -0,0 +1,771 @@
+/*
+ *	Wireless Tools
+ *
+ *		Jean II - HPLB 97->99 - HPL 99->07
+ *
+ * The changelog...
+ *
+ * This files is released under the GPL license.
+ *     Copyright (c) 1997-2002 Jean Tourrilhes <jt@hpl.hp.com>
+ */
+
+/* --------------------------- HISTORY --------------------------- */
+/*
+ * wireless 16 :		(Jean Tourrilhes)
+ * -----------
+ *	o iwconfig, iwpriv & iwspy
+ *
+ * wireless 17 :		(Justin Seger)
+ * -----------
+ *	o Compile under glibc fix
+ *	o merge iwpriv in iwconfig
+ *	o Add Wavelan roaming support
+ *	o Update man page of iwconfig
+ *
+ * wireless 18 :
+ * -----------
+ *		(From Andreas Neuhaus <andy@fasta.fh-dortmund.de>)
+ *	o Many fix to remove "core dumps" in iwconfig
+ *	o Remove useless headers in iwconfig
+ *	o CHAR wide private ioctl
+ *		(From Jean Tourrilhes)
+ *	o Create iwcommon.h and iwcommon.c
+ *	o Separate iwpriv again for user interface issues
+ *	  The folllowing didn't make sense and crashed :
+ *		iwconfig eth0 priv sethisto 12 15 nwid 100
+ *	o iwspy no longer depend on net-tools-1.2.0
+ *	o Reorganisation of the code, cleanup
+ *	o Add ESSID stuff in iwconfig
+ *	o Add display of level & noise in dBm (stats in iwconfig)
+ *	o Update man page of iwconfig and iwpriv
+ *	o Add xwireless (didn't check if it compiles)
+ *		(From Dean W. Gehnert <deang@tpi.com>)
+ *	o Minor fixes
+ *		(Jan Rafaj <rafaj@cedric.vabo.cz>)
+ *	o Cosmetic changes (sensitivity relative, freq list)
+ *	o Frequency computation on double
+ *	o Compile clean on libc5
+ *		(From Jean Tourrilhes)
+ *	o Move listing of frequencies to iwspy
+ *	o Add AP address stuff in iwconfig
+ *	o Add AP list stuff in iwspy
+ *
+ * wireless 19 :
+ * -----------
+ *		(From Jean Tourrilhes)
+ *	o Allow for sensitivity in dBm (if < 0) [iwconfig]
+ *	o Formatting changes in displaying ap address in [iwconfig]
+ *	o Slightly improved man pages and usage display
+ *	o Add channel number for each frequency in list [iwspy]
+ *	o Add nickname... [iwconfig]
+ *	o Add "port" private ioctl shortcut [iwpriv]
+ *	o If signal level = 0, no range or dBms [iwconfig]
+ *	o I think I now got set/get char strings right in [iwpriv]
+ *		(From Thomas Ekstrom <tomeck@thelogic.com>)
+ *	o Fix a very obscure bug in [iwspy]
+ *
+ * wireless 20 :
+ * -----------
+ *		(From Jean Tourrilhes)
+ *	o Remove all #ifdef WIRELESS ugliness, but add a #error :
+ *		we require Wireless Extensions 9 or nothing !  [all]
+ *	o Switch to new 'nwid' definition (specific -> iw_param) [iwconfig]
+ *	o Rewriten totally the encryption support [iwconfig]
+ *		- Multiple keys, through key index
+ *		- Flexible/multiple key size, and remove 64bits upper limit
+ *		- Open/Restricted modes
+ *		- Enter keys as ASCII strings
+ *	o List key sizes supported and all keys in [iwspy]
+ *	o Mode of operation support (ad-hoc, managed...) [iwconfig]
+ *	o Use '=' to indicate fixed instead of ugly '(f)' [iwconfig]
+ *	o Ability to disable RTS & frag (off), now the right way [iwconfig]
+ *	o Auto as an input modifier for bitrate [iwconfig]
+ *	o Power Management support [iwconfig]
+ *		- set timeout or period and its value
+ *		- Reception mode (unicast/multicast/all)
+ *	o Updated man pages with all that ;-)
+ *
+ * wireless 21 :
+ * -----------
+ *		(from Alan McReynolds <alan_mcreynolds@hpl.hp.com>)
+ *	o Use proper macros for compilation directives [Makefile]
+ *		(From Jean Tourrilhes)
+ *	o Put licensing info everywhere (almost). Yes, it's GPL !
+ *	o Document the use of /etc/pcmcia/wireless.opts [PCMCIA]
+ *	o Add min/max modifiers to power management parameters [iwconfig]
+ *		-> requested by Lee Keyser-Allen for the Spectrum24 driver
+ *	o Optionally output a second power management parameter [iwconfig]
+ *	---
+ *	o Common subroutines to display stats & power saving info [iwcommon]
+ *	o Display all power management info, capability and values [iwspy]
+ *	---
+ *	o Optional index for ESSID (for Aironet driver) [iwcommon]
+ *	o IW_ENCODE_NOKEY for write only keys [iwconfig/iwspy]
+ *	o Common subrouting to print encoding keys [iwspy]
+ *	---
+ *	o Transmit Power stuff (dBm + mW) [iwconfig/iwspy]
+ *	o Cleaner formatting algorithm when displaying params [iwconfig]
+ *	---
+ *	o Fix get_range_info() and use it everywhere - Should fix core dumps.
+ *	o Catch WE version differences between tools and driver and
+ *	  warn user. Thanks to Tobias Ringstrom for the tip... [iwcommon]
+ *	o Add Retry limit and lifetime support. [iwconfig/iwlist]
+ *	o Display "Cell:" instead of "Access Point:" in ad-hoc mode [iwconfig]
+ *	o Header fix for glibc2.2 by Ross G. Miller <Ross_Miller@baylor.edu>
+ *	o Move header selection flags in Makefile [iwcommon/Makefile]
+ *	o Spin-off iwlist.c from iwspy.c. iwspy is now much smaller
+ *	  After moving this bit of code all over the place, from iwpriv
+ *	  to iwconfig to iwspy, it now has a home of its own... [iwspy/iwlist]
+ *	o Wrote quick'n'dirty iwgetid.
+ *	o Remove output of second power management parameter [iwconfig]
+ *	  Please use iwlist, I don't want to bloat iwconfig
+ *	---
+ *	o Fix bug in display ints - "Allen Miu" <aklmiu@mit.edu> [iwpriv]
+ *
+ * wireless 22 :
+ * -----------
+ *		(From Jim Kaba <jkaba@sarnoff.com>)
+ *	o Fix socket_open to not open all types of sockets [iwcommon]
+ *		(From Michael Tokarev <mjt@tls.msk.ru>)
+ *	o Rewrite main (top level) + command line parsing of [iwlist]
+ *		(From Jean Tourrilhes)
+ *	o Set commands should return proper success flag [iwspy/iwpriv]
+ *	  requested by Michael Tokarev
+ *	---
+ *		(From Torgeir Hansen <torgeir@trenger.ro>)
+ *	o Replace "strcpy(wrq.ifr_name," with strncpy to avoid buffer
+ *	  overflows. This is OK because the kernel use strncmp...
+ *	---
+ *	o Move operation_mode in iwcommon and add NUM_OPER_MODE [iwconfig]
+ *	o print_stats, print_key, ... use char * instead if FILE * [iwcommon]
+ *	o Add `iw_' prefix to avoid namespace pollution [iwcommon]
+ *	o Add iw_get_basic_config() and iw_set_basic_config() [iwcommon]
+ *	o Move iw_getstats from iwconfig to iwcommon [iwcommon]
+ *	o Move changelog to CHANGELOG.h [iwcommon]
+ *	o Rename iwcommon.* into iwlib.* [iwcommon->iwlib]
+ *	o Compile iwlib. as a dynamic or static library [Makefile]
+ *	o Allow the tools to be compiled with the dynamic library [Makefile]
+ *	--- Update to Wireless Extension 12 ---
+ *	o Show typical/average quality in iwspy [iwspy]
+ *	o Get Wireless Stats through ioctl instead of /proc [iwlib]
+ *
+ * wireless 23 :
+ * -----------
+ *	o Split iw_check_addr_type() into two functions mac/if [iwlib]
+ *	o iw_in_addr() does appropriate iw_check_xxx itself  [iwlib]
+ *	o Allow iwspy on MAC address even if IP doesn't check [iwspy]
+ *	o Allow iwconfig ap on MAC address even if IP doesn't check [iwconfig]
+ *	---
+ *	o Fix iwlist man page about extra commands [iwlist]
+ *	---
+ *	o Fix Makefile rules for library compile (more generic) [Makefile]
+ *	---
+ *	o Set max length for all GET request with a iw_point [various]
+ *	o Fix set IW_PRIV_TYPE_BYTE to be endian/align clean [iwpriv]
+ *	---
+ *		(From Kernel Jake <kerneljake@hotmail.com>)
+ *	o Add '/' at the end of directories to create them [Makefile]
+ *		(From Pavel Roskin <proski@gnu.org>)
+ *	o Replace "cp" with "install" to get permissions proper [Makefile]
+ *	o Install Man-Pages at the proper location [Makefile]
+ *	o Add automatic header selection based on libc/kernel [iwlib.h]
+ *	---
+ *	o Add "commit" to force parameters on the card [iwconfig]
+ *	o Wrap ioctl() in iw_set/get_ext() wrappers [all]
+ *	o Beautify set request error messages [iwconfig]
+ *
+ * wireless 24 :
+ * -----------
+ *	o Added common function to display frequency [iwlib]
+ *	o Added handler to parse Wireless Events [iwlib]
+ *	o Added tool to display Wireless Events [iwevent]
+ *	o Pass command line to subroutines [iwlist]
+ *	o Scanning support through SIOCSIWSCAN [iwlist]
+ *	---
+ *	o Added common function to display bitrate [iwlib]
+ *	o Add bitrate/encoding scanning support [iwlist]
+ *	o Allow to read scan results for non-root users [iwlist]
+ *	o Set 5s timeout on waiting for scan results [iwlist]
+ *	o Cleanup iwgetid & support ap+scheme display [iwgetid]
+ *	o iwevent man page [iwevent]
+ *		(From Guus Sliepen <guus@warande3094.warande.uu.nl>)
+ *	o iwgetid man page [iwgetid]
+ *	---
+ *	o Add "#define WIRELESS_EXT > 13" around event code [iwlib]
+ *	o Move iw_enum_devices() from iwlist.c to iwlib.c [iwlib]
+ *	o Use iw_enum_devices() everywhere [iwconfig/iwspy/iwpriv]
+ *		(From Pavel Roskin <proski@gnu.org>, rewrite by me)
+ *	o Return proper error message on non existent interfaces [iwconfig]
+ *	o Read interface list in /proc/net/wireless and not SIOCGIFCONF [iwlib]
+ *	---
+ *		(From Pavel Roskin <proski@gnu.org> - again !!!)
+ *	o Don't loose flags when setting encryption key [iwconfig]
+ *	o Add <time.h> [iwevent]
+ *	---
+ *		(From Casey Carter <Casey@Carter.net>)
+ *	o Improved compilations directives, stricter warnings [Makefile]
+ *	o Fix strict warnings (static func, unused args...) [various]
+ *	o New routines to display/input Ethernet MAC addresses [iwlib]
+ *	o Correct my english & spelling [various]
+ *	o Get macaddr to compile [macaddr]
+ *	o Fix range checking in max number of args [iwlist]
+ *	---
+ *	o Display time when we receive event [iwevent]
+ *	---
+ *	o Display time before event, easier to read [iwevent]
+ *		(From "Dr. Michael Rietz" <rietz@mail.amps.de>)
+ *	o Use a generic set of header, may end header mess [iwlib]
+ *		(From Casey Carter <Casey@Carter.net>)
+ *	o Zillions cleanups, small fixes and code reorg [all over]
+ *	o Proper usage/help printout [iwevent, iwgetid, ...]
+ *	---
+ *	o Send broadcast address for iwconfig ethX ap auto/any [iwconfig]
+ *	---
+ *	o Send NULL address for iwconfig ethX ap off [iwconfig]
+ *	o Add iw_in_key() helper (and use it) [iwlib]
+ *	o Create symbolink link libiw.so to libiw.so.XX [Makefile]
+ *		(From Javier Achirica <achirica@ttd.net>)
+ *	o Always send TxPower flags to the driver [iwconfig]
+ *		(From John M. Choi <johnchoi@its.caltech.edu>)
+ *	o Header definition for Slackware (kernel 2.2/glibc 2.2) [iwlib]
+ *
+ * wireless 25 :
+ * -----------
+ *	o Remove library symbolic link before creating it [Makefile]
+ *	o Display error and exit if WE < 14 [iwevent]
+ *		(From Sander Jonkers <sander@grachtzicht.cjb.net>)
+ *	o Fix iwconfig usage display to show "enc off" [iwconfig]
+ *		(From Pavel Roskin <proski@gnu.org>)
+ *	o Formating : add spaces after cell/ap addr [iwconfig]
+ *	---
+ *	o Do driver WE source version verification [iwlib]
+ *		(From Pavel Roskin <proski@gnu.org>)
+ *	o Cleanup user configurable options [Makefile]
+ *	o add FORCE_WEXT_VERSION [Makefile]
+ *	o Add uninstall directived [Makefile]
+ *	o Cleanup version warnings [iwlib]
+ *	o Fix iwconfig usage display to show "mode MODE" [iwconfig]
+ *	o Replace "rm -f + ln -s" with "ln -sfn" in install [Makefile]
+ *	---
+ *	o Add various documentation in source code of [iwpriv]
+ *	o Allow to get more than 16 private ioctl description [iwlib]
+ *	o Ignore ioctl descriptions with null name [iwpriv]
+ *	o Implement sub-ioctls (simple/iw_point) [iwpriv]
+ *	---
+ *	o Add DISTRIBUTIONS file with call for help [README]
+ *	o Change iw_byte_size in iw_get_priv_size [iwlib]
+ *	o Document various bugs of new driver API with priv ioctls [iwpriv]
+ *	o Implement float/addr priv data types [iwpriv]
+ *	o Fix off-by-one bug (priv_size <= IFNAMSIZ) [iwpriv]
+ *	o Reformat/beautify ioctl list display [iwpriv]
+ *	o Add "-a" command line to dump all read-only priv ioctls [iwpriv]
+ *	o Add a sample showing new priv features [sample_priv_addr.c]
+ *	o Update other samples with new driver API [sample_enc.c/sample_pm.c]
+ *	---
+ *	o Fix "iwpriv -a" to not call ioctls not returning anything [iwpriv]
+ *	o Use IW_MAX_GET_SPY in increase number of addresses read [iwspy]
+ *	o Finish fixing the mess of off-by-one on IW_ESSID_MAX_SIZE [iwconfig]
+ *	o Do interface enumeration using /proc/net/dev [iwlib]
+ *	---
+ *	o Display various --version information [iwlib, iwconfig, iwlist]
+ *	o Filled in Debian 2.3 & Red-Hat 7.3 sections in [DISTRIBUTIONS]
+ *	o Filled in Red-Hat 7.2, Mandrake 8.2 and SuSE 8.0 in [DISTRIBUTIONS]
+ *	o Display current freq/channel after the iwrange list [iwlist]
+ *	o Display current rate after the iwrange list [iwlist]
+ *	o Display current txpower after the iwrange list [iwlist]
+ *	o Add BUILD_NOLIBM to build without libm [Makefile]
+ *	o Fix infinite loop on unknown events/scan elements [iwlib]
+ *	o Add IWEVCUSTOM support [iwevent, iwlist]
+ *	o Add IWEVREGISTERED & IWEVEXPIRED support [iwevent]
+ *		(From Pavel Roskin <proski@gnu.org>)
+ *	o Make $(DYNAMIC_LINK) relative (and not absolute) [Makefile]
+ *	---
+ *	o Replace all float occurence with double [iwlib, iwlist]
+ *	o Implement iwgetid --mode [iwgetid]
+ *	o Convert frequency to channel [iwlist, iwlib]
+ *		(Suggested by Pavel Roskin <proski@gnu.org> - always him !)
+ *	o Implement --version across the board [iwspy, iwevent, iwpriv]
+ *	o Implement iwgetid --freq [iwgetid]
+ *	o Display "Access Point/Cell" [iwgetid]
+ *	---
+ *	o New manpage about configuration (placeholder) [wireless.7]
+ *	o Catch properly invalid arg to "iwconfig ethX key" [iwconfig]
+ *	o Put placeholder for Passphrase to key conversion [iwlib]
+ *	o Allow args of "iwconfig ethX key" in any order [iwconfig]
+ *	o Implement token index for private commands [iwpriv]
+ *	o Add IW_MODE_MONITOR for passive monitoring [iwlib]
+ *		I wonder why nobody bothered to ask for it before ;-)
+ *	o Mention distribution specific document in [PCMCIA]
+ *	o Create directories before installing stuff in it [Makefile]
+ *	---
+ *	o Add Debian 3.0 and PCMCIA in [wireless.7]
+ *	o Add iw_protocol_compare() in [iwlib]
+ *	---
+ *	o Complain about version mistmatch at runtime only once [iwlib]
+ *	o Fix IWNAME null termination [iwconfig, iwlib]
+ *	o "iwgetid -p" to display protocol name and check WE support [iwgetid]
+ *
+ * wireless 26 :
+ * -----------
+ *	o #define IFLA_WIRELESS if needed [iwlib]
+ *	o Update man page with SuSE intruction (see below) [wireless.7]
+ *		(From Alexander Pevzner <pzz@pzz.msk.ru>)
+ *	o Allow to display all 8 bit rates instead of 7 [iwlist]
+ *	o Fix retry lifetime to not set IW_RETRY_LIMIT flag [iwconfig]
+ *		(From Christian Zoz <zoz@suse.de>)
+ *	o Update SuSE configuration instructions [DISTRIBUTIONS]
+ *	---
+ *	o Update man page with regards to /proc/net/wireless [iwconfig.8]
+ *	o Add NOLIBM version of iw_dbm2mwatt()/iw_mwatt2dbm() [iwlib]
+ *	---
+ *	o Fix "iwconfig ethX enc on" on WE-15 : set buffer size [iwconfig]
+ *	o Display /proc/net/wireless before "typical data" [iwspy]
+ *		(From Pavel Roskin <proski@gnu.org>)
+ *	o Fix uninstall [Makefile]
+ *	o Change "Encryption mode" to "Security mode" [iwconfig/iwlist]
+ *	---
+ *	o Add kernel headers that will be removed from wireless.h [iwlib]
+ *	o Remove IW_MAX_GET_SPY, people should use AP-List [iwspy]
+ *	o Re-word List of "Access Points" to "Peers/Access-Points" [iwlist]
+ *	o Add support for SIOCGIWTHRSPY event [iwevent/iwlib]
+ *	o Add support for SIOCSIWTHRSPY/SIOCGIWTHRSPY ioctls [iwspy]
+ *	---
+ *	o Add SIOCGIWNAME/Protocol event display [iwlist scan/iwevent]
+ *	o Add temporary encoding flag setting [iwconfig]
+ *	o Add login encoding setting [iwlib/iwconfig]
+ *	---
+ *	o Fix corruption of encryption key setting when followed by another
+ *	  setting starting with a valid hex char ('essid' -> 'E') [iwlib]
+ *	o Fix iw_in_key() so that it parses every char and not bundle of
+ *	  two so that 'enc' is not the valid key '0E0C' [iwlib]
+ *	o Fix parsing of odd keys '123' is '0123' instead of '1203' [iwlib]
+ *	---
+ *	o Implement WE version tool redirector (need WE-16) [iwredir]
+ *	o Add "make vinstall" to use redirector [Makefile]
+ *	o Fix compilation warning in WE < 16 [iwlib, iwspy]
+ *	o Allow to specify PREFIX on make command line [Makefile]
+ *	---
+ *	o Update wireless.h (more frequencies) [wireless.h]
+ *	o Allow to escape ESSID="any" using "essid - any" [iwconfig]
+ *	o Updated Red-Hat 9 wireless config instructions [DISTRIBUTIONS]
+ *		(From Pavel Roskin <proski@gnu.org>)
+ *	o Replace all %d into %i so we can input hex/oct [iwlib, iwpriv]
+ *	---
+ *	o If >= WE-16, display kernel version in "iwconfig --version" [iwlib]
+ *		(From Antonio Vilei <francesco.sigona@unile.it>)
+ *	o Fix "wrq.u.bitrate.value = power;" => txpower [iwconfig]
+ *		(From Casey Carter <Casey@Carter.net>)
+ *	o Make iwlib.h header C++ friendly. [iwlib]
+ *	---
+ *		(From Pavel Roskin <proski@gnu.org>)
+ *	o Make sure that KERNEL_SRC point to a valid directory [Makefile]
+ *	o Print message if card support WE but has no version info [iwlib]
+ *		(From Simon Kelley <simon@thekelleys.org.uk>)
+ *	o If power has no mode, don't print garbage [iwlib]
+ *	---
+ *		(Bug reported by Guus Sliepen <guus@sliepen.eu.org>)
+ *	o Don't cast "int power" to unsigned long in sscanf [iwconfig]
+ *		(From Pavel Roskin <proski@gnu.org>)
+ *	o Add $(LDFLAGS) for final linking [Makefile]
+ *
+ * wireless 27 :
+ * -----------
+ *	o Add 'sed' magic to automatically get WT/WE versions [Makefile]
+ *	o Change soname of iwlib to libiwWE.so.WT [Makefile]
+ *		Now dynamicaly linked versioned install can work
+ *	o Default to dynamic build, don't build static lib [Makefile]
+ *	o Update installation instructions [INSTALL]
+ *	o fflush(stdout), so that redirect to file/pipe works [iwevent]
+ *		(From Pavel Roskin <proski@gnu.org>)
+ *	o Display properly interface name larger than 8 char [all]
+ *	---
+ *	o Implement auto/fixed frequencies [iwconfig]
+ *		(From Pavel Roskin <proski@gnu.org>)
+ *	o Don't fail is ldconfig fails [Makefile]
+ *	---
+ *	o Fix one forgotten strcpy(ifname) -> strncpy change [iwconfig]
+ *	o Fix all dangerous sprintf, replace with snprintf [iwlib]
+ *	o Change iw_print_xxx() API to take buffer length [iwlib]
+ *	---
+ *	o "iwspy ethX +" did not work, fix wrq.u.data.length [iwspy]
+ *	o Fix stupid bug in displaying link/ap/cell stats [iwspy]
+ *	o Fix display of fixed length char private args [iwpriv]
+ *	o Add raw output for shell scripts, options -r [iwgetid]
+ *	o Tweak scheme output for freq and mode [iwgetid]
+ *		(From Andreas Mohr)
+ *	o Spelling fixes in README and man page
+ *	---
+ *	o Add definitions for older version of W-Ext [iwlib]
+ *	o Always force compile with latest local version of wext [Makefile]
+ *	o Change soname of iwlib back to libiw.so.WT [Makefile]
+ *	o Get rid of redirector and "make vinstall" [Makefile/iwredir]
+ *	o Convert any struct iw_range to latest version [iwlib]
+ *	o Change run-time version warning to reflect new reality [iwlib]
+ *	o Remove compile-time version warning [iwlib]
+ *	o Add iw_get_kernel_we_version() to guess kernel WE version [iwlib]
+ *	o Remove all #ifdef WIRELESS_EXT, use dynamic iwrange version [all]
+ *	o Get/display wireless stats based on iwrange version [iwlib]
+ *	o Get power and retry settings based on iwrange version [iwconfig]
+ *	o Display power and retry settings based on iwrange version [iwlist]
+ *	o Optimise use of iwrange : read on demand [iwevent]
+ *	---
+ *	o #include <wireless.h>, instead of using a #define [iwlib.h]
+ *	o Copy latest wireless.XX.h as wireless.h and install it [Makefile]
+ *	---
+ *	o Fix various iwlist retry display bugs [iwlist]
+ *	o Fix dynamic link to libiw back to be libiw.so (doh !) [Makefile]
+ *	---
+ *	o Trivial cleanups and docs updates
+ *	---
+ *	o Implement "iwconfig XXX txpower on" and fix "fixed" [iwconfig]
+ *	o Always properly initialise sanlen before recvfrom() [iwevent]
+ *	o Zero buffer so we don't print garbage after essid [iwgetid]
+ *	o Document that 00:00:00:00:00:00 == no association [iwconfig.8]
+ *		(From Guus Sliepen <guus@sliepen.eu.org>)
+ *	o Fix doc typo : ad_hoc => ad-hoc [wireless.7/DISTRIBUTIONS.txt]
+ *	---
+ *		(From vda <vda@port.imtp.ilyichevsk.odessa.ua>)
+ *	o Accept arbitrary number of private definitions [iwlib/iwpriv]
+ *	---
+ *	o Added Hotplug documentation [HOTPLUG.txt]
+ *	o Add dependancies (gcc way), remove makedepend [Makefile]
+ *		(From Maxime Charpenne <maxime.charpenne@free.fr>)
+ *	o Traduction en francais des pages manuel [fr/*]
+ *	o Fix some incorrect/ambiguous sentences [iwconfig.8/iwevent.8]
+ *		(From Joshua Kwan <joshk@triplehelix.org>)
+ *	o Add 'const' qualifier to iwlib API [iwlib.c/iwlib.h]
+ *		(From Joey Hess <joey@dragon.kitenet.net>)
+ *	o Add Debian schemes scripts [debian/ifscheme*]
+ *	---
+ *	o Add 'ifrename', complete rewrite of nameif [ifrename]
+ *	o Update documentation about ifrename [HOTPLUG.txt]
+ *		(From Joshua Kwan <joshk@triplehelix.org>)
+ *	o Fix disabling of key/enc with iw_set_basic_config() & WE<13 [iwlib.c]
+ *	---
+ *	o Various bug fixes and improvements [ifrename]
+ *	---
+ *	o Man pages for ifrename [ifrename.8/iftab.5]
+ *	o Update hotplug/ifrename documentation [HOTPLUG.txt]
+ *	---
+ *	o Read configuration from stdin [ifrename]
+ *		(From Thomas Hood <jdthood@yahoo.co.uk>)
+ *	o Spell check and updated man page [wireless.7]
+ *		(From Pavel Roskin <proski@gnu.org>)
+ *	o Update and spellcheck documentation [HOTPLUG.txt]
+ *	---
+ *	o Spin-off 'ifscheme' in a separate package to please Guus Sliepen
+ *	o Update documentation on 'ifscheme' [DISTRIBUTIONS.txt/README]
+ *		(From dann frazier <dannf@debian.org>)
+ *	o Spell check and updated man page [iwlist.8]
+ *	---
+ *	o Cache interface static data (ifname/iwrange) [iwevent.c]
+ *	---
+ *	o Change the policy to delete entry from cache [iwevent.c]
+ *	o If no TxPower in iwrange, still print current TxPower [iwlist.c]
+ *	o Use iw_get_basic_config() in iwconfig, bloat-- [iwconfig.c/iwlib.h]
+ *	---
+ *		(From Pavel Roskin <proski@gnu.org>)
+ *	o Fix mode boundary checking in iw_get_basic_config() [iwlib.c]
+ *	---
+ *	o Improved priv documentation [iwpriv.c]
+ *		(From Pavel Roskin <proski@gnu.org>)
+ *	o Fix token index bug : allow zero args [iwpriv.c]
+ *	o Grammar fixes in priv documentation [iwpriv.c]
+ *	---
+ *	o Make iw_protocol_compare() smarter [iwlib.c]
+ *	o Display freq->channel conversion in scan results [iwlist]
+ *	o Display freq->channel conversion in events [iwevent]
+ *	o Interface name takeover support [ifrename]
+ *	o Update docu for Debian Sarge, various improvements [HOTPLUG.txt]
+ *	o Set wireless parameters in the proper order [iwlib]
+ *	---
+ *		(Suggested by Pavel Roskin <proski@gnu.org>)
+ *	o Be less dramatic is driver doesn't export txpower info [iwlist]
+ *	o Be less dramatic is driver doesn't export bitrate info [iwlist]
+ *	o Use 'updated' bits to disable printing some qual [iwlib]
+ *	o Change the way we show 'updated' bits -> '=' vs. ':' [iwlib]
+ *	o Cosmetic update to channel display [iwlist/iwevent]
+ *	---
+ *	o Easy scanning API (blocking & non-blocking) [iwlib]
+ *	o Add channel only support to iwgetid [iwgetid]
+ *	o Compile iwgetid with iwlib for above [Makefile/iwgetid]
+ *		(From Loic Minier <lool@dooz.org> via Guus Sliepen)
+ *	o Fix french man pages to not use special 'oe' char [fr/*.8]
+ *		(From Thomas Hood <jdthood@yahoo.co.uk>)
+ *	o Use hyphens instead of underscores in Debian docs [*.txt/*.7]
+ *	---
+ *	o Update for WE-17 (wrq.u.freq.flags, IW_QUAL_*) [all]
+ *	o Use iw_get_ext() instead of ioctl() [iwgetid]
+ *	o Retry getting scan results with larger buffer [iwlist/iwlib]
+ *	o Display wireless event capabilities [iwlist]
+ *	o Add support for relative TxPower (yick !) [iwconfig/iwlist]
+ *	o Create iw_print_txpower() [iwlib]
+ *	o Add "Set" prefix for all SET wireless events [iwevent]
+ *		(Suggested by Pavel Roskin <proski@gnu.org>)
+ *	o Add support for get_freq and get_essid events [iwevent]
+ *	---
+ *	o Reorganise iw_print_freq() => create iw_print_freq_value() [iwlib]
+ *	o Create iw_channel_to_freq() and use it [iwlib/iwconfig/iwevent]
+ *	o Fixup for WE-18 : Set scan takes an iw_point [iwlist/iwlib]
+ *	o Fixup for WE-19 : Take care of IW_EV_POINT_OFF [iwlib]
+ *	---
+ *	o Introduces iw_sockets_close() [all]
+ *	o Set proper size on SIOCGIWSTATS requests [iwlib]
+ *	o Use iw_print_freq_value() in iwlist [iwlist]
+ *	o Optimise iw_print_bitrate() [iwlib]
+ *	o Fix wrq.u.data.flags => wrq.u.txpower.flags [iwconfig]
+ *		(From Denis Ovsienko <pilot@altlinux.ru>)
+ *	o Add dry-run support (only print name changes) [ifrename]
+ *	---
+ *	o Move WE_VERSION/WT_VERSION to iwlib.h [iwlib/Makefile]
+ *	o Add support for new selector pcmciaslot [ifrename]
+ *	o Improve/cleanup DEBUG/verbose output [ifrename]
+ *	o Minor documentation updates [HOTPLUG.txt/DISTRIBUTIONS.txt]
+ *		(From Francesco Potorti` <pot@potorti.it>)
+ *	o Allow iwgetid to accept '-c' options [iwgetid]
+ *		(From Ian Gulliver <ian@penguinhosting.net>)
+ *	o Transform #define DEBUG into verbose command line switch [ifrename]
+ *	---
+ *		(From Dan Williams <dcbw@redhat.com>)
+ *	o Fix buffer memory leak in scanning [iwlib/iwlist]
+ *	---
+ *	o Make sure gcc inline stuff properly [iwlib.h]
+ *	o Update Hotplug documentation [HOTPLUG.txt]
+ *	o Add support for new selector firmware [ifrename]
+ *
+ * wireless 28 :
+ * -----------
+ *	o Fix gcc inline hack when using kernel headers [iwlib.h]
+ *		(From Denis Ovsienko <pilot@altlinux.ru>)
+ *	o Allow '-n' without '-i', even though inefficient [ifrename]
+ *		(From Thomas Hood <jdthood@aglu.demon.nl>)
+ *	o Fix technical and spelling errors in Hotplug doc [HOTPLUG.txt]
+ *	---
+ *	o Include wireless.h as a local file, not a system file [iwlib.h]
+ *	o Split install targets [Makefile]
+ *		(Suggested by Jost Diederichs <jost@qdusa.com>)
+ *	o Increase scanning timeout for MadWifi [iwlib/iwlist]
+ *		(Suggested by Ned Ludd <solar@gentoo.org>)
+ *	o Multicall version of the tools for embedded [iwmulticall]
+ *	---
+ *	o Fix some install Makefile targets broken in pre2 [Makefile]
+ *	---
+ *	o Add option for stripping symbols on tools [Makefile]
+ *	o Add escaping of essid keyworks with -- in manpage [iwconfig.8]
+ *	o Update sensitivity description [iwconfig.8]
+ *	o Fix iw_print_timeval() for timezone [iwlib/iwevent]
+ *		(Suggested by Jan Minar <jjminar@FastMail.FM>)
+ *	o Escape interface name for --help/--version with -- [iwconfig]
+ *	o Allow --help/--version to be interface names [iwlist]
+ *		(From Martynas Dubauskis <martynas@gemtek.lt>)
+ *	o Fix invalid sizeof for stat memcpy in easy scanning API [iwlib.c]
+ *		(From Andreas Mohr <andi@rhlx01.fht-esslingen.de>)
+ *	o Fix my horrendous spelling [HOTPLUG.txt/PCMCIA.txt/README/*.8]
+ *	---
+ *	o Make static lib use PIC objects [Makefile]
+ *	o Add SYSFS selector support to ifrename [ifrename]
+ *	o Fix a fd leak in pcmciaslot selector [ifrename]
+ *	o Don't complain about eth0/wlan0 if takeover enabled [ifrename]
+ *	o Update man pages for sysfs and eth0/wlan0 [ifrename.8]
+ *	o Update man pages for frequ auto/off [iwconfig.8]
+ *	o More clever manual loading and docking tricks [HOTPLUG.txt]
+ *		(From Pavel Heimlich tropikhajma@seznam.cz)
+ *	o Czech (cs) man pages [cs/*]
+ *	---
+ *	o Fudge patch below for better integration [iwconfig/iwevent/iwlist]
+ *		(From Jouni Malinen <jkmaline@cc.hut.fi>)
+ *	o WE-18/WPA event display [iwevent]
+ *	o WE-18/WPA parameter display [iwconfig]
+ *	---
+ *	o Replace iw_pr_ether() with iw_saether_ntop() [iwlib]
+ *	o Replace iw_in_ether() with iw_saether_aton() [iwlib]
+ *	o Remove iw_get_mac_addr() -> unused and bad API [iwlib]
+ *	o Add iw_mac_ntop() and iw_mac_aton() for any-len mac addr [iwlib]
+ *	o Slim down iw_ether_aton() using iw_mac_ntop() [iwlib]
+ *	o Slim down iw_in_key(), avoid memcpy [iwlib]
+ *	o Add support for any-len mac addr selector [ifrename]
+ *	---
+ *	o Re-add temp output buffer in iw_in_key() to avoid corruptions [iwlib]
+ *	---
+ *	o Add WE-19 headers, compile with that as default
+ *	o IW_EV_POINT_LEN has shrunk, so invert IW_EV_POINT_OFF fixup [iwlib]
+ *	o Remove WE backward compat from iwlib.h header [iwlib]
+ *	o Add support for IW_QUAL_DBM in iw_print_stats() [iwlib]
+ *	o Add support for ARPHRD_IEEE80211 in iw_check_mac_addr_type() [iwlib]
+ *		-> iwspy work on wifi0 netdev from airo.c
+ *	---
+ *	o Set flags to 0 before asking old power settings for 'on' [iwconfig]
+ *		(Suggested by Denis Ovsienko <pilot@altlinux.ru>)
+ *	o Ignore empty lines in iface enumeration iw_enum_devices() [iwlib]
+ *		(From Pavel Roskin <proski@gnu.org>)
+ *	o Fix invalid buffer size in 'iwlist power' [iwlist]
+ *		(Suggested by Francesco Potorti` <pot@gnu.org>)
+ *	o Remove kernel headers, use glibc headers [iwlib]
+ *	---
+ *	o Show explicit state for SIOCSIWAP, not numbers [iwconfig/iwevent] 
+ *	o Add WE-18 ioctls to the stream parser in standard_ioctl_hdr [iwlib]
+ *		(From Chris Hessing <Chris.Hessing@utah.edu>)
+ *	o Add GENIE parsing support in scan resuls [iwlist]
+ *	---
+ *	o Change iw_extract_event_stream() API to add value index [iwlib]
+ *	o Scan : display bitrate values on a single line [iwlist]
+ *	---
+ *	o Revert to previous iw_extract_event_stream() API, debloat [iwlib]
+ *	o Keep track of value index in [iwlist]
+ *	---
+ *	o Check event stream 'point' payload size to avoid overflow [iwlib]
+ *	o Make all users of event stream 'point' safe to NULL [iwlist/iwevent]
+ *	o 'iwconfig txpower 1dBm' should not be 'mW' [iwconfig]
+ *	o Forward compat. to WE-21 : essid len is strlen, not +1 [iwconfig]
+ *	---
+ *	o Forgot one place where essid len was strlen+1 [iwlib]
+ *	o Update definition of 'ap' and 'sens' to reflect reality [man]
+ *	---
+ *	o Introduce WE_MAX_VERSION to take into account forward compat [iwlib]
+ *	o Add WE-20 headers, compile with that as default
+ *	---
+ *	o Fix 'inline' for gcc-4 as well. Grrr... [iwlib]
+ *
+ * wireless 29 :
+ * -----------
+ *	o Add new power value : 'power saving' [iwconfig/iwlist/iwlib]
+ *	o Optimise getting iwrange when setting TxPower [iwconfig]
+ *	o Optimise displaying current power values (better loop) [iwlist]
+ *	---
+ *	o Add modulation bitmasks ioctls [iwconfig/iwlist]
+ *	o Add short and long retries [iwconfig/iwlist/iwlib]
+ *	o Fix 'relative' power saving to not be *1000 [iwconfig/iwlib]
+ *	o iw_print_pm_value() require we_version [iwlib]
+ *	o Optimise displaying range power values (subroutine) [iwlist]
+ *	---
+ *	o Fix 'relative' retry to not be *1000 [iwconfig/iwlib]
+ *	o iw_print_retry_value() require we_version [iwlib]
+ *	o Optimise getting iwrange when setting PowerSaving [iwconfig]
+ *	o Optimise displaying current retry values (better loop) [iwlist]
+ *	o Optimise displaying range retry values (subroutine) [iwlist]
+ *	---
+ *	o Fix stupid bug in displaying range retry values [iwlist]
+ *	---
+ *	o Add support for unicast and broadcast bitrates [iwconfig/iwlist]
+ *	---
+ *	o Replace spaghetti code with real dispatcher in set_info() [iwconfig]
+ *		Code is more readable, maintainable, and save 700 bytes...
+ *	o Drop 'domain' alias for 'nwid'. Obsolete. [iwconfig]
+ *	o Make iw_usage() use dispatcher data instead of hardcoded [iwconfig]
+ *	o Factor out modifier parsing for retry/power [iwconfig]
+ *	o Fix iwmulticall to compile with new dispatcher above [iwmulticall]
+ *	o Add WE_ESSENTIAL compile option to drop 10kB [Makefile]
+ *	---
+ *	o Update manpages with new features above [man]
+ *	---
+ *	o Add temp variable to sscanf() to fix 64 bits issues [iwconfig]
+ *	o De-inline get_pm_value/get_retry_value to reduce footprint [iwlist]
+ *	o Optimise iw_print_ie_cipher/iw_print_ie_auth [iwlist]
+ *	o Add "Memory footprint reduction" section in doc [README]
+ *	o Add 'last' scan option for left-over scan [iwlist]
+ *		(From Stavros Markou <smarkou@patras.atmel.com>)
+ *	o Add 'essid' scan option for directed scan [iwlist]
+ *	---
+ *		(Bug reported by Henrik Brix Andersen <brix@gentoo.org>)
+ *	o Fix segfault on setting bitrate (parse wrong arg) [iwconfig]
+ *	---
+ *	o Revert 'CC=gcc' to normal [Makefile]
+ *	o Integrate properly patch below [iwlist]
+ *		(From Brian Eaton <eaton.lists@gmail.com>)
+ *	o More WPA support : iwlist auth/wpakeys/genie [iwlist]
+ *	---
+ *	o Tweak man pages : interface is often optional [iwlist.8/iwspy.8]
+ *	o Drop obsolete port/roam code from [iwpriv]
+ *		(From Pavel Roskin <proski@gnu.org>)
+ *	o Fix bug where all auth masks use iw_auth_capa_name [iwlist]
+ *		(From Dima Ryazanov <someone@berkeley.edu>)
+ *	o Fix iw_scan()/iw_process_scan() for non-root -> EPERM [iwlib]
+ *		(Bug reported by Arkadiusz Miskiewicz <arekm@pld-linux.org>)
+ *	o Fix "iwconfig nickname" (was abreviated) [iwconfig]
+ *		(Bug reported by Charles Plessy)
+ *	o Invalid mode from driver segfault iwlist scan [iwlist]
+ *		(From Aurelien Jacobs <aurel@gnuage.org>)
+ *	o Replace index() with strchr() [iwlib/iwconfig/iwpriv]
+ *		(From Jens Thoms Toerring)
+ *	o Parser/printf/sscanf fixes and optimisation [iwconfig]
+ *	---
+ *		(From Pavel Roskin <proski@gnu.org>)
+ *	o Fix bug extracting mountpoint of sysfs (wrong field) [ifrename]
+ *		(Suggested by Pavel Roskin <proski@gnu.org>)
+ *	o Read sysfs symlinks transparently [ifrename]
+ *	---
+ *	o Fix README header to talk about ifrename [README]
+ *	o Add 'prevname' selector for udev compatibility [ifrename]
+ *	o Read parent directory names in SYSFS selector [ifrename]
+ *	o Make dry-run output compatible with udev [ifrename]
+ *	o Update man page with useful SYSFS selectors [iftab.5]
+ *	---
+ *	o Factorise wildcard rewrite '*'->'%d' to hide it from -D -V [ifrename]
+ *	o Reorganise sysfs description, better wording [iftab.5]
+ *		(Suggested by Pavel Roskin <proski@gnu.org>)
+ *	o Enhance explanation of arp and iwproto [iftab.5]
+ *	---
+ *		(Bug reported by Johannes Berg <johannes@sipsolutions.net>)
+ *	o Band-aid for the 64->32bit iwevent/iwscan issues [iwlib]
+ *	---
+ *	o Better band-aid for the 64->32bit iwevent/iwscan issues [iwlib]
+ *		(Suggested by Kay Sievers <kay.sievers@vrfy.org>)
+ *	o Add udev compatible output, print new DEVPATH [ifrename]
+ *	---
+ *	o Fix DEVPATH output to use the real devpath from udev [ifrename]
+ *	o Add udev rules for ifrename integration [19-udev-ifrename.rules]
+ *	---
+ *	o Add largest bitrate in easy scan API [iwlib]
+ *	---
+ *	o Debug version : output IW_EV_LCP_LEN [iwlist]
+ *	---
+ *		(Bug reported by Santiago Gala/Roy Marples)
+ *	o Fix 64->32bit band-aid on 64 bits, target is local aligned [iwlib]
+ *	---
+ *		(Bug reported by Santiago Gala/Roy Marples)
+ *	o More fix to the 64->32bit band-aid on 64 bits [iwlib]
+ *	---
+ *		(Bug reported by Dimitris Kogias)
+ *	o Fix GENIE parsing os chipher/key_mngt [iwlist]
+ *		(Bug reported by Guus Sliepen <guus@debian.org>)
+ *	o Compiler warning on DEBUG code [iwlist]
+ *	---
+ *	o --version output WE_MAX_VERSION instead of WE_VERSION [iwlib]
+ *	o Change iwstats dBm range to [-192;63] in iw_print_stats() [iwlib.c]
+ *	o Implement iwstats IW_QUAL_RCPI in iw_print_stats()  [iwlib.c]
+ *		(Bug reported by Guus Sliepen <guus@sliepen.eu.org>)
+ *	o LINUX_VERSION_CODE removed, only use GENERIC_HEADERS [iwlib.h]
+ *		(Bug reported by Johan Danielsson <joda11147@gmail.com>)
+ *	o Fix OUI type check for WPA 1 IE [iwlist.c]
+ *	---
+ *		(Bug reported by Florent Daignière)
+ *	o Don't look for "fixed" out of array in set_txpower_info() [iwconfig]
+ */
+
+/* ----------------------------- TODO ----------------------------- */
+/*
+ * One day, maybe...
+ *
+ * iwconfig :
+ * --------
+ *	Make disable a per encryption key modifier if some hardware
+ *	requires it.
+ *	IW_QUAL_RCPI
+ *
+ * iwspy :
+ * -----
+ *	Add an "auto" flag to have the driver cache the last n results
+ *
+ * iwlist :
+ * ------
+ *	Add scanning command line modifiers
+ *	More scan types support
+ *
+ * ifrename :
+ * --------
+ *	Link Type should use readable form instead of numeric value
+ *
+ * Doc & man pages :
+ * ---------------
+ *	Update main doc.
+ */
diff --git a/COPYING b/COPYING
new file mode 100644
index 0000000..d60c31a
--- /dev/null
+++ b/COPYING
@@ -0,0 +1,340 @@
+		    GNU GENERAL PUBLIC LICENSE
+		       Version 2, June 1991
+
+ Copyright (C) 1989, 1991 Free Software Foundation, Inc.
+     59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ Everyone is permitted to copy and distribute verbatim copies
+ of this license document, but changing it is not allowed.
+
+			    Preamble
+
+  The licenses for most software are designed to take away your
+freedom to share and change it.  By contrast, the GNU General Public
+License is intended to guarantee your freedom to share and change free
+software--to make sure the software is free for all its users.  This
+General Public License applies to most of the Free Software
+Foundation's software and to any other program whose authors commit to
+using it.  (Some other Free Software Foundation software is covered by
+the GNU Library General Public License instead.)  You can apply it to
+your programs, too.
+
+  When we speak of free software, we are referring to freedom, not
+price.  Our General Public Licenses are designed to make sure that you
+have the freedom to distribute copies of free software (and charge for
+this service if you wish), that you receive source code or can get it
+if you want it, that you can change the software or use pieces of it
+in new free programs; and that you know you can do these things.
+
+  To protect your rights, we need to make restrictions that forbid
+anyone to deny you these rights or to ask you to surrender the rights.
+These restrictions translate to certain responsibilities for you if you
+distribute copies of the software, or if you modify it.
+
+  For example, if you distribute copies of such a program, whether
+gratis or for a fee, you must give the recipients all the rights that
+you have.  You must make sure that they, too, receive or can get the
+source code.  And you must show them these terms so they know their
+rights.
+
+  We protect your rights with two steps: (1) copyright the software, and
+(2) offer you this license which gives you legal permission to copy,
+distribute and/or modify the software.
+
+  Also, for each author's protection and ours, we want to make certain
+that everyone understands that there is no warranty for this free
+software.  If the software is modified by someone else and passed on, we
+want its recipients to know that what they have is not the original, so
+that any problems introduced by others will not reflect on the original
+authors' reputations.
+
+  Finally, any free program is threatened constantly by software
+patents.  We wish to avoid the danger that redistributors of a free
+program will individually obtain patent licenses, in effect making the
+program proprietary.  To prevent this, we have made it clear that any
+patent must be licensed for everyone's free use or not licensed at all.
+
+  The precise terms and conditions for copying, distribution and
+modification follow.
+
+		    GNU GENERAL PUBLIC LICENSE
+   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
+
+  0. This License applies to any program or other work which contains
+a notice placed by the copyright holder saying it may be distributed
+under the terms of this General Public License.  The "Program", below,
+refers to any such program or work, and a "work based on the Program"
+means either the Program or any derivative work under copyright law:
+that is to say, a work containing the Program or a portion of it,
+either verbatim or with modifications and/or translated into another
+language.  (Hereinafter, translation is included without limitation in
+the term "modification".)  Each licensee is addressed as "you".
+
+Activities other than copying, distribution and modification are not
+covered by this License; they are outside its scope.  The act of
+running the Program is not restricted, and the output from the Program
+is covered only if its contents constitute a work based on the
+Program (independent of having been made by running the Program).
+Whether that is true depends on what the Program does.
+
+  1. You may copy and distribute verbatim copies of the Program's
+source code as you receive it, in any medium, provided that you
+conspicuously and appropriately publish on each copy an appropriate
+copyright notice and disclaimer of warranty; keep intact all the
+notices that refer to this License and to the absence of any warranty;
+and give any other recipients of the Program a copy of this License
+along with the Program.
+
+You may charge a fee for the physical act of transferring a copy, and
+you may at your option offer warranty protection in exchange for a fee.
+
+  2. You may modify your copy or copies of the Program or any portion
+of it, thus forming a work based on the Program, and copy and
+distribute such modifications or work under the terms of Section 1
+above, provided that you also meet all of these conditions:
+
+    a) You must cause the modified files to carry prominent notices
+    stating that you changed the files and the date of any change.
+
+    b) You must cause any work that you distribute or publish, that in
+    whole or in part contains or is derived from the Program or any
+    part thereof, to be licensed as a whole at no charge to all third
+    parties under the terms of this License.
+
+    c) If the modified program normally reads commands interactively
+    when run, you must cause it, when started running for such
+    interactive use in the most ordinary way, to print or display an
+    announcement including an appropriate copyright notice and a
+    notice that there is no warranty (or else, saying that you provide
+    a warranty) and that users may redistribute the program under
+    these conditions, and telling the user how to view a copy of this
+    License.  (Exception: if the Program itself is interactive but
+    does not normally print such an announcement, your work based on
+    the Program is not required to print an announcement.)
+
+These requirements apply to the modified work as a whole.  If
+identifiable sections of that work are not derived from the Program,
+and can be reasonably considered independent and separate works in
+themselves, then this License, and its terms, do not apply to those
+sections when you distribute them as separate works.  But when you
+distribute the same sections as part of a whole which is a work based
+on the Program, the distribution of the whole must be on the terms of
+this License, whose permissions for other licensees extend to the
+entire whole, and thus to each and every part regardless of who wrote it.
+
+Thus, it is not the intent of this section to claim rights or contest
+your rights to work written entirely by you; rather, the intent is to
+exercise the right to control the distribution of derivative or
+collective works based on the Program.
+
+In addition, mere aggregation of another work not based on the Program
+with the Program (or with a work based on the Program) on a volume of
+a storage or distribution medium does not bring the other work under
+the scope of this License.
+
+  3. You may copy and distribute the Program (or a work based on it,
+under Section 2) in object code or executable form under the terms of
+Sections 1 and 2 above provided that you also do one of the following:
+
+    a) Accompany it with the complete corresponding machine-readable
+    source code, which must be distributed under the terms of Sections
+    1 and 2 above on a medium customarily used for software interchange; or,
+
+    b) Accompany it with a written offer, valid for at least three
+    years, to give any third party, for a charge no more than your
+    cost of physically performing source distribution, a complete
+    machine-readable copy of the corresponding source code, to be
+    distributed under the terms of Sections 1 and 2 above on a medium
+    customarily used for software interchange; or,
+
+    c) Accompany it with the information you received as to the offer
+    to distribute corresponding source code.  (This alternative is
+    allowed only for noncommercial distribution and only if you
+    received the program in object code or executable form with such
+    an offer, in accord with Subsection b above.)
+
+The source code for a work means the preferred form of the work for
+making modifications to it.  For an executable work, complete source
+code means all the source code for all modules it contains, plus any
+associated interface definition files, plus the scripts used to
+control compilation and installation of the executable.  However, as a
+special exception, the source code distributed need not include
+anything that is normally distributed (in either source or binary
+form) with the major components (compiler, kernel, and so on) of the
+operating system on which the executable runs, unless that component
+itself accompanies the executable.
+
+If distribution of executable or object code is made by offering
+access to copy from a designated place, then offering equivalent
+access to copy the source code from the same place counts as
+distribution of the source code, even though third parties are not
+compelled to copy the source along with the object code.
+
+  4. You may not copy, modify, sublicense, or distribute the Program
+except as expressly provided under this License.  Any attempt
+otherwise to copy, modify, sublicense or distribute the Program is
+void, and will automatically terminate your rights under this License.
+However, parties who have received copies, or rights, from you under
+this License will not have their licenses terminated so long as such
+parties remain in full compliance.
+
+  5. You are not required to accept this License, since you have not
+signed it.  However, nothing else grants you permission to modify or
+distribute the Program or its derivative works.  These actions are
+prohibited by law if you do not accept this License.  Therefore, by
+modifying or distributing the Program (or any work based on the
+Program), you indicate your acceptance of this License to do so, and
+all its terms and conditions for copying, distributing or modifying
+the Program or works based on it.
+
+  6. Each time you redistribute the Program (or any work based on the
+Program), the recipient automatically receives a license from the
+original licensor to copy, distribute or modify the Program subject to
+these terms and conditions.  You may not impose any further
+restrictions on the recipients' exercise of the rights granted herein.
+You are not responsible for enforcing compliance by third parties to
+this License.
+
+  7. If, as a consequence of a court judgment or allegation of patent
+infringement or for any other reason (not limited to patent issues),
+conditions are imposed on you (whether by court order, agreement or
+otherwise) that contradict the conditions of this License, they do not
+excuse you from the conditions of this License.  If you cannot
+distribute so as to satisfy simultaneously your obligations under this
+License and any other pertinent obligations, then as a consequence you
+may not distribute the Program at all.  For example, if a patent
+license would not permit royalty-free redistribution of the Program by
+all those who receive copies directly or indirectly through you, then
+the only way you could satisfy both it and this License would be to
+refrain entirely from distribution of the Program.
+
+If any portion of this section is held invalid or unenforceable under
+any particular circumstance, the balance of the section is intended to
+apply and the section as a whole is intended to apply in other
+circumstances.
+
+It is not the purpose of this section to induce you to infringe any
+patents or other property right claims or to contest validity of any
+such claims; this section has the sole purpose of protecting the
+integrity of the free software distribution system, which is
+implemented by public license practices.  Many people have made
+generous contributions to the wide range of software distributed
+through that system in reliance on consistent application of that
+system; it is up to the author/donor to decide if he or she is willing
+to distribute software through any other system and a licensee cannot
+impose that choice.
+
+This section is intended to make thoroughly clear what is believed to
+be a consequence of the rest of this License.
+
+  8. If the distribution and/or use of the Program is restricted in
+certain countries either by patents or by copyrighted interfaces, the
+original copyright holder who places the Program under this License
+may add an explicit geographical distribution limitation excluding
+those countries, so that distribution is permitted only in or among
+countries not thus excluded.  In such case, this License incorporates
+the limitation as if written in the body of this License.
+
+  9. The Free Software Foundation may publish revised and/or new versions
+of the General Public License from time to time.  Such new versions will
+be similar in spirit to the present version, but may differ in detail to
+address new problems or concerns.
+
+Each version is given a distinguishing version number.  If the Program
+specifies a version number of this License which applies to it and "any
+later version", you have the option of following the terms and conditions
+either of that version or of any later version published by the Free
+Software Foundation.  If the Program does not specify a version number of
+this License, you may choose any version ever published by the Free Software
+Foundation.
+
+  10. If you wish to incorporate parts of the Program into other free
+programs whose distribution conditions are different, write to the author
+to ask for permission.  For software which is copyrighted by the Free
+Software Foundation, write to the Free Software Foundation; we sometimes
+make exceptions for this.  Our decision will be guided by the two goals
+of preserving the free status of all derivatives of our free software and
+of promoting the sharing and reuse of software generally.
+
+			    NO WARRANTY
+
+  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
+FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
+OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
+PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
+OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
+TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
+PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
+REPAIR OR CORRECTION.
+
+  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
+WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
+REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
+INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
+OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
+TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
+YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
+PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGES.
+
+		     END OF TERMS AND CONDITIONS
+
+	    How to Apply These Terms to Your New Programs
+
+  If you develop a new program, and you want it to be of the greatest
+possible use to the public, the best way to achieve this is to make it
+free software which everyone can redistribute and change under these terms.
+
+  To do so, attach the following notices to the program.  It is safest
+to attach them to the start of each source file to most effectively
+convey the exclusion of warranty; and each file should have at least
+the "copyright" line and a pointer to where the full notice is found.
+
+    <one line to give the program's name and a brief idea of what it does.>
+    Copyright (C) <year>  <name of author>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+
+Also add information on how to contact you by electronic and paper mail.
+
+If the program is interactive, make it output a short notice like this
+when it starts in an interactive mode:
+
+    Gnomovision version 69, Copyright (C) year  name of author
+    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
+    This is free software, and you are welcome to redistribute it
+    under certain conditions; type `show c' for details.
+
+The hypothetical commands `show w' and `show c' should show the appropriate
+parts of the General Public License.  Of course, the commands you use may
+be called something other than `show w' and `show c'; they could even be
+mouse-clicks or menu items--whatever suits your program.
+
+You should also get your employer (if you work as a programmer) or your
+school, if any, to sign a "copyright disclaimer" for the program, if
+necessary.  Here is a sample; alter the names:
+
+  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
+  `Gnomovision' (which makes passes at compilers) written by James Hacker.
+
+  <signature of Ty Coon>, 1 April 1989
+  Ty Coon, President of Vice
+
+This General Public License does not permit incorporating your program into
+proprietary programs.  If your program is a subroutine library, you may
+consider it more useful to permit linking proprietary applications with the
+library.  If this is what you want to do, use the GNU Library General
+Public License instead of this License.
diff --git a/DISTRIBUTIONS.txt b/DISTRIBUTIONS.txt
new file mode 100644
index 0000000..7ff2e66
--- /dev/null
+++ b/DISTRIBUTIONS.txt
@@ -0,0 +1,377 @@
+	Distribution specific notes on Wireless Configuration
+	-----------------------------------------------------
+
+***** HELP *****
+	If people send me information about the specifics of each
+distribution, I'll try to collect that here. Don't forget to mention
+to which distribution those instructions apply, the tool used (if any)
+and the files modified.
+	Actually, the people packaging my tools for a specific
+distribution have a moral obligation to send me the exact detailed
+instructions of what they have done. I will list in the wireless.7
+man page only distributions that give me an official answer.
+***** HELP *****
+
+				-----
+
+INTRODUCTION
+------------
+	The tools enable users to change the card settings at run time
+(when running iwconfig, for example). However, most users want the
+card to be configured either at boot time or when the card is
+activated in the system.
+	Each distribution has its own configuration scripts, and
+therefore is slightly different. Some distributions even add some
+graphical setup tool (nice). This file describe the procedure for a
+few of them.
+	Note : if you install the Pcmcia package in source form from
+the official Linux-Pcmcia web site (as opposed to precompiled by a
+distribution, please use the PCMCIA method).
+
+	Please remember : I don't use your distribution, and I have
+absolutely no clue about how your distribution works. I'm just
+collecting random information here without beeing able to verify it.
+
+				-----
+
+WIRELESS DRIVERS
+----------------
+	Most Linux wireless drivers support Wireless Extensions, and
+therefore may be configure via Wireless Tools and the methods
+described in this file.
+
+	However, a few drivers have no support or limited support for
+Wireless Extensions (like read only). In those cases, these are your
+options :
+		o read the driver documentation.
+		o use the driver specific interface or tools to
+configure the card, and try to integrate that in your distribution.
+		o implement Wireless Extension support in the driver.
+	In some cases, there are easier workaround. Different version
+of the driver may add Wireless Extension (often alongside the
+proprietary method). In some other case, there may be another driver
+supporting the same card and with support for Wireless Extensions.
+
+	Some Linux wireless drivers don't export all wireless settings
+via Wireless Extensions, not even through iwpriv. Those setting may be
+available through the driver specific interface. Refer to previous
+section for workarounds.
+
+---------------------------------------------------------------------
+
+PCMCIA METHOD
+-------------
+		(Contributed by Jean Tourrilhes <jt@hpl.hp.com>)
+	This method work for *all* distributions.
+	For Pcmcia cards, it is possible to overwrite the Pcmcia
+configuration files of the distribution with the original Pcmcia
+configuration files from the Pcmcia package (/etc/pcmcia/*). If you
+install the Pcmcia package in source form from the official
+Linux-Pcmcia web site, this will be done automatically.
+	Once this is done, you can no longer use the specific tools
+and configuration files of the distribution, and are required to use
+Pcmcia style of configuration (see Pcmcia Howto).
+	In such a case, Wireless configuration is done through
+wireless.opts, and documented in the file PCMCIA.txt.
+
+---------------------------------------------------------------------
+
+DEBIAN 2.2 (and earlier)
+----------
+		(Contributed by Jean Tourrilhes <jt@hpl.hp.com>)
+	Debian 2.2 (and earlier) doesn't support any Wireless
+Configuration. You are required to use the Pcmcia method. Also, the
+Wireless Tools package is not part of the standard packages.
+
+---------------------------------------------------------------------
+
+DEBIAN 3.0 (and later)
+----------
+		(Contributed by Guus Sliepen <guus@sliepen.eu.org>)
+	Debian also has another way of configuring network devices,
+controlled by /etc/network/interfaces. Users can add a wireless
+interface to /etc/network/interfaces, using the standard options to
+set the address and such, but the wireless-tools package adds new
+option statements that can be used to configure keys, channel,
+etcetera.
+	From the README.Debian script that comes with wireless-tools:
+
+	/etc/network/interfaces
+	-----------------------
+
+You can now add extra statements to the iface sections of the files in
+/etc/network/interfaces that are specific for wireless interfaces. They
+are of the form:
+
+    wireless-<function> <value>
+
+Before the interface is brought up, such a statement will result in the
+execution of the following command:
+
+    iwconfig <interface> <function> <value>
+
+Example:
+
+iface eth0 inet static
+    address 192.168.1.2
+    network 192.168.1.0
+    netmask 255.255.255.0
+    broadcast 192.168.1.255
+    wireless-essid Home
+    wireless-mode ad-hoc
+
+	The current Debian script support all arguments present in
+wireless.opts apart from Nickname. You can check this in the script
+/etc/network/if-pre-up.d/wireless-tool.
+	You will need of course to install the Wireless Tools package
+if it's not already done, which is part of the standard package list
+(use dselect, dpkg, apt or anything you like to get it).
+
+				-----
+
+		(Contributed by Joey Hess <joey@dragon.kitenet.net>)
+/etc/network/interfaces is much more flexible than it appears. It can probably
+do everything pcmcia schemes can do, and more. Here is part of mine:
+
+auto wlan0
+mapping wlan0
+        script /usr/local/bin/ifscheme-mapping
+
+iface wlan0-home inet static
+        address 192.168.1.5
+        gateway 192.168.1.1
+        netmask 255.255.255.0
+        wireless-mode ad-hoc
+        wireless-essid wortroot
+        wireless-nick dragon
+        wireless-channel 1
+
+iface wlan0-away inet dhcp
+        wireless-mode managed
+
+Now I can type 'ifscheme -s away' when I leave home, rather like
+cardctl scheme.
+
+The ifscheme script is at http://bugs.debian.org/154444. If the request in
+bug #154442 is implemented, it will become very flexible indeed..
+
+Debian will hopefully be using this same file eventually for pcmcia network
+devices too. It's already doable but takes a little work. This is all rather
+rough and badly documented so far.
+
+You can also do mapping based on the MAC address, if you want specific
+configuration on specific card.  See
+/usr/share/doc/ifupdown/examples/get-mac-address.sh and the stanza in
+/usr/share/doc/ifupdown/examples/network-interfaces.gz that uses it.
+This comes back to the problem I alluded to with mapping scripts not
+being "nestable" yet, and bug #154442. You can do what you want today,
+but you may need to write your own mapping script which uses a
+combination of MAC address and scheme info to return a stanza name to
+ifupdown.
+
+				-----
+
+		(Contributed by Jean Tourrilhes <jt@hpl.hp.com>)
+	The 'ifscheme' scripts mentionned above are now available in
+Debian Sarge, in the 'ifscheme' package.
+	The MAC address based mapping mentioned above is deprecated,
+you should use 'ifrename' to assign a consistent interface name to
+each of your network interface. This is documented in
+HOTPLUG.txt. This enable the combination of MAC address identification
+of interfaces with scheme multi-configuration.
+
+				-----
+
+	If you need automatic wireless configuration, you can look at
+the following packages :
+	o ifupdown-roaming :
+		http://panopticon.csustan.edu/thood/ifupdown-roaming.html
+	o waproamd
+		http://0pointer.de/lennart/projects/waproamd/
+
+---------------------------------------------------------------------
+
+SuSE 8.0 and later
+--------
+		(Contributed by Christian Zoz <zoz@suse.de>)
+	All network configuration is done in the directory
+/etc/sysconfig/network. It does not matter if it's a build in NIC or
+PCMCIA, USB, etc. The files network.opts and wireless.opts in
+/etc/pcmcia are not used any longer. There is /sbin/ifup to set up all
+kind of network interface.
+	There is a file /etc/sysconfig/network/wireless where you may
+set most of the options of iwconfig in seperate variables (they are
+named like the options). Additionally you may use
+WIRELESS_IWCONFIG_OPTIONS e.g. for setting key 2, 3 or 4 or
+unsupported iwconfig commands. This file is documented and its
+settings are used for any wlan NIC.
+	Configuration of wireless variable looks like :
+		WIRELESS_ESSID="<essid>"
+	Every variable from file wireless may be used in the interface
+configuration files /etc/sysconfig/network/ifcfg-* as well. As
+expectable this overwrites the global setting in wireless. For
+sophisticated use of the ifcfg-* files read 'man ifup'.
+
+	Hint for PCMCIA and USB users:
+	You need not to use the iterface name for the configuration as
+this may vary from one plugin to another. You may use a description of
+your hardware instead (ifcfg-<MACADDRESS> or ifcfg-pcmcia-1 for card
+in Slot 1)
+
+	Some of the variables can be set with YaST2 as well.
+
+	If you miss the 'schemes' functionality from the pcmcia-cs
+packages use the tool SCPM (System Configuration Profile Management)
+instead. This extends the pcmcia schemes to the whole system
+configuration. Read 'info scpm'. Since SuSE 8.1 there also is a YaST2
+modul for SCPM.
+
+---------------------------------------------------------------------
+
+RED-HAT 7.2
+-----------
+		(Grabbed from various source - Google is your friend)
+	Configuration is done in the file :
+		/etc/sysconfig/network-scripts/ifcfg-ethN
+	Where 'ethN' is the name of the wireless interface (such as
+eth0, eth1, ...).
+	The following lines may be added in this file :
+		MODE=<mode>
+		ESSID="<essid>"
+		RATE=<rate>
+		TXPOWER=<txpower>
+		KEY="<key>"
+	The full list of configuration can be found in the file :
+		/etc/sysconfig/network-scripts/ifup-wireless
+
+	Note that Brad Allison has other tips for 7.2 :
+	http://jackal.dnsalias.com:8080/public/misc/wireless/wireless.html
+
+---------------------------------------------------------------------
+
+RED-HAT 7.3 and later
+-----------
+		(Cut'n'pasted from Brad Allison web page)
+	http://jackal.dnsalias.com:8080/public/misc/wireless/wireless.html
+
+	If you are running RedHat 7.3, I would tell you to simply run
+/usr/bin/redhat-config-network and click "Devices", Click "Add", then
+select "Wireless Connection". You can find the full instructions in
+RedHat's Customization Guide for RH7.3 in Chapter 6, Network
+Configuration: Wireless Connection.
+		http://www.redhat.com/docs/manuals/linux/
+		http://www.redhat.com/docs/manuals/linux/RHL-7.3-Manual/custom-guide/s1-network-config-wireless.html
+
+	However, according to the Errata: The version of the Red Hat
+Network Administration Tool that shipped with Red Hat Linux 7.3 did
+not include wireless connection in the configuration wizard. An
+enhancement errata will be released soon with this feature. You can
+download the newest version of redhat-config-network from rpmfind.net.
+		http://www.redhat.com/docs/errata/RHL-7.3-Manual/
+		http://www.rpmfind.net/linux/rpm2html/search.php?query=redhat-config-network&submit=Search+...
+
+				-----
+
+		(Grabbed from various source - Google is your friend)
+	The current graphical user interface support :
+		ESSID, Mode, Freq, Channel, Rate, Key
+
+	Compared to Red-Hat 7.2, the Wireless Setting in the
+configuration file have change to include the WIRELESS_ prefix :
+		WIRELESS_MODE=<mode>
+		WIRELESS_ESSID='<essid>'
+		WIRELESS_ENC_KEY='<key>'
+	The underlying configuration files and configurations options
+seems to be indentical to what is done in Mandrake 8.2 (or vice
+versa), so please check the section below. This allow configuration of
+additional wireless settings not available in the GUI.
+
+				-----
+
+		(Extrapolated from web page of Martin Pot <m.t.pot@ieee.org>)
+		http://ii.net/~mpot/wireless/router.cgi
+	Red-Hat 7.3 also seem to support configuration in
+wireless.opts to some extent. But for compatibility with the network
+admin tools, I would still recommend to use the above method.
+	Red-Hat 7.3 seems to load wvlan_cs for Orinoco cards and
+friends. The above web page explain how to switch it to orinoco_cs.
+
+---------------------------------------------------------------------
+
+RED-HAT 9.0 and later
+-----------
+		(Cut'n'pasted from Dax Kelson web page)
+	http://www.gurulabs.com/RedHatLinux9-review.html
+
+	A little known fact is that newer versions of RHL support
+multiple network profiles. This is useful for machines that commonly
+plug into different networks (think laptops). The easy way to create
+network profiles is to use the redhat-config-network command. The
+question then becomes, what happens when you type "ifup eth0"? The
+behavior wasn't defined in previous versions, however, now in RHL 9
+the following behavior is defined;
+
+	search path for:
+# ifup $DEV
+	is:
+/etc/sysconfig/networking/profiles/$CURRENT_PROFILE/ifcfg-$DEV
+/etc/sysconfig/networking/profiles/default/ifcfg-$DEV
+/etc/sysconfig/network-scripts/ifcfg-$DEV
+
+	A cool trick is to boot your RHL box directly into a profile
+from the GRUB boot screen. To do this, create a separate
+/etc/boot/grub.conf entry for each network profile, and in each entry
+add the kernel argument netprofile=profilename.
+
+				-----
+
+	I'm pretty certain the profile scheme above also apply to
+wireless settings, which is good news...
+
+---------------------------------------------------------------------
+
+MANDRAKE 8.2 and later
+------------
+		(Grabbed from various source - Google is your friend)
+	Configuration is done in the file :
+		/etc/sysconfig/network-scripts/ifcfg-ethN
+	Where 'ethN' is the name of the wireless interface (such as
+eth0, eth1, ...).
+	The following lines may be added in this file :
+		WIRELESS_MODE=<mode>
+		WIRELESS_ESSID=<essid>
+		WIRELESS_NWID=<nwid>
+		WIRELESS_FREQ=<freq/channel>
+		WIRELESS_SENS=<sensitivity>
+		WIRELESS_RATE=<rate>
+		WIRELESS_ENC_KEY=<keys>
+		WIRELESS_RTS=<rts>
+		WIRELESS_FRAG=<frag>
+		WIRELESS_IWCONFIG=<iwconfig command>
+		WIRELESS_IWSPY=<iwspy command>
+		WIRELESS_IWPRIV=<iwpriv command>
+	Most likely, you only need to add a few of those lines and not
+all of them. The script doing the configuration and where you can
+check the details is :
+		/etc/network/network-scripts/ifup-wireless
+	You will of course need the Wireless Tools package :
+		rpm -Uvh wireless-tools-XX-Xmdk.XXX.rpm
+
+	Mandrake can also have wireless setting added to its
+Auto-Install procedure :
+	http://members.shaw.ca/mandrake/drakx/8.2/HTML/section4-13.html
+
+				-----
+
+		(in e-mail from Thierry Vignaud <tvignaud@mandrakesoft.com>)
+	You may use the following tool :
+		o drakconnect
+	You may read the following documentation :
+		o ifcfg
+
+---------------------------------------------------------------------
+
+
+	Have fun...
+
+	Jean
diff --git a/HOTPLUG.txt b/HOTPLUG.txt
new file mode 100644
index 0000000..d22a1f0
--- /dev/null
+++ b/HOTPLUG.txt
@@ -0,0 +1,1062 @@
+		Sane network interface management with Hotplug
+		----------------------------------------------
+
+INTRODUCTION
+------------
+	In the old days all wireless cards were managed by the
+excellent Pcmcia subsystem and its rich configuration scripts, and
+life was good. Then came the wireless PCI cards, then the wireless
+USB dongles. Some unification was needed, and rather than adapt the
+Pcmcia subsystem for PCI and USB, it was decided to create the much
+simpler Hotplug system.
+	The USB subsystem already uses Hotplug. The Pcmcia subsystem
+is migrating to it : CardBus cards (32 bits) already use Hotplug,
+whereas Pcmcia cards (16 bits) still use the old Pcmcia scripts.
+	The Hotplug system is still in its infancy, but already shows
+some good promise. Most users are disappointed at first by its
+apparent lack of features compared to the Pcmcia scripts. In this
+document, we will show how to fully exploit the Hotplug system and try
+to implement the equivalent of all the functionality of the Pcmcia
+scripts.
+
+ASSUMPTIONS
+-----------
+	The target audience of this document is mostly power users and
+distribution maintainers, but it should give enough clues to help
+newbies. You should have read and understood DISTRIBUTIONS.txt. The
+procedures described here are more advanced than the simple
+configuration described in DISTRIBUTIONS.txt.
+	The main focus is of course on removable wireless interfaces,
+but we will to talk about network interface management in general, so
+this should apply also to built-in Ethernet cards.
+
+PROBLEM STATEMENT
+-----------------
+	Let's assume a Linux system and two or more network devices,
+Device A and Device B. Those devices may be built-in or removable,
+they may be present or absent from the system at any time, and they
+may activated in any particular order.
+	The user wants to assign Configuration A to Device A and
+Configuration B to Device B, without the possibility that Device A
+gets assigned Configuration B.
+	Different users may have different definitions of what is
+Device A. For some, it's a specific instance of a specific hardware,
+for others any hardware that meets some criteria (a wireless card, an
+Ethernet card).
+	The user may also want to have multiple configurations for a
+given device such that the chosen configuration depends on various
+factors, just as with the old Pcmcia schemes. Device A may need
+Configuration A1 or Configuration A2 depending on those factors.
+	By default, all network interfaces are created using default
+interface names (starting at "eth0" and going up). I call that the
+"all my cards are eth0" problem : im most distributions, "eth0" points
+to a single fixed configuration in the configuration
+database. Clearly, this won't satisfy our requirements.
+
+EXAMPLE SYSTEM
+--------------
+	The distribution I use is Debian 3.0, and some parts of what I
+say here will be specific to it. However, it should be easy to
+translate this material to other distributions and I welcome additions
+to this document.
+
+	The example system is as follows :
+		o Linux 2.6.X SMP kernel with hotplug support
+		o Fully modular system (all network drivers as modules)
+		o PCI Ethernet card : AMD PCnet LANCE (pcnet32 - eth4)
+		o PCI Ethernet card : HP 100VG J2585B (hp100 - eth2)
+		o ISA Wireless card : Old AT&T Wavelan (wavelan - eth3)
+		o ISA-Pcmcia bridge : VADEM VG-469 (i82365 - slot 0)
+		o PCI-CardBus bridge : Ricoh RL5c475 (yenta_socket - slot 2)
+		o Pcmcia 802.11 card : Aironet 350 (airo_cs - eth0)
+		o Pcmcia 802.11 card : Lucent Orinoco (orinoco_cs - eth0)
+		o CardBus 802.11 card : SMC 2835W (prism54 - prism0)
+
+	This system just happens to be my Linux development box. It
+has enough interfaces to make it interesting. All the examples I
+present in this document are extracted from this system.
+
+BASIC CONCEPTS
+--------------
+	Most of the concept and tricks presented here are not really
+new. The main contribution is to integrate them.
+
+	1) Removable network interfaces are managed by Hotplug
+(Pcmcia, CardBus, USB...). We can't assume that those interfaces are
+always present in this system and available at boot time (Pcmcia cards
+were not made to be soldered in the Pcmcia slot). Therefore Hotplug is
+the way to go.
+	2) Built-in PCI and ISA cards are managed by the init scripts,
+as they have always been. The ISA subsystem will never have Hotplug
+support, and hotplug is not necessary for PCI cards.
+	3) Built-in devices that are disable most of the time should
+be enabled manually by the user. Therefore both Hotplug and the init
+scripts should ignore those devices by default.
+	4) (1), (2) and (3) must be compatible on the same system and
+play nice with each other.
+
+	5) A well defined and consistent network interface name is
+assigned to each network hardware interface using 'ifrename'. Device A
+is always named 'ethA' (or whatever name you like such as
+'mynetworkcard').
+	6) No interface is called 'eth0' (or 'wlan0'). Any unknown
+device would be 'eth0', so known devices should be called something
+else.
+	7) Multiple configurations for a single interface (schemes)
+are managed by the ifup/ifdown subsystem.
+
+CONFIGURATION FROM INIT SCRIPTS
+-------------------------------
+	It may seem paradoxical, but before setting up Hotplug, we
+need to make sure that the initialisation of network cards via init
+scripts is done properly and doesn't get in the way of the Hotplug
+subsystem.
+	The configuration of network cards via init scripts is the
+traditional way networking is initialised in Linux. The advantage of
+this method is that it's very well documented and understood, and has
+not changed much over the years. Unfortunately, it doesn't adequately
+support removable cards.
+
+	The init scripts perform the following 3 functions in order :
+		1) Load necessary driver modules
+		2) Rename interface to name chosen by the user
+		3) Configure those network interfaces
+
+	1) Applicability
+	----------------
+	Configuration from init scripts is applicable to any built-in
+network interface (ISA, PCI...), i.e., interfaces available at boot
+time and that will never be removed from the system.
+	The Hotplug subsystem also has the ability to configure some
+of the built-in network interfaces, such as PCI cards. However, there
+is a class of devices that will never have Hotplug support, such as
+ISA and EISA cards.
+
+	2) Loading driver modules (if/as needed)
+	----------------------------------------
+	Most distributions build the kernel drivers as modules. This
+modular setup allows to minimise the amount of memory used by the
+system and the flexible loading/unloading of drivers.
+	You can also compile your kernel with static drivers
+(non-modular). In that case, the driver will always be available in
+the kernel, you don't need to configure the module subsystem, so you
+can skip directly to the next section.
+
+	There are 3 alternatives to manage device drivers as
+modules.
+		1) Some distributions have an explicit list of modules
+that are loaded at boot time. If you want to use that feature you need
+to check the documentation of your distribution.
+		2) Some system, such as Hotplug, Discover or Kudzu,
+can scan the various buses of the PC and load the appropriate
+drivers. This is mostly configuration-free, but may not support all
+devices and may load unnecessary modules.
+		3) The module subsystem also allows to load modules
+'on-demand'. When an application try to access or configure a network
+interface, the corresponding module is loaded.
+
+	I personally prefer to use the 'on-demand' feature of the
+module subsystem, as this allow you to not have to specify a static
+list of modules that need to be loaded, and only modules really needed
+are loaded which saves kernel memory. You can also choose which module
+to load when there are multiple modules available that support your
+hardware (which happens quite often).
+
+	With kernel 2.6.X the module subsystem is configured in the
+file /etc/modprobe.conf or files in the directory /etc/modprobe.d/. To
+configure 'on-demand' module loading, on my test system I need to add
+to the following lines to the configuration :
+
+--------- /etc/modprobe.d/local or /etc/modprobe.conf ------
+# HP 100VG J2585B PCI card
+alias eth2 hp100
+
+# AMD AMD PCnet LANCE PCI card
+alias eth4 pcnet32
+
+# Old AT&T Wavelan ISA card
+alias eth3 wavelan
+options wavelan io=0x390 irq=15
+------------------------------------------------------------
+
+	Your distribution may already have lines for your interfaces,
+either replace these or make sure they are correct (some distributions
+are notorious for picking the wrong driver name in some cases). This
+file also contains configuration for lot of other subsystems,
+obviously you don't want to touch that.
+	In this file, you put the name you would like the interface to
+have (we'll fix that in a minute). Note that for modern PCI cards this
+is much more straightforward than for old ISA cards.
+
+	3) Installing 'ifrename'
+	------------------------
+	You will need to install ifrename on your system. 'ifrename'
+is part of the Wireless Tools package (version 27 and later) and is a
+complete rewrite of the now obsolete 'nameif'.
+	Some distributions, such as Debian Sarge, offer a separate
+package for 'ifrename', and in this case you should just install this
+package. Other distributions may include ifrename as part of their
+'wireless-tools' package (this should be the case for Gentoo, Fedora
+and Mandrake). Other distributions, such as Debian 3.0, don't include
+ifrename at all, so you should compile yourself a recent version of
+Wireless Tools (v27 or later) and install it.
+
+	In any case, you should verify that 'ifrename' is properly
+installed and check the path needed to call it :
+--------------------------
+> which ifrename
+/sbin/ifrename
+--------------------------
+	Most distributions will install 'ifrename' in '/sbin', while if
+you compile your own wireless tools, it will be in '/usr/local/sbin'.
+
+	4) Making the boot scripts call 'ifrename'
+	------------------------------------------
+	You need to make sure 'ifrename' is run at boot time. Most
+distributions don't do that yet by default.
+	This is a part that is distribution-specific, so you will need
+to look into your own init files, or ask people familiar with your
+distribution. It will need to run just before the call to 'ifup' or
+'ifconfig' command.
+
+	In Debian 3.0 and Debian Sarge, it needs to be run from
+/etc/init.d/networking, which is not the default. The necessary patch
+is below :
+
+----------------------------------------------------------------
+--- networking-orig     Wed Feb 18 13:56:23 2004
++++ networking  Fri Feb 20 14:51:06 2004
+@@ -120,6 +120,15 @@ case "$1" in
+         doopt syncookies no
+         doopt ip_forward no
+ 
++       # Optionally remap interface names based on MAC address.
++       # '/sbin/ifrename' is part of wireless-tools package.
++       # /etc/iftab is currently not created by default. Jean II
++       if [ -x /sbin/ifrename ] && [ -r /etc/iftab ]; then
++           echo -n "Remapping network interfaces name: "
++           ifrename -p
++           echo "done."
++       fi
++
+         echo -n "Configuring network interfaces: "
+         ifup -a
+        echo "done."
+----------------------------------------------------------------
+	Don't forget to set the appropriate path to the ifrename
+command (see step (3) above).
+
+	You may also want to also set the proper options for ifrename
+(check the man page).
+	The option '-p' enables module autoloading compatibility.
+	The default version of 'ifrename' also includes some special
+Debian support : using "ifrename -p -d", only the proper modules are
+loaded. If you are using Debian, you should use this option.
+
+	5) Renaming interfaces
+	----------------------
+	As stated above, we use 'ifrename' to assign names to
+interfaces.
+
+	First, you need to get the MAC address of each of your
+interfaces. You can read the MAC address on the label of the card, or
+display it using the 'ifconfig -a' command. Remember that the
+interface won't load yet with the proper name, so you may need to do a
+bit looking around :
+
+-----------------------------
+# modprobe pcnet32
+# ifconfig eth0
+eth0      Link encap:Ethernet  HWaddr 00:10:83:34:BA:E5  
+[...]
+-----------------------------
+
+	The configuration of 'ifrename' is simple, you just specify
+which name should be used for each MAC address in the file
+/etc/iftab :
+
+--------- /etc/iftab ------------------------
+# HP 100VG J2585B PCI card
+eth2		mac 08:00:09:*
+
+# Old AT&T Wavelan ISA card
+eth3		mac 08:00:0E:*
+
+# AMD AMD PCnet LANCE PCI card
+eth4		mac 00:10:83:*
+---------------------------------------------
+
+	The '*' in the MAC address is a wildcard and allows me to
+replicate my configuration between multiple identical computers. If
+you have to manage large number of computers (like a rack of servers
+or clusters), then you may want to look at other selectors offered by
+'ifrename'.
+
+	To test that ifrename works, do the following :
+		o Load all your drivers, see section (2)
+		o Check /proc/net/dev to see which interface exist
+		o Bring all interfaces down : ifconfig ethX down
+		o Run ifrename
+		o Check each interface with ifconfig
+		o Bring all interfaces up : ifconfig ethX up
+
+	6) Configuring interfaces
+	-------------------------
+	Most likely, your distribution is already doing this part
+properly. Just assign the proper IP and wireless configuration to each
+of the interface names you have chosen.
+	This part is distribution specific, and I already document it
+in the file DISTRIBUTIONS.txt.
+
+	In Debian, you would need to modify the file
+/etc/network/interfaces so that it looks something like this :
+
+--------- /etc/network/interfaces -----------
+# AMD PCnet LANCE PCI card
+auto eth4
+iface eth4 inet dhcp
+
+# HP 100VG J2585B PCI card
+auto eth2
+iface eth2 inet static
+    address 10.0.0.2
+    netmask 255.255.255.0
+    broadcast 10.0.0.255
+    gateway 10.0.0.1
+---------------------------------------------
+
+	This was the last part. Now, at your next boot, all your
+interfaces should be assigned the proper name and the proper
+configuration.
+
+CONFIGURATION VIA HOTPLUG
+-------------------------
+	Dealing with removable interfaces is similar to dealing with
+built-in interfaces, the main difference is that we will use the
+Hotplug scripts instead of the init scripts. Another difference is
+that it will likely require more work on your part because most
+distributions are not fully ready for it.
+
+	1) Applicability
+	----------------
+	The Hotplug configuration method is the best choice for any
+removable network interface, such as :
+		o Pcmcia (16 bits) network cards
+		o CardBus (32 bits) network cards
+		o USB network dongles
+		o Hot-PCI network cards
+	It may also be used to manage other types of network
+interfaces, although it may not be the best choice for them.
+
+	2) How Hotplug works
+	--------------------
+	Conceptually, Hotplug is very simple. When something
+interesting happens, the Linux kernel generates an Hotplug event. This
+runs the proper script from the /etc/hotplug directory.
+	There are 3 types of Hotplug events we care about :
+		o PCI event : a CardBus device is added or removed
+from the system. The script /etc/hotplug/pci.agent is run.
+		o USB event : a USB device is added or removed
+from the system. The script /etc/hotplug/usb.agent is run.
+		o Network event : a network interface is added or
+removed from the system. The script /etc/hotplug/net.agent is run.
+
+	If we insert a CardBus network card in the system, the
+following happens :
+		1) Kernel detects new CardBus device
+		2) Kernel generates PCI Hotplug event
+		3) /etc/hotplug/pci.agent runs, finds proper driver module
+		4) /etc/hotplug/pci.agent loads driver module
+		5) Driver module initialises, creates new network device
+		6) Kernel detects new network device
+		7) Kernel generates Network Hotplug event
+		8) /etc/hotplug/net.agent runs, configures network device
+	The sequence of events is similar for removals and USB devices.
+
+	3) Make sure ifup does not deadlock
+	-----------------------------------
+	<Most people should ignore this part>
+	The first problem is that we need to make sure the command
+'ifup' does not deadlock by calling itself re-entrantly. If the system
+has built-in interfaces, the 'ifup' may reenter itself at boot time
+via Hotplug :
+		1) Init scripts start running
+		2) Init script calls 'ifup -a' to initialise built-in
+			network interfaces
+		3) 'ifup' auto-loads driver module for built-in network
+			interface 'eth4'
+		4) Driver module initialises, creates new network device
+		5) Kernel generates Network hotplug event
+		6) /etc/hotplug/net.agent runs, call 'ifup eth4'
+	Note that you can produce the same reentrancy if you call ifup
+manually on an interface which module is not yet loaded.
+
+	The default version of 'ifup' for Debian 3.0 and Debian Sarge
+is not reentrant and can therefore deadlock if not used properly. The
+patch to make 'ifup' properly reentrant is available here :
+		http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=231197
+	Contemporary versions of Debian (Sarge and later) have a
+net.agent script that contains workarounds to prevents deadlock
+situations, so for normal use the default 'ifup' should work fine.
+
+	Other distributions have very different ifup programs and I
+have not tried those (tell me about it !).
+
+	4) Installing Hotplug for Debian Sarge (testing/unstable)
+	---------------------------------------------------------
+	Thanks to the great work of many people, Debian Sarge has all
+the necessary packages and hotplug support, and will work mostly 'out
+of the box'.
+	You will need to install the following packages :
+		o hotplug
+		o ifrename
+
+	While the installation of Hotplug is simple, its configuration
+may seem complex. The current network Hotplug script has 3 modes :
+'all', 'auto' and 'hotplug'. However for our purpose they all produce
+the same results when configured. This mode is controlled by the
+variable NET_AGENT_POLICY in /etc/default/hotplug.
+
+	In the mode "all", Hotplug will run ifup for all network
+events. This will result in failure messages if some interfaces have
+already been configured by the init scripts. This mode is not
+recommended.
+
+	In the mode "auto", Hotplug will run ifup only for those
+interfaces listed in a auto stanza in /etc/network/interfaces. If
+you choose this mode, you need to put in /etc/network/interfaces a
+"auto" line for the interfaces you want to control with hotplug.
+--------- /etc/network/interfaces -----------
+# Enable Hotplug support for "auto" mode (Sarge and later)
+auto eth0 eth1 eth2 eth3 eth4 wlan0 wlan1 prism0 prism1 airo0 airo1
+---------------------------------------------
+	This will result in some failure message at boot time, the
+init script will attempt to enable all those interfaces, and generate
+an error for all those not available at this time. It will also
+generate an error messages for interface which have already been
+configured by the init scripts. This mode is also not recommended.
+
+	In the mode "hotplug", hotplug network events are ignored by
+ifup by default. To enable them you will need to add the following
+lines to /etc/network/interfaces :
+--------- /etc/network/interfaces -----------
+# Enable Hotplug support for "hotplug" mode (Sarge and later)
+mapping hotplug
+    script echo
+---------------------------------------------
+
+	To enable them for only selected interfaces, e.g., ethA, make
+/etc/network/interfaces look like this :
+--------- /etc/network/interfaces -----------
+# Enable Hotplug support for "hotplug" mode (Sarge and later)
+mapping hotplug
+    script grep
+    map ethA
+---------------------------------------------
+
+	5) Installing Hotplug for Debian 3.0
+	------------------------------------
+	Debian 3.0 doesn't come by default with hotplug, but the
+hotplug package is available as regular Debian package (on the CD or
+downloadable in Debian archive), so you can just install that.
+
+	Unfortunately, this version of hotplug is not fully compatible
+with kernel 2.6.X. You will need to do the following modifications to
+the file /etc/hotplug/net.agent.
+
+------- /etc/hotplug/net.agent ------------------
+--- net.agent-d1        Fri Feb 20 18:18:05 2004
++++ net.agent   Fri Feb 20 18:22:50 2004
+@@ -26,7 +26,7 @@ if [ "$INTERFACE" = "" ]; then
+ fi
+ 
+ case $ACTION in
+-register)
++add|register)
+ 
+     case $INTERFACE in
+        # interfaces that are registered after being "up" (?)
+@@ -52,7 +52,7 @@ register)
+     mesg $1 $ACTION event not handled
+     ;;
+ 
+-unregister)
++remove|unregister)
+     # Assume that we want to run ifdown no matter what,  
+     # because it is not going to remove the data from the 
+     # ifstate database otherwise.
+-------------------------------------------------
+
+	Compared to the version in Sarge, this older version of
+hotplug is much more basic, and doesn't have any scanning at boot time
+and doesn't need to be enabled in /etc/network/interfaces.
+
+	6) Installing hotplug on other distributions
+	--------------------------------------------
+	The canonical version of hotplug is available at :
+		http://linux-hotplug.sourceforge.net/
+
+	Most distributions have customized hotplug packages and
+chances are that the canonical version won't completely work on your
+system. All these various changing versions make it difficult for me
+to tell what exactly needs to be changed in the hotplug scripts to
+make them work. However, most should work out of the box.
+
+	My guess is that in a few releases, all these problems will
+sort themselves out. Just be patient.
+
+	7) Dealing with 'init' hotplug
+	------------------------------
+	In addition to the standard kernel Hotplug events, modern
+versions of the Hotplug scripts add init scripts that scan the system
+buses and generate pseudo Hotplug events at boot time. For the PCI
+buses, the script /etc/hotplug/pci.rc is run, for the USB bus,
+/etc/hotplug/usb.rc is run.
+	The end result is that the Hotplug subsystem will also attempt
+to configure built-in devices :
+		1) Kernel boots
+		2) Init runs, start to initialise the OS
+		3) /etc/hotplug/pci.rc runs, generates pseudo Hotplug event
+		4) /etc/hotplug/pci.agent loads driver module
+		5) Driver module initialises, creates new network device
+		6) Kernel generates Network Hotplug event
+		7) /etc/hotplug/net.agent runs, configures network device
+
+	At this point, you realise that at initialisation, both
+Hotplug and the regular init scripts (see "CONFIGURATION FROM INIT
+SCRIPTS") are trying to configure the same devices in parallel. This
+may create problems and is totally redundant.
+	Another reason I don't like this mechanism is that it blindly
+attempts to load drivers for all hardware present on the system and
+doesn't use the module loader configuration files to select preferred
+drivers. It's fairly common to have multiple drivers for a given
+hardware, and because of Murphy's law, Hotplug will usually load the
+wrong one. It's also fairly common to have hardware on the system that
+doesn't need enabling (for example, the IDE controller on my SCSI
+machine), not loading the driver makes your kernel smaller and boot
+faster.
+
+	Hotplug does have a way of disabling the loading of drivers
+on a case by case basis. Drivers listed in /etc/hotplug/blacklist
+will not be loaded.
+	Hotplug can be disabled for a whole subsystem by editing the
+appropriate .rc script in /etc/hotplug, or just deleting/renaming
+those files.
+
+	8) Making hotplug scripts call ifrename
+	---------------------------------------
+	The last hotplug step is to make sure that 'ifrename' is run
+by the hotplug subsystem at the right time. As before, we want to run
+it just before calling 'ifup'.
+	The latest version of the hotplug scripts have this feature
+integrated. However, you need to check that the path used for calling
+'ifrename' is the proper one on your system. And, for older versions
+of hotplug scripts, you will need to add this support yourself.
+
+	Check the path for ifrename :
+--------------------------
+> which ifrename
+/sbin/ifrename
+--------------------------
+
+	The patch to add 'ifrename' to hotplug looks like :
+
+------- /etc/hotplug/net.agent ------------------
+--- net.agent-s2        Fri Feb 20 17:18:46 2004
++++ net.agent   Fri Feb 20 17:32:43 2004
+@@ -40,6 +40,21 @@ add|register)
+            # we can't do much here without distro-specific knowledge
+            # such as whether/how to invoke DHCP, set up bridging, etc.
+ 
++           # Run ifrename as needed - Jean II
++           # Remap interface names based on MAC address. This works around
++           # the dreaded configuration problem "all my cards are 'eth0'"...
++           # This needs to be done before ifup, otherwise ifup will get
++           # confused by the name change and because iface needs to be
++           # down to change its name.
++           if [ -x /sbin/ifrename ] && [ -r /etc/iftab ]; then
++               debug_mesg invoke ifrename for $INTERFACE
++               NEWNAME=`/sbin/ifrename -i $INTERFACE`
++               if [ -n "$NEWNAME" ]; then
++                   debug_mesg iface $INTERFACE is remapped to $NEWNAME
++                   INTERFACE=$NEWNAME
++               fi;
++           fi
++
+            # RedHat and similar
+            export IN_HOTPLUG=1
+            if [ -x /sbin/ifup ]; then
+-------------------------------------------------
+
+	If your hotplug scripts already include ifrename support then
+you should find a section in /etc/hotplug/net.agent looking like the
+patch above. Otherwise, just cut'n'paste the patch above in the right
+place.
+	The path for 'ifrename' is used twice above, so don't forget
+to modify both occurences.
+
+
+	9) Loading driver modules
+	-------------------------
+	Wow ! The most difficult part is done.
+	In theory, you don't need to do any specific configuration for
+the driver modules to be loaded. The 'pci.agent' and 'usb.agent'
+should load the right driver module for you.
+	Also, you don't need to define aliases in /etc/modprobe.d/* or
+in /etc/modprobe.conf, it's useless and may be counterproductive.
+
+	If you use a driver compiled statically in the kernel, you
+also have nothing to do.
+
+	10) Renaming interfaces
+	-----------------------
+	We still use ifrename to assign names to interfaces. The
+configuration of 'ifrename' is the same. To keep the possibility of
+having multiple wireless cards (one in each CardBus slot), we use
+wildcards in both the MAC address and the name :
+
+--------- /etc/iftab -----------------------
+# SMC 2835W wireless CardBus card
+prism*		mac 00:30:B4:*
+---------------------------------------------
+
+	If you insert two cards, they would be named prism0 and
+prism1. Note that 'name wildcarding' is a feature only available in
+2.6.X and 2.4.30 and later, so if you use older version of 2.4.X you
+will need to be explicit and list each card separatly :
+
+--------- /etc/iftab -----------------------
+# SMC 2835W wireless CardBus card
+prism0		mac 00:30:B4:64:27:8B
+prism1		mac 00:30:B4:64:27:8D
+---------------------------------------------
+
+	11) Configuring interfaces
+	-------------------------
+	At this point, configuration of Hotplug interfaces is done
+just like their built-in counterparts. This part is still distribution
+specific, and still already documented in the file DISTRIBUTIONS.txt.
+
+	In Debian, you would need to modify the file
+/etc/network/interfaces like this :
+
+--------- /etc/network/interfaces -----------
+# Enable Hotplug support (Sarge and later)
+mapping hotplug
+    script grep
+    map prism0
+
+# SMC 2835W wireless CardBus card
+iface prism0 inet static
+    address 10.0.1.2
+    netmask 255.255.255.0
+    broadcast 10.0.1.255
+    wireless-essid THE_ESSID
+    wireless-mode ad-hoc
+    wireless-channel 5
+---------------------------------------------
+
+	Note that you should not have wireless-* lines if you are
+using waproamd to set these parameters.
+
+	Now, just cross your fingers and plug the card in the slot...
+
+PCMCIA INTERFACES (16 bits)
+---------------------------
+	The Pcmcia subsystem has quite some legacy, and can use
+various configuration procedures. The Pcmcia subsystem exclusively
+uses hotplug for 32 bits cards (if you are using the kernel Pcmcia
+modules, which is the only option for 2.6.X). For 16 bit cards cardmgr
+is still required for managing the sockets and loading
+modules. Cardmgr is configured by files in the /etc/pcmcia directory.
+
+	To use Hotplug network configuration with 16 bits Pcmcia
+cards, first make sure the Pcmcia subsystem is properly configured and
+that cardmgr loads the right driver module (in most case, it
+should). Then, make sure that you don't have any configuration entries
+in /etc/pcmcia/network.opts and /etc/pcmcia/wireless.opts. Make sure
+that none of the entries in your system network configuration use
+'eth0' or 'wlan0' (in /etc/network/interfaces for Debian users).
+	Then, just follow the procedure described above for
+"Configuration Using Hotplug" to configure your network cards.
+
+	You might want a little bit of explanation on why this magic
+will work (which would help in case it doesn't work).
+	There are two types of Pcmcia network configuration scripts,
+available as /etc/pcmcia/network. The original Pcmcia script
+configures network cards using options found in
+/etc/pcmcia/network.opts and /etc/pcmcia/wireless.opts. Most
+distributions replace it with a script calling 'ifup'. By making sure
+that network.opts and wireless.opts are "empty", we neutralise the
+first set of scripts. By making sure no system configuration uses
+'eth0' or 'wlan0', we neutralise the second set of scripts, the script
+would call 'ifup' with the default interface name, which is usually
+'eth0', ifup would not find a configuration for it and would just
+ignore it.
+	The card would still be configured because hotplug network
+events are generated for every interfaces, not only for devices
+managed by hotplug. So, net.agent would receive an event and perform
+the necessary steps to configure it.
+
+	Personally, I'm still using the original Pcmcia scripts for my
+Pcmcia cards as described in the file PCMCIA.txt, because it still
+works and I will migrate my complex configurations over time.
+	You can also decide to not use Hotplug for Pcmcia cards and
+modify the distribution Pcmcia scripts in /etc/pcmcia/* to handle
+Pcmcia cards with ifrename. You would need to modify
+/etc/pcmcia/network to add 'ifrename' before 'ifup' the same way it
+was done for /etc/hotplug/net.agent. But, as in the long term Pcmcia
+will migrate to Hotplug, I would not bother...
+
+MANUAL LOADING, DOCKING STATIONS
+--------------------------------
+	Manual loading is used for built-in network interfaces that
+are only use at specific time, and that you want disabled the rest of
+the time. We assume that you still use modules so that when the
+interface is not used you can remove the driver from the kernel.
+
+	First, you need to set the configuration for those interfaces,
+the same way it's done for other network interfaces. The main
+difference is that you need to specify that those interfaces should
+not be enabled at boot time. It's also a good idea to disable Hotplug
+init scripts.
+	With Debian, you just need to make sure that the 'auto"
+keyword doesn't apply to this interface.
+
+	If you use drivers statically built in the kernel, make sure
+that ifrename runs at boot time (see CONFIGURATION FROM INIT
+SCRIPTS). Once it's done, you can just enable and disable those
+interfaces with 'ifup ethX' and 'ifdown ethX'.
+
+	If you use both a modular system, make sure that the
+'on-demand' module loading is properly configured :
+
+--------- /etc/modprobe.d/local or /etc/modprobe.conf ------
+# HP 100VG J2585B PCI card
+alias eth2 hp100
+
+# AMD AMD PCnet LANCE PCI card
+alias eth4 pcnet32
+------------------------------------------------------------
+
+	Then, you should instruct 'ifup' to load module and use
+ifrename prior to configuring the interface, and remove the module
+when going down. With Debian, this is done with :
+
+--------- /etc/network/interfaces -----------
+# AMD AMD PCnet LANCE PCI card
+# noauto
+iface eth4 inet dhcp
+    pre-up /sbin/ifrename -p -n eth4
+    post-down /sbin/modprobe -r eth4
+
+# HP 100VG J2585B PCI card
+# noauto
+iface eth2 inet static
+    address 10.0.0.2
+    netmask 255.255.255.0
+    broadcast 10.0.0.255
+    gateway 10.0.0.1
+    pre-up /sbin/ifrename -p -n eth2
+    post-down /sbin/modprobe -r eth2
+---------------------------------------------
+
+	We use the '-n' option of ifrename to specify the name of the
+interface after renaming. This assume that the mapping for those
+interfaces don't use wildcards. The '-p' option make sure ifrename
+probes the module prior to using it.
+	Using "modprobe -r" make sure that if the driver is composed
+of multiple module all the modules are unloaded.
+	
+	To enable the interface, just use :
+-----------------------------------
+ifup eth4
+-----------------------------------
+	And to disable the interface :
+-----------------------------------
+ifdown eth4
+-----------------------------------
+
+	This solution is obviously Debian specific, but could be
+adapted to other distributions. If you can't manage to get your
+distributions to use those tricks, you can do things manually.
+	If you don't use Hotplug, you enable an interface with :
+-----------------------------------
+modprobe eth4
+ifrename
+ifup eth4
+-----------------------------------
+	If you use hotplug, you only need to do :
+-----------------------------------
+modprobe eth4
+-----------------------------------
+	On the other hand, disabling the interface is done with :
+-----------------------------------
+ifdown eth4
+modprobe -r eth4
+-----------------------------------
+
+
+	Docking stations for laptops may contain built-in
+interfaces. My previous laptop had one, and Linux had no support for
+it. After docking, I was able to bring up the network ISA card in the
+docking station.
+	However, with most laptops and version of Linux, the issue is
+that after docking, the new devices are not seen. The solutions is to
+force a rescan of the PCI bus. Documentation is unclear on that, maybe
+'scanpci' may help.
+
+	To be able to simply manage my docking station, I had created
+two little scripts to enable and disable my network interface.
+	After docking, you would run :
+-------- /sbin/dock ----------------------------
+#!/bin/sh
+modprobe eth4
+ifrename
+ifup eth4
+------------------------------------------------
+	And prior to undocking, you would run :
+-------- /sbin/undock ----------------------------
+#!/bin/sh
+ifdown eth4
+modprobe -r eth4
+------------------------------------------------
+	Thanks to 'ifrename', the network interface in your dock will
+always be properly configured regardless of if you have a Pcmcia
+network card in the Pcmcia slot or not.
+
+
+SCHEMES (MULTI-CONFIG)
+----------------------
+	Most Ethernet cards will only connect to a single network, or
+can use DHCP to be auto-configured. With Wireless Cards, it's much
+more likely that you will need multiple configurations, for example at
+work, at home and on-the-go.
+
+	Most distributions have various level of support for such
+schemes. Some distributions offer simple network schemes, while other
+offer "overall" schemes changing the whole configuration. I document
+the support for schemes in various distributions in the file
+DISTRIBUTIONS.txt.
+
+	You can also use tools such as ifplugd, waproamd or
+wlandetect. Those tools are a kind of "wireless-DHCP", they attempt to
+automatically detect the proper wireless configuration and apply
+it. Most will also attempt to detect network changes.
+	The main limitation of those tools is that they offer very
+little manual control. If two valid alternatives are possible, you
+can't switch between them. If a configuration can't be detected, they
+usually fail.
+	That's the same concept as using DHCP versus Static IP
+addresses. Some people are very happy with DHCP, my style is Static IP
+addresses.
+
+	If you use Debian and want to use simple manual schemes, these
+are the things you need to do.
+	1) Make sure that 'ifscheme' and 'ifscheme-mapping' are
+installed on the system. You may find them in a separate tar file on
+my web site.
+	2) Check the path for 'ifscheme-mapping' (using whereis).
+	3) Modify you /etc/network/interface to add proper mapping and
+configuration.
+
+------- /etc/network/interfaces ----------------------
+# Enable Hotplug support (Sarge and later)
+mapping hotplug
+    script echo
+
+# SMC 2835W wireless CardBus card
+mapping prism0
+    script /sbin/ifscheme-mapping
+
+iface prism0-any inet dhcp
+    wireless-essid any
+    wireless-mode managed
+
+iface prism0-adhoc inet static
+    address 10.0.1.2
+    network 10.0.1.0
+    netmask 255.255.255.0
+    broadcast 10.0.1.255
+    wireless-essid THE_ESSID
+    wireless-mode ad-hoc
+    wireless-channel 5
+
+iface prism0-other inet static
+    address 10.10.10.2
+    network 10.10.10.0
+    netmask 255.255.255.0
+    broadcast 10.10.10.255
+    wireless-essid ANOTHER_ESSID
+    wireless-mode ad-hoc
+    wireless-key "s:secure"
+------------------------------------------------------
+
+FIRMWARE LOADING
+----------------
+	A lot of modern wireless card don't have built in firmware and
+need firmware loading. Recent kernels (2.6.X) have a firmware
+loader. These are a few notes on how to use it.
+
+	First, read the documentation coming with your driver, because
+each driver has specificities (like the name of the firmware file it
+requires). Some drivers may offer additional ways to load the
+firmware, but in the long term things should be standardised around
+the hotplug method to simplify packaging in distributions.
+
+	You need to compile your kernel with firmware loading
+(CONFIG_FW_LOADER in "Generic Driver Options"). If your driver was
+built from the kernel, chances are that it enabled this feature
+already. Make sure you boot from this new kernel.
+
+	The 'sysfs' file system must be mounted. The easiest is to
+mount it at boot time, add a line for it in /etc/fstab :
+
+-------- /etc/fstab ------------------------------
+sysfs		/sys	      sysfs  defaults                   0      0
+--------------------------------------------------
+
+	Then, you add the firmware file in the directory where it's
+expected, which is /usr/lib/hotplug/firmware/ in most cases.
+
+	Most distributions nowadays have a version of the Hotplug
+scripts that knows how to deal with firmware. If it is not the case,
+just grab the 'firmware.agent' file from an alternate source and copy
+it into your /etc/hotplug directory (make sure it's executable).
+	You can try the canonical version :
+		http://linux-hotplug.sourceforge.net/
+	Or Debian's version :
+		http://packages.debian.org/unstable/admin/hotplug
+
+	Note that firmware loading will usually only work with
+interfaces that are fully managed by Hotplug. This is the only way to
+ensure the that proper sequence of action is happening in the right
+order every time. Firmware loading may not work properly for
+interfaces configured in the init scripts.
+	This means that if you have a built-in interface that require
+firmware loading, you should just use manage those interfaces like
+removable interfaces (see section above). However, interface
+configuration need to be explicitly triggered at boot time.
+
+	One possibility is to set-up Hotplug to be run from the init
+script at boot time. This is usually an option for recent
+distributions (it's not the case for Hotplug in Debian 3.0). But, we
+have seen that this has some issues.
+	The other possibility is to use an hybrid between the init
+script method and the hotplug method. First, you need to add an alias
+for the driver in /etc/modprobe.conf. Then, you need to specify a
+mapping for this interface in /etc/iftab, and specify a configuration
+for this interface and that it is enabled at boot time. Lastly,
+you make sure that the network init scripts run 'ifrename
+-p'. 'ifrename' will trigger the module to load, and all the Hotplug
+events will be generated properly to configure the interface.
+
+DEVICES WITH MULTIPLE NAMES
+---------------------------
+	Some wireless drivers offer multiple network interfaces for
+the same device. A classical example is the Aironet driver that
+creates a 'ethX' and 'wifiY' for each card.
+
+	'ifrename' allows you a finer selection of interfaces than
+'nameif'. For example, to only rename the pseudo-Ethernet network
+interface name of the Aironet driver, you would do :
+
+--------- /etc/iftab -----------------------
+# Cisco Aironet 350 wireless Pcmcia card
+airo*		mac 00:07:0E:* arp 1
+---------------------------------------------
+
+	After that, your device would be available through 'eth0' and
+'wifi0'.
+
+	You can rename both interfaces. You just need to remember that
+'ifrename' starts matching from the last line of the file, so you
+would do :
+--------- /etc/iftab -----------------------
+# Cisco Aironet 350 wireless Pcmcia card
+wifi*		mac 00:07:0E:*
+airo*		mac 00:07:0E:* arp 1
+---------------------------------------------
+
+	The current version of 'ifrename' supports only the most useful
+selectors, but it is architectured such as adding selectors is relatively
+trivial. If you find a case that 'ifrename' can't handle, you should
+just extend it.
+
+DEVICES WITHOUT MAC ADDRESSES
+-----------------------------
+	Most Ethernet and Wireless devices have a fixed and unique MAC
+address, and it is therefore advised to name them based on this
+criteria. However, there are also network interfaces that don't have a
+fixed and unique MAC address, for example Ethernet over USB, IP over
+FireWire, PPP and tunnel interfaces.
+	The driver for those devices creates the interface with a name
+specific to the driver, such as ppp* for PPP interfaces and usb* for
+Ethernet over USB, and therefore they are easy to identify and
+configure, and few users feel the need to rename them. Moreover, some
+of them, such as PPP, have their own configuration scripts and
+methodology addressing their unique needs.
+
+	There are a few cases where you might want to rename
+interfaces without MAC addresses. One example is two Ethernet over USB
+dongles. The way to do this is to use alternate ifrename
+selectors. Choosing the right selector depends on what you want to
+achieve.
+	A quick theoretical example to illustrate :
+--------- /etc/iftab -----------------------
+# All other usbnet devices
+usb*		driver usbnet
+# Specific usbnet devices
+usb-p		firmware "Prolific PL-2301/PL-2302"
+usb-4		bus-info usb-00:02.0-1.4
+---------------------------------------------
+
+TROUBLESHOOTING
+---------------
+	If your interface doesn't show up as expected with ifconfig,
+you will need to find out why. First, you need to be familiar with the
+sequence of actions in the system and find which one did not happen.
+
+	You need to check that the driver module(s) was loaded using
+'lsmod'.
+
+	You need to check if the interface was properly renamed with
+'ifrename'. You can use 'ifrename -D -V' to debug your /etc/iftab.
+	Get the list of interfaces on your system with 'ifconfig -a'
+or 'cat /proc/net/dev', and check if an interface is using the name
+you assigned or 'eth0'. Check any suspicious interfaces with 'ifconfig
+eth0', and check its MAC address. Note that some rare drivers don't
+have a proper MAC address before brought up, which fools ifrename.
+	Verify that no line in /etc/iftab matches the all-zero MAC
+address. The all-zero MAC address matches the loopback interface 'lo'
+and various pseudo network devices, renaming the loopback interface is
+highly discouraged.
+
+	You need to check which configuration was given to the
+interface using 'ifconfig' and 'iwconfig'.
+
+	The Hotplug subsystem has also good debugging facilities.
+	To enable Hotplug debugging, just make sure the variable DEBUG
+is defined in /sbin/hotplug :
+--------- /sbin/hotplug ------------------------------
+--- /sbin/hotplug-old      Tue Mar 26 09:00:20 2002
++++ /sbin/hotplug       Fri Feb 20 18:40:38 2004
+@@ -22,7 +22,7 @@
+ cd /etc/hotplug
+ . hotplug.functions
+ 
+-# DEBUG=yes export DEBUG
++DEBUG=yes export DEBUG
+ 
+ if [ "$DEBUG" != "" ]; then
+     mesg "arguments ($*) env (`env`)"
+------------------------------------------------------
+	Then, you can check your message logs for Hotplug events with
+'tail -f /var/log/messages'. Verify that the various Hotplug events
+happen as expected (pci, firmware, net...), and verify the log
+messages from 'net.agent'.
+
+
+	Have fun...
+
+	Jean
diff --git a/IFRENAME-VS-XXX.txt b/IFRENAME-VS-XXX.txt
new file mode 100644
index 0000000..dba3dfe
--- /dev/null
+++ b/IFRENAME-VS-XXX.txt
@@ -0,0 +1,141 @@
+		Network interface renaming comparison
+		-------------------------------------
+
+INTRODUCTION
+------------
+	The Wireless Tools package includes 'ifrename', a tool to
+rename network interfaces. However, this is not the only solution to
+the problem of renaming network interfaces. This document explain the
+differences between ifrename and the various alternatives.
+	    The subject of interface renaming may look simple at first
+glance, and is simple in 95% of the cases, however there are many
+complex scenario and those tools have many features, which explain why
+we need to go in more details than just saying 'tool X is better'.
+
+NAMEIF
+------
+	The tool 'nameif' was designed to rename network
+interfaces. It either loads mapping from the file /etc/mactab or
+accept mapping on the command line.
+	It is part of the net-tools package :
+		http://www.tazenda.demon.co.uk/phil/net-tools/
+
+	Advantages over 'ifrename' :
+		+ More widespread, available in very old distributions
+		+ simpler/smaller
+	Drawbacks compared to 'ifrename' :
+		- Only support MAC address selector
+		- Does not support hotplug invocation
+		- Does not support module on-demand loading
+	Comments :
+		o The fact that nameif does not support selector other
+than the MAC address is problematic, as USB-NET devices may not have
+MAC addresses and some ethernet/wireless drivers can't query the MAC
+address before 'ifconfig up'.
+		o 'ifrename' was designed as a better 'nameif', and
+its concept is very similar.
+
+IPROUTE
+-------
+	The tool 'ip' can rename network interfaces with the following
+syntax :
+		> ip link set <oldname> name <newname>
+	It is part of the 'iproute' package :
+		http://developer.osdl.org/dev/iproute2/
+
+	Advantages over 'ifrename' :
+		+ integrated in 'iproute', which most people need anyway
+	Drawbacks compared to 'ifrename' :
+		- Do not support any selector, must use old interface name
+		- No 'batch' mode, must rename each interface manually
+	Comments :
+		o 'ip' only provide the most basic facility. To use it
+automatically, like in init/hotplug scripts, wrappers adding some
+rules/selector must be written.
+
+DRIVER MODULE PARAMETERS
+------------------------
+	Some network driver have module parameters enabling to specify
+the network name of all the devices created by the driver. This is
+driver specific, so you will need to check your driver.
+
+	Advantages over 'ifrename' :
+		+ very simple to get configured and running
+	Drawbacks compared to 'ifrename' :
+		- Not universally supported : few drivers do it
+		- Fragmented : each driver does it differently
+		- The only selector available is the driver
+	Comments :
+		o This method was never popular with the kernel
+people, and this feature is being removed from driver that use to
+include it.
+
+UDEV
+----
+	The package 'udev' include facility to rename network
+interfaces, with rules such as :
+		KERNEL="eth*", SYSFS{address}="00:52:8b:d5:04:48", NAME="lan"
+	This is part of the udev package :
+		http://www.kernel.org/pub/linux/utils/kernel/hotplug/udev.html
+
+	Advantages over 'ifrename' :
+		+ simpler to setup if 'udev' is already properly setup
+		+ automatically generates persistent rules
+	Drawbacks compared to 'ifrename' :
+		- Less selectors that 'ifrename'
+		- Require kernel 2.6.X or later with sysfs support
+		- Do no support non-hotplug interfaces
+		- Require 'udev', not everybody uses it (static /dev, devfs)
+	Comments :
+		o 'udev' support many selectors, basically all those
+present in 'sysfs' (excluding symlinks), even if the documentation
+only show instructions to use the MAC address (which is problematic
+with virtual devices some drivers - see above). 'ifrename' can also
+use all selectors present in 'sysfs' (like 'udev'), can use sysfs
+symlinks and parent directories, plus some other selectors not present
+in sysfs that were found to be useful.
+		o Not all interfaces are managed by hotplug. All
+virtual devices, such as tunnels and loopbacks, are not associated
+with a hardware bus, and therefore are not managed by hotplug. All
+driver compiled statically into the kernel are not managed by
+hotplug. 'udev' can't deal with those devices.
+		o It is common practice on embedded system to use a
+static /dev and not 'udev' to save space and boot time. And to not use
+hotplug for the same reasons.
+		o 'ifrename' has now a udev compatiblity mode that
+enables to trivially integrate it into 'udev' as an IMPORT rule. This
+requires udev version 107 or better and ifrename 29-pre17 or better.
+
+SELECTOR AWARE NETWORK SCRIPTS
+------------------------------
+	Another method is to not rename the interface at all, and make
+the various network script selector aware. The basic idea is to simply
+ignore the interface name and have all the network scripts based on
+selectors.
+	The main example is the original Pcmcia network scripts. They
+allow you to configure an interface directly based on MAC address and
+Pcmcia socket. Another example is the script get-mac-address.sh used
+as a mapping in some Debian configuration. On the other hand, Red-Hat
+and Fedora scripts don't apply, as they wrap around 'nameif'.
+
+	Advantages over 'ifrename' :
+		+ usually simpler to setup and understand
+	Drawbacks compared to 'ifrename' :
+		- Less selectors that 'ifrename'
+		- Only work for the scripts, other tools left confused
+	Comments :
+		o This method is conceptually simpler, and works
+well. It eliminates the two steps process of other methods (renaming ;
+configuring).
+		o Unfortunately, this method only apply to the
+specific scripts, and not to the majority of the networking tools
+which are still based on interface name. This means that when the user
+use those other tools, he is left guessing which interface is which.
+		o Distributions never never really embraced this
+method, as they all replaced the original Pcmcia scripts with one
+using the interfacename.
+
+	Have fun...
+
+	Jean
+
diff --git a/INSTALL b/INSTALL
new file mode 100644
index 0000000..5cc017d
--- /dev/null
+++ b/INSTALL
@@ -0,0 +1,151 @@
+Very important note :
+-------------------
+	This release of the Wireless Tools is not compatible with
+Wireless Extensions earlier than 9. Version 9 and 10 should work fine
+but are not recommended. Version 8 and earlier will not work.
+	Kernels that support this version of the Wireless Tools are
+listed below. For all kernels before that, see at the end.
+
+You need :
+--------
+	o Compiler and development environment
+	o A kernel supporting wireless extensions version 11 or higher
+		-> from 2.4.4 onward (including 2.6.X)
+		Note : CONFIG_NET_RADIO must be enabled
+	o (Optional) A Pcmcia package supporting Wireless Extension
+	o A driver supporting wireless extensions
+		-> Check my web pages for status of various drivers.
+	Note : more recent kernels and drivers are likely to support
+		more wireless extension features...
+
+Compile wireless tools :
+----------------------
+	In theory, a "make" should suffice to create the tools.
+
+Installation :
+------------
+	"make install" should do the right thing for you, and install
+the tools, their library and the man pages. You can also uninstall the
+tools via "make uninstall".
+	Note that the default installation is in the directory
+'/usr/local/sbin'. This may not be in your path. Also, other version
+of the tools may exist on the system, so double check which version is
+the default and adjust your path as necessary.
+
+Create a local copy of the tools :
+--------------------------------
+	By default, the package is built with iwlib as a dynamic
+library, and the tool will expect to use the default version of libiw
+on the system. This means you can't use the tools until they are
+properly installed.
+	If you just want to experiment with a "local" version of the
+tools, you may want to pass the BUILD_STATIC flag to Makefile. It will
+create a self contained version of the tools.
+		-------------
+		make clean
+		make BUILD_STATIC='y'
+		-------------
+	The resulting binary can be used in the compilation directory
+or installed in any place you like.
+
+Other useful Makefile options :
+-----------------------------
+	PREFIX : where the tools will be installed (default : /usr/local)
+	CC : Compiler to use (defaul : gcc)
+	BUILD_STATIC : build tools with a static version of the wireless lib
+	BUILD_NOLIBM : build tools without mathematical lib (slower)
+	BUILD_STRIPPING : strip symbols from tools/lib.
+	BUILD_WE_ESSENTIAL : remove less used and obsolete features.
+
+	You can pass those options on the command line of make, or
+modify the top of the Makefile. You can also set them as environment
+variable, but this is not recommended.
+	If you pass those options on the command line, you should pass
+the same command line options for all invocations of make ("make" and
+"make install").
+
+Memory footprint reduction :
+--------------------------
+	The Wireless Tools are used in various embedded systems where
+memory footprint is a great concern. The Wireless Tools package offer
+multiple options to customise the compilation depending on the level
+of features you want.
+	The list below details the must useful combinations of these
+options, from the largest footprint to the smallest. Footprint depend
+on lot's of factor and is purely indicative (version 29-pre7+, i386,
+glibc, gcc 3.3.5).
+
+	1) Static build
+	Command line : make BUILD_STATIC='y'
+	- : Largest footprint
+	- : libiw not included (other third party tools may depend on it)
+	Size : ~280 kB
+
+	2) Default build
+	Command line : make
+	+ : Fully featured version of the tools
+	- : Largest footprint (except for static version of tools)
+	Size : ~190 kB (libiw : ~29 kB ; ifrename : ~29 kB)
+
+	3) Stripping (remove function symbols)
+	Command line : make BUILD_STRIPPING='y'
+	+ : Fully featured version of the tools
+	- : Still quite large
+	Size : ~110 kB (libiw : ~23 kB ; ifrename : ~17 kB)
+
+	4) Multicall version (include stripping)
+	Command line : make iwmulticall ; make install-iwmulticall
+	+ : Fully featured version of the tools
+	+ : Small
+	- : libiw not included (other third party tools may depend on it)
+	- : ifrename is not included
+	Size : ~55 kB
+
+	5) Multicall + Essential
+	Command line : make BUILD_WE_ESSENTIAL='y' iwmulticall
+	+ : Smaller
+	- : Some less used features are left out 
+	- : libiw not included (other third party tools may depend on it)
+	- : ifrename is not included
+	Size : ~44 kB
+
+	6) iwconfig only + essential + static
+	Command line : make BUILD_WE_ESSENTIAL='y'  BUILD_STATIC='y' BUILD_STRIPPING='y' iwconfig
+	+ : Very small
+	- : Very limited functionality : no scanning, no event, no iwpriv
+	- : libiw not included (other third party tools may depend on it)
+	- : ifrename is not included
+	Size : ~28 kB
+
+Wireless headers (past history) :
+-------------------------------
+	Previous version of the Wireless Tools had to be compiled with
+the same version of Wireless Extension that the kernel was using, and
+that was a major source of troubles.
+	Starting with version 27, Wireless Tools include all the ugly
+code to deal with any version of Wireless Extensions, so now you can
+compile a single "generic" version of the tools for any kernel.
+	Well, there are some limits, Wireless Extensions earlier than
+v11 are not supported (v9 and v10 should work fine), and versions
+later than the latest definition in the package are not
+supported. Once compile, the command "iwconfig --version" should tell
+you that.
+	Note that the previous option to make versioned installed of
+the tools no longer make sense and therefore is gone.
+
+Old kernel with older Wireless Extensions :
+-----------------------------------------
+	Kernel prior to 2.2.14 : Those kernels include Wireless
+Extensions v8 or earlier. Those versions don't have proper support for
+802.11b, so are not very useful. You may want to consider upgrading.
+	Kernel 2.2.19 to 2.2.25 : Those kernels include Wireless
+Extensions v10. The tools should mostly work with it, but many drivers
+won't. You can upgrade those kernel to WE v15 with a patch on my web
+page.
+	Kernel 2.2.14 to 2.2.18 : Those kernels include Wireless
+Extensions v9. Same as above, you may want to upgrade to a later 2.2.X
+kernel and then apply the patch.
+	Kernel 2.0.X : Those kernels include very old version of
+Wireless Extensions. Same deal as old 2.2.X kernels.
+
+	Jean <jt@hpl.hp.com>
diff --git a/Makefile b/Makefile
new file mode 100644
index 0000000..25c7e15
--- /dev/null
+++ b/Makefile
@@ -0,0 +1,244 @@
+##
+## Please check the configurion parameters below
+##
+
+## Installation directory. By default, go in /usr/local.
+## Distributions should probably use /, but they probably know better...
+ifndef PREFIX
+  PREFIX = /usr/local
+endif
+
+## Compiler to use
+ifneq ($(strip $(TOOLPREFIX)),)
+CROSS:=$(TOOLPREFIX)
+endif
+
+CC = $(CROSS)gcc
+## Other tools you need to modify for cross compile (static lib only)
+
+AR = $(CROSS)ar
+
+RANLIB = $(CROSS)ranlib
+
+## Uncomment this to build tools using static version of the library.
+## Mostly useful for embedded platforms without ldd, or to create
+## a local version (non-root).
+# BUILD_STATIC = y
+
+## Uncomment this to build without using libm (less efficient).
+## This is mostly useful for embedded platforms without maths.
+# BUILD_NOLIBM = y
+
+## Uncomment this to strip binary from symbols. This reduce binary size.
+## by a few percent but make debug worse...
+# BUILD_STRIPPING = y
+
+## Uncomment this to build with only essential functionality.
+## This leaves out the less used features and cut in half the tools.
+## This is mostly useful for embedded platforms without limited feature needs.
+# BUILD_WE_ESSENTIAL = y
+
+# ***************************************************************************
+# ***** Most users should not need to change anything beyond this point *****
+# ***************************************************************************
+
+# Version of the Wireless Tools
+WT_VERSION := $(shell sed -ne "/WT_VERSION/{s:\([^0-9]*\)::;p;q;}" < iwlib.h )
+
+# Version of Wireless Extensions.
+WE_VERSION := $(shell sed -ne "/WE_VERSION/{s:\([^0-9]*\)::;p;q;}" < iwlib.h )
+
+# Always use local header for wireless extensions
+WEXT_HEADER = wireless.$(WE_VERSION).h
+
+# Targets to build
+STATIC=libiw.a
+DYNAMIC=libiw.so.$(WT_VERSION)
+#bilal: unused progs are removed
+#PROGS= iwconfig iwlist iwpriv iwspy iwgetid iwevent ifrename
+PROGS= iwconfig iwlist iwpriv iwevent
+MANPAGES8=iwconfig.8 iwlist.8 iwpriv.8 iwspy.8 iwgetid.8 iwevent.8 ifrename.8
+MANPAGES7=wireless.7
+MANPAGES5=iftab.5
+EXTRAPROGS= macaddr iwmulticall
+
+# Composition of the library :
+OBJS = iwlib.o
+
+# Select which library to build and to link tool with
+ifdef BUILD_STATIC
+  IWLIB=$(STATIC)
+  IWLIB_INSTALL=install-static
+else
+  IWLIB=$(DYNAMIC)
+  IWLIB_INSTALL=install-dynamic
+endif
+
+# Standard name for dynamic library so that the dynamic linker can pick it.
+# We will just create a symbolic link to the real thing.
+DYNAMIC_LINK= libiw.so
+
+# Install directories
+INSTALL_DIR= $(PREFIX)/sbin/
+INSTALL_LIB= $(PREFIX)/lib/
+INSTALL_INC= $(PREFIX)/include/
+INSTALL_MAN= $(PREFIX)/man/
+
+# Various commands
+RM = rm -f
+RM_CMD = $(RM) *.BAK *.bak *.d *.o *.so ,* *~ *.a *.orig *.rej *.out
+LDCONFIG = ldconfig
+
+# Do we want to build with or without libm ?
+ifdef BUILD_NOLIBM
+  LIBS=
+  WELIB_FLAG= -DWE_NOLIBM=y
+else
+  LIBS= -lm
+endif
+
+# Stripping or not ?
+ifdef BUILD_STRIPPING
+  STRIPFLAGS= -Wl,-s
+else
+  STRIPFLAGS=
+endif
+
+# Do we want to build with only essential functionality ?
+ifdef BUILD_WE_ESSENTIAL
+  WEDEF_FLAG= -DWE_ESSENTIAL=y
+endif
+
+# Other flags
+CFLAGS=-Os -W -Wall -Wstrict-prototypes -Wmissing-prototypes -Wshadow \
+	-Wpointer-arith -Wcast-qual -Winline -I.
+#CFLAGS=-O2 -W -Wall -Wstrict-prototypes -I.
+#bilal: incs added. cflags changed.
+INCS+=	-I${MADWIFI_DIR}/wlan/core/hal  -I${MADWIFI_DIR}/core/net80211 -I${MADWIFI_DIR}/wlan -I${MADWIFI_DIR}/wlan/core -I${MADWIFI_DIR}/wlan/tools -I${MADWIFI_DIR}/madwifi/tools -I${MADWIFI_DIR}/madwifi -I${MADWIFI_DIR}/madwifi/hal -I${MADWIFI_DIR}/madwifi/net80211 -I$(KERNEL_DIR)/include
+CFLAGS += -I. -Wall ${INCS}
+DEPFLAGS=-MMD
+XCFLAGS=$(CFLAGS) $(DEPFLAGS) $(WARN) $(HEADERS) $(WELIB_FLAG) $(WEDEF_FLAG)
+PICFLAG=-fPIC
+
+# Standard compilation targets
+all:: $(IWLIB) $(PROGS)
+
+%: %.o
+	$(CC) $(LDFLAGS) $(STRIPFLAGS) $(XCFLAGS) -o $@ $^ $(LIBS)
+%.o: %.c wireless.h
+	$(CC) $(XCFLAGS) -c $<
+%.so: %.c wireless.h
+	$(CC) $(XCFLAGS) $(PICFLAG) -c -o $@ $<
+
+iwconfig: iwconfig.o $(IWLIB)
+
+iwlist: iwlist.o $(IWLIB)
+
+iwpriv: iwpriv.o $(IWLIB)
+
+iwspy: iwspy.o $(IWLIB)
+
+iwgetid: iwgetid.o $(IWLIB)
+
+iwevent: iwevent.o $(IWLIB)
+
+ifrename: ifrename.o $(IWLIB)
+
+macaddr: macaddr.o $(IWLIB)
+
+# Always do symbol stripping here
+iwmulticall: iwmulticall.o
+	$(CC) $(LDFLAGS) -Wl,-s $(XCFLAGS) -o $@ $^ $(LIBS)
+
+# It's a kind of magic...
+wireless.h:
+	cp $(WEXT_HEADER) wireless.h
+
+# Compilation of the dynamic library
+$(DYNAMIC): $(OBJS:.o=.so)
+	$(CC) -shared -o $@ -Wl,-soname,$@ $(STRIPFLAGS) $(LIBS) -lc $^
+	ln -sfn $(DYNAMIC) $(DYNAMIC_LINK)
+
+# Compilation of the static library
+$(STATIC): $(OBJS:.o=.so)
+	$(RM) $@
+	$(AR) cru $@ $^
+	$(RANLIB) $@
+
+# Installation : So crude but so effective ;-)
+# Less crude thanks to many contributions ;-)
+install:: $(IWLIB_INSTALL) install-bin install-hdr install-man
+
+# Install the dynamic library
+install-dynamic:: $(DYNAMIC)
+	install -m 755 -d $(INSTALL_LIB)
+	install -m 755 $(DYNAMIC) $(INSTALL_LIB)
+	ln -sfn $(DYNAMIC) $(INSTALL_LIB)/$(DYNAMIC_LINK)
+	@echo "*** Don't forget to add $(INSTALL_LIB) to /etc/ld.so.conf, and run ldconfig as root. ***"
+	@$(LDCONFIG) || echo "*** Could not run ldconfig ! ***"
+
+# Install the static library
+install-static:: $(STATIC)
+	install -m 755 -d $(INSTALL_LIB)
+	install -m 644 $(STATIC) $(INSTALL_LIB)
+
+# All the binaries. Careful, no dependancy on install-dynamic
+install-bin:: all
+	install -m 755 -d $(INSTALL_DIR)
+	@echo "Product name:$(PRODUCT_NAME)"
+ifneq ($(PRODUCT_NAME),AP-302v2)
+	install -m 755 $(PROGS) $(INSTALL_DIR)
+endif
+
+# Headers to go with the wireless lib (dev)
+install-hdr:: wireless.h
+	install -m 755 -d $(INSTALL_INC)
+	install -m 644 iwlib.h $(INSTALL_INC)
+	install -m 644 wireless.h $(INSTALL_INC)
+
+# How could you live without those manapages ?
+install-man::
+	install -m 755 -d $(INSTALL_MAN)/man8/
+	install -m 644 $(MANPAGES8) $(INSTALL_MAN)/man8/
+	install -m 755 -d $(INSTALL_MAN)/man7/
+	install -m 644 $(MANPAGES7) $(INSTALL_MAN)/man7/
+	install -m 755 -d $(INSTALL_MAN)/man5/
+	install -m 644 $(MANPAGES5) $(INSTALL_MAN)/man5/
+
+install-iwmulticall:: iwmulticall
+	install -m 755 -d $(INSTALL_DIR)
+	install -m 755 $< $(INSTALL_DIR)/iwconfig
+	( cd $(INSTALL_DIR) ; \
+	  ln -f -s iwconfig iwlist ; \
+	  ln -f -s iwconfig iwspy ; \
+	  ln -f -s iwconfig iwpriv ; \
+	  ln -f -s iwconfig iwgetid )
+
+clean::
+	$(RM_CMD) 
+
+realclean::
+	$(RM_CMD) 
+	$(RM) $(STATIC) $(DYNAMIC) $(PROGS) $(EXTRAPROGS) libiw* wireless.h
+
+uninstall::
+	for f in $(PROGS); do \
+	  $(RM) $(INSTALL_DIR)/$$f; \
+	done
+	$(RM) $(INSTALL_LIB)/$(STATIC)
+	$(RM) $(INSTALL_LIB)/$(DYNAMIC)
+	$(RM) $(INSTALL_LIB)/$(DYNAMIC_LINK)
+	$(RM) $(INSTALL_INC)/iwlib.h
+	$(RM) $(INSTALL_INC)/wireless.h
+	for f in $(MANPAGES8); do \
+	  $(RM) $(INSTALL_MAN)/man8/$$f; \
+	done
+	for f in $(MANPAGES7); do \
+	  $(RM) $(INSTALL_MAN)/man7/$$f; \
+	done
+	for f in $(MANPAGES5); do \
+	  $(RM) $(INSTALL_MAN)/man5/$$f; \
+	done
+
+# Include dependancies
+-include *.d
diff --git a/PCMCIA.txt b/PCMCIA.txt
new file mode 100644
index 0000000..32a478a
--- /dev/null
+++ b/PCMCIA.txt
@@ -0,0 +1,160 @@
+	Pcmcia Wireless configuration
+	-----------------------------
+
+	One of the most exciting things having happen after release 20
+is the addition of Wireless Tools support in the Pcmcia init
+scripts. Here is a quick intro on the subject...
+
+Pre-requisite :
+-------------
+	o Pcmcia package with Wireless Extension support : 3.1.15 onward
+	o A driver with Wireless Extension support
+	o The tools (iwconfig and co.) installed in the /usr/local/sbin
+		or /usr/sbin
+
+Raylink driver :
+--------------
+	The Raylink driver as of 1.70 doesn't support writable
+Wireless Extensions, so enabling wireless.opts on this driver will
+make things worse.
+	On the other hand, the latest version of the Raylink driver
+accepts Wireless Extensions at boot time, so the procedure described
+below will work.
+
+Distribution specific notes :
+---------------------------
+	Most modern distributions don't use wireless.opts and have
+their own procedure for wireless configuration, which is usually
+compatible with their configuration tools and work for non-Pcmcia
+devices. This is documented in DISTRIBUTIONS.txt.
+	The procedure described here will work only with the original
+Pcmcia configuration scripts. If you use a precompiled package part of
+a distributions, this is usually not the case (see above).
+	On the other hand, if you install the Pcmcia package in source
+form from the official Linux-Pcmcia web site, it will install the
+proper init scripts and those instructions will apply.
+
+Basic support :
+-------------
+	The file /etc/pcmcia/wireless.opts contains some templates for
+the most common drivers. Just fill in your card configuration in the
+template corresponding to your driver configuration.
+	Then, to activate it, you just need to remove or comment the 4
+lines at the top of wireless.opts and restart the Pcmcia package.
+
+	Things to take care of :
+	The options of wireless.opts will be used directly as
+arguments of iwconfig. So, you need iwconfig, and you need to check
+the man page of iwconfig to know how to format them.
+	A quick way to determine the correct options without
+restarting Pcmcia is to play a bit with iwconfig directly to see what
+is possible and what is the proper setup of the card and to copy that
+in wireless.opts.
+	At the end of wireless.opts, there is also a generic template
+containing all the possible options and explaining their meaning. Not
+all of them are supported by all cards (actually, most cards support a
+limited subset of it).
+	The current card templates are designed to match the MAC
+address of the card. Please check that this matches with your card.
+	Also, sample describe the most common/useful options available
+with the card, for more advance option, borrow options from the
+template. You can also remove some options, the card will usually
+initialise with a sane value.
+
+	Alternatively, you can also discard the current wireless.opts
+and replace it with a file looking like this :
+----------- wireless.opts ---------------------
+case "$ADDRESS" in
+*,*,*,*)
+    ESSID="MY_ESSID"
+    MODE="Managed"
+    ;;
+esac
+-----------------------------------------------
+
+
+Scheme support :
+--------------
+	The file wireless.opts fully supports schemes. This allow you
+to define different configurations (home, work...) and to switch on
+the fly between them.
+	The best way to explain it is to show an example.
+	Let's say you have an infrastructured setup at work (MY_WORK)
+and an Ad-Hoc network at home (MY_HOME). Moreover, when a specific card
+is inserted, you want it to be in Ad-Hoc mode (TEST). The work setup
+will be the default...
+
+	Each Wireless LAN will have the following configuration :
+--------- wireless.opts --------------------
+# Lucent Wavelan IEEE - Ad-Hoc mode for test card
+*,*,*,00:60:1D:03:9F:2D)
+    ESSID="TEST"
+    MODE="Ad-Hoc"
+    FREQ="10"
+    RATE="1M"
+    ;;
+
+# Lucent Wavelan IEEE - Ad-Hoc mode at home
+home,*,*,00:60:1D:*|home,*,*,00:02:2D:*)
+    ESSID="MY_HOME"
+    MODE="Ad-Hoc"
+    FREQ="5"
+    ;;
+
+# Lucent Wavelan IEEE - infrastructured mode at work
+*,*,*,00:60:1D:*|*,*,*,00:02:2D:*)
+    ESSID="MY_WORK"
+    MODE="Managed"
+    KEY="s:verysecurekey"
+    ;;
+--------------------------------------------
+
+	Don't forget the IP configuration :
+--------- network.opts ---------------------
+# Wavelan IEEE : ad-hoc mode for test card
+*,*,*,00:60:1D:03:9F:2D)
+    DHCP="n"
+    IPADDR="10.0.0.1"
+    NETMASK="255.255.255.0"
+    NETWORK="10.0.0.0"
+    BROADCAST="10.0.0.255"
+    ;;
+
+# Wavelan IEEE : ad-hoc mode at home
+home,*,*,00:60:1D:*|home,*,*,00:02:2D:*)
+    DHCP="n"
+    IPADDR="10.0.1.19"
+    NETMASK="255.255.255.0"
+    NETWORK="10.0.1.0"
+    BROADCAST="10.0.1.255"
+    GATEWAY="15.0.1.1"
+    ;;
+
+# Wavelan IEEE : infrastructured mode at work
+*,*,*,00:60:1D:*|*,*,*,00:02:2D:*)
+    DHCP="y"
+    ;;
+--------------------------------------------
+
+	Now, when you are at work you do :
+> cardctl scheme default
+	And at home, you do :
+> cardctl scheme home
+
+	I guess you get the idea ;-)
+
+More elaborated configurations :
+------------------------------
+	Some people may need some more complex configurations. For
+example, you might want to do one of the following thing :
+		o cycle through a set of schemes
+		o autodetect the proper scheme
+	There is currently no support to do that. However, the
+Wireless Tools package contains a tool called "iwgetid" that can help
+in this job. The source code contains some hints on how to achieve the
+above thing.
+	If you ever write such a package, please send me the URL.
+	Good luck !
+
+
+	Jean <jt@hpl.hp.com>
diff --git a/README b/README
new file mode 100644
index 0000000..442c622
--- /dev/null
+++ b/README
@@ -0,0 +1,162 @@
+	Wireless Tools & IfRename
+	-------------------------
+
+	This package contains the Wireless tools, used to manipulate
+the Wireless Extensions. The Wireless Extensions is an interface
+allowing you to set Wireless LAN specific parameters and get the
+specific stats.
+	It also contains the IfRename package, used for advance
+renaming of network interfaces.
+
+web page :
+--------
+	You'll find a lot of useful info on :
+		http://www.hpl.hp.com/personal/Jean_Tourrilhes/Linux/Tools.html
+		http://web.hpl.hp.com/personal/Jean_Tourrilhes/Linux/
+
+Precompiled version :
+-------------------
+	Most Linux distributions offer precompiled package containing
+these tools. And many of them preinstall them by default. On the other
+hand, installation of this package is (now) easy and allows you to get
+a more up-to-date version.
+
+INSTALL
+-------
+	This file contains installation instructions and requirements.
+	A *must*-read.
+
+DISTRIBUTION.txt
+----------------
+	This file documents how to configure wireless cards at
+boot time with various Linux distributions (using Wireless
+Extensions). Please read it carefully before asking questions.
+	In this file, I try to collect all the specifics of Wireless
+Extensions integration in the most common Linux distributions. I need
+your help to complete this file.
+
+HOTPLUG.txt
+-----------
+	This file documents how to manage and configure removable
+wireless cards using Hotplug. This is more advanced than the simple
+procedures of DISTRIBUTION.txt. This is currently mostly Debian
+specific, but I hope you will contribute for other distributions.
+
+PCMCIA.txt
+----------
+	This file describes how to use PCMCIA init script to configure
+Wireless Extensions and how to use PCMCIA schemes.
+
+man pages (iwconfig.8, iwlist.8, iwpriv.8, iwspy.8)
+---------
+	VERY IMPORTANT : I try to keep the man pages up to date, so
+you'd better read them before asking questions.
+	ALSO IMPORTANT : Those man pages describe the capacities of
+the tools, no device implements the full range (and drivers usually
+implement even less).
+
+	As far as I know, the man pages are the most complete, up to
+date and accurate documentation of the wireless tools. An update of
+the web page related to Wireless Extensions is long overdue. Send
+feedback to me.
+	The man pages can either be copied into a location where the
+command "man" will find them, such as /usr/local/man/man8, or can be
+read locally with the command :
+		nroff -man xxx.8 | less
+
+localised man pages (fr/*)
+-------------------
+	Localised man pages are not made by me, therefore the only
+localisations available are those sent to me by courageous volonteers,
+and I expect those man pages to 'lag' compared to the english
+version (i.e. not have all the latest updates). Translating man pages
+is not a very gratifying task, especially due to my broken english,
+and many technical terms don't translate well to other languages, so
+refer to the english version when in doubt.
+
+iwconfig.c
+----------
+	The main wireless tool. Used for device configuration and to see
+the most common wireless parameters.
+
+iwlist.c
+--------
+	Display some large chunk of information not displayed by iwconfig.
+	For example, all bit rates, all frequencies, all keys...
+
+iwspy.c
+-------
+	Mobile IP support test and allows to get stats per MAC
+address (instead of globally). Also, for some drivers/devices, this is
+the only way to get stats in Ad-Hoc mode.
+
+iwpriv.c
+--------
+	Manipulate driver private ioctls : all parameters that are
+specific to a driver or a device and therefore not part of iwconfig.
+
+iwgetid.c
+---------
+	Output the ESSID or NWID of the specified device.
+	Can also output it in a form that can be used as a PCMCIA Scheme.
+
+iwevent.c
+---------
+	Display Wireless Events. Most recent drivers will support this
+relatively new feature, but some older drivers may not support it.
+
+ifrename.c :
+----------
+	Rename network interfaces based on various selectors.
+
+iwlib.c
+-------
+	The Wireless Tools helper library. May be useful if you want
+to create your own applications using Wireless Extensions.
+
+iwmulticall.c
+-------------
+	Multicall version of the tools for embedded systems.
+
+Changelog, contributions :
+------------------------
+	See CHANGELOG.h
+
+wireless.h
+----------
+	Definition of the Wireless Extensions. Remember that the
+definition used by the drivers and the tools must match, otherwise
+funny things may happen. The tools try to check for that.
+	Since Wireless Extensions v12, you can no longer drop this
+file into your kernel headers to update the Wireless Extensions, you
+need to use the full patches available on my web page. So, the use is
+more if you plan to do some cross compile or something similar.
+	Just for your enjoyment, there are various releases of it. If
+your kernel/drivers are old, you may want to try the older releases...
+
+sample_xxx.c :
+------------
+	Various samples of code showing how to implement some of the
+more tricky features of Wireless Extensions in your driver.
+	Note that there is no guarantee that this code compiles, let
+alone works, but it should point you in the proper direction.
+	Also, have a look at existing drivers in the Linux kernel.
+
+19-udev-ifrename.rules :
+----------------------
+	udev rules to integrate properly ifrename (udev >= 107).
+
+Other tools :
+-----------
+	My web page lists many other tools using Wireless
+Extensions that you may find useful...
+	http://www.hpl.hp.com/personal/Jean_Tourrilhes/Linux/Tools.html#links
+
+Other questions :
+---------------
+	You have the source, and it is documented. In 99% of cases,
+you will find your answer there.
+
+	Good luck...
+
+	Jean <jt@hpl.hp.com>
diff --git a/README.fr b/README.fr
new file mode 100644
index 0000000..b71dc48
--- /dev/null
+++ b/README.fr
@@ -0,0 +1,162 @@
+	Wireless Tools
+	--------------
+
+	Ce paquetage contient les Wireless Tools (Outils Wireless), utilisé pour
+manipuler les Wireless Extensions. Les Wireless Extensions sont une interface
+vous permettant de manier les paramètres spécifiques aux Wireless LAN (réseaux
+sans fil) et d'obtenir les statistiques spécifiques.
+
+page web :
+--------
+	Vous trouverez beaucoup d'informations utiles sur :
+		http://www.hpl.hp.com/personal/Jean_Tourrilhes/Linux/Tools.html
+		http://web.hpl.hp.com/personal/Jean_Tourrilhes/Linux/
+
+version pré compilée
+--------------------
+	La plupart des distributions Linux fournit un paquetage pré compilé
+contenant ces outils. Et beaucoup d'entre elles les pré installent par défaut.
+Par ailleurs, l'installation de ce paquetage est (maintenant) facile et vous
+permet d'obtenir une version plus à jour.
+
+INSTALL
+-------
+	Ce fichier contient les instructions et les requis pour l'installation.
+	*Doit* être lu.
+
+DISTRIBUTION.txt
+----------------
+	Ce fichier documente la manière de configurer les cartes wireless au
+démarrage avec différentes distributions Linux (en utilisant les Wireless
+Extensions). Veuillez le lire attentivement avant de poser des questions.
+	Dans ce fichier, j'essaye de rassembler toutes les spécificités de
+l'intégration des Wireless Extensions dans les ditributions Linux les plus
+courantes. J'ai besoin de votre aide pour compléter ce fichier.
+
+HOTPLUG.txt
+-----------
+	Ce fichier documente la manière de gérer et configurer les cartes
+wireless éjectables utilisant Hotplug. Il est plus avancé que les simples
+procédures de DISTRIBUTIONS.txt. Pour l'instant, il est principalement orienté
+Debian, mais j'espère que vous contribuerez pour d'autres distributions.
+
+PCMCIA.txt
+----------
+	Ce fichier décrit comment utiliser le script init PCMCIA pour configurer
+les Wireless Extensions et comment utiliser les schemes PCMCIA (NDT : procédures
+automatiques).
+
+pages man (iwconfig.8, iwlist.8, iwpriv.8, iwspy.8)
+---------
+	TRÈS IMPORTANT : J'essaye de garder les pages man à jour, ainsi vous
+devriez les lire avant de poser des questions.
+	TRÈS IMPORTANT : Ces pages man décrivent les fonctionnalités des outils,
+pas un périphérique n'en implémente toute l'étendue (et les pilotes en
+implémentent souvent encore moins).
+
+	Pour autant que je sache, les pages man constituent la plus complète, la
+plus à jour et la plus précise des documentations des Wireless Tools. Une mise
+à jour de la page web concernant les Wireless Extensions a été faite il y a fort
+longtemps. Envoyez-moi vos retours.
+
+	Les pages man peuvent aussi bien être copiées dans un endroit où la
+commande « man » les trouvera, comme /usr/local/man/man8, ou peut être lue
+localement avec la commande :
+		nroff -man xxx.8 | less
+(NDT : ou plus simplement avec « man ./xxx.8 »)
+
+pages man localisées (fr/*)
+--------------------
+	Les pages de man localisées ne sont pas écrites par moi (NDT\ : ainsi
+que ce document), par conséquent les seules disponibles sont celles qui me sont
+envoyées par de courageux volontaires et il faut s'attendre à ce que ces pages
+man soient en décalage par rapport à la version anglaise (c.-à-d. qu'elles
+n'aient pas toutes les mises à jour). La traduction des pages man n'est pas une
+tâche très gratifiante, sans compter mon anglais bancal et un certain nombre
+de termes techniques difficilement traduisibles vers d'autres langues, donc
+référez-vous à la version anglaise en cas de doute.
+
+iwconfig.c
+----------
+	L'outil wireless principal. Utilisé pour la configuration du matériel et
+pour voir les paramètres wireless les plus communs.
+
+iwlist.c
+--------
+	Affiche une grosse quantité d'information qui ne l'est pas par iwconfig.
+	Par exemple, tous les débits, toutes les fréquences, toutes les clefs...
+
+iwspy.c
+-------
+	Test de support Mobile IP et autorise la récupération de statistiques
+par adresse MAC (au lieu des stats globales). Aussi, pour certains
+pilotes/périphériques, c'est la seule manière d'obtenir des stats en mode
+Ad-Hoc.
+
+iwpriv.c
+--------
+	Manipule les ioctls privées des pilotes (« driver private ioctls ») :
+tous les paramètres qui sont spécifiques à un pilote ou à un périphérique et
+qui, par conséquent, ne font pas partie de iwconfig.
+
+iwgetid.c
+---------
+	Affiche l'ESSID ou le NWID du périphérique spécifié.
+	Peut aussi l'afficher dans un format pouvant être utilisé comme un
+« PCMCIA Scheme ».
+
+iwevent.c
+---------
+	Affiche les « Wireless Events » (Événements Wireless). Cela est
+nouveau, il n'y a donc pas encore beaucoup de pilotes qui le supportent...
+
+ifrename.c :
+----------
+	Renomme les interfaces réseau basées sur différents attributs.
+
+iwlib.c
+-------
+	Les librairies « helper » Wireless Tools. Peuvent être utiles si vous
+voulez créer votre propre application en utilisant les Wireless Extensions.
+
+Changelog, contributions :
+------------------------
+	Voir CHANGELOG.h
+
+wireless.h
+----------
+	Définition des Wireless Extensions. Gardez à l'esprit que la définition
+utilisée par les pilotes et les outils (Wireless Tools) doivent correspondre,
+sinon de drôles de choses peuvent arriver. Les outils essayent de le vérifier.
+	Depuis les Wireless Extensions v12, vous ne pouvez plus mettre ce
+fichier dans les entêtes de votre noyau pour mettre à jour les Wireless
+Extensions, vous avez besoin d'utiliser les patches complets disponibles sur ma
+page web. Donc, son utilité est plus pour le cas où vous prévoyez de faire de
+la compilation transverse (if you plan to do some « cross compile ») ou quelque
+chose de similaire.
+Juste pour votre plaisir, il y en a différentes versions. Si vos noyau/pilotes
+sont anciens, vous voudrez peut-être essayer les anciennes versions...
+
+sample_xxx.c :
+------------
+	Différents échantillons de code montrant comment implémenter quelques
+unes des caractéristiques les plus intéressantes des Wireless Extensions dans
+votre pilote.
+	Notez qu'il n'y a pas d'assurance que ce code compile, laissez-le tel
+quel, mais cela devrait vous orienter dans la bonne direction.
+	Aussi, jetez un ½il aux pilotes existant dans le noyau Linux.
+
+Autres outils :
+-------------
+	Ma page web liste bien d'autres outils utilisant les Wireless
+Extensions que vous pourriez trouver utiles...
+	http://www.hpl.hp.com/personal/Jean_Tourrilhes/Linux/Tools.html#links
+
+Autres questions :
+----------------
+	Vous avez le source, et il est documenté. Dans 99% des cas, vous y
+trouverez votre réponse.
+
+	Bonne chance...
+
+	Jean <jt@hpl.hp.com>
diff --git a/awf_event.h b/awf_event.h
new file mode 100644
index 0000000..e70ca7f
--- /dev/null
+++ b/awf_event.h
@@ -0,0 +1,35 @@
+
+#ifndef _AWF_EVENT_H_
+#define _AWF_EVENT_H_
+
+
+#define AWF_PRINT_STATUS(_arg)			\
+		do {				\
+			if (awf_mode)		\
+			{			\
+				awf_event_t t;		\
+				t.status = _arg;	\
+				fwrite(&t, sizeof(awf_event_t), 1, stdout);	\
+			}			\
+		} while (0)
+
+typedef struct awf_event_s	awf_event_t;
+typedef enum conn_status_e	conn_status_e;
+
+enum conn_status_e {
+	ASSOCIATED,	// associated
+	AUTHENTICATED,	// authenticated
+	AUTHORIZED,	// authorized
+	DISCONNECTED,
+	NETWORK_NOT_FOUND,
+	WPA_HANDSHAKE_FAIL,
+	AUTH_FAILED,
+	CONFIG_MISMATCH,
+};
+
+struct awf_event_s
+{
+	conn_status_e status;
+};
+
+#endif
diff --git a/cs/ifrename.8 b/cs/ifrename.8
new file mode 100644
index 0000000..b524c47
--- /dev/null
+++ b/cs/ifrename.8
@@ -0,0 +1,158 @@
+.\" Jean II - HPL - 2004
+.\" ifrename.8
+.\"
+.TH IFRENAME 8 "1.bøezen 2004" "wireless-tools" "Linux - Manuál programátora"
+.\"
+.\" NAME part
+.\"
+.SH JMÉNO
+ifrename \- Pøejmenuje sí»ová rozhraní v závislosti na rùzných statických kritériích
+.\"
+.\" SYNOPSIS part
+.\"
+.SH SYNTAXE
+.B "ifrename [-c configfile] [-p] [-d] [-v] [-V] [-D]"
+.br
+.B "ifrename [-c configfile] [-i interface] [-n newname]"
+.\"
+.\" DESCRIPTION part
+.\"
+.SH POPIS
+.B Ifrename 
+je nástroj, který umo¾òuje pøiøadit stálý název pro ka¾dé
+sí»ové rozhraní.
+.PP
+Ve výchozím stavu jsou názvy rozhraní dynamické a ka¾dému sí»ovému rozhraní
+je pøiøazen první dostupný název
+.RI ( eth0 ", " eth1 "...)."
+Poøadí, v kterém jsou sí»ová rozhraní vytváøena, se mù¾e li¹it. U zabudovaných
+rozhraní závisí na jejich rozpoznání kernelem pøi spou¹tìní. Výmìnná zaøízení mù¾e
+u¾ivatel pøipojit v jakémkoliv poøadí.
+.PP
+.B Ifrename
+umo¾òuje u¾ivateli rozhodnout, jaký název bude sí»ové rozhraní mít.
+.B Ifrename 
+mù¾e vyu¾ít celou øadu
+.IR voleb ", "
+aby urèil, jak jsou názvy rozhraní pøiøazovány sí»ovým rozhraním v systému.
+Nejbì¾nìj¹í volbou je  
+.IR "MAC adresa" 
+rozhraní.
+.PP
+.B Ifrename
+musí být spu¹tìn pøedtím, ne¾ jsou rozhraní aktivována, proto je vìt¹inou pou¾íván
+v rùzných skriptech (init, hotplug), ale jen zøídka pøímo u¾ivatelem.
+Jako výchozí,
+.B ifrename 
+pøejmenuje v¹echna rozhraní pøítomná v  systému pou¾itím namapování definovaného v
+.IR /etc/iftab .
+.\"
+.\" PARAMETER part
+.\"
+.SH PARAMETRY
+.TP
+.BI "-c " konfiguracni_soubor
+Nastaví konfiguraèní soubor, který bude pou¾it (výchozí je 
+.IR /etc/iftab ).
+Konfiguraèní soubor definuje namapování voleb a názvù rozhraní
+a je popsán v
+.IR iftab (5).
+.br
+Pokud je
+.I konfiguracni_soubor
+urèen jako "-", je konfigurace naètena ze stdin.
+.TP
+.B -p
+Pokusí se zavést moduly jádra pøed pøejmenováním rozhraní. Jako výchozí 
+prochází
+.B ifrename 
+pouze rozhraní, která jsou ji¾ zavedena a nezavádí automaticky po¾adované
+jaderné moduly. Tento pøepínaè umo¾òuje hladkou integraci se systémem, který
+nezavádí moduly pøed voláním
+.BR ifrename .
+.TP
+.B -d
+Povolí rùzné úpravy specifické pro
+.B Debian. 
+V kombinaci s
+.BR -p
+budou zavedeny pouze moduly pro rozhraní urèená v
+.I /etc/network/interface
+.
+.TP
+.BI "-i " rozhraní
+Pøejmenuje pouze urèené
+.IR rozhraní ,
+místo v¹ech rozhraní v systému. Vypí¹e nový název rozhraní.
+.TP
+.BI "-n " novy_nazev
+Kdy¾ je pou¾ito spolu s 
+.IR -i ,
+urèí nový název rozhraní. Seznam namapování z konfiguraèního
+souboru je ignorován, rozhraní urèené pomocí 
+.I -i
+je rovnou pøejmenováno na
+.IR novy_nazev 
+Nový název mù¾e být ¾olík (wildcard), ale mù¾e obsahovat pouze jedinou "*".
+.br
+Pokud je pou¾it bez
+.IR -i ,
+pøejmenuje rozhraní s pou¾itím pouze tìch namapování, která by je pøejmenovala na
+.IR novy_nazev .
+Nový název nesmí být ¾olík. Tento zpùsob pou¾ití ifrename 
+.RI ( -n " bez " -i )
+není doporuèen, proto¾e je neefektivní. Musejí být zpracována v¹echna rozhraní systému, 
+a proto není ve vìt¹inì pøípadù rychlej¹í ne¾ kdyby je ifrename pøejmenovalo v¹echny (bez
+.IR -n " a zároveò bez " -i ).
+.TP
+.B -t
+Povolí podporu pøevzetí názvù. To umo¾ní výmìnu názvù rozhraní
+mezi dvìma èi více rozhraními.
+.br
+Pøevzetí umo¾òuje rozhraní "ukrást" název jinému rozhraní.
+To funguje pouze s jádrem 2.6.x a pokud druhé rozhraní nebì¾í.
+Tímpádem není kompatibilní s Hotplug. Druhému rozhraní je pøiøazen
+náhodný název, který lze pozdìji pomocí "ifrename" zmìnit.
+.br
+Poèet pøevzetí je omezen, aby se zabránilo nekoneèným smyèkám,
+a proto nemusejí být nìkteré komplexní vícecestné situace správnì zpracovány.
+.br
+V ka¾dém pøípadì není pøevod názvù a ani pou¾ívání této mo¾nosti doporuèeno,
+je lep¹í zvolit pro rozhraní jedineèné a jednoznaèné názvy...
+.TP
+.B -D
+Re¾im dry-run ("naneèisto"). Ifrename nezmìní ¾ádné rozhraní, pouze vypí¹e
+nový název rozhraní, pokud je to mo¾né, a skonèí.
+.br
+V re¾imu dry-run nejsou øe¹eny wildcards. Nový název rozhraní je vyti¹tìn
+i v pøípadì, ¾e je stejný jako pùvodní název.
+.TP
+.B -V
+U¾vanìný re¾im. Ifrename zobrazí interní výsledky prùchodu svým
+konfiguraèním souborem a dotazy na volby rozhraní. V kombinaci s
+pøepínaèem
+.I dry-run
+pøedstavuje dobrý zpùsob debugování komplexních nastavení nebo triviálních
+problémù.
+.\"
+.\" AUTHOR part
+.\"
+.SH AUTOR
+Jean Tourrilhes \- jt@hpl.hp.com
+.\"
+.\" TRANSLATION part
+.\"
+.SH PØEKLAD
+Pavel Heimlich \- tropikhajma@seznam.cz, bøezen 2005 (wireless_tools.28pre4).
+.\"
+.\" FILES part
+.\"
+.SH SOUBORY
+.I /etc/iftab
+.\"
+.\" SEE ALSO part
+.\"
+.SH DAL©Í INFORMACE
+.BR ifconfig (8),
+.BR ip (8),
+.BR iftab (5).
diff --git a/cs/iftab.5 b/cs/iftab.5
new file mode 100644
index 0000000..869b7c7
--- /dev/null
+++ b/cs/iftab.5
@@ -0,0 +1,189 @@
+.\" Jean II - HPL - 2004
+.\" iftab.5
+.\"
+.TH IFTAB 5 "1.bøezen 2004" "wireless-tools" "Linux - Manuál programátora"
+.\"
+.\" NAME part
+.\"
+.SH JMÉNO
+iftab \- statické informace o sí»ových rozhraních
+.\"
+.\" DESCRIPTION part
+.\"
+.SH POPIS
+Soubor
+.B /etc/iftab
+obsahuje popisnou informaci o rùzných sí»ových rozhraních.
+.B iftab
+je pou¾íván pouze programem
+.IR ifrename (8)
+k pøiøazení stálých názvù sí»ových rozhraní ka¾dému sí»ovému rozhraní.
+.PP
+.B /etc/iftab
+definuje sadu
+.IR namapování .
+Ka¾dé namapování obsahuje název rozhraní a sadu deskriptorù.
+Deskriptory umo¾òují
+.B ifrename
+identifikovat ka¾dé sí»ové rozhraní v  systému. Pokud sí»ové rozhraní odpovídá
+v¹em deskriptorùm z namapování,
+.B ifrename
+se pokusí zmìnit název rozhraní na název urèený v namapování.
+.\"
+.\" MAPPINGS part
+.\"
+.SH NAMAPOVÁNÍ
+Ka¾dé namapování je popsáno na zvlá¹tní øádce, zaèínající
+.IR "interface name" ,
+(názvem rozhraní) a obsahuje sadu
+.IR deskriptorù ,
+oddìlených mezerami nebo tabulátory.
+.PP
+Vztah mezi deskriptory v namapování je
+.IR "logické a" .
+Namapování odpovídá sí»ovému rozhraní, pouze kdy¾ odpovídají v¹echny deskriptory.
+Pokud sí»ové rozhraní nepodporuje urèitý deskriptor, nebude vyhovovat ¾ádnému
+namapování pou¾ívajícímu tento deskriptor.
+.PP
+Pokud je potøeba pou¾ít alternativní deskriptory pro název rozhraní
+(logické nebo), vytvoøte dvì rùzná namapování se stejným názvem rozhraní
+(na ka¾dém øádku jednu).
+.B Ifrename
+v¾dycky pou¾ije první odpovídající namapování od
+.I konce
+.BR iftab ,
+proto by restriktivnìj¹í namapování mìla být uvedena naposled.
+.\"
+.\" INTERFACE NAME part
+.\"
+.SH NÁZEV ROZHRANÍ
+První èástí ka¾dého namapování je název rozhraní. Pokud sí»ové rozhraní
+odpovídá v¹em deskriptorùm v namapování,
+.B ifrename
+se pokusí zmìnit název rozhraní na název urèený v namapování.
+.PP
+Název rozhraní v namapování je buïto pouhý název rozhraní (jako tøeba
+.IR eth2 " nebo " wlan0 )
+nebo ¹ablona obsahující jediného ¾olíka (wildcard) (napø.
+.IR eth* " nebo " wlan* ).
+V pøípadì ¾olíka nahradí jádro znak "*" za nejni¾¹í dostupné
+celé èíslo, které zajistí jedineènost názvu rozhraní.
+.\"
+.\" DESCRIPTORS part
+.\"
+.SH DESKRIPTORY
+Ka¾dý deskriptor je slo¾en z názvu deskriptoru a hodnoty deskriptoru.
+Deskriptory urèují statické vlastnosti sí»ového rozhraní, jejich
+cílem je jednoznaènì identifikovat ka¾dý kus hardware.
+.PP
+Vìt¹ina u¾ivatelù pou¾ije pouze volbu
+.B mac
+, ostatní volby jsou urèeny k zvlá¹tním nastavením.
+.TP
+.BI mac " MAC adresa"
+Porovná MAC adresu rozhraní se zadanou MAC adresou. MAC adresu
+rozhraní je mo¾né zobrazit pomocí
+.IR ifconfig (8)
+nebo
+.IR ip (8).
+Zadaná MAC adresa mù¾e 
+obsahovat "*" pro výbìr ¾olíkù (wildcards).
+.br
+Je to nejbì¾nìj¹í volba, proto¾e vìt¹ina rozhraní má unikátní MAC
+adresu, která umo¾òuje sí»ové rozhraní jednoznaènì identifikovat.
+Nicménì nìkterá rozhraní nemají MAC adresu, dokud nejsou aktivována
+a v takovém pøípadì je u¾ití tohoto selektoru o¹idné.
+.TP
+.BI arp " typ arp"
+Porovná typ ARP (ARP Type)(také zvané "Link Type") rozhraní se zadaným typem ARP.
+Typ ARP u rozhraní je mo¾né zobrazit pomocí
+.IR ifconfig (8)
+nebo
+.IR ip (8).
+.br
+Tento selektor je u¾iteèný pokud ovladaè vytváøí více sí»ových rozhraní
+pro jedinou sí»ovou kartu.
+.TP
+.BI driver " název ovladaèe"
+Porovná název ovladaèe rozhraní se zadaným názvem ovladaèe.
+Název ovladaèe rozhraní je mo¾né zobrazit pomocí
+.IR "ethtool -i" (8).
+.TP
+.BI businfo " informace o sbìrnici"
+Porovná informaci o sbìrnici rozhraní rozhraní se zadanou informací
+o sbìrnici. Informaci o sbìrnici rozhraní je mo¾né zobrazit pomocí
+.IR "ethtool -i" (8).
+.TP
+.BI firmware " verze firmware"
+Porovná verzi firmware rozhraní s informací o verzi firmware.
+Revizi firmware rozhraní je mo¾né zobrazit pomocí
+.IR "ethtool -i" (8).
+.TP
+.BI baseaddress " port"
+Porovná port rozhraní se zadaným portem. Port rozhraní je mo¾né zobrazit pomocí
+.IR ifconfig (8).
+.br
+Proto¾e vìt¹ina karet pou¾ívá dynamické pøidìlování portù, je
+tato volba u¾iteèná pouze pro ISA a EISA karty.
+.TP
+.BI irq " èíslo pøeru¹ení"
+Porovná èíslo pøeru¹ení (IRQ) rozhraní se zadaným
+èíslem pøeru¹ení. Èíslo pøeru¹ení rozhraní je mo¾né zobrazit pomocí
+.IR ifconfig (8).
+.br
+Proto¾e pøeru¹ení mohou být sdílená, obvykle tento selektor nestaèí
+k jednoznaèné identifikaci rozhraní.
+.TP
+.BI iwproto " bezdrátový protokol"
+Porovná bezdrátový protokol rozhraní se zadaným
+bezdrátovým protokolem. Bezdrátový protokol rozhraní je mo¾né zobrazit pomocí
+.IR iwconfig (8).
+.br
+Tato volba je podporována pouze na bezdrátových rozhraních a nestaèí
+k jednoznaèné identifikaci rozhraní.
+.TP
+.BI pcmciaslot " pcmcia slot"
+Porovná èíslo Pcmcia socketu rozhraní se zadaným èíslem slotu. Èíslo Pcmcia socketu
+rozhraní je mo¾né zobrazit pomocí
+.IR "cardctl ident" (8).
+.br
+Tato volba je obvykle podporována pouze na 16 bitových kartách, pro 32 bitové
+karty je lep¹í pou¾ít selektor
+.BR businfo .
+.\"
+.\" EXAMPLE part
+.\"
+.SH PØÍKLAD
+# Toto je komentáø
+.br
+eth2		mac 08:00:09:DE:82:0E
+.br
+eth3		driver wavelan irq 15 baseaddress 0x390
+.br
+eth4		driver pcnet32 businfo 0000:02:05.0
+.br
+air*		mac 00:07:0E:* arp 1
+.\"
+.\" AUTHOR part
+.\"
+.SH AUTOR
+Jean Tourrilhes \- jt@hpl.hp.com
+.\"
+.\" TRANSLATION part
+.\"
+.SH PØEKLAD
+Pavel Heimlich \- tropikhajma@seznam.cz, bøezen 2005 (wireless_tools.28pre4).
+.\"
+.\" FILES part
+.\"
+.SH SOUBORY
+.I /etc/iftab
+.\"
+.\" SEE ALSO part
+.\"
+.SH DAL©Í INFORMACE
+.BR ifrename (8),
+.BR ifconfig (8),
+.BR ip (8),
+.BR ethtool (8),
+.BR iwconfig (8).
diff --git a/cs/iwconfig.8 b/cs/iwconfig.8
new file mode 100644
index 0000000..712eacd
--- /dev/null
+++ b/cs/iwconfig.8
@@ -0,0 +1,535 @@
+.\" Jean II - HPLB - 1996 => HPL - 2004
+.\" iwconfig.8
+.\"
+.TH IWCONFIG 8 "22.èervna 2004" "wireless-tools" "Linux - Manuál programátora"
+.\"
+.\" NAME part
+.\"
+.SH JMÉNO
+iwconfig \- nastavuje rozhraní bezdrátové sítì
+.\"
+.\" SYNOPSIS part
+.\"
+.SH SYNTAXE
+.BI "iwconfig [" rozhraní ]
+.br
+.BI "iwconfig " rozhraní " [essid " X "] [nwid " N "] [mode " M "] [freq " F "]
+.br
+.BI "                   [channel " C ] [sens " S "] [ap " A "] [nick " NN ]
+.br
+.BI "                   [rate " R "] [rts " RT "] [frag " FT "] [txpower " T ]
+.br
+.BI "                   [enc " E "] [key " K "] [power " P "] [retry " R ]
+.br
+.BI "                   [commit]
+.br
+.BI "iwconfig --help"
+.br
+.BI "iwconfig --version"
+.\"
+.\" DESCRIPTION part
+.\"
+.SH POPIS
+.B Iwconfig
+je podobný pøíkazu
+.IR ifconfig (8),
+ale je vìnovaný bezdrátovým rozhraním. Je pou¾íván k nastavení tìch parametrù 
+sí»ových rozhraní, které jsou specifické pro bezdrátový provoz (napø. frekvence).
+.B Iwconfig
+mù¾e být také pou¾it k zobrazení tìchto parametrù a bezdrátových
+statistik (získaných z
+.IR /proc/net/wireless ).
+.PP
+V¹echny tyto parametry a statistiky jsou závislé na zaøízení. Ka¾dý ovladaè
+poskytuje, v závislosti na hardwarové podpoøe, jen nìkteré z nich
+a rozsah hodnot se mù¾e mìnit. Prosím obracejte se na manuálové stránky
+jednotlivých zaøízení pro dal¹í detaily.
+.\"
+.\" PARAMETER part
+.\"
+.SH PARAMETRY
+.TP
+.B essid
+Nastaví ESSID (nebo Network Name - u nìkterých produktù mù¾e být nazváno
+Domain ID). ESSID se pou¾ívá k identifikaci bunìk, které jsou
+souèástí stejné virtuální sítì.
+.br
+Na rozdíl od adresy AP nebo NWID, která urèuje jedinou buòku, ESSID
+urèuje skupinu bunìk, spojených opakovaèi (repeater) nebo infrastrukturou,
+mezi kterými mù¾e u¾ivatel transparentnì pøecházet.
+.br
+U nìkterých karet je mo¾né vypnout kontrolu ESSID (promiskuitní ESSID)
+pomocí
+.IR off " nebo " any " (a " on
+k opìtovnému zapnutí).
+.br
+Pokud je ESSID sítì jedním z klíèových slov
+.RI ( off ", " on " nebo " any ),
+pou¾ije se
+.I --
+.br 
+.B Pøíklady:
+.br
+.I "	iwconfig eth0 essid any"
+.br
+.I "	iwconfig eth0 essid ""Moje sit""
+.br
+.I "	iwconfig eth0 essid -- ""ANY""
+.TP
+.BR nwid / domain
+Nastaví Network ID (u nìkterých produktù mù¾e být nazváno Domain ID).
+Proto¾e v¹echny sousedící bezdrátové sítì sdílejí stejné médium, je
+tento parametr pou¾íván k jejich rozli¹ení (tvorbì logických kolokovaných
+sítí) a identifikaci nodù patøících do stejné buòky.
+.br
+Tento parametr se pou¾ívá pouze u pre-802.11 zaøízení. Protokol 802.11
+pou¾ívá pro tuto funkci ESSID a adresu AP.
+.br
+U nìkterých karet je mo¾né vypnout kontrolu Network ID (promiskuitní NWID)
+pomocí 
+.IR off " (a " on
+k opìtovnému zapnutí).
+.br
+.B Pøíklady:
+.br
+.I "	iwconfig eth0 nwid AB34
+.br
+.I "	iwconfig eth0 nwid off"
+.TP
+.BR freq / channel
+Nastaví pracovní frekvenci nebo kanál zaøízení. Hodnota ni¾¹í ne¾ 1000
+znamená èíslo kanálu, hodnota vy¹¹í ne¾ 1000 je frekvence v Hz.
+Je mo¾né pøipojit k hodnotì pøíponu k, M nebo G (napøíklad "2.46G" pro
+frekvenci 2,46 GHz), nebo doplnit dostateèný poèet nul.
+.br
+Kanály jsou obvykle èíslovány od 1, je mo¾né pou¾ít
+.IR iwlist (8)
+k získání celkového poètu kanálù, seznamu dostupných frekvencí a zobrazení souèasné
+frekvence jako kanálu. V závislosti na pøedpisech mohou být nìkteré frekvence/kanály
+nedostupné.
+.br
+.B Pøíklady:
+.br
+.I "	iwconfig eth0 freq 2422000000"
+.br
+.I "	iwconfig eth0 freq 2.422G"
+.br
+.I "	iwconfig eth0 channel 3"
+.TP
+.B sens
+Nastaví práh citlivosti. To je nejni¾¹í úroveò síly signálu pøi které
+hardware pova¾uje pøijaté pakety za pou¾itelné. Kladné hodnoty jsou
+interpretovány jako hodnota pou¾ívaná hardwarem nebo jako procenta,
+negativní hodnoty jako dBm. V závislosti na hardwarové implementaci mù¾e
+mít tento parametr dal¹í funkce.
+.br
+Tento parametr mù¾e ovládat práh pøíjmu (receive threshold) - nejni¾¹í úroveò signálu
+pøi které se hardware pokusí o pøíjem paketu, slab¹í signál je ignorován. Mù¾e také
+nastavovat práh ústupu (defer threshold) - nejni¾¹í úroveò signálu, od které hardware 
+pova¾uje kanál za obsazený. Pøi správném nastavení tìchto prahù karta neztrácí èas 
+pøíjmen ¹umu. U moderních zaøízení se zdá, ¾e tyto prahy regulují automaticky.
+.br
+U moderních karet mù¾e tento parametr ovládat práh pøedání (handover/roaming
+threshold) - nejni¾¹í úroveò signálu pøi které hardware je¹tì zùstane asociováno se
+souèasným pøístupovým bodem. Pokud úroveò signálu poklesne pod tuto hodnotu, 
+zaène karta hledat nový/lep¹í pøístupový bod.
+.br
+.B Pøíklad:
+.br
+.I "	iwconfig eth0 sens -80"
+.TP
+.B mode
+nastaví pracovní re¾im zaøízení, co¾ závisí na topologii sítì.
+Re¾im mù¾e být
+.I Ad-Hoc
+(sí» slo¾ená pouze z jedné buòky a bez pøístupového bodu),
+.I Managed
+(node se pøipojuje do sítì slo¾ené z mnoha pøístupových bodù, s roamingem),
+.I Master
+(node je synchronisation master nebo slou¾í jako pøístupový bod),
+.I Repeater
+(node pøedává pakety mezi ostatními bezdrátovými nody),
+.I Secondary
+(node slou¾í jako zálo¾ní master/repeater),
+.I Monitor
+(node není asociován s ¾ádnou buòkou a pasivnì monitoruje pakety na frekvenci) nebo
+.IR Auto .
+.br
+.B pøíklad:
+.br
+.I "	iwconfig eth0 mode Managed"
+.br
+.I "	iwconfig eth0 mode Ad-Hoc"
+.TP
+.B ap
+Naøídí kartì pøipojit se k pøístupovému bodu urèenému adresou,
+pokud je to mo¾né. Pokud se kvalita spojení pøíli¹ sní¾í,
+mù¾e se ovladaè vrátit do automatického módu (karta vybere
+nejlep¹í pøístupový bod v dosahu).
+.br
+Je také mo¾né pou¾ít
+.I off
+k opìtovnému zapnutí automatického módu beze zmìny souèasného pøístupového bodu
+nebo
+.I any
+èi
+.I auto
+k vynucení opìtovné asociace karty s momentálnì nejlep¹ím pøístupovým bodem.
+.br
+.B Pøíklad :
+.br
+.I "	iwconfig eth0 ap 00:60:1D:01:23:45"
+.br
+.I "	iwconfig eth0 ap any"
+.br
+.I "	iwconfig eth0 ap off"
+.TP
+.BR nick [name]
+Nastaví pøezdívku neboli station name. Nìkteré 802.11 produkty ji definují,
+ale co se týká protokolù (MAC, IP, TCP), není pou¾ívána a pøi konfiguraci je
+zcela nepotøebná. Pou¾ívají ji pouze nìkteré diagnostické nástroje.
+.br
+.B Pøíklad:
+.br
+.I "	iwconfig eth0 nickname ""Muj linuxovy node""
+.TP
+.BR rate / bit [rate]
+U karet, které podporují více pøenosových rychlostí, nastaví rychlost pøenosu v b/s.
+Rychlost pøenosu je rychlost, kterou jsou bity pøená¹eny médiem,
+rychlost pro u¾ivatele je ni¾¹í kvùli sdílení média a rùzné re¾ii.
+.br
+Je mo¾né pøipojit k hodnotì pøíponu k, M nebo G (dekadický násobitel:
+10^3, 10^6 a 10^9 b/s), nebo doplnit dostateèný poèet nul. Význam hodnoty ni¾¹í ne¾
+1000 závisí na pou¾ité kartì, obvykle znamená index v seznamu pøenosových rychlostí.
+Je mo¾né pou¾ít
+.I auto
+ke zvolení re¾imu automatické pøenosové rychlosti (ústup na ni¾¹í rychlost v za¹umìných
+kanálech), co¾ je u vìt¹iny karet výchozí nastavení, a
+.I fixed
+k návratu k pevnému nastavení. Pokud je urèena pøenosová rychlost a 
+.IR auto ,
+mù¾e ovladaè pou¾ít v¹echny pøenosové rychlosti rovné této hodnotì a ni¾¹í.
+.br
+.B Pøíklady:
+.br
+.I "	iwconfig eth0 rate 11M"
+.br
+.I "	iwconfig eth0 rate auto"
+.br
+.I "	iwconfig eth0 rate 5.5M auto"
+.TP
+.BR rts [_threshold]
+RTS/CTS pøidá handshake pøed ka¾dým pøenosem paketù, aby se zajistilo,
+¾e je kanál volný. To zvý¹í re¾ii, ale také výkon v pøípadì skrytých nodù
+nebo velkého poètu aktivních nodù. Tento parametr nastavuje velikost nejmen¹ího 
+paketu, pro který node vysílá RTS; hodnota rovná maximální velikosti paketu
+tento mechanismus vypne. Je také mo¾né nastavit tento parametr na
+.IR auto ", " fixed " nebo " off .
+.br
+.B Pøíklady:
+.br
+.I "	iwconfig eth0 rts 250"
+.br
+.I "	iwconfig eth0 rts off"
+.TP
+.BR frag [mentation_threshold]
+Fragmentace dovoluje rozdìlit IP paket na dávku nìkolika men¹ích èástí
+pøenesených médiem. To ve vìt¹inì pøípadù zvìt¹í re¾ii, ale ve velmi za¹umìnìm
+prostøedí sní¾í ztráty zpùsobené chybami a umo¾ní paketùm projít
+pøi zaru¹ení. Tento parametr nastaví maximální velikost fragmentu; hodnota
+rovná maximální velikosti paketu tento mechanismus vypne. Je také
+mo¾né nastavit tento mechanismus na
+.IR auto ", " fixed " nebo " off .
+.br
+.B Pøíklady:
+.br
+.I "	iwconfig eth0 frag 512"
+.br
+.I "	iwconfig eth0 frag off"
+.TP
+.BR key / enc [ryption]
+Pou¾ívá se k nastavení ¹ifrovacích klíèù a bezpeènostního re¾imu.
+.br
+Pro nastavení aktuálního ¹ifrovacího klíèe se pouze zadá klíè v hexadecimální podobì jako
+.IR XXXX-XXXX-XXXX-XXXX " nebo " XXXXXXXX .
+Pro nastavení jiného ne¾ aktuálního klíèe pøidejte pøed nebo za vlastní klíè
+.I [index]
+(tím se nezmìní aktuální klíè). Je také mo¾né zadat klíè
+jako øetìzec ASCII znakù pomocí pøedpony
+.I s:
+. Passphrase není v souèasnosti podporovaná.
+.br
+Pro urèení, který klíè má být aktivní, se vlo¾í
+.I [index]
+(bez zadání hodnoty klíèe).
+.br
+.IR off " a " on
+Vypnou a znovu zapnou ¹ifrování.
+.br
+Bezpeènostní re¾im mù¾e být
+.I open
+(otevøený) nebo
+.IR restricted ,
+(uzavøený) a jeho význam závisí na pou¾ité kartì. Vìt¹ina karet nepou¾ívá v
+.I open
+(otevøeném) re¾imu ¾ádnou autentizaci a karta mù¾e také pøijímat
+neza¹ifrované relace, zatímco v
+.I restricted
+(uzavøeném) re¾imu jsou akceptovány pouze za¹ifrované relace a karta pou¾ije autentizaci,
+pokud je k dispozici.
+.br
+Pokud je tøeba nastavit více klíèù, nebo nastavit klíè a urèit aktivní klíè,
+je nutné pou¾ít více pøepínaèù
+.B key
+. Parametry mohou být v jakémkoliv poøadí, poslední má pøednost.
+.br
+.B Pøíklady:
+.br
+.I "	iwconfig eth0 key 0123-4567-89"
+.br
+.I "	iwconfig eth0 key [3] 0123-4567-89"
+.br
+.I "	iwconfig eth0 key s:password [2]"
+.br
+.I "	iwconfig eth0 key [2]"
+.br
+.I "	iwconfig eth0 key open"
+.br
+.I "	iwconfig eth0 key off"
+.br
+.I "	iwconfig eth0 key restricted [3] 0123456789"
+.br
+.I "	iwconfig eth0 key 01-23 key 45-67 [4] key [4]"
+.TP
+.BR power
+Nastavuje re¾im øízení spotøeby a jeho parametry.
+.br
+Pro nastavení èasu mezi probuzeními se vlo¾í
+.IR "period `hodnota'" .
+Pro nastavení prodlevy pøed návratem do spánku se vlo¾í
+.IR "timeout `hodnota'" .
+Je také mo¾né pøidat modifikátory
+.IR min " a " max
+. Hodnoty znamenají poèet sekund, pro urèení v milisekundách
+nebo mikrosekundách se pou¾ije pøípona m nebo u. Nìkdy jsou
+tyto hodnoty bez jednotek (poèet období mezi beacons a podobnì).
+.br
+.IR off " a " on
+vypne a novu zapne øízení spotøeby. Je také mo¾né nastavit
+re¾im øízení spotøeby na
+.I all
+(pøijímá v¹echny pakety),
+.I unicast
+(pøijímá pouze unicast pakety, zahazuje multicast a broadcast) a
+.I multicast
+(pøijímá pouze multicast a broadcast, zahazuje unicast pakety).
+.br
+.B Pøíklady:
+.br
+.I "	iwconfig eth0 power period 2"
+.br
+.I "	iwconfig eth0 power 500m unicast"
+.br
+.I "	iwconfig eth0 power timeout 300u all"
+.br
+.I "	iwconfig eth0 power off"
+.br
+.I "	iwconfig eth0 power min period 2 power max period 4"
+.TP
+.BR txpower
+U karet podporujících rozdílné vysílací výkony nastavuje vysílací výkon v dBm. Je-li dán výkon 
+.I W
+ve Wattech, je výkon v dBm roven
+.IR "P = 30 + 10.log(W)" .
+Pokud je hodnota doplnìna pøíponou
+.IR mW ,
+je automaticky pøevedena na dBm.
+.br
+Navíc volby 
+.IR on " a " off
+povolí a zaká¾ou vysílání, 
+.IR auto " a " fixed
+povolí a zaká¾ou mo¾nost mìnit výkon (pokud je tato vlastnost k dispozici).
+.br
+.B Pøíklady:
+.br
+.I "	iwconfig eth0 txpower 15"
+.br
+.I "	iwconfig eth0 txpower 30mW"
+.br
+.I "	iwconfig eth0 txpower auto"
+.br
+.I "	iwconfig eth0 txpower off"
+.TP
+.BR retry
+Vìt¹ina karet umí MAC retransmisi a nìkteré umo¾òují nastavit
+chování tohoto mechanismu.
+.br
+pro nastavení maximálního poètu pokusù o zaslání se zadá
+.IR "limit `hodnota'" .
+Toto je absolutní hodnota (bez jednotky).
+Pro nastavení nejdel¹ího období, ve kterém se má MAC pokou¹et o zaslání, se zadá
+.IR "lifetime `hodnota'" .
+Hodnoty znamenají poèet sekund, pro urèení v milisekundách
+nebo mikrosekundách se pou¾ije pøípona m nebo u.
+.br
+je také mo¾né pøidat modifikátory
+.IR min " a " max
+. Pokud karta podporuje automatický re¾im, urèují tyto modifikátory rozmezí pro limit nebo lifetime.
+Nìkteré karty definují rùzné hodnoty v závislosti na velikosti
+paketù, napø. v 802.11 urèuje
+.I min limit
+tzv. "short retry limit" - limit pro pakety, na které není aplikováno RTS/CTS.
+.br
+.B Pøíklady:
+.br
+.I "	iwconfig eth0 retry 16"
+.br
+.I "	iwconfig eth0 retry lifetime 300m"
+.br
+.I "	iwconfig eth0 retry min limit 8"
+.TP
+.BR commit
+Nìkteré karty nemusí provést zmìny zadané pøes Wireless Extensions
+okam¾itì (mohou èekat na nashromá¾dìní zmìn a pøijmout je
+a¾ kdy¾ je karta aktivována pomocí ifconfig). Tento pøíkaz (pokud
+je dostupný) pøinutí kartu k pøijetí v¹ech nevyøízených zmìn.
+.br
+To není vìt¹inou potøeba, proto¾e karta èasem zmìny pøijme, ale mù¾e to
+být u¾iteèné pøi ladìní.
+.\"
+.\" DISPLAY part
+.\"
+.SH ZOBRAZENÍ
+Pro ka¾dé zaøízení, které podporuje wireless extensions, zobrazí
+.I iwconfig
+název pou¾itého
+.B MAC protokolu
+ (název zaøízení u proprietárních protokolù),
+.B ESSID
+(Network Name),
+.BR NWID ,
+.B frekvenci
+(nebo kanál),
+.BR sensitivity 
+(citlivost),
+.B mode
+(pracovní re¾im), 
+.B Access Point
+(adresu pøístupového bodu),
+.B bit-rate
+(pøenosovou rychlost),
+.BR "RTS threshold"
+(práh RTS), 
+.BR "fragmentation threshold"
+(práh fragmentace),
+.B encryption key
+(¹ifrovací klíè) a nastavení
+.B power management
+(øízení spotøeby)(pokud je k dispozici).
+.PP
+Zobrazené parametry mají stejný význam a hodnoty jako parametry, 
+které mohou být nastaveny, pro jejich podrobnìj¹í vysvìtlení se prosím 
+obra»te se na pøedchozí èást.
+.br
+Nìkteré parametry jsou zobrazeny pouze ve své krátké/zkrácené podobì
+(napø. ¹ifrování). Je mo¾né pou¾ít
+.IR iwlist (8)
+k získání detailù.
+.br
+Nìkteré parametry mají dva re¾imy (napø. pøenosová rychlost). Pokud
+hodnotu uvozuje
+.RB ` = ',
+znamená to, ¾e parametr je pevný a daný touto hodnotou, pokud
+ji uvozuje
+.RB ` : ',
+je parametr v automatickém re¾imu a je zobrazena aktuální hodnota (a
+mù¾e se zmìnit).
+.TP
+.BR "Access Point" / Cell
+Adresa rovná 00:00:00:00:00:00 znamená, ¾e se karta nedokázala asociovat
+s pøístupovým bodem (nejspí¹e problém v nastavení).
+Parametr
+.B Access Point
+bude zobrazen jako
+.B Cell
+v re¾imu ad-hoc (ze zøejmých dùvodù), ale jinak znamená to samé.
+.PP
+Pokud existuje
+.IR "/proc/net/wireless" ,
+.I iwconfig
+se také pokusí zobrazit jeho obsah. Nicménì tyto hodnoty závisí na
+ovladaèi a zvlá¹tnostech hardware, tak¾e pro jejich správnou interpretaci je nutné obrátit se na
+dokumentaci ovladaèe.
+.TP
+.B Link quality
+Celková kvalita spoje. Mù¾e být zalo¾ena na úrovni ru¹ení 
+èi interference, poètu chyb na úrovni bitù nebo rámcù, síle pøijímaného
+signálu, synchronizaci èasování nebo dal¹ích hardwarových mìøeních. Je to
+celková hodnota a zcela zále¾í na ovladaèi a hardware.
+.TP
+.B Signal level
+Received signal strength (RSSI - indikátor síly pøijímaného signálu). 
+Mù¾e být v libovolných jednotkách nebo dBm,
+.I iwconfig
+pou¾ívá informace z ovladaèe k interpretaci surových dat v
+.I /proc/net/wireless
+a zobrazení správné jednotky nebo maximální hodnoty (pomocí 8 bitových výpoètù). V
+.I Ad-Hoc
+re¾imu mù¾e být nedefinovaná a mìl by být pou¾it 
+.IR iwspy .
+.TP
+.B Noise level
+Úroveò ¹umu pozadí (kdy¾ není pøená¹en ¾ádný paket). Platí stejné poznámky 
+jako pro
+.BR "Signal level" .
+.TP
+.B Rx invalid nwid
+Poèet pøijatých paketù s odli¹ným NWID nebo ESSID. Pou¾ívá se 
+k detekci problémù v nastavení nebo existence sousední sítì
+(na stejné frekvuenci).
+.TP
+.B Rx invalid crypt
+Poèet paketù, které hardware nedokázal de¹ifrovat. Mù¾e indikovat
+neplatné nastavení ¹ifrování.
+.TP
+.B Rx invalid frag
+Poèet paketù, pro které hardware nedokázal správnì znovu sestavit
+jednotlivé fragmenty na fyzické vrstvì (nejspí¹e jeden chybìl).
+.TP
+.B Tx excessive retries
+Poèet paketù, které hardware nedokázal odeslat. Vìt¹ina MAC
+protokolù zkusí poslat paket nìkolikrát, ne¾ to vzdá.
+.TP
+.B Invalid misc
+Ostatní pakety ztracené v souvislosti s urèitými bezdrátovými operacemi.
+.TP
+.B Missed beacon
+Poèet pravidelných beacons z buòky nebo pøístupového bodu, které nebyly zachyceny.
+Beacons jsou vysílány v pravidelných intervalech pro udr¾ení koordinace a
+pokud nejsou zachyceny, vìt¹inou to znamená, ¾e je karta mimo dosah.
+.\"
+.\" AUTHOR part
+.\"
+.SH AUTOR
+Jean Tourrilhes \- jt@hpl.hp.com
+.\"
+.\" TRANSLATION part
+.\"
+.SH PØEKLAD
+Pavel Heimlich \- tropikhajma@seznam.cz, bøezen 2005 (wireless_tools.28pre4).
+.\"
+.\" FILES part
+.\"
+.SH SOUBORY
+.I /proc/net/wireless
+.\"
+.\" SEE ALSO part
+.\"
+.SH DAL©Í INFORMACE
+.BR ifconfig (8),
+.BR iwspy (8),
+.BR iwlist (8),
+.BR iwevent (8),
+.BR iwpriv (8),
+.BR wireless (7).
diff --git a/cs/iwevent.8 b/cs/iwevent.8
new file mode 100644
index 0000000..2dcc580
--- /dev/null
+++ b/cs/iwevent.8
@@ -0,0 +1,118 @@
+.\" Jean Tourrilhes - HPL - 2002 - 2004
+.\" iwevent.8
+.\"
+.TH IWEVENT 8 "23.èerven 2004" "net-tools" "Linux - Manuál programátora"
+.\"
+.\" NAME part
+.\"
+.SH JMÉNO
+iwevent \- Zobrazí bezdrátové události vyvolané ovladaèi a zmìnami nastavení
+.\"
+.\" SYNOPSIS part
+.\"
+.SH SYNTAXE
+.BI "iwevent "
+.br
+.\"
+.\" DESCRIPTION part
+.\"
+.SH POPIS
+.B iwevent
+zobrazí bezdrátové události pøijaté prostøednictvím socketu RTNetlink. Ka¾dý
+øádek zobrazuje jednotlivou bezdrátovou událost popisující, co se stalo
+na urèeném bezdrátovém rozhraní.
+.br
+Tento pøíkaz nemá ¾ádné parametry.
+.\"
+.\" DISPLAY part
+.\"
+.SH ZOBRAZENÍ
+Jsou dva typy bezdrátových událostí.
+.PP
+První typ jsou události vztahující se ke zmìnì bezdrátových nastavení na
+rozhraní (typicky prostøednictvím
+.B iwconfig
+nebo skriptu volajícího
+.BR iwconfig ).
+Jsou oznamována pouze nastavení, která mohou vést k naru¹ení spojení.
+V souèasnosti jsou oznamovány události mìnící jedno z následujících
+nastavení:
+.br
+.I "	Network ID"
+.br
+.I "	ESSID"
+.br
+.I "	Frequency"
+.br
+.I "	Mode"
+.br
+.I "	Encryption"
+.br
+V¹echny tyto události jsou generovány na v¹ech bezdrátových rozhraních
+bezdrátovým subsystémem jádra (ale jen kdy¾ byl ovladaè pøeveden na
+nové API ovladaèù).
+.PP
+Dal¹ím typem jsou události generované hardwarem, kdy¾ se nìco stane
+nebo byl byla dokonèena úloha. Tyto události zahrnují:
+.TP
+.B New Access Point/Cell address
+(nová adresa pøístupového bodu/buòky) Rozhraní se pøipojilo k novému
+pøístupovému bodu èi AD-Hoc buòce nebo s ním ztratilo spojení. Je to 
+stejná MAC adresa, jako hlásí
+.BR iwconfig .
+.TP
+.B Scan request completed
+(po¾adavek na skenování dokonèen) Po¾adavek na skenování byl dokonèen,
+výsledek je k dispozici (viz
+.BR iwlist 
+).
+.TP
+.B Tx packet dropped
+(vyslaný paket zahozen) Paket smìrovaný na tuto adresu byl zahozen, proto¾e rozhraní se
+domnívá, ¾e tento node u¾ neodpovídá (obvykle pokud bylo pøekroèeno maximum
+pokusù na úrovni MAC). Toto je obvykle prvotní známka toho, ¾e
+node mohl opustit buòku nebo se ocitl mimo dosah, ale mù¾e to být i 
+zeslabením signálu nebo nadmìrným ru¹ením.
+.TP
+.B Custom driver event
+(Zvlá¹tní událost ovladaèe) Událost specifická pro ovladaè. Prosím prozkoumejte dokumentaci ovladaèe.
+.TP
+.B Registered node
+Rozhraní úspì¹nì zaregistrovalo nového bezdrátového klienta/peer.
+Vìt¹inou je generována, pokud rozhraní pracuje jako pøístupový bod
+(re¾im master).
+.TP
+.B Expired node
+Registrace klienta/peer na tomto rozhraní vypr¹ela. 
+Vìt¹inou je generována, pokud rozhraní pracuje jako pøístupový bod
+(re¾im master).
+.TP
+.B Spy threshold crossed
+(pøekroèen práh pro sledování) Síla signálu u jedné z adres v seznamu iwspy poklesla pod spodní práh nebo
+pøekroèila horní práh.
+.PP
+Vìt¹ina bezdrátových ovladaèù generuje pouze èást z tìchto událostí, nikoli
+v¹echny. Jejich seznam zále¾í na konkrétní kombinaci hardware a ovladaèe.
+Pro více informací o vytváøení událostí prosím prozkoumejte dokumentaci
+ovladaèe a pou¾ijte
+.IR iwlist (8)
+k zji¹tìní, co ovladaè podporuje.
+.\"
+.\" AUTHOR part
+.\"
+.SH AUTOR
+Jean Tourrilhes \- jt@hpl.hp.com
+.\"
+.\" TRANSLATION part
+.\"
+.SH PØEKLAD
+Pavel Heimlich \- tropikhajma@seznam.cz, bøezen 2005 (wireless_tools.28pre4).
+.\"
+.\" SEE ALSO part
+.\"
+.SH DAL©Í INFORMACE
+.BR iwconfig (8),
+.BR iwlist (8),
+.BR iwspy (8),
+.BR iwpriv (8),
+.BR wireless (7).
diff --git a/cs/iwgetid.8 b/cs/iwgetid.8
new file mode 100644
index 0000000..332363e
--- /dev/null
+++ b/cs/iwgetid.8
@@ -0,0 +1,118 @@
+.\" Guus Sliepen - 2001
+.\" Doplnil a opravil Jean Tourrilhes - 2002-2003
+.\" iwgetid.8
+.\"
+.TH IWGETID 8 "2.prosinec 2003" "wireless-tools" "Linux - Manuál programátora"
+.\"
+.\" NAME part
+.\"
+.SH JMÉNO
+iwgetid \- Zobrazí ESSID, NWID nebo adresu AP/Cell (pøístupového bodu/buòky) v bezdrátové síti
+.\"
+.\" SYNOPSIS part
+.\"
+.SH SYNTAXE
+.BI "iwgetid " [interface] " [--raw] [--scheme] [--ap] [--freq]"
+.br
+.BI "                   [--mode] [--protocol] [--channel]
+.br
+.\"
+.\" DESCRIPTION part
+.\"
+.SH POPIS
+.B iwgetid
+se pou¾ívá k zji¹tìní NWID, ESSID nebo adresy AP/Cell (pøístupového bodu/buòky)
+v bezdrátové síti, která je právì vyu¾ívána. Zobrazená informace je stejná jako
+ta, kterou ukazuje
+.BR iwconfig ", ale " iwgetid
+se snadnìji integruje do skriptù.
+.br
+Jako výchozí,
+.B iwgetid
+vypí¹e 
+.I ESSID
+zaøízení, pokud zaøízení nemá ¾ádné ESSID, vytiskne jeho
+.IR NWID .
+.br
+Výchozí formát pro výstup je pretty-printing (èlovìkem èitelný).
+.\"
+.\" OPTIONS part
+.\"
+.SH VOLBY
+.TP
+.B --raw
+Tento pøepínaè vypne pretty-printing.
+Je mo¾né jej kombinovat s ostatními pøepínaèi (s výjimkou
+.BR --scheme ),
+tak¾e se správnou kombinací pøepínaèù lze vytisknout surové
+ESSID, adresu AP nebo Mode.
+.br
+Tento formát je ideální pro ulo¾ení výsledku iwgetid jako promìnné ve skriptech
+.I Shellu
+nebo
+.I Perlu
+nebo pro pøedání výsledku jako parametru pøíkazové øádky pro
+.BR iwconfig .
+.TP
+.B --scheme
+Tento pøepínaè je podobný pøedchozímu, vypne pretty-printing 
+a odstraní v¹echny znaky, které nejsou alfanumerické
+(jako mezery, interpunkci a kontrolní znaky).
+.br
+Výsledný výstup je validní <<\ Pcmcia scheme identifer\ >> (který mù¾e být
+pou¾it jako parametr pøíkazu
+.BR "cardctl scheme" ).
+Tento formát je také ideální, pokud je výsledek iwgetid pou¾it jako volba ve skriptech
+.I Shellu
+nebo
+.I Perlu
+nebo jako název souboru.
+.TP
+.B --ap
+Zobrazí MAC adresu bezdrátového
+.I Access Point
+(pøístupového bodu) nebo
+.IR Cell .
+(buòky)
+.TP
+.B --freq
+Zobrazí aktuální
+.I frequency
+(frekvenci) nebo
+.I channel
+(kanál), pou¾ívaný rozhraním.
+.TP
+.B --channel
+Zobrazí aktuální
+.I channel
+(kanál), pou¾ívaný rozhraním. Kanál je získán z aktuální frekvence
+a seznamu frekvencí dodaného rozhraním.
+.TP
+.B --mode
+Zobrazí aktuální
+.I mode
+(re¾im) rozhraní.
+.TP
+.B --protocol
+Zobrazí
+.I protocol name
+(název protokolu) rozhraní. Tak je mo¾né identifikovat v¹echny karty, které
+jsou vzájemnì kompatibilní a akceptují stejný typ nastavení.
+.br
+Je to také mo¾nost jak 
+.I ovìøit podporu Wireless Extensions
+na rozhraní, proto¾e je to jediný atribut,
+který v¹echny ovladaèe podporující Wireless Extensions musejí podporovat.
+.\"
+.\" TRANSLATION part
+.\"
+.SH PØEKLAD
+Pavel Heimlich \- tropikhajma@seznam.cz, bøezen 2005 (wireless_tools.28pre4).
+.\"
+.\" SEE ALSO part
+.\"
+.SH DAL©Í INFORMACE
+.BR iwconfig (8),
+.BR ifconfig (8),
+.BR iwspy (8),
+.BR iwpriv (8).
diff --git a/cs/iwlist.8 b/cs/iwlist.8
new file mode 100644
index 0000000..01f238d
--- /dev/null
+++ b/cs/iwlist.8
@@ -0,0 +1,120 @@
+.\" Jean II - HPLB - 96
+.\" iwlist.8
+.\"
+.TH IWLIST 8 "23.èerven 2004" "wireless-tools" "Linux - Manuál programátora"
+.\"
+.\" NAME part
+.\"
+.SH JMÉNO
+iwlist \- Získá podrobnìj¹í bezdrátové informace o bezdrátovém rozhraní
+.\"
+.\" SYNOPSIS part
+.\"
+.SH SYNTAXE
+.BI "iwlist " rozhraní " scanning"
+.br
+.BI "iwlist " rozhraní " frequency"
+.br
+.BI "iwlist " rozhraní " rate"
+.br
+.BI "iwlist " rozhraní " key"
+.br
+.BI "iwlist " rozhraní " power"
+.br
+.BI "iwlist " rozhraní " txpower"
+.br
+.BI "iwlist " rozhraní " retry"
+.br
+.BI "iwlist " rozhraní " event"
+.br
+.BI "iwlist --help"
+.br
+.BI "iwlist --version"
+.\"
+.\" DESCRIPTION part
+.\"
+.SH POPIS
+.B Iwlist
+se pou¾ívá k zobrazení doplòujících informací o bezdrátovém sí»ovém
+rozhraní, které nejsou zobrazovány pøíkazem
+.IR iwconfig (8).
+Hlavní parametr urèuje typ informace, kterou
+.B iwlist
+zobrazí v detailní podobì, vèetnì informace, kterou poskytuje
+.IR iwconfig (8).
+.\"
+.\" PARAMETER part
+.\"
+.SH PARAMETRY
+.TP
+.BR scan [ning]
+Vypí¹e seznam pøístupových bodù a Ad-Hoc buòek v dosahu a 
+volitelnì i spoustu informací o nich (ESSID, kvalita,
+frekvence, re¾im...). Typ zobrazené informace závisí na mo¾nostech karty.
+.br
+Spu¹tìní skenování je privilegovaná operace (mù¾e ji provést pouze
+.RI root
+) a normální u¾ivatel mù¾e pouze èíst zbylé výsledky skenování. 
+Jako výchozí je zpùsob, kterým je skenování provedeno (jeho rozsah)
+ovlivnìn aktuálním nastavením ovladaèe. U tohoto pøíkazu se poèítá s dodateènými parametry
+pro kontrolu zpùsobu skenování, to ale zatím není implementováno.
+.TP
+.BR freq [uency]/ channel
+Vypí¹e seznam dostupných frekvencí pro zaøízení a poèet definovaných kanálù
+Prosím vìnujte pozornost tomu, ¾e ovladaè obvykle vrací
+celkový poèet kanálù a pouze frekvence dostupné v aktuálním locale,
+tak¾e mezi zobrazenými frekvencemi a èísly kanálù není vztah "jedna k jedné".
+.TP
+.BR rate / bit [rate]
+Vypí¹e pøenosové rychlosti podporované zaøízením.
+.TP
+.BR key / enc [ryption]
+Vypí¹e podporované velikosti ¹ifrovacích klíèù a zobrazí v¹echny ¹ifrovací
+klíèe dostupné v zaøízení.
+.TP
+.B power
+Vypí¹e rùzné atributy a re¾imy øízení spotøeby zaøízení.
+.TP
+.B txpower
+vypí¹e dostupné vysílací výkony zaøízení.
+.TP
+.B retry
+vypí¹e limity pro transmit retry a retry lifetime na zaøízení.
+.TP
+.BR ap / accesspoint / peers
+Vypí¹e pøístupové body v dosahu a volitelnì i kvalitu spoje
+Tato volba je 
+.B zastaralá
+a je nyní opu¹tìna ve prospìch skenování (viz vý¹e), vìt¹ina
+ovladaèù ji nepodporuje.
+.br
+Nìkteré ovladaèe mohou s tímto pøíkazem vracet zvlá¹tní seznam peerù
+nebo pøístupových bodù, jako napø. seznam peerù asociovaních s/registrovaných s
+kartou. Více informací obsahuje dokumentace ovladaèù.
+.TP
+.B event
+Vypí¹e bezdrátové události podporované zaøízením.
+.TP
+.B --version
+Zobrazí verzi wireless tools a doporuèenou a aktuální verzi Wireless Extensions
+s ohledem na bezdrátové rozhraní.
+.\"
+.\" TRANSLATION part
+.\"
+.SH PØEKLAD
+Pavel Heimlich \- tropikhajma@seznam.cz, bøezen 2005 (wireless_tools.28pre4).
+.\"
+.\" FILES part
+.\"
+.SH SOUBORY
+.I /proc/net/wireless
+.\"
+.\" SEE ALSO part
+.\"
+.SH DAL©Í INFORMACE
+.BR iwconfig (8),
+.BR iwspy (8).
+.BR iwevent (8),
+.BR iwpriv (8),
+.BR wireless (7).
+
diff --git a/cs/iwpriv.8 b/cs/iwpriv.8
new file mode 100644
index 0000000..72ad4da
--- /dev/null
+++ b/cs/iwpriv.8
@@ -0,0 +1,136 @@
+.\" Jean II - HPLB - 96
+.\" iwpriv.8
+.\"
+.TH IWPRIV 8 "31.øíjen 1996" "net-tools" "Linux - Manuál programátora"
+.\"
+.\" NAME part
+.\"
+.SH JMÉNO
+iwpriv \- konfiguruje doplòkové (specifické) parametry bezdrátového
+sí»ového rozhraní
+.\"
+.\" SYNOPSIS part
+.\"
+.SH SYNTAXE
+.BI "iwpriv [" rozhraní ]
+.br
+.BI "iwpriv " "rozhraní specifický-pøíkaz " "[" specifické-parametry ]
+.br
+.BI "iwpriv " "rozhraní specifický-pøíkaz [I] " "[" specifické-parametry ]
+.br
+.BI "iwpriv " rozhraní " --all"
+.br
+.BI "iwpriv " rozhraní " roam " {on,off}
+.br
+.BI "iwpriv " rozhraní " port " {ad-hoc,managed,N}
+.\"
+.\" DESCRIPTION part
+.\"
+.SH POPIS
+.B Iwpriv
+je doprovodným nástrojem k
+.IR iwconfig (8).
+.B Iwpriv
+pracuje s parametry a nastaveními specifickými pro ka¾dý ovladaè (na rozdíl od
+.IR "iwconfig" ,
+který pracuje s obecnými).
+.PP
+Bez uvedení parametru
+.B iwpriv
+vypí¹e specifické pøikazy dostupné na ka¾dém rozhraní a 
+parametry, které vy¾adují. Pomocí této informace mù¾e u¾ivatel
+pou¾ít tyto specifické pøíkazy na urèeném rozhraní.
+.PP
+Teoreticky by dokumentace ka¾dého ovladaèe mìla uvádìt, jak
+pou¾ívat tyto pro rozhraní specifické pøíkazy a jejich úèinek.
+.\"
+.\" PARAMETER part
+.\"
+.SH PARAMETRY
+.TP
+.IR specifický-pøíkaz " [" specifické-parametry ]
+Vykoná urèený
+.I specifický-pøíkaz
+na rozhraní.
+.br
+Pøíkaz mù¾e pou¾ít nebo vy¾adovat parametry a mù¾e zobrazit informaci.
+Parametry tedy mohou i nemusejí být vy¾adovány a mìly by odpovídat tomu, co
+pøíkaz oèekává. Seznam pøíkazù, které
+.B iwpriv
+zobrazí (kdy¾ je volán bez parametrù), by mìl napovìdìt, jak s parametry zacházet.
+.br
+Nicménì pro informaci o pøíkazech a jejich správném pou¾ití je nejlep¹í
+se obrátit na dokumnetaci k ovladaèi zaøízení.
+.TP
+.I "specifický-pøíkaz [I]" "[" specifické-parametry ]
+Viz vý¹e, pouze
+.I I
+(celé èíslo) je pøedáno pøíkazu jako
+.IR "Token Index" .
+Token Index pou¾ívají jen nìkteré pøíkazy (vìt¹ina jej ignoruje), kdy jej pou¾ít by
+mìla øíci dokumnetace ovladaèe.
+.TP
+.BR -a / --all
+Vykoná a zobrazí v¹echny specifické pøíkazy, které nemají ¾ádné parametry
+(tj. pouze ètou).
+.TP
+.B roam
+Povolí nebo zaká¾e roaming, je-li podporován. Volá specifický pøíkaz
+.IR setroam ,
+který je obsa¾en v ovladaèi
+.IR "wavelan_cs".
+.TP
+.B port
+Pøeète nebo nastaví druh portu. Volá specifický pøíkaz
+.IR gport_type ", " sport_type ", " get_port " nebo " set_port ","
+obsa¾ený v ovladaèích
+.IR wavelan2_cs " a " wvlan_cs "."
+.\"
+.\" DISPLAY part
+.\"
+.SH ZOBRAZENÍ
+Pro ka¾dé zaøízení, které podporuje specifické pøíkazy, zobrazí
+.I iwpriv
+seznam dostupných specifických pøíkazù.
+.PP
+To zahrnuje název specifického pøíkazu, parametry, které mohou být nastaveny a jejich typ
+a parametry které mohou být zobrazeny a jejich typ.
+.PP
+Napøíklad mù¾e zobrazit :
+.br
+.B "eth0      Available specific ioctl :"
+.br
+.B "          setqualthr (89F0) : set   1 byte & get   0"
+.br
+.B "          gethisto (89F7) : set   0      & get  16 int"
+.PP
+To znamená, ¾e je mo¾né nastavit quality threshold a zobrazit
+histogram s a¾ 16 hodnotami pomocí tìchto pøíkazù:
+.br
+.I "  iwpriv eth0 setqualthr 20"
+.br
+.I "  iwpriv eth0 gethisto"
+.\"
+.\" AUTHOR part
+.\"
+.SH AUTOR
+Jean Tourrilhes \- jt@hpl.hp.com
+.\"
+.\" TRANSLATION part
+.\"
+.SH PØEKLAD
+Pavel Heimlich \- tropikhajma@seznam.cz, bøezen 2005 (wireless_tools.28pre4).
+.\"
+.\" FILES part
+.\"
+.SH SOUBORY
+.I /proc/net/wireless
+.\"
+.\" SEE ALSO part
+.\"
+.SH DAL©Í INFORMACE
+.BR iwconfig (8),
+.BR iwlist (8),
+.BR iwevent (8),
+.BR iwspy (8),
+.BR wireless (7).
diff --git a/cs/iwspy.8 b/cs/iwspy.8
new file mode 100644
index 0000000..101b129
--- /dev/null
+++ b/cs/iwspy.8
@@ -0,0 +1,111 @@
+.\" Jean II - HPLB - 96
+.\" iwspy.8
+.\"
+.TH IWSPY 8 "31.øíjen 1996" "net-tools" "Linux - Manuál programátora"
+.\"
+.\" NAME part
+.\"
+.SH JMÉNO
+iwspy \- Získá bezdrátové statistiky o urèených nodech
+.\"
+.\" SYNOPSIS part
+.\"
+.SH SYNTYXE
+.BI "iwspy " rozhraní 
+.br
+.BI "iwspy " rozhraní " [+] " DNSNAME " | " IPADDR " | " HWADDR " [...]"
+.br
+.BI "iwspy " rozhraní " off"
+.br
+.BI "iwspy " rozhraní " setthr " "low high"
+.br
+.BI "iwspy " rozhraní " getthr"
+.\"
+.\" DESCRIPTION part
+.\"
+.SH POPIS
+.B Iwspy
+se pou¾ívá k nastavení seznamu sledovaných adres na bezdrátovém sí»ovém rozhraní a
+k zpìtnému ètení informací o kvalitì spoje pro ka¾dou z nich. Tyto
+informace jsou stejné jako ty uvedené v
+.IR "/proc/net/wireless":
+kvalita spoje, síla signálu, hladina ¹umu.
+.PP
+Tyto informace jsou aktualizovány poka¾dé, kdy¾ je pøijat nový paket, tak¾e
+ka¾dá adresa na seznamu zvy¹uje zátì¾ ovladaèe.
+.PP
+Tato funkcionalita platí pouze pro nody v aktuální bezdrátové buòce, není mo¾né 
+sledovat pøístupové body, se kterými není zaøízení asociováno (k tomu slou¾í skenování)
+, ani nody v jiných buòkách. V re¾imu Managed procházejí pakety vìt¹inou pøes pøístupový
+bod a v tom pøípadì je získána síla signálu pøístupového bodu. Proto je tato funkce 
+u¾iteèná víceménì jen v re¾imu Ad-Hoc nebo Master.
+.\"
+.\" PARAMETER part
+.\"
+.SH PARAMETRY
+Je mo¾né nastavit a¾ 8 adres.
+.TP
+.BR DNSNAME " | " IPADDR
+Nastaví IP adresu nebo, v nìkterých pøípadech, DNS název (pomocí name
+resolveru). Proto¾e hardware pracuje s hardwarovými adresami,
+.B iwspy
+pøelo¾í IP adresu pomocí
+.IR ARP .
+Mù¾e se stát, ¾e adresa není v ARP cache a
+.B iwspy
+neuspìje. V tom pøípadì pou¾ijte
+.IR ping (8)
+na toto jméno/adresu a zkuste to znovu.
+.TP
+.B HWADDR
+Nastaví hardwarovou (MAC) adresu (tato adresa se nepøekládá ani nekontroluje,
+na rozdíl od IP adresy). Adresa musí obsahuvat dvojteèky
+.RB ( : )
+aby byla uznána za hardwarovou adresu.
+.TP
+.B +
+Pøidá novou sadu adres na konec stávajícího seznamu, místo aby jej nahradil.
+Seznam adres je pro ka¾dé zaøízení jedineèný, proto by tato volba mìla být u¾ívána, aby
+se zabránilo konfliktùm.
+.TP
+.B off
+Odstraní souèasný seznam adres a vypne sledovací funkci.
+.TP
+.B setthr
+Nastaví
+.I low
+(spodní) a
+.I high
+(horní) práh síly signálu, pro spu¹tìní události iwspy (podporuje-li to ovladaè).
+.br
+Poka¾dé, kdy¾ síla signálu jakékoliv z adres sledované iwspy
+poklesne pod spodní práh nebo pøehroèí horní práh, je vygenerována bezdrátová událost.
+.br
+To je mo¾né pou¾ít ke sledování výpadkù spoje bez nutnosti pravidelného spou¹tìní iwspy.
+.TP
+.B getthr
+Získá aktuální
+.I low
+(spodní) a 
+.I high
+(horní) práh síly signálu pro událost iwspy.
+.\"
+.\" TRANSLATION part
+.\"
+.SH PØEKLAD
+Pavel Heimlich \- tropikhajma@seznam.cz, bøezen 2005 (wireless_tools.28pre4).
+\"
+.\" FILES part
+.\"
+.SH SOUBORY
+.I /proc/net/wireless
+.\"
+.\" SEE ALSO part
+.\"
+.SH DAL©Í INFORMACE
+.BR iwconfig (8),
+.BR iwlist (8),
+.BR iwevent (8),
+.BR iwpriv (8),
+.BR wireless (7).
+
diff --git a/cs/wireless.7 b/cs/wireless.7
new file mode 100644
index 0000000..d11c083
--- /dev/null
+++ b/cs/wireless.7
@@ -0,0 +1,129 @@
+.\" Jean Tourrilhes - HPL - 2002 - 2004
+.\" wireless.7
+.\"
+.TH WIRELESS 7 "4.duben 2004" "wireless-tools" "Linux - Manuál programátora"
+.\"
+.\" NAME part
+.\"
+.SH JMÉNO
+wireless \- Wireless Tools a Wireless Extensions
+.\"
+.\" SYNOPSIS part
+.\"
+.SH SYNTAXE
+.B iwconfig
+.br
+.B iwpriv \-a
+.br
+.\"
+.\" DESCRIPTION part
+.\"
+.SH POPIS
+.B Wireless Extensions
+jsou API, které umo¾òují manipulovat s bezdrátovými sí»ovými rozhraními.
+Skládají se ze souboru nástrojù a konfiguraèních souborù. Podrobnìji
+jsou popsány v Linux Wireless LAN Howto.
+.br
+.B Wireless Tools
+se pou¾ívají ke zmìnì konfigurace bezdrátových sí»ových rozhraní za bìhu,
+k získání jejich aktuální konfigurace, statistik a diagnostice.
+Popisují je jejich vlastní manuálové stránky, viz odkazy ní¾e.
+.br
+.B Nastavení bezdrátového pøipojení
+se v ka¾dé distribuci linuxu li¹í. Tato manuálová stránka bude obsahovat
+postup nastavení pro nìkolik bì¾ných distribucí. Prozatím se podívejte do 
+souboru DISTRIBUTIONS.txt, který je souèástí balíèku Wireless Tools.
+.\"
+.\" DEBIAN 3.0 part
+.\"
+.SH DEBIAN 3.0
+V Debianu 3.0 (a vy¹¹ím) je mo¾né nastavit bezdrátová sí»ová zaøízení
+nástrojem pro nastavení sítì
+.BR ifupdown (8).
+.TP
+.B Soubor:
+.I /etc/network/interfaces
+.TP
+.B Forma:
+.RI wireless\- "<funkce> <hodnota>"
+.br
+wireless\-essid Home
+.br
+wireless\-mode Ad\-Hoc
+.TP
+.B Dal¹í informace:
+.I /etc/network/if\-pre\-up.d/wireless\-tools
+.br
+.I /usr/share/doc/wireless\-tools/README.Debian
+.\"
+.\" SuSE 8.0 part
+.\"
+.SH SuSE 8.0
+SuSE 8.0 (a vy¹¹í) integrovalo nastavení bezdrátového pøipojení do svých
+sí»ových skriptù.
+.TP
+.B Nástroj:
+.B Yast2
+.TP
+.B Soubor:
+.I /etc/sysconfig/network/wireless
+.br
+.I /etc/sysconfig/network/ifcfg\-*
+.TP
+.B Forma:
+.RI WIRELESS_ "<funkce>" = "<hodnota>"
+.br
+WIRELESS_ESSID="Home"
+.br
+WIRELESS_MODE=Ad\-Hoc
+.TP
+.B Dal¹í informace:
+man ifup
+.br
+info scpm
+.\"
+.\" PCMCIA part
+.\"
+.SH PÙVODNÍ PCMCIA SKRIPTY
+Pokud pou¾íváte pùvodní konfiguraèní skripty z balíèku Pcmcia,
+Mù¾ete pou¾ít tuto metodu.
+.TP
+.B Soubor:
+.I /etc/pcmcia/wireless.opts
+.TP
+.B Forma:
+*,*,*,*)
+.br
+ESSID="Home"
+.br
+MODE="Ad-Hoc"
+.br
+;;
+.TP
+.B Dal¹í informace:
+.I /etc/pcmcia/wireless
+.br
+Soubor
+.IR "PCMCIA.txt" ,
+který je souèástí balíèku Wireless Tools
+.\"
+.\" AUTHOR part
+.\"
+.SH AUTOR
+Jean Tourrilhes \- jt@hpl.hp.com
+.br
+.I http://www.hpl.hp.com/personal/Jean_Tourrilhes/Linux/
+.\"
+.\" TRANSLATION part
+.\"
+.SH PØEKLAD
+Pavel Heimlich \- tropikhajma@seznam.cz, bøezen 2005 (wireless_tools.28pre4).
+.\"
+.\" SEE ALSO part
+.\"
+.SH DAL©Í INFORMACE
+.BR iwconfig (8),
+.BR iwlist (8),
+.BR iwspy (8),
+.BR iwpriv (8),
+.BR iwevent (8).
diff --git a/fr/ifrename.8 b/fr/ifrename.8
new file mode 100644
index 0000000..f3b9fd4
--- /dev/null
+++ b/fr/ifrename.8
@@ -0,0 +1,147 @@
+.\" Jean II - HPL - 2004
+.\" ifrename.8
+.\"
+.\" Traduction 2004/08/25 Maxime CHARPENNE (voir
+.\" http://www.delafond.org/traducmanfr/)
+.\" 1ère traduction        : version 27-pre25
+.TH IFRENAME 8 "01 mars 2004" "wireless-tools" "Manuel du programmeur Linux"
+.\"
+.\" NAME part
+.\"
+.SH NOM
+ifrename \- renomme les interfaces réseau basées sur différents critères
+statiques
+.\"
+.\" SYNOPSIS part
+.\"
+.SH SYNOPSIS
+.B "ifrename [-c configfile] [-p] [-d]"
+.br
+.B "ifrename [-c configfile] [-i interface] [-n newname]"
+.\"
+.\" DESCRIPTION part
+.\"
+.SH DESCRIPTION
+.B Ifrename
+est un outil vous permettant d'assigner un nom cohérent à chacune de vos
+interfaces réseau.
+.PP
+Par défaut, les noms d'interface sont dynamiques, et à chaque interface réseau
+est assigné le premier nom disponible
+.RI ( eth0 ", " eth1 "...)."
+L'ordre dans lequel les interfaces réseau sont créées peut varier. Pour les
+interfaces fixes («\ built-in interfaces\ »), l'énumération du noyau au
+démarrage peut varier. Pour les interfaces débranchables, l'utilisateur peut les
+brancher dans n'importe quel ordre.
+.PP
+.B Ifrename
+permet à l'utilisateur de décider quel nom une interface réseau aura.
+.B Ifrename 
+peut utiliser différents sélecteurs
+.RI "(«\ " selectors "\ »)"
+pour spécifier comment les noms d'interface correspondent aux interfaces réseau
+du système, le plus commun des sélecteurs étant
+.RI "l'" "adresse MAC"
+de l'interface.
+.PP
+.B Ifrename
+doit être lancé avant que les interfaces ne soient démarrées, raison pour
+laquelle il est surtout utile dans divers scripts (init, hotplug), mais il est
+rarement utilisé directement par l'utilisateur. Par défaut,
+.B ifrename 
+renomme toutes les interfaces système présentes en utilisant les correspondances
+définies dans
+.IR /etc/iftab .
+.\"
+.\" PARAMETER part
+.\"
+.SH PARAMÈTRES
+.TP
+.BI "-c " configfile
+Fixe le fichier de configuration à utiliser (par défaut
+.IR /etc/iftab ).
+Le fichier de configuration définit la correspondance entre les sélecteurs et
+les noms d'interface, et il est décrit dans
+.IR iftab (5).
+.br
+Si
+.I configfile
+est «\ -\ », la configuration est lue depuis stdin.
+.TP
+.B -p
+Sonde (charge) les modules noyau avant de renommer les interfaces. Par
+défaut,
+.B ifrename 
+vérifie seulement les interfaces déjà chargées, et ne charge pas
+automatiquement les modules noyau requis. Cette option autorise une intégration
+en douceur dans les systèmes qui ne chargent pas les modules avant d'appeler
+.BR ifrename .
+.TP
+.B -d
+Active divers bidouillages spécifiques à la
+.BR Debian .
+Combiné avec
+.BR -p ,
+seuls les modules pour les interfaces spécifiées dans
+.I /etc/network/interface
+sont chargés.
+.TP
+.BI "-i " interface
+Renomme seulement
+.RI "l'" interface 
+spécifiée, par opposition à toutes les interfaces présentes sur le système. Le
+nouveau nom de l'interface est affiché.
+.TP
+.BI "-n " newname
+Si utilisé avec
+.IR -i ,
+spécifie le nouveau nom de l'interface. La liste des correspondances depuis le
+fichier de configuration est ignorée. Le nouveau nom peut être un joker
+(«\ wildcard\ ») qui contient une seule '*'.
+.TP
+.B -t
+Active l'absorption («\ takover\ ») de nom. Cela permet d'échanger un nom
+d'interface entre deux interfaces ou plus.
+.br
+L'absorption permet à une interface de «\ voler\ » le nom d'une autre
+interface. Cela fonctionne seulement avec le noyau 2.6.X et si l'autre
+interface est désactivée. En conséquence, ce n'est pas compatible avec Hotplug.
+L'autre interface se voit assigner un nom aléatoire, mais peut être renommée
+plus tard avec 'ifrename'.
+.br
+Le nombre d'absorptions est limité pour éviter les boucles circulaires, et donc
+certaines situations d'échanges de noms complexes ne seront pas complètement
+traitées.
+.br
+Dans tous les cas, l'échange de noms et l'utilisation de cette caractéristique
+sont découragés, et vous êtes invités à choisir des noms uniques et sans
+ambiguïté pour vos interfaces...
+.\"
+.\" AUTHOR part
+.\"
+.SH AUTEUR
+Jean Tourrilhes \- jt@hpl.hp.com
+.\"
+.\" TRADUCTION part
+.\"
+.SH TRADUCTION
+Maxime CHARPENNE, août 2004 (wireless_tools.27-pre25).
+.\"
+.\" AVERTISSEMENT part
+.\"
+.SH AVERTISSEMENT SUR LA TRADUCTION
+Il est possible que cette traduction soit imparfaite ou périmée. En cas de
+doute, veuillez vous reporter au document original en langue anglaise fourni
+avec le programme.
+.\"
+.\" FILES part
+.\"
+.SH FICHIERS
+.I /etc/iftab
+.\"
+.\" SEE ALSO part
+.\"
+.SH VOIR AUSSI
+.BR ifconfig (8),
+.BR ip (8),
+.BR iftab (5).
diff --git a/fr/iftab.5 b/fr/iftab.5
new file mode 100644
index 0000000..21c8936
--- /dev/null
+++ b/fr/iftab.5
@@ -0,0 +1,196 @@
+.\" Jean II - HPL - 2004
+.\" iftab.5
+.\"
+.\" Traduction 2004/08/25 Maxime CHARPENNE (voir
+.\" http://www.delafond.org/traducmanfr/)
+.\" 1ère traduction        : version 27-pre25
+.\"
+.TH IFTAB 5 "01 mars 2004" "wireless-tools" "Manuel du Programmeur Linux"
+.\"
+.\" NAME part
+.\"
+.SH NOM
+iftab \- informations statiques sur les interfaces réseau
+.\"
+.\" DESCRIPTION part
+.\"
+.SH DESCRIPTION
+Le fichier
+.B /etc/iftab
+contient de l'information descriptive à propos des diverses interfaces réseau.
+.B iftab
+n'est utilisé que par le programme
+.IR ifrename (8)
+pour assigner un nom d'interface réseau cohérent à chaque interface réseau.
+.PP
+.B /etc/iftab
+définit un ensemble de
+.RI "correspondances («\ " mappings "\ »)."
+Chaque correspondance contient un nom d'interface et un ensemble de sélecteurs
+(«\ selectors\ »). Les sélecteurs permettent à
+.B ifrename
+d'identifier chaque interface réseau du système. Si une interface réseau
+correspond à tous les descripteurs d'une correspondance,
+.B ifrename
+essaye de changer le nom de l'interface par le nom de l'interface donné dans la
+correspondance.
+.\"
+.\" MAPPINGS part
+.\"
+.SH CORRESPONDANCES («\ MAPPINGS\ »)
+Chaque correspondance est décrite sur une ligne distincte, elle commence avec
+.IR "interface name" " (nom d'interface),"
+et contient un ensemble de
+.RI "descripteurs («\ " descriptors "\ »),"
+séparés par des espaces ou des tabulations.
+.PP
+La relation entre les descripteurs d'une correspondance est un
+.IR "et logique" .
+Une correspondance s'applique à une interface réseau seulement si tous les
+descripteurs s'appliquent. Si une interface réseau ne supporte pas un
+descripteur particulier, elle ne s'appliquera à aucune correspondance qui
+utilise ce descripteur.
+.PP
+Si vous voulez utiliser des descripteurs alternatifs pour un nom d'interface
+(ou logique), spécifiez deux correspondances différentes avec le même nom
+d'interface (une par ligne).
+.B Ifrename
+utilise toujours la première correspondance en commençant par la
+.I fin
+de
+.BR iftab ,
+donc les correspondances les plus restrictives devraient être définies en
+dernier.
+.\"
+.\" INTERFACE NAME part
+.\"
+.SH NOM D'INTERFACE
+La première partie de chaque correspondance est un nom d'interface. Si une
+interface réseau correspond à tous les descripteurs d'une correspondance,
+.B ifrename
+essaye de changer le nom de l'interface par le nom de l'interface donné dans la
+correspondance.
+.PP
+Le nom de l'interface d'une correspondance est soit un nom d'interface complet
+(comme
+.IR eth2 " ou " wlan0 )
+ou un motif de nom d'interface contenant un seul caractère joker (comme
+.IR eth* " ou " wlan* ).
+Dans le cas d'un caractère joker («\ wildcard\ »), le noyau remplace le
+caractère '*' par le plus petit entier disponible faisant un nom d'interface
+unique.
+.\"
+.\" DESCRIPTORS part
+.\"
+.SH DESCRIPTEURS («\ DESCRIPTORS\ »)
+Chaque descripteur est composé d'un nom de descripteur et d'une valeur de
+descripteur. Les descripteurs définissent un attribut statique d'une interface
+réseau, le but étant d'identifier de manière unique chaque périphérique.
+.PP
+La plupart des utilisateurs n'utiliseront que le sélecteur
+.BR mac ,
+les autres sélecteurs étant pour une configuration plus spécialisée.
+.TP
+.BI mac " adresse mac"
+Correspond à l'Adresse MAC de l'interface avec l'adresse MAC spécifiée.
+L'adresse MAC de l'interface peut être montrée en utilisant
+.IR ifconfig (8)
+ou
+.IR ip (8).
+L'adresse MAC spécifiée peut contenir une '*' pour la correspondance joker
+(«\ wildcard matching\ »).
+.br
+C'est le plus commun des sélecteurs, vu que chaque interface possède une
+adresse MAC unique, ce qui permet de les identifier sans ambiguïté.
+.TP
+.BI arp " arp type"
+Fait correspondre le Type ARP («\ ARP Type\ ») (aussi appelé «\ Link Type\ »)
+de l'interface avec le type ARP spécifié. Le Type ARP de l'interface peut être
+montré en utilisant
+.IR ifconfig (8)
+ou
+.IR ip (8).
+.br
+Ce sélecteur est utile quand un pilote crée plusieurs interfaces réseau pour
+une seule carte réseau.
+.TP
+.BI driver " driver name"
+Fait correspondre le Nom de Pilote («\ Driver Name\ ») de l'interface avec le
+nom de pilote spécifié. Le Nom de Pilote de l'interface peut être montré en
+utilisant
+.IR "ethtool -i" (8).
+.TP
+.BI businfo " bus information"
+Fait correspondre l'Information de Bus («\ Bus Information\ ») de l'interface
+avec l'information de bus spécifiée. L'Information de Bus de l'interface peut
+être montrée en utilisant
+.IR "ethtool -i" (8).
+.TP
+.BI baseaddress " base address"
+Fait correspondre l'Adresse de Base («\ Base Address\ ») de l'interface avec
+l'adresse de base spécifiée. L'Adresse de Base de l'interface peut être montrée
+en utilisant
+.IR ifconfig (8).
+.br
+Ce sélecteur n'est utile que pour les cartes ISA et EISA car la plupart des
+cartes utilisent l'allocation dynamique pour l'Adresse de Base.
+.TP
+.BI irq " irq line"
+Fait correspondre la Ligne IRQ (interruption) de l'interface avec la ligne IRQ
+spécifiée. La Ligne IRQ de l'interface peut être montrée en utilisant
+.IR ifconfig (8).
+.br
+Ce sélecteur n'est habituellement pas suffisant pour identifier de manière
+unique une interface, car les Lignes IRQ peuvent être partagées.
+.TP
+.BI iwproto " wireless protocol"
+Fait correspondre le Protocole Wireless de l'interface avec le protocole
+wireless spécifié. Le Protocole Wireless de l'interface peut être montré
+en utilisant
+.IR iwconfig (8).
+.br
+Ce sélecteur n'est valable que pour les interfaces wireless et n'est pas
+suffisant pour en identifier une de manière unique.
+.\"
+.\" EXAMPLE part
+.\"
+.SH EXEMPLE
+# Ceci est un commentaire
+.br
+eth2		mac 08:00:09:DE:82:0E
+.br
+eth3		driver wavelan interrupt 15 baseaddress 0x390
+.br
+eth4		driver pcnet32 businfo 0000:02:05.0
+.br
+air*		mac 00:07:0E:* arp 1
+.\"
+.\" AUTHOR part
+.\"
+.SH AUTEUR
+Jean Tourrilhes \- jt@hpl.hp.com
+.\"
+.\" TRADUCTION part
+.\"
+.SH TRADUCTION
+Maxime CHARPENNE, août 2004 (wireless_tools.27-pre25).
+.\"
+.\" AVERTISSEMENT part
+.\"
+.SH AVERTISSEMENT SUR LA TRADUCTION
+Il est possible que cette traduction soit imparfaite ou périmée. En cas de
+doute, veuillez vous reporter au document original en langue anglaise fourni
+avec le programme.
+.\"
+.\" FILES part
+.\"
+.SH FICHIERS
+.I /etc/iftab
+.\"
+.\" SEE ALSO part
+.\"
+.SH VOIR AUSSI
+.BR ifrename (8),
+.BR ifconfig (8),
+.BR ip (8),
+.BR iwconfig (8).
diff --git a/fr/iwconfig.8 b/fr/iwconfig.8
new file mode 100644
index 0000000..9e45759
--- /dev/null
+++ b/fr/iwconfig.8
@@ -0,0 +1,569 @@
+.\" Jean II - HPLB - 1996 => HPL - 2004
+.\" iwconfig.8
+.\"
+.\" Traduction 2003/07/15 Maxime CHARPENNE (voir
+.\" http://www.delafond.org/traducmanfr/)
+.\" 1ère traduction        : version 26
+.\" Mise à jour 2004/01/28 : version 27-pre9 (beta)
+.\" Mise à jour 2004/02/26 : version 27-pre11 (alpha)
+.\" Mise à jour 2004/08/23 : version 27-pre25
+.\"
+.TH IWCONFIG 8 "22 juin 2004" "wireless-tools" "Manuel du programmeur Linux"
+.\"
+.\" NAME part
+.\"
+.SH NOM
+iwconfig \- configure une interface réseau sans-fil (wireless)
+.\"
+.\" SYNOPSIS part
+.\"
+.SH SYNOPSIS
+.BI "iwconfig [" interface ]
+.br
+.BI "iwconfig " interface " [essid " X "] [nwid " N "] [freq " F "] [channel " C ]
+.br
+.BI "                   [sens " S "] [mode " M "] [ap " A "] [nick " NN ]
+.br
+.BI "                   [rate " R "] [rts " RT "] [frag " FT "] [txpower " T ]
+.br
+.BI "                   [enc " E "] [key " K "] [power " P "] [retry " R ]
+.br
+.BI "                   [commit]
+.br
+.BI "iwconfig --help"
+.br
+.BI "iwconfig --version"
+.\"
+.\" DESCRIPTION part
+.\"
+.SH DESCRIPTION
+.B Iwconfig
+est similaire à
+.IR ifconfig (8),
+mais est dédié aux interfaces wireless. Il est utilisé pour manier les
+paramètres des interfaces réseaux qui sont spécifiques aux opérations wireless
+(par exemple\ : la fréquence).
+.B Iwconfig
+peut aussi être utilisé pour afficher ces paramètres, et les statistiques
+concernant le sans fil (extraites de
+.IR /proc/net/wireless ).
+.PP
+Tous ces paramètres et statistiques dépendent du matériel. Chaque pilote ne
+fournira que quelques uns d'entre eux en fonction du support matériel, et
+l'étendue des valeurs peut changer. Veuillez vous référer aux pages man de
+chaque matériel pour plus de détails.
+.\"
+.\" PARAMETER part
+.\"
+.SH PARAMÈTRES
+.TP
+.B essid
+Positionne le ESSID ( ou Network Name - pour certains produits, il peut aussi
+être désigné comme Domain ID). L'ESSID est utilisé pour identifier les cellules
+qui font partie du même réseau virtuel.
+.br
+Par opposition à l'adresse de l'AP ou au NWID qui définissent une seule cellule,
+l'ESSID définit un groupe de cellules connectées via des répéteurs ou via
+l'infrastructure, où l'utilisateur peut «\ roamer\ » ou errer de manière
+transprente (c.-à-d. changer de cellule sans perdre sa connexion).
+.br
+Avec certaines cartes, vous pouvez désactiver le contrôle du ESSID (ESSID
+promiscuous) avec
+.IR off " ou " any " (et " on
+pour le réactiver).
+.br
+.B Exemples :
+.br
+.I "	iwconfig eth0 essid any"
+.br
+.I "	iwconfig eth0 essid ""Mon Reseau""
+.TP
+.BR nwid / domain
+Positionne le Network ID (pour certains produits, il peut aussi être appelé
+Domain ID). Comme tous les réseaux sans fil adjacents partagent le même médium,
+ce paramètre est utilisé pour les différencier (créer des réseaux logiques
+colocalisés) et pour identifier des noeuds appartenant à la même cellule.
+.br
+Ce paramètre est seulement utilisé par les matériels antérieurs à 802.11, la
+norme 802.11 se servant du ESSID et de l'adresse de l'AP pour cette fonction.
+.br
+Avec certaines cartes, vous pouvez désactiver le contrôle du Network ID (NWID
+promiscuous) avec
+.IR off " (et " on
+pour le réactiver).
+.br
+.B Exemples :
+.br
+.I "	iwconfig eth0 nwid AB34
+.br
+.I "	iwconfig eth0 nwid off"
+.TP
+.BR freq / channel
+Positionne la fréquence d'exploitation ou canal du périphérique. Une valeur
+inférieure à 1\ 000 indique un numéro de canal, une valeur supérieure à 1\ 000
+est une fréquence en Hz. Vous pouvez ajouter le suffixe k, M ou G à la valeur
+(par exemple, «\ 2.46G\ » pour la fréquence 2,46\ GHz), ou ajouter suffisamment
+de «\ 0\ ».
+.br
+Les canaux sont habituellement numérotés à partir de 1, et vous pouvez utiliser
+.IR iwlist (8)
+pour obtenir le nombre total de canaux, lister les fréquences disponibles, et
+afficher le fréquence courante comme un canal.
+Suivants les réglementations, certaines fréquences/canaux peuvent ne pas
+être disponibles.
+.br
+.B Exemples :
+.br
+.I "	iwconfig eth0 freq 2422000000"
+.br
+.I "	iwconfig eth0 freq 2.422G"
+.br
+.I "	iwconfig eth0 channel 3"
+.TP
+.B sens
+Positionne le seuil de sensibilité. C'est le niveau de signal le plus bas pour
+lequel le matériel essaye de réceptionner un paquet, les signaux plus bas sont
+ignorés. Ceci est utilisé pour éviter de recevoir le bruit de fond, donc vous
+devriez le positionner en fonction du niveau de bruit moyen. Les valeurs
+positives sont supposées être les valeurs brutes utilisées par le matériel ou
+un pourcentage, les valeurs négatives sont supposées être des dBm.
+.br
+Avec certains matériels, ce paramètre contrôle aussi le seuil de report
+(defer threshold) (signal le plus faible pour lequel le matériel considère le
+canal occupé) et le seuil de cession (handover threshold) (niveau de signal pour
+lequel le matériel commence à chercher un nouveau Point d'Accès).
+.br
+.B Exemple :
+.br
+.I "	iwconfig eth0 sens -80"
+.TP
+.B mode
+Positionne le mode de fonctionnement du matériel, qui dépend de la topologie du
+réseau. Le mode peut être
+.I Ad-Hoc
+(réseau composé d'une seule cellule et sans Point d'Accès),
+.I Managed
+(un noeud se connecte à un réseau composé de plusieurs Points d'Accès, avec
+roaming ou errance),
+.I Master
+(le noeud est le maître qui synchronise ou agit comme un Point d'Accès),
+.I Repeater
+(le noeud transmet les paquets entre les autres n½uds wireless),
+.I Secondary
+(le noeud agit comme un maître/répéteur supplémentaire),
+.I Monitor
+(le noeud agit comme un moniteur passif et ne fait que recevoir des paquets) ou
+.IR Auto .
+.br
+.B Exemple :
+.br
+.I "	iwconfig eth0 mode Managed"
+.br
+.I "	iwconfig eth0 mode Ad-Hoc"
+.TP
+.B ap
+Force la carte à s'enregistrer auprès du Point d'Accès donné par l'adresse,
+si c'est possible. Quand la qualité de la connexion devient trop mauvaise,
+le pilote peut revenir en mode automatique (la carte sélectionne le meilleur
+Point d'Accès à portée).
+.br
+Vous pouvez aussi utiliser
+.I off
+pour réactiver le mode automatique sans changer le Point d'Accès courant,
+ou vous pouvez utiliser
+.I any
+ou
+.I auto
+pour forcer la carte à se ré associer avec le meilleur Point d'Accès courant.
+.br
+.B Exemple :
+.br
+.I "	iwconfig eth0 ap 00:60:1D:01:23:45"
+.br
+.I "	iwconfig eth0 ap any"
+.br
+.I "	iwconfig eth0 ap off"
+.TP
+.BR nick [name]
+Positionne le surnom (nickname), ou nom de station. Quelques produits
+802.11 le définissent, mais il n'est pas utilisé dans la mesure où les
+protocoles les plus usités (MAC, IP, TCP) ne s'en servent pas en l'état.
+Seuls quelques outils de diagnostic peuvent l'utiliser.
+.br
+.B Exemple :
+.br
+.I "	iwconfig eth0 nickname ""My Linux Node""
+.TP
+.BR rate / bit [rate]
+Pour les cartes supportant plusieurs débits, positionne le débit en b/s. Le
+débit est la vitesse à laquelle les bits sont transmis sur le médium, la
+vitesse du lien pour l'utilisateur est inférieure à cause du partage du médium
+et des diverses entêtes.
+.br
+Vous pouvez ajouter le suffixe k, M ou G à la valeur (multiplicateur décimal\ :
+10^3, 10^6 et 10^9\ b/s), ou ajouter suffisamment de «\ 0\ ». Les valeurs
+en-dessous de 1000 sont spécifiques à la carte, habituellement un index de la
+liste des débit supportés. Utilisez
+.I auto
+pour sélectionner le mode débit automatique (repli à un débit moindre pour
+les canaux bruités), ce qui est le mode par défaut pour la plupart des cartes,
+et
+.I fixed
+pour revenir à des paramètres fixes. Si vous spécifiez une valeur de débit
+et ajoutez
+.IR auto ,
+le driver utilisera tous les débits inférieurs et égaux à cette valeur.
+.br
+.B Exemples :
+.br
+.I "	iwconfig eth0 rate 11M"
+.br
+.I "	iwconfig eth0 rate auto"
+.br
+.I "	iwconfig eth0 rate 5.5M auto"
+.TP
+.BR rts [_threshold]
+RTS/CTS ajoute une «\ poignée de main\ » avant chaque transmission de paquet
+pour être sûr que le canal est libre. Cela ajoute des entêtes (NDT\ : données de
+gestion), mais augmente les performances en cas de n½uds cachés ou
+d'un grand nombre de noeuds actifs. Ce paramètre fixe la taille du plus petit
+paquet pour lequel le noeud envoie un RTS\ ; une valeur égale à la taille
+maximale des paquets inhibe ce mécanisme. Vous pouvez aussi positionner
+ce paramètre sur
+.IR auto ", " fixed " ou " off .
+.br
+.B Exemples :
+.br
+.I "	iwconfig eth0 rts 250"
+.br
+.I "	iwconfig eth0 rts off"
+.TP
+.BR frag [mentation_threshold]
+La fragmentation permet de découper un paquet IP en une série de plus petits
+fragments transmis par le médium. Dans la plupart des cas, cela ajoute des
+entêtes, mais dans un environnement très bruité, cela réduit les coûts de
+transmission dus aux erreurs et permet aux paquets d'être acheminés malgré
+des séries d'interférences. Ce paramètre fixe la taille de fragment maximale\ ;
+une valeur égale à la taille maximale de paquet désactive ce procédé. Vous
+pouvez aussi mettre ce paramètre à
+.IR auto ", " fixed " ou " off .
+.br
+.B Exemples :
+.br
+.I "	iwconfig eth0 frag 512"
+.br
+.I "	iwconfig eth0 frag off"
+.TP
+.BR key / enc [ryption]
+Utilisé pour manipuler les clefs de cryptage ou brouillage et le mode de
+sécurité.
+.br
+Pour mettre la clef courante de cryptage, il suffit d'entrer la clef
+en hexadécimal telle que
+.IR XXXX-XXXX-XXXX-XXXX " ou " XXXXXXXX .
+Pour entrer une autre clef que la clef courante, ajoutez (au début ou à la
+fin)
+.I [index]
+à la clef elle-même (cela ne changera pas la clef active). Vous pouvez aussi
+entrer la clef comme une chaîne ASCII en utilisant le préfixe
+.IR s: .
+Les phrases en tant que mot de passe ne sont actuellement pas supportées.
+.br
+Pour changer la clef active parmi les clefs déjà entrées, il suffit d'entrer
+.RI l' "[index]"
+(sans entrer de valeur de clef).
+.br
+.IR off " et " on
+désactive et réactive le cryptage.
+.br
+Le mode de sécurité peut être
+.I open
+ou
+.IR restricted ,
+et sa signification dépend de la carte utilisée. Avec la plupart des cartes,
+le mode
+.I open
+n'utilise pas d'authentification et la carte accepte des sessions non cryptées,
+alors que le mode
+.I restricted
+n'accepte que des sessions cryptées et la carte utilisera l'authentification
+si disponible.
+.br
+Si vous avez besoin de mettre plusieurs clefs, ou de mettre une clef et de
+changer la clef active, vous avez besoin d'utiliser des instructions à clefs
+.RB ( "key" )
+multiples. Les arguments peuvent être mis dans n'importe quel ordre, le
+dernier sera prioritaire.
+.br
+.B Exemples :
+.br
+.I "	iwconfig eth0 key 0123-4567-89"
+.br
+.I "	iwconfig eth0 key [3] 0123-4567-89"
+.br
+.I "	iwconfig eth0 key s:password [2]"
+.br
+.I "	iwconfig eth0 key [2]"
+.br
+.I "	iwconfig eth0 key open"
+.br
+.I "	iwconfig eth0 key off"
+.br
+.I "	iwconfig eth0 key restricted [3] 0123456789"
+.br
+.I "	iwconfig eth0 key 01-23 key 45-67 [4] key [4]"
+.TP
+.BR power
+Utilisé pour manipuler les paramètres et le mode du procédé de gestion
+d'énergie.
+.br
+Pour fixer la période entre les éveils, entrez la
+.IR "period `valeur'" .
+Pour fixer la temporisation avant le retour en veille, entrez la
+.IR "timeout `valeur'" .
+Vous pouvez aussi ajouter les modificateurs
+.IR min " et " max ".
+Par défaut, ces valeurs sont exprimées en secondes, ajoutez le suffixe m ou u
+pour spécifier les valeurs en millisecondes ou microsecondes. Parfois, ces
+valeurs sont sans unité (nombre de périodes de beacon, dwell ou similaire).
+.br
+.IR off " et " on
+désactive et réactive la gestion d'énergie. Enfin, vous pouvez mettre la
+gestion d'énergie en mode
+.I all
+(reçoit tous les paquets),
+.I unicast
+(reçoit seulement les paquets unicast, ignore les paquets multicast et de
+broadcast) et
+.I multicast
+(reçoit seulement les paquets multicast et de broadcast, ignore l'unicast).
+.br
+.B Exemples :
+.br
+.I "	iwconfig eth0 power period 2"
+.br
+.I "	iwconfig eth0 power 500m unicast"
+.br
+.I "	iwconfig eth0 power timeout 300u all"
+.br
+.I "	iwconfig eth0 power off"
+.br
+.I "	iwconfig eth0 power min period 2 power max period 4"
+.TP
+.BR txpower
+Pour les cartes supportant plusieurs puissances de transmission, règle la
+puissance de transmission en dBm. Si
+.I W
+est la puissance en Watt, la puissance en dBm est
+.IR "P\ =\ 30\ +\ 10.log(W)" .
+Si la valeur est post fixée par
+.IR mW ,
+elle sera automatiquement convertie en dBm.
+.br
+De plus,
+.IR on " et " off
+active et désactive la radio, et
+.IR auto " et " fixed
+active et désactive le contrôle de puissance (si ces fonctions sont
+disponibles).
+.br
+.B Exemples :
+.br
+.I "	iwconfig eth0 txpower 15"
+.br
+.I "	iwconfig eth0 txpower 30mW"
+.br
+.I "	iwconfig eth0 txpower auto"
+.br
+.I "	iwconfig eth0 txpower off"
+.TP
+.BR retry
+La plupart des cartes supportent les retransmissions MAC (contrôle d'accès
+au médium), et certaines permettent le paramétrage du mécanisme des tentatives
+(en cas d'échec).
+.br
+Pour fixer le nombre maximum d'essais, entrez
+.IR "limit `valeur'" .
+C'est une valeur absolue (sans unité).
+Pour fixer le temps maximum autorisé au mécanisme MAC pour ses tentatives,
+entrez
+.IR "lifetime `valeur'" .
+Par défaut, cette valeur est en secondes, ajouter le suffixe m ou u pour
+spécifier les valeurs en millisecondes ou microsecondes.
+.br
+Vous pouvez aussi ajouter les modificateurs
+.IR min " et " max ".
+Si la carte supporte le mode automatique, ils définissent les limites du
+lifetime, ou les limites inférieure et supérieure (NDT\ : de l'intervalle
+temporel dans lequel le mécanisme MAC est autorisé à réitérer ses tentatives).
+D'autres cartes définissent des valeurs différentes en fonction de la taille
+des paquets, par exemple la norme 802.11 définit une
+.I min limit
+qui est la limite inférieure d'essai (paquets non RTS/CTS).
+.br
+.B Exemples :
+.br
+.I "	iwconfig eth0 retry 16"
+.br
+.I "	iwconfig eth0 retry lifetime 300m"
+.br
+.I "	iwconfig eth0 retry min limit 8"
+.TP
+.BR commit
+Certaines cartes peuvent ne pas appliquer immédiatement les changements
+effectués par les Wireless Extensions (elles peuvent attendre pour prendre en
+compte les changements ou les appliquer seulement quand la carte est montée via
+ifconfig). Cette commande (si disponible) force la carte à appliquer les
+changements en suspens.
+.br
+Cela n'est normalement pas nécessaire, car la carte appliquera éventuellement
+les changements, mais peut être utile pour débuggage.
+.\"
+.\" DISPLAY part
+.\"
+.SH AFFICHAGE
+Pour chaque matériel qui supporte les extensions wireless,
+.I iwconfig
+affiche le nom du
+.B protocole MAC
+utilisé (nom du matériel pour les protocoles propriétaires),
+.RB l' ESSID
+(Network Name), le
+.BR NWID ,
+la
+.B fréquence
+(ou canal), la
+.BR sensibilité ,
+le
+.B mode
+d'exploitation, l'adresse du
+.BR "Point d'Accès",
+le
+.BR débit ,
+le
+.BR "seuil RTS" " (" "RTS threshold" "), le "
+.BR "seuil de fragmentation" " (" "fragmentation threshold" "), la
+.B clef de cryptage
+et les paramètres de
+.BR "gestion de l'énergie" " (" "power management" ")"
+(en fonction de la disponibilité).
+.PP
+Les paramètres affichés ont la même signification et la même valeur que ceux
+que vous pouvez régler, veuillez vous reporter à la précédente partie pour
+leur explication détaillée.
+.br
+Quelques paramètres sont affichés seulement dans une forme abrégée (comme le
+cryptage). Vous devez utiliser
+.IR iwlist (8)
+pour avoir tous les détails.
+.br
+Certains paramètres ont deux modes (comme le débit). Si la valeur est préfixée
+par
+.RB «\ =\ »,
+cela veut dire que le paramètre est fixé et forcé à cette valeur, s'il est
+préfixé par
+.RB «\ :\ »,
+le paramètre est en mode automatique et la valeur courante est montrée (et peut
+changer).
+.TP
+.BR "Access Point" / Cell
+Une adresse égale à 00:00:00:00:00:00 signifie que la carte n'a pas réussi à
+s'associer avec un Point d'Accès (le plus souvent une question de
+configuration).
+Le paramètre
+.B Access Point
+sera montré comme une cellule
+.RB ( Cell )
+en mode ad hoc (pour des raisons évidentes), mais il fonctionne néanmoins
+de la même manière.
+.PP
+Si
+.I /proc/net/wireless
+existe,
+.I iwconfig
+affichera aussi son contenu. Il faut noter que ces valeurs dépendent des
+spécifications du pilote et de la carte, vous devrez donc vous référez à la
+documentation du pilote pour une interprétation correcte de ces valeurs.
+.TP
+.B Link quality
+Qualité globale du lien. Peut être basé sur le niveau de contention ou des
+interférences, le taux d'erreur de trame ou de bit, la qualité du signal reçu,
+des synchronisations temporelles, ou autre métrique matérielle. C'est une valeur
+agrégat, et dépend totalement du pilote et du matériel.
+.TP
+.B Signal level
+Force du signal reçu (RSSI - force du signal reçu). Cela peut être des unités
+arbitraires ou des dBm,
+.I iwconfig
+utilise des méta-informations du pilote pour interpréter les valeurs
+brutes données par
+.I /proc/net/wireless
+et affiche l'unité ou la valeur maximale correspondante (utilise l'arithmétique
+8 bits). En mode
+.I Ad-Hoc
+cela peut être indéfini et vous devriez utiliser
+.IR iwspy .
+.TP
+.B Noise level
+Niveau du bruit de fond (quand aucun paquet n'est transmis). Commentaires
+similaires à ceux de
+.BR "Signal level" .
+.TP
+.B Rx invalid nwid
+Nombre de paquets reçus avec un NWID ou ESSID différent. Utilisé pour détecter
+des problèmes de configuration ou l'existence de réseau adjacent (sur la même
+fréquence).
+.TP
+.B Rx invalid crypt
+Nombre de paquets que le matériel a été incapable de décrypter. Cela peut être
+utilisé pour détecter des mauvais paramètres de cryptage.
+.TP
+.B Rx invalid frag
+Nombre de paquets pour lesquels le matériel a été incapable de ré-assembler
+correctement les fragments de la couche liaison (le plus souvent, il en manque
+un).
+.TP
+.B Tx excessive retries
+Nombre de paquets que la carte n'a pas réussi à envoyer. La plupart des
+protocoles MAC réessaient un certain nombre de fois avant d'abandonner.
+.TP
+.B invalid misc
+Autres paquets perdus en relation avec les opérations spécifiques au sans fil.
+.TP
+.B Missed beacon
+Nombre de beacons périodiques émis par la Cellule ou le Point d'Accès que nous
+avons manqué. Les beacons sont envoyés à intervalles réguliers pour maintenir la
+coordination de la cellule, l'impossibilité de les recevoir indiquant souvent
+que la carte est hors de portée.
+.\"
+.\" AUTHOR part
+.\"
+.SH AUTEUR
+Jean Tourrilhes \- jt@hpl.hp.com
+.\"
+.\" TRADUCTION part
+.\"
+.SH TRADUCTION
+Maxime CHARPENNE, août 2004 (wireless_tools.27-pre25).
+.\"
+.\" AVERTISSEMENT part
+.\"
+.SH AVERTISSEMENT SUR LA TRADUCTION
+Il est possible que cette traduction soit imparfaite ou périmée. En cas de
+doute, veuillez vous reporter au document original en langue anglaise fourni
+avec le programme.
+.\"
+.\" FILES part
+.\"
+.SH FICHIERS
+.I /proc/net/wireless
+.\"
+.\" SEE ALSO part
+.\"
+.SH VOIR AUSSI
+.BR ifconfig (8),
+.BR iwspy (8),
+.BR iwlist (8),
+.BR iwevent (8),
+.BR iwpriv (8),
+.BR wireless (7).
diff --git a/fr/iwevent.8 b/fr/iwevent.8
new file mode 100644
index 0000000..d287c8a
--- /dev/null
+++ b/fr/iwevent.8
@@ -0,0 +1,131 @@
+.\" Jean Tourrilhes - HPL - 2002 - 2004
+.\" iwevent.8
+.\"
+.\" Traduction 2003/08/17 Maxime CHARPENNE (voir
+.\" http://www.delafond.org/traducmanfr/)
+.\" 1ère traduction        : version 26
+.\" Manuel identique pour la version 27-pre9 (beta)
+.\" Mise à jour 2004/02/26 : version 27-pre11 (alpha)
+.\" Mise à jour 2004/08/23 : version 27-pre25
+.\"
+.TH IWEVENT 8 "23 juin 2004" "net-tools" "Manuel du Programmeur Linux"
+.\"
+.\" NAME part
+.\"
+.SH NOM
+iwevent \- Affiche les Événements Wireless (Wireless Events) générés par les
+pilotes et les changements de paramètres.
+.\"
+.\" SYNOPSIS part
+.\"
+.SH SYNOPSIS
+.BI "iwevent "
+.br
+.\"
+.\" DESCRIPTION part
+.\"
+.SH DESCRIPTION
+.B iwevent
+affiche les «\ Wireless Events\ » (événements du système Wireless) reçu par le
+socket RTNetlink. Chaque ligne affiche le Wireless Event spécifique qui décrit
+ce qui s'est passé sur l'interface sans fil spécifiée.
+.br
+Cette commande ne prend aucun argument.
+.\"
+.\" DISPLAY part
+.\"
+.SH AFFICHAGE
+Il y a deux classes de Wireless Events.
+.PP
+La première classe regroupe les événements relatifs à un changement des
+paramètres du sans fil sur l'interface (typiquement fait par
+.B iwconfig
+ou un script appelant
+.BR iwconfig ).
+Seuls les paramètres qui peuvent entraîner une perturbation de la connectivité
+sont rapportés. Les événements actuellement rapportés changent un des paramètres
+suivants\ :
+.br
+.I "	Network ID"
+.br
+.I "	ESSID"
+.br
+.I "	Frequency"
+.br
+.I "	Mode"
+.br
+.I "	Encryption"
+.br
+Tous ces événements seront générer sur toutes les interfaces sans fil par le
+sous-système «\ wireless\ » du noyau (mais seulement si le pilote a été converti
+àl'API du nouveau pilote).
+.PP
+La deuxième classe d'événements concerne ceux générés par le matériel, lorsque
+quelque chose arrive ou qu'une tâche s'est terminée. Ces événements incluent\ :
+.TP
+.B New Access Point/Cell address
+L'interface a joint un nouveau point d'accès ou cellule ad hoc, ou perdu son
+association avec. Il s'agit de la même adresse MAC affiché par
+.BR iwconfig .
+.TP
+.B Scan request completed
+Une requête de balayage (scanning) a été achevée, les résultats du «\ scan\ »
+sont disponibles (voir
+.BR iwlist ).
+.TP
+.B Tx packet dropped
+Un paquet à destination de cette adresse a été rejeté car l'interface croit que
+ce noeud ne répond plus (habituellement, le seuil maximum des émissions de la
+couche MAC est atteint). C'est habituellement la première indication pouvant
+révéler que le noeud a quitté la cellule ou est hors de portée, mais cela peut
+être due à une atténuation ou une contention excessive.
+.TP
+.B Custom driver event
+Événement spécifique au pilote. Veuillez consulter la documentation du pilote.
+.TP
+.B Registered node
+L'interface a réussi à enregistrer un nouveau client/paire sans fil. Sera
+généré la plupart du temps quand l'interface agit comme un point d'accès (mode
+master).
+.TP
+.B Expired node
+L'enregistrement d'un client/paire sur cette interface a expiré. Sera généré la
+plupart du temps quand l'interface agit comme un point d'accès (mode master).
+.TP
+.B Spy threshold crossed
+La force du signal pour une des adresses de la «\ spy list\ » (NDT\ : voir
+iwspy(8)) est passé en-dessous du seuil bas, ou est passé au-dessus du seuil
+haut.
+.PP
+La plupart des pilotes wireless génèrent seulement un sous-ensemble de ces
+événements, pas tous, la liste exacte dépendant de la combinaison spécifique
+matériel/pilote. Veuillez consulter la documentation du pilote pour les détails
+de ce qui les génèrent, et utilisez
+.IR iwlist (8)
+pour vérifier ce que le pilote supporte.
+.\"
+.\" AUTHOR part
+.\"
+.SH AUTEUR
+Jean Tourrilhes \- jt@hpl.hp.com
+.\"
+.\" TRADUCTION part
+.\"
+.SH TRADUCTION
+Maxime CHARPENNE, août 2004 (wireless_tools.27-pre25).
+.\"
+\" AVERTISSEMENT part
+.\"
+.SH AVERTISSEMENT SUR LA TRADUCTION
+Il est possible que cette traduction soit imparfaite ou périmée. En cas de
+doute, veuillez vous reporter au document original en langue anglaise fourni
+avec le programme.
+.\"
+.\" SEE ALSO part
+.\"
+.SH VOIR AUSSI
+.BR iwconfig (8),
+.BR iwlist (8),
+.BR iwspy (8),
+.BR iwpriv (8),
+.BR wireless (7).
diff --git a/fr/iwgetid.8 b/fr/iwgetid.8
new file mode 100644
index 0000000..3512ddb
--- /dev/null
+++ b/fr/iwgetid.8
@@ -0,0 +1,136 @@
+.\" Guus Sliepen - 2001
+.\" Completed and fixed up by Jean Tourrilhes - 2002-2003
+.\" iwgetid.8
+.\"
+.\" Traduction 2003/08/17 Maxime CHARPENNE (voir
+.\" http://www.delafond.org/traducmanfr/)
+.\" 1ère traduction        : version 26
+.\" Mise à jour 2004/01/29 : version 27-pre9 (beta)
+.\" Manuel identique pour la version 27-pre11 (alpha)
+.\" Mise à jour 2004/08/23 : version 27-pre25
+.\"
+.TH IWGETID 8 "02 décembre 2003" "wireless-tools" "Manuel du Programmeur Linux"
+.\"
+.\" NAME part
+.\"
+.SH NOM
+iwgetid \- Rapporte le ESSID, NWID ou l'Adresse de l'AP/Cell (Point d'Accès/\
+Cellule) du réseau sans fil.
+.\"
+.\" SYNOPSIS part
+.\"
+.SH SYNOPSIS
+.BI "iwgetid " [interface] " [--raw] [--scheme] [--ap] [--freq]"
+.br
+.BI "                    [--mode] [--protocol] [--channel]
+.br
+.\"
+.\" DESCRIPTION part
+.\"
+.SH DESCRIPTION
+.B iwgetid
+est utilisé pour trouver le NWID, ESSID ou l'adresse de l'AP ou cellule du
+réseau sans fil utilisé présentement. L'information rapportée est la même
+que celle montrée par
+.BR iwconfig ", mais " iwgetid
+est plus facile à intégrer dans les scripts.
+.br
+Par défaut,
+.B iwgetid
+affichera
+.RI l' ESSID
+de la carte, et si la carte n'a pas d'ESSID, il affichera son
+.IR NWID .
+.br
+Le formatage par défaut de la sortie est embelli.
+.\"
+.\" OPTIONS part
+.\"
+.SH OPTIONS
+.TP
+.B --raw
+Cette option désactive l'embellissement de l'affichage de l'information. Cette
+option est orthogonale aux autres options (sauf
+.BR --scheme ),
+donc, avec la combinaison appropriée des options, il est possible d'afficher
+en brut l'ESSID, l'Adresse de l'AP ou le Mode.
+.br
+Ce format est idéal quand on stocke le résultat de iwgetid comme une variable
+dans les scripts
+.I Shell
+ou
+.IR Perl ,
+ou pour passer le résultat comme argument sur la ligne de commande de
+.BR iwconfig .
+.TP
+.B --scheme
+Cette option est similaire à la précédente, elle désactive l'embellissement de
+l'affichage des données et supprime tous les caractères non alphanumériques
+(comme les caractères d'espacement, la ponctuation et les caractères de
+contrôle).
+.br
+La sortie résultante est un identifiant Pcmcia valide («\ Pcmcia scheme
+identifer\ ») (qui peut être utilisé comme argument de la commande
+.BR "cardctl scheme" ).
+Ce format est aussi idéal quand on utilise le résultat de iwgetid comme un
+sélecteur («\ selector\ ») dans les scripts
+.I Shell
+ou
+.IR Perl ,
+ou comme un nom de fichier.
+.TP
+.B --ap
+Affiche l'adresse MAC du
+.I Point d'Access
+ou de la
+.I Cellule
+sans fil.
+.TP
+.B --freq
+Affiche la
+.I fréquence
+ou le
+.I canal
+courant utilisé par l'interface.
+.TP
+.B --channel
+Affiche le canal
+.RI ( channel )
+courant utilisé par l'interface. Le canal est déterminé en utilisant la
+fréquence courante et la liste de fréquence fournie par l'interface.
+.TP
+.B --mode
+Affiche le
+.I mode
+courant de l'interface.
+.TP
+.B --protocol
+Affiche le
+.I nom de protocole
+de l'interface. Il permet d'identifer toutes les cartes qui sont compatibles
+entre elles et qui acceptent le même type de configuration.
+.br
+Cela peut aussi être utilisé pour
+.I vérifier la compatibilité de Wireless Extension
+sur l'interface, car c'est le seul attribut que tous les pilotes supportant
+Wireless Extension doivent avoir.
+.\"
+.\" TRADUCTION part
+.\"
+.SH TRADUCTION
+Maxime CHARPENNE, août 2004 (wireless_tools.27-pre25).
+.\"
+\" AVERTISSEMENT part
+.\"
+.SH AVERTISSEMENT SUR LA TRADUCTION
+Il est possible que cette traduction soit imparfaite ou périmée. En cas de
+doute, veuillez vous reporter au document original en langue anglaise fourni
+avec le programme.
+.\"
+.\" SEE ALSO part
+.\"
+.SH VOIR AUSSI
+.BR iwconfig (8),
+.BR ifconfig (8),
+.BR iwspy (8),
+.BR iwpriv (8).
diff --git a/fr/iwlist.8 b/fr/iwlist.8
new file mode 100644
index 0000000..26eb5c2
--- /dev/null
+++ b/fr/iwlist.8
@@ -0,0 +1,145 @@
+.\" Jean II - HPLB - 96
+.\" iwlist.8
+.\"
+.\" Traduction 2003/08/17 Maxime CHARPENNE (voir
+.\" http://www.delafond.org/traducmanfr/)
+.\" 1ère traduction        : version 26
+.\" Mise à jour 2004/01/29 : version 27-pre9 (beta)
+.\" Manuel identique pour la version 27-pre11 (alpha)
+.\" Mise à jour 2004/08/23 : version 27-pre25
+.\"
+.TH IWLIST 8 "23 juin 2004" "wireless-tools" "Manuel du Programmeur Linux"
+.\"
+.\" NAME part
+.\"
+.SH NOM
+iwlist \- Obtient plus d'informations wireless détaillées depuis une interface wireless
+.\"
+.\" SYNOPSIS part
+.\"
+.SH SYNOPSIS
+.BI "iwlist " interface " scanning"
+.br
+.BI "iwlist " interface " frequency"
+.br
+.BI "iwlist " interface " rate"
+.br
+.BI "iwlist " interface " key"
+.br
+.BI "iwlist " interface " power"
+.br
+.BI "iwlist " interface " txpower"
+.br
+.BI "iwlist " interface " retry"
+.br
+.BI "iwlist " interface " event"
+.br
+.BI "iwlist --help"
+.br
+.BI "iwlist --version"
+.\"
+.\" DESCRIPTION part
+.\"
+.SH DESCRIPTION
+.B Iwlist
+est utilisé pour afficher de l'information additionnelle d'une interface réseau
+wireless qui n'est pas affichée par
+.IR iwconfig (8)
+L'argument principal est utilisé pour sélectionner une catégorie d'information,
+.B iwlist
+affiche dans une forme détaillée toute information relative à cette catégorie,
+y compris les informations déjà montrées par
+.IR iwconfig (8).
+.\"
+.\" PARAMETER part
+.\"
+.SH PARAMÈTRES
+.TP
+.BR scan [ning]
+Donne la liste des Points d'Accès et des cellules Ad-Hoc à portée, et
+optionnellement plein d'autres informations à leur propos (ESSID, Quality,
+Frequency, Mode...). Le type d'information retourné dépend de ce que la carte
+supporte.
+.br
+Le «\ Triggering scanning\ » est une opération nécessitant les privilèges
+de
+.I root
+et les utilisateurs normaux peuvent juste lire les résultats («\ letf-over scan
+results\ »). Par défaut, les paramètres courants du pilote auront une grande
+incidence sur la manière dont le scan est réalisé (la boucle du scan). Aussi,
+cette commande est supposée prendre des arguments supplémentaires pour contrôler
+le comportement du scan, mais cela n'est actuellement pas implémenté.
+.TP
+.BR freq [uency]/ channel
+Donne la liste des fréquences disponibles du périphérique et le nombre de canaux
+définis. Veuillez noter que, habituellement, le pilote retourne le nombre total
+de canaux et seulement les fréquences disponibles dans la région considérée,
+donc il n'y a pas correspondance entre le nombre de fréquences affichées et le
+nombre de canaux.
+.TP
+.BR rate / bit [rate]
+Liste les débits supportés par le périphérique (en b/s).
+.TP
+.BR key / enc [ryption]
+Liste les tailles des clefs de cryptage supportées et affiche toutes
+les clefs de cryptage disponibles dans le périphérique.
+.TP
+.B power
+Liste les divers attributs et modes d'économie d'énergie («\ Power
+Management\ ») du périphérique.
+.TP
+.B txpower
+Liste les différentes puissances d'émission («\ Transmit Powers\ »)
+disponibles dans le périphérique.
+.TP
+.B retry
+Liste les limites des tentatives de transmissions («\ transmit retry limits\ »)
+et la durée de vie des tentatives («\ retry lifetime\ ») du périphériques
+(NDT\ : voir la section
+.B retry
+de iwconfig(8)).
+.TP
+.BR ap / accesspoint / peers
+Donne la liste des Points d'Accès à portée, et optionnellement la qualié de leur
+lien. Cette option est
+.B obsolète
+et est maintenant dépréciée en faveur du support scan (voir ci-dessus), et la
+plupart des pilotes ne le supporte pas.
+.br
+Quelques pilotes peuvent utiliser cette commande pour retourner une
+liste spécifique de Paires («\ Peers\ ») ou de Points d'Accès, telle que la
+liste des Paires associés/enregistrés avec la carte. Voir la documentation du
+pilote pour plus de détails.
+.TP
+.B event
+Liste les événements wireless supportés par le périphérique.
+.TP
+.B --version
+Affiche la version des outils, ainsi que la version courante et recommandée des
+Wireless Extensions pour l'outil et les diverses interfaces sans fil.
+.\"
+.\" TRADUCTION part
+.\"
+.SH TRADUCTION
+Maxime CHARPENNE, août 2004 (wireless_tools.27-pre25).
+.\"
+\" AVERTISSEMENT part
+.\"
+.SH AVERTISSEMENT SUR LA TRADUCTION
+Il est possible que cette traduction soit imparfaite ou périmée. En cas de
+doute, veuillez vous reporter au document original en langue anglaise fourni
+avec le programme.
+.\"
+.\" FILES part
+.\"
+.SH FICHIERS
+.I /proc/net/wireless
+.\"
+.\" SEE ALSO part
+.\"
+.SH VOIR AUSSI
+.BR iwconfig (8),
+.BR iwspy (8).
+.BR iwevent (8),
+.BR iwpriv (8),
+.BR wireless (7).
diff --git a/fr/iwpriv.8 b/fr/iwpriv.8
new file mode 100644
index 0000000..5df5220
--- /dev/null
+++ b/fr/iwpriv.8
@@ -0,0 +1,156 @@
+.\" Jean II - HPLB - 96
+.\" iwpriv.8
+.\"
+.\" Traduction 2003/08/17 Maxime CHARPENNE (voir
+.\" http://www.delafond.org/traducmanfr/)
+.\" 1ère traduction     : version 26
+.\" Manuel identique pour version 27-pre9 (beta)
+.\" Manuel identique pour version 27-pre11 (alpha)
+.\"
+.TH IWPRIV 8 "31 octobre 1996" "net-tools" "Manuel du programmeur Linux"
+.\"
+.\" NAME part
+.\"
+.SH NOM
+iwpriv \- configure les paramètres optionnels (privés) d'une interface réseau
+sans fil
+.\"
+.\" SYNOPSIS part
+.\"
+.SH SYNOPSIS
+.BI "iwpriv [" interface ]
+.br
+.BI "iwpriv " "interface private-command " "[" private-parameters ]
+.br
+.BI "iwpriv " "interface private-command [I] " "[" private-parameters ]
+.br
+.BI "iwpriv " interface " --all"
+.br
+.BI "iwpriv " interface " roam " {on,off}
+.br
+.BI "iwpriv " interface " port " {ad-hoc,managed,N}
+.\"
+.\" DESCRIPTION part
+.\"
+.SH DESCRIPTION
+.B Iwpriv
+est l'outil à utiliser avec
+.IR iwconfig (8).
+.B Iwpriv
+traite les paramètres et attributs spécifiques à chaque pilote (contrairement
+à
+.I iwconfig
+qui ne s'occupe que des génériques).
+.PP
+Sans argument,
+.B iwpriv
+liste les commandes privées disponibles sur chaque interface, ainsi que les
+paramètres qu'elles requièrent. En utilisant ces informations, l'utilisateur
+peut appliquer ces commandes particulières sur les interfaces spécifiées.
+.PP
+En théorie, la documentation de chaque pilote devrait indiquer comment utiliser
+ces commandes spécifiques et leurs effets.
+.\"
+.\" PARAMETER part
+.\"
+.SH PARAMÈTRES
+.TP
+.IR private-command " [" private-parameters ]
+Exécute la
+.I private-command
+(commande privée) spécifiée sur l'interface.
+.br
+La commande peut éventuellement prendre ou nécessiter des arguments, et peut
+afficher de l'information. En conséquent, les paramètres de la ligne de
+commande peuvent ou peuvent ne pas être nécessaires et doivent correspondre
+aux besoins de la commande. La liste des commandes que
+.B iwpriv
+affiche (quand il est appelé sans paramètre) doit vous donner des indications
+sur ces paramètres.
+.br
+Cependant, vous devriez vous reporter à la documentation du pilote du
+périphérique pour utiliser les commandes correctement, ainsi que connaître
+leurs effets.
+.TP
+.I "private-command [I]" "[" private-parameters ]
+Idem, sauf que
+.I I
+(un entier) est passé à la commande en tant que
+.I "Token Index"
+(indication d'index). Seules quelques commandes utiliseront ce «\ Token
+Index\ » (la plupart l'ignoreront), et la documentation du pilote devrait
+préciser quand il est nécessaire.
+.TP
+.BR -a / --all
+Exécute et affiche toutes les commandes privées qui ne prennent aucun argument
+(c.-à-d. en lecture seule).
+.TP
+.B roam
+Active ou désactive le «\ roaming\ », s'il est supporté. Appelle la commande
+privée
+.IR setroam .
+Trouvé dans le pilote
+.I wavelan_cs
+.TP
+.B port
+Lit ou configure le type de port. Appelle les commandes privées
+.IR gport_type ", " sport_type ", " get_port " ou " set_port
+trouvées dans les pilotes
+.IR wavelan2_cs " et " wvlan_cs .
+.\"
+.\" DISPLAY part
+.\"
+.SH AFFICHAGE
+Pour chaque matériel qui supporte les commandes privées,
+.I iwpriv
+affichera la liste des commandes privées disponibles.
+.PP
+Cela inclut le nom de la commande privée, le nombre d'arguments qui peuvent
+être entrés et leur type, ainsi que le nombre d'arguments qui peuvent être
+affichés et leur type.
+.PP
+Par exemple, vous pouvez avoir l'affichage suivant\ :
+.br
+.B "eth0      Available private ioctl :"
+.br
+.B "          setqualthr (89F0) : set   1 byte & get   0"
+.br
+.B "          gethisto (89F7) : set   0      & get  16 int"
+.PP
+Cela veut dire que vous pouvez fixer le seuil de qualité et afficher un
+histogramme jusqu'à 16 valeurs avec les commandes suivantes\ :
+.br
+.I "  iwpriv eth0 setqualthr 20"
+.br
+.I "  iwpriv eth0 gethisto"
+.\"
+.\" AUTHOR part
+.\"
+.SH AUTHOR
+Jean Tourrilhes \- jt@hpl.hp.com
+.\"
+.\" TRADUCTION part
+.\"
+.SH TRADUCTION
+Maxime CHARPENNE, août 2003.
+.\"
+\" AVERTISSEMENT part
+.\"
+.SH AVERTISSEMENT SUR LA TRADUCTION
+Il est possible que cette traduction soit imparfaite ou périmée. En cas de
+doute, veuillez vous reporter au document original en langue anglaise fourni
+avec le programme.
+.\"
+.\" FILES part
+.\"
+.SH FILES
+.I /proc/net/wireless
+.\"
+.\" SEE ALSO part
+.\"
+.SH SEE ALSO
+.BR iwconfig (8),
+.BR iwlist (8),
+.BR iwevent (8),
+.BR iwspy (8),
+.BR wireless (7).
diff --git a/fr/iwspy.8 b/fr/iwspy.8
new file mode 100644
index 0000000..3bd4e15
--- /dev/null
+++ b/fr/iwspy.8
@@ -0,0 +1,116 @@
+.\" Jean II - HPLB - 96
+.\" iwspy.8
+.\"
+.\" Traduction 2003/08/18 Maxime CHARPENNE (voir
+.\" http://www.delafond.org/traducmanfr/)
+.\" 1ère traduction        : version 26
+.\" Manuel identique pour la version 27-pre9 (beta)
+.\" Manuel identique pour la version 27-pre11 (alpha)
+.\"
+.TH IWSPY 8 "31 octobre 1996" "net-tools" "Manuel du Programmeur Linux"
+.\"
+.\" NAME part
+.\"
+.SH NOM
+iwspy \- Obtenir des statistiques wireless depuis des n½uds donnés
+.\"
+.\" SYNOPSIS part
+.\"
+.SH SYNOPSIS
+.BI "iwspy " interface
+.br
+.BI "iwspy " interface " [+] " DNSNAME " | " IPADDR " | " HWADDR " [...]"
+.br
+.BI "iwspy " interface " off"
+.br
+.BI "iwspy " interface " setthr " "low high"
+.br
+.BI "iwspy " interface " getthr"
+.\"
+.\" DESCRIPTION part
+.\"
+.SH DESCRIPTION
+.B Iwspy
+est utilisé pour fixer une liste d'adresses sur une interface réseau sans fil,
+et obtenir des informations sur la qualité du lien pour chacune d'elles. Ces
+informations sont les mêmes que celles disponibles dans
+.IR /proc/net/wireless "\ :"
+qualité du lien, force du signal et niveau du bruit.
+.PP
+Ces informations sont mises à jour à chaque fois qu'un nouveau paquet est reçu,
+donc chaque adresse de la liste ajoute quelques précisions en plus.
+.PP
+Remarquez que cette fonctionnalité ne marche que pour les n½uds faisant partie
+des cellules sans fil courantes.
+.\"
+.\" PARAMETER part
+.\"
+.SH PARAMÈTRES
+Vous pouvez fixer jusqu'à 8 adresses.
+.TP
+.BR DNSNAME " | " IPADDR
+Paramètre une adresse IP, ou dans certains cas un nom DNS (en utilisant le
+Â«\ resolver\ Â» de nom). Comme le matériel fonctionne avec des adresses
+matérielles,
+.B iwspy
+traduira les adresses IP grâce à
+.IR ARP .
+Dans certains cas, cette adresse peut ne pas être dans le cache ARP et
+.B iwspy
+échouera. Dans cette situation, exécuter
+.IR ping (8)
+vers ces noms/adresses et réessayer.
+.TP
+.B HWADDR
+Paramètre une adresse matérielle (MAC) (cette adresse n'est pas traduite et
+vérifer comme le sont les adresses IP). L'adresse doit contenir deux-points
+.RB ( : )
+pour être reconnue comme une adresse matérielle.
+.TP
+.B +
+Ajoute un nouveau jeu d'adresses à la fin de la liste courante au lieu de la
+remplacer. La liste d'adresses est unique pour chaque carte, donc chaque
+utilisateur devrait utiliser cette option pour éviter les conflits.
+.TP
+.B off
+Enlève la liste d'adresses courante et désactive la fonctionnalité de
+scrutation.
+.TP
+.B setthr
+Fixe les seuils de force de signal
+.IR low " (bas) et " high " (haut)"
+pour les événements iwspy (pour les pilotes qui le supportent).
+.br
+Chaque fois que la force du signal, pour une des adresses contrôlées avec
+iwspy, passe au-dessous du seuil bas ou au-dessus du seuil haut, un Wireless
+Event est généré.
+.br
+Ceci peut être utilisé pour surveiller la qualité du lien sans avoir à lancer
+iwspy périodiquement.
+.TP
+.B getthr
+Récupère les seuils
+.IR low " (bas) et " high " (haut)"
+de la force du signal pour l'événement iwspy.
+.\"
+\" AVERTISSEMENT part
+.\"
+.SH AVERTISSEMENT SUR LA TRADUCTION
+Il est possible que cette traduction soit imparfaite ou périmée. En cas de
+doute, veuillez vous reporter au document original en langue anglaise fourni
+avec le programme.
+\"
+.\" FILES part
+.\"
+.SH FICHIERS
+.I /proc/net/wireless
+.\"
+.\" SEE ALSO part
+.\"
+.SH VOIR AUSSI
+.BR iwconfig (8),
+.BR iwlist (8),
+.BR iwevent (8),
+.BR iwpriv (8),
+.BR wireless (7).
+
diff --git a/fr/wireless.7 b/fr/wireless.7
new file mode 100644
index 0000000..63aa8f3
--- /dev/null
+++ b/fr/wireless.7
@@ -0,0 +1,145 @@
+.\" Jean Tourrilhes - HPL - 2002 - 2004
+.\" wireless.7
+.\"
+.\" Traduction 2004/02/26 Maxime CHARPENNE (voir
+.\" http://www.delafond.org/traducmanfr/)
+.\" 1ère traduction        : version 27-pre11 (alpha)
+.\" Mise à jour 2004/08/24 : version 27-pre25
+.TH WIRELESS 7 "04 mars 2004" "wireless-tools" "Manuel du Programmeur Linux"
+.\"
+.\" NAME part
+.\"
+.SH NOM
+wireless \- Wireless Tools et Wireless Extensions
+.\"
+.\" SYNOPSIS part
+.\"
+.SH SYNOPSIS
+.B iwconfig
+.br
+.B iwpriv \-a
+.br
+.\"
+.\" DESCRIPTION part
+.\"
+.SH DESCRIPTION
+Les
+.B Wireless Extensions
+sont une API vous permettant de manipuler les interfaces réseaux Wireless LAN.
+Ils sont composés d'une gamme d'outils et de fichiers de configuration. Ils sont
+plus amplement détaillés dans le Linux Wireless LAN Howto.
+.br
+Les
+.B Wireless Tools
+sont utilisés pour changer la configuration des interfaces réseau LAN wireless
+à la volée, pour obtenir leur configuration courante, pour avoir des
+statistiques et pour les diagnostiquer. Ils sont décrits dans leur propre page
+man, voir ci-dessous pour les références.
+.br
+La
+.B configuration Wireless
+est propre à chaque distribution Linux. Cette page man contiendra à l'avenir
+la procédure de configuration pour quelques distributions les plus communes.
+(quand j'en ai les informations nécessaires). Pour le moment, consultez le
+fichier DISTRIBUTIONS.txt inclus avec le paquetage Wireless Tools.
+.\"
+.\" DEBIAN 3.0 part
+.\"
+.SH DEBIAN 3.0
+Dans la Debian 3.0 (et suivante) vous pouvez configurer les périphériques
+réseaux LAN wireless en utilisant l'outil de configuration réseau
+.BR ifupdown (8).
+.TP
+.B Fichier :
+.I /etc/network/interfaces
+.TP
+.B Format :
+.RI wireless\- "<fonction> <valeur>"
+.br
+wireless\-essid Maison
+.br
+wireless\-mode Ad\-Hoc
+.TP
+.B Voir aussi :
+.I /etc/network/if\-pre\-up.d/wireless\-tools
+.br
+.I /usr/share/doc/wireless\-tools/README.Debian
+.\"
+.\" SuSE 8.0 part
+.\"
+.SH SuSE 8.0
+La SuSE 8.0 (et suivante) a intégré la configuration wireless dans ses
+scripts réseaux.
+.TP
+.B Outils :
+.B Yast2
+.TP
+.B Fichiers :
+.I /etc/sysconfig/network/wireless
+.br
+.I /etc/sysconfig/network/ifcfg\-*
+.TP
+.B Format :
+.RI WIRELESS_ "<fonction>" = "<valeur>"
+.br
+WIRELESS_ESSID="Maison"
+.br
+WIRELESS_MODE=Ad\-Hoc
+.TP
+.B Voir aussi :
+man ifup
+.br
+info scpm
+.\"
+.\" PCMCIA part
+.\"
+.SH SCRIPTS ORIGINAUX PCMCIA
+Si vous utilisez les scripts originaux de configuration du paquetage Pcmcia,
+vous pouvez utiliser cette méthode.
+.TP
+.B Fichier :
+.I /etc/pcmcia/wireless.opts
+.TP
+.B Format :
+*,*,*,*)
+.br
+    ESSID="Maison"
+.br
+    MODE="Ad-Hoc"
+.br
+    ;;
+.TP
+.B Voir aussi :
+.I /etc/pcmcia/wireless
+.br
+Le fichier
+.I PCMCIA.txt
+qui fait partie du paquetage Wireless Tools.
+.\"
+.\" AUTHOR part
+.\"
+.SH AUTEUR
+Jean Tourrilhes \- jt@hpl.hp.com
+.br
+.I http://www.hpl.hp.com/personal/Jean_Tourrilhes/Linux/
+.\"
+.\" TRADUCTION part
+.\"
+.SH TRADUCTION
+Maxime CHARPENNE, août 2004 (wireless-tools.27-pre25).
+.\"
+.\" AVERTISSEMENT part
+.\"
+.SH AVERTISSEMENT SUR LA TRADUCTION
+Il est possible que cette traduction soit imparfaite ou périmée. En cas de
+doute, veuillez vous reporter au document original en langue anglaise fourni
+avec le programme.
+.\"
+.\" SEE ALSO part
+.\"
+.SH VOIR AUSSI
+.BR iwconfig (8),
+.BR iwlist (8),
+.BR iwspy (8),
+.BR iwpriv (8),
+.BR iwevent (8).
diff --git a/ifrename.8 b/ifrename.8
new file mode 100644
index 0000000..da10181
--- /dev/null
+++ b/ifrename.8
@@ -0,0 +1,183 @@
+.\" Jean II - HPL - 2004-2007
+.\" ifrename.8
+.\"
+.TH IFRENAME 8 "26 February 2007" "wireless-tools" "Linux Programmer's Manual"
+.\"
+.\" NAME part
+.\"
+.SH NAME
+ifrename \- rename network interfaces based on various static criteria
+.\"
+.\" SYNOPSIS part
+.\"
+.SH SYNOPSIS
+.B "ifrename [-c configfile] [-p] [-d] [-u] [-v] [-V] [-D]"
+.br
+.B "ifrename [-c configfile] [-i interface] [-n newname]"
+.\"
+.\" DESCRIPTION part
+.\"
+.SH DESCRIPTION
+.B Ifrename 
+is a tool allowing you to assign a consistent name to each of your
+network interface.
+.PP
+By default, interface names are dynamic, and each network interface is
+assigned the first available name
+.RI ( eth0 ", " eth1 "...)."
+The order network interfaces are created may vary. For built-in
+interfaces, the kernel boot time enumeration may vary. For removable
+interface, the user may plug them in any order.
+.PP
+.B Ifrename
+allow the user to decide what name a network interface will have.
+.B Ifrename 
+can use a variety of
+.I selectors
+to specify how interface names match the network interfaces on the
+system, the most common selector is the interface 
+.IR "MAC address" .
+.PP
+.B Ifrename
+must be run before interfaces are brought up, which is why it's mostly
+useful in various scripts (init, hotplug) but is seldom used directly
+by the user. By default,
+.B ifrename 
+renames all present system interfaces using mappings defined in
+.IR /etc/iftab .
+.\"
+.\" PARAMETER part
+.\"
+.SH PARAMETERS
+.TP
+.BI "-c " configfile
+Set the configuration file to be used (by default 
+.IR /etc/iftab ).
+The configuration file define the mapping between selectors and
+interface names, and is described in
+.IR iftab (5).
+.br
+If
+.I configfile
+is "-", the configuration is read from stdin.
+.TP
+.B -p
+Probe (load) kernel modules before renaming interfaces. By default
+.B ifrename 
+only check interfaces already loaded, and doesn't auto-load the
+required kernel modules. This option enables smooth integration with
+system not loading modules before calling
+.BR ifrename .
+.TP
+.B -d
+Enable various
+.B Debian
+specific hacks. Combined with
+.BR -p ,
+only modules for interfaces specified in
+.I /etc/network/interface
+are loaded.
+.TP
+.BI "-i " interface
+Only rename the specified
+.I interface 
+as opposed to all interfaces on the system. The new interface name is
+printed.
+.TP
+.BI "-n " newname
+When used with
+.IR -i ,
+specify the new name of the interface. The list of mappings from the
+configuration file is bypassed, the interface specified with
+.I -i
+is renamed directly to
+.IR newname .
+The new name may be a wildcard containing a single '*'.
+.br
+When used without 
+.IR -i ,
+rename interfaces by using only mappings that would rename them to
+.IR newname .
+The new name may not be a wildcard. This use of ifrename is
+discouraged, because inefficient
+.RI ( -n " without " -i ).
+All the interfaces of the system need to be processed at each
+invocation, therefore in most case it is not faster than just letting
+ifrename renaming all of them (without both 
+.IR -n " and " -i ).
+.TP
+.B -t
+Enable name takeover support. This allow interface name swapping
+between two or more interfaces.
+.br
+Takeover enable an interface to 'steal' the name of another
+interface. This works only with kernel 2.6.X and if the other
+interface is down. Consequently, this is not compatible with
+Hotplug. The other interface is assigned a random name, but may be
+renamed later with 'ifrename'.
+.br
+The number of takeovers is limited to avoid circular loops, and
+therefore some complex multi-way name swapping situations may not be
+fully processed.
+.br
+In any case, name swapping and the use of this feature is discouraged,
+and you are invited to choose unique and unambiguous names for your
+interfaces...
+.TP
+.B -u
+Enable
+.I udev
+output mode. This enables proper integration of
+.B ifrename
+in the
+.I udev
+framework,
+.BR udevd (8)
+will use
+.B ifrename
+to assign interface names present in
+.IR /etc/iftab .
+In this mode the output of ifrename can be parsed
+directly by
+.BR udevd (8)
+as an IMPORT action. This requires
+.I udev
+version 107 or later.
+.TP
+.B -D
+Dry-run mode. Ifrename won't change any interface, it will only print
+new interface name, if applicable, and return.
+.br
+In dry-run mode, interface name wildcards are not resolved. New
+interface name is printed, even if it is the same as the old name.
+.br
+Be also aware that some selectors can only be read by root, for
+example those based on
+.BR ethtool ),
+and will fail silently if run by a normal user. In other words,
+dry-run mode under a standard user may not give the expected result.
+.TP
+.B -V
+Verbose mode. Ifrename will display internal results of parsing its
+configuration file and querying the interfaces selectors. Combined
+with the
+.I dry-run
+option, this is a good way to debug complex configurations or trivial
+problems.
+.\"
+.\" AUTHOR part
+.\"
+.SH AUTHOR
+Jean Tourrilhes \- jt@hpl.hp.com
+.\"
+.\" FILES part
+.\"
+.SH FILES
+.I /etc/iftab
+.\"
+.\" SEE ALSO part
+.\"
+.SH SEE ALSO
+.BR ifconfig (8),
+.BR ip (8),
+.BR iftab (5).
diff --git a/ifrename.c b/ifrename.c
new file mode 100644
index 0000000..9a29d17
--- /dev/null
+++ b/ifrename.c
@@ -0,0 +1,2721 @@
+/*
+ *	Wireless Tools
+ *
+ *		Jean II - HPL 04 -> 07
+ *
+ * Main code for "ifrename". This is tool allows to rename network
+ * interfaces based on various criteria (not only wireless).
+ * You need to link this code against "iwlib.c" and "-lm".
+ *
+ * This file is released under the GPL license.
+ *     Copyright (c) 2007 Jean Tourrilhes <jt@hpl.hp.com>
+ */
+
+/* 
+ * The changelog for ifrename is in the file CHANGELOG.h ;-)
+ *
+ * This work is a nearly complete rewrite of 'nameif.c'.
+ * Original CopyRight of version of 'nameif' I used is :
+ * -------------------------------------------------------
+ * Name Interfaces based on MAC address.
+ * Writen 2000 by Andi Kleen.
+ * Subject to the Gnu Public License, version 2.  
+ * TODO: make it support token ring etc.
+ * $Id: nameif.c,v 1.3 2003/03/06 23:26:52 ecki Exp $
+ * -------------------------------------------------------
+ *
+ *	It started with a series of patches to nameif which never made
+ * into the regular version, and had some architecural 'issues' with
+ * those patches, which is the reason of this rewrite.
+ *	Difference with standard 'nameif' :
+ *	o 'nameif' has only a single selector, the interface MAC address.
+ *	o Modular selector architecture, easily add new selectors.
+ *	o Wide range of selector, including sysfs and sysfs symlinks...
+ *	o hotplug invocation support.
+ *	o module loading support.
+ *	o MAC address wildcard.
+ *	o Interface name wildcard ('eth*' or 'wlan*').
+ *	o Non-Ethernet MAC addresses (any size, not just 48 bits)
+ */
+
+/***************************** INCLUDES *****************************/
+
+/* This is needed to enable GNU extensions such as getline & FNM_CASEFOLD */
+#ifndef _GNU_SOURCE 
+#define _GNU_SOURCE
+#endif
+
+#include <getopt.h>		/* getopt_long() */
+#include <linux/sockios.h>	/* SIOCSIFNAME */
+#include <fnmatch.h>		/* fnmatch() */
+//#include <sys/syslog.h>
+
+#include "iwlib.h"		/* Wireless Tools library */
+
+// This would be cool, unfortunately...
+//#include <linux/ethtool.h>	/* Ethtool stuff -> struct ethtool_drvinfo */
+
+/************************ CONSTANTS & MACROS ************************/
+
+/* Our default configuration file */
+const char DEFAULT_CONF[] =		"/etc/iftab"; 
+
+/* Debian stuff */
+const char DEBIAN_CONFIG_FILE[] =	"/etc/network/interfaces";
+
+/* Backward compatibility */
+#ifndef ifr_newname
+#define ifr_newname ifr_ifru.ifru_slave
+#endif
+
+/* Types of selector we support. Must match selector_list */
+const int SELECT_MAC		= 0;	/* Select by MAC address */
+const int SELECT_ETHADDR	= 1;	/* Select by MAC address */
+const int SELECT_ARP		= 2;	/* Select by ARP type */
+const int SELECT_LINKTYPE	= 3;	/* Select by ARP type */
+const int SELECT_DRIVER		= 4;	/* Select by Driver name */
+const int SELECT_BUSINFO	= 5;	/* Select by Bus-Info */
+const int SELECT_FIRMWARE	= 6;	/* Select by Firmware revision */
+const int SELECT_BASEADDR	= 7;	/* Select by HW Base Address */
+const int SELECT_IRQ		= 8;	/* Select by HW Irq line */
+const int SELECT_INTERRUPT	= 9;	/* Select by HW Irq line */
+const int SELECT_IWPROTO	= 10;	/* Select by Wireless Protocol */
+const int SELECT_PCMCIASLOT	= 11;	/* Select by Pcmcia Slot */
+const int SELECT_SYSFS		= 12;	/* Select by sysfs file */
+const int SELECT_PREVNAME	= 13;	/* Select by previous interface name */
+#define SELECT_NUM		14
+
+#define HAS_MAC_EXACT	1
+#define HAS_MAC_FILTER	2
+#define MAX_MAC_LEN	16	/* Maximum lenght of MAC address */
+
+const struct ether_addr	zero_mac = {{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}};
+
+const struct option long_opt[] =
+{ 
+  {"config-file", 1, NULL, 'c' },
+  {"debian", 0, NULL, 'd' },
+  {"dry-run", 0, NULL, 'D' },
+  {"help", 0, NULL, '?' },
+  {"interface", 1, NULL, 'i' },
+  {"newname", 1, NULL, 'n' },
+  {"takeover", 0, NULL, 't' },
+  {"udev", 0, NULL, 'u' },
+  {"version", 0, NULL, 'v' },
+  {"verbose", 0, NULL, 'V' },
+  {NULL, 0, NULL, '\0' },
+};
+
+/* Pcmcia stab files */
+#define PCMCIA_STAB1	"/var/lib/pcmcia/stab"
+#define PCMCIA_STAB2	"/var/run/stab"
+
+/* Max number of sysfs file types we support */
+#define SYSFS_MAX_FILE	8
+
+/* Userspace headers lag, fix that... */
+#ifndef ARPHRD_IEEE1394
+#define ARPHRD_IEEE1394 24
+#endif
+#ifndef ARPHRD_EUI64
+#define ARPHRD_EUI64 27
+#endif
+#ifndef ARPHRD_IRDA
+#define ARPHRD_IRDA 783
+#endif
+
+/* Length of various non-standard MAC addresses */
+const int	weird_mac_len[][2] =
+{
+  { ARPHRD_IEEE1394, 8 },
+  { ARPHRD_EUI64, 8 },
+  { ARPHRD_IRDA, 4 },
+};
+const int weird_mac_len_num = sizeof(weird_mac_len) / sizeof(weird_mac_len[0]);
+
+/****************************** TYPES ******************************/
+
+/* Cut'n'paste from ethtool.h */
+#define ETHTOOL_BUSINFO_LEN	32
+/* these strings are set to whatever the driver author decides... */
+struct ethtool_drvinfo {
+	__u32	cmd;
+	char	driver[32];	/* driver short name, "tulip", "eepro100" */
+	char	version[32];	/* driver version string */
+	char	fw_version[32];	/* firmware version string, if applicable */
+	char	bus_info[ETHTOOL_BUSINFO_LEN];	/* Bus info for this IF. */
+				/* For PCI devices, use pci_dev->slot_name. */
+	char	reserved1[32];
+	char	reserved2[16];
+	__u32	n_stats;	/* number of u64's from ETHTOOL_GSTATS */
+	__u32	testinfo_len;
+	__u32	eedump_len;	/* Size of data from ETHTOOL_GEEPROM (bytes) */
+	__u32	regdump_len;	/* Size of data from ETHTOOL_GREGS (bytes) */
+};
+#define ETHTOOL_GDRVINFO	0x00000003 /* Get driver info. */
+
+/* Description of an interface mapping */
+typedef struct if_mapping
+{ 
+  /* Linked list */
+  struct if_mapping *	next;
+
+  /* Name of this interface */
+  char			ifname[IFNAMSIZ+1];
+  char *		sysfs_devpath;
+  int			sysfs_devplen;
+
+  /* Selectors for this interface */
+  int			active[SELECT_NUM];	/* Selectors active */
+
+  /* Selector data */
+  unsigned char		mac[MAX_MAC_LEN];	/* Exact MAC address, hex */
+  int			mac_len;		/* Length (usually 6) */
+  char			mac_filter[16*3 + 1];	/* WildCard, ascii */
+  unsigned short	hw_type;		/* Link/ARP type */
+  char			driver[32];		/* driver short name */
+  char		bus_info[ETHTOOL_BUSINFO_LEN];	/* Bus info for this IF. */
+  char			fw_version[32];		/* Firmware revision */
+  unsigned short	base_addr;		/* HW Base I/O address */ 
+  unsigned char		irq;			/* HW irq line */
+  char			iwproto[IFNAMSIZ + 1];	/* Wireless/protocol name */
+  int			pcmcia_slot;		/* Pcmcia slot */
+  char *		sysfs[SYSFS_MAX_FILE];	/* sysfs selectors */
+  char			prevname[IFNAMSIZ+1];	/* previous interface name */
+} if_mapping;
+
+/* Extra parsing information when adding a mapping */
+typedef struct add_extra
+{ 
+  char *		modif_pos;		/* Descriptor modifier */
+  size_t		modif_len;
+} parsing_extra;
+
+/* Prototype for adding a selector to a mapping. Return -1 if invalid value. */
+typedef int (*mapping_add)(struct if_mapping *	ifnode,
+			   int *		active,
+			   char *		pos,
+			   size_t		len,
+			   struct add_extra *	extra,
+			   int			linenum);
+
+/* Prototype for comparing the selector of two mapping. Return 0 if matches. */
+typedef int (*mapping_cmp)(struct if_mapping *	ifnode,
+			   struct if_mapping *	target);
+/* Prototype for extracting selector value from live interface */
+typedef int (*mapping_get)(int			skfd,
+			   const char *		ifname,
+			   struct if_mapping *	target,
+			   int			flag);
+
+/* How to handle a selector */
+typedef struct mapping_selector
+{
+  char *	name;
+  mapping_add	add_fn;
+  mapping_cmp	cmp_fn;
+  mapping_get	get_fn;
+} mapping_selector;
+
+/* sysfs global data */
+typedef struct sysfs_metadata
+{
+  char *		root;			/* Root of the sysfs */
+  int			rlen;			/* Size of it */
+  int			filenum;		/* Number of files */
+  char *		filename[SYSFS_MAX_FILE];	/* Name of files */
+} sysfs_metadata;
+
+/**************************** PROTOTYPES ****************************/
+
+static int
+	mapping_addmac(struct if_mapping *	ifnode,
+		       int *			active,
+		       char *			pos,
+		       size_t			len,
+		       struct add_extra *	extra,
+		       int			linenum);
+static int
+	mapping_cmpmac(struct if_mapping *	ifnode,
+		       struct if_mapping *	target);
+static int
+	mapping_getmac(int			skfd,
+		       const char *		ifname,
+		       struct if_mapping *	target,
+		       int			flag);
+static int
+	mapping_addarp(struct if_mapping *	ifnode,
+		       int *			active,
+		       char *			pos,
+		       size_t			len,
+		       struct add_extra *	extra,
+		       int			linenum);
+static int
+	mapping_cmparp(struct if_mapping *	ifnode,
+		       struct if_mapping *	target);
+static int
+	mapping_getarp(int			skfd,
+		       const char *		ifname,
+		       struct if_mapping *	target,
+		       int			flag);
+static int
+	mapping_adddriver(struct if_mapping *	ifnode,
+			  int *			active,
+			  char *		pos,
+			  size_t		len,
+			  struct add_extra *	extra,
+			  int			linenum);
+static int
+	mapping_cmpdriver(struct if_mapping *	ifnode,
+			  struct if_mapping *	target);
+static int
+	mapping_addbusinfo(struct if_mapping *	ifnode,
+			   int *		active,
+			   char *		pos,
+			   size_t		len,
+			   struct add_extra *	extra,
+			   int			linenum);
+static int
+	mapping_cmpbusinfo(struct if_mapping *	ifnode,
+			   struct if_mapping *	target);
+static int
+	mapping_addfirmware(struct if_mapping *	ifnode,
+			    int *		active,
+			    char *		pos,
+			    size_t		len,
+			    struct add_extra *	extra,
+			    int			linenum);
+static int
+	mapping_cmpfirmware(struct if_mapping *	ifnode,
+			    struct if_mapping *	target);
+static int
+	mapping_getdriverbusinfo(int			skfd,
+				 const char *		ifname,
+				 struct if_mapping *	target,
+				 int			flag);
+static int
+	mapping_addbaseaddr(struct if_mapping *	ifnode,
+			    int *		active,
+			    char *		pos,
+			    size_t		len,
+			    struct add_extra *	extra,
+			    int			linenum);
+static int
+	mapping_cmpbaseaddr(struct if_mapping *	ifnode,
+			    struct if_mapping *	target);
+static int
+	mapping_addirq(struct if_mapping *	ifnode,
+		       int *			active,
+		       char *			pos,
+		       size_t			len,
+		       struct add_extra *	extra,
+		       int			linenum);
+static int
+	mapping_cmpirq(struct if_mapping *	ifnode,
+		       struct if_mapping *	target);
+static int
+	mapping_getbaseaddrirq(int			skfd,
+			       const char *		ifname,
+			       struct if_mapping *	target,
+			       int			flag);
+static int
+	mapping_addiwproto(struct if_mapping *	ifnode,
+			   int *		active,
+			   char *		pos,
+			   size_t		len,
+			   struct add_extra *	extra,
+			   int			linenum);
+static int
+	mapping_cmpiwproto(struct if_mapping *	ifnode,
+			   struct if_mapping *	target);
+static int
+	mapping_getiwproto(int			skfd,
+			   const char *		ifname,
+			   struct if_mapping *	target,
+			   int			flag);
+static int
+	mapping_addpcmciaslot(struct if_mapping *	ifnode,
+			      int *			active,
+			      char *			pos,
+			      size_t			len,
+			      struct add_extra *	extra,
+			      int			linenum);
+static int
+	mapping_cmppcmciaslot(struct if_mapping *	ifnode,
+			   struct if_mapping *		target);
+static int
+	mapping_getpcmciaslot(int			skfd,
+			      const char *		ifname,
+			      struct if_mapping *	target,
+			      int			flag);
+static int
+	mapping_addsysfs(struct if_mapping *	ifnode,
+			 int *			active,
+			 char *			pos,
+			 size_t			len,
+			 struct add_extra *	extra,
+			 int			linenum);
+static int
+	mapping_cmpsysfs(struct if_mapping *	ifnode,
+			 struct if_mapping *	target);
+static int
+	mapping_getsysfs(int			skfd,
+			 const char *		ifname,
+			 struct if_mapping *	target,
+			 int			flag);
+static int
+	mapping_addprevname(struct if_mapping *	ifnode,
+			   int *		active,
+			   char *		pos,
+			   size_t		len,
+			   struct add_extra *	extra,
+			   int			linenum);
+static int
+	mapping_cmpprevname(struct if_mapping *	ifnode,
+			   struct if_mapping *	target);
+static int
+	mapping_getprevname(int			skfd,
+			   const char *		ifname,
+			   struct if_mapping *	target,
+			   int			flag);
+
+/**************************** VARIABLES ****************************/
+
+/* List of mapping read for config file */
+struct if_mapping *	mapping_list = NULL;
+
+/* List of selectors we can handle */
+const struct mapping_selector	selector_list[] =
+{
+  /* MAC address and ARP/Link type from ifconfig */
+  { "mac", &mapping_addmac, &mapping_cmpmac, &mapping_getmac },
+  { "ethaddr", &mapping_addmac, &mapping_cmpmac, &mapping_getmac },
+  { "arp", &mapping_addarp, &mapping_cmparp, &mapping_getarp },
+  { "linktype", &mapping_addarp, &mapping_cmparp, &mapping_getarp },
+  /* Driver name, Bus-Info and firmware rev from ethtool -i */
+  { "driver", &mapping_adddriver, &mapping_cmpdriver,
+    &mapping_getdriverbusinfo },
+  { "businfo", &mapping_addbusinfo, &mapping_cmpbusinfo,
+    &mapping_getdriverbusinfo },
+  { "firmware", &mapping_addfirmware, &mapping_cmpfirmware,
+    &mapping_getdriverbusinfo },
+  /* Base Address and IRQ from ifconfig */
+  { "baseaddress", &mapping_addbaseaddr, &mapping_cmpbaseaddr,
+    &mapping_getbaseaddrirq },
+  { "irq", &mapping_addirq, &mapping_cmpirq, &mapping_getbaseaddrirq },
+  { "interrupt", &mapping_addirq, &mapping_cmpirq, &mapping_getbaseaddrirq },
+  /* Wireless Protocol from iwconfig */
+  { "iwproto", &mapping_addiwproto, &mapping_cmpiwproto, &mapping_getiwproto },
+  /* Pcmcia slot from cardmgr */
+  { "pcmciaslot", &mapping_addpcmciaslot, &mapping_cmppcmciaslot, &mapping_getpcmciaslot },
+  /* sysfs file (udev emulation) */
+  { "sysfs", &mapping_addsysfs, &mapping_cmpsysfs, &mapping_getsysfs },
+  /* previous interface name */
+  { "prevname", &mapping_addprevname, &mapping_cmpprevname, &mapping_getprevname },
+  /* The Terminator */
+  { NULL, NULL, NULL, NULL },
+};
+const int selector_num = sizeof(selector_list)/sizeof(selector_list[0]);
+
+/* List of active selectors */
+int	selector_active[SELECT_NUM];	/* Selectors active */
+
+/*
+ * All the following flags are controlled by the command line switches...
+ * It's a bit hackish to have them all as global, so maybe we should pass
+ * them in a big struct as function arguments... More complex and
+ * probably not worth it ?
+ */
+
+/* Invocation type */
+int	print_newname = 0;
+char *	new_name = NULL;
+
+/* Takeover support */
+int	force_takeover = 0;	/* Takeover name from other interface */
+int	num_takeover = 0;	/* Number of takeover done */
+
+/* Dry-run support */
+int	dry_run = 0;		/* Just print new name, don't rename */
+
+/* Verbose support (i.e. debugging) */
+int	verbose = 0;
+
+/* udev output support (print new DEVPATH) */
+int	udev_output = 0;
+
+/* sysfs global data */
+struct sysfs_metadata	sysfs_global =
+{
+  NULL, 0,
+  0, { NULL, NULL, NULL, NULL, NULL },
+};
+
+/******************** INTERFACE NAME MANAGEMENT ********************/
+/*
+ * Bunch of low level function for managing interface names.
+ */
+
+/*------------------------------------------------------------------*/
+/*
+ * Compare two interface names, with wildcards.
+ * We can't use fnmatch() because we don't want expansion of '[...]'
+ * expressions, '\' sequences and matching of '.'.
+ * We only want to match a single '*' (converted to a %d at that point)
+ * to a numerical value (no ascii).
+ * Return 0 is matches.
+ */
+static int
+if_match_ifname(const char *	pattern,
+		const char *	value)
+{
+  const char *	p;
+  const char *	v;
+  int		n;
+  int		ret;
+
+  /* Check for a wildcard */
+  p = strchr(pattern, '*');
+
+  /* No wildcard, simple comparison */
+  if(p == NULL)
+    return(strcmp(pattern, value));
+
+  /* Check is prefixes match */
+  n = (p - pattern);
+  ret = strncmp(pattern, value, n);
+  if(ret)
+    return(ret);
+
+  /* Check that value has some digits at this point */
+  v = value + n;
+  if(!isdigit(*v))
+    return(-1);
+
+  /* Skip digits to go to value suffix */
+  do
+    v++;
+  while(isdigit(*v));
+
+  /* Pattern suffix */
+  p += 1;
+
+  /* Compare suffixes */
+  return(strcmp(p, v));
+}
+
+/*------------------------------------------------------------------*/
+/*
+ * Steal interface name from another interface. This enable interface
+ * name swapping.
+ * This will work :
+ *	1) with kernel 2.6.X
+ *	2) if other interface is down
+ * Because of (2), it won't work with hotplug, but we don't need it
+ * with hotplug, only with static ifaces...
+ */
+static int
+if_takeover_name(int			skfd,
+		 const char *		victimname)
+{
+  char		autoname[IFNAMSIZ+1];
+  int		len;
+  struct ifreq	ifr;
+  int		ret;
+
+  /* Compute name for victim interface */
+  len = strlen(victimname);
+  memcpy(autoname, victimname, len + 1);
+  if(len > (IFNAMSIZ - 2))
+    len = IFNAMSIZ - 2;		/* Make sure we have at least two char */
+  len--;			/* Convert to index */
+  while(isdigit(autoname[len]))
+    len--;			/* Scrap all trailing digits */
+  strcpy(autoname + len + 1, "%d");
+
+  if(verbose)
+    fprintf(stderr, "Takeover : moving interface `%s' to `%s'.\n",
+	    victimname, autoname);
+
+  /* Prepare request */
+  bzero(&ifr, sizeof(struct ifreq));
+  strncpy(ifr.ifr_name, victimname, IFNAMSIZ); 
+  strncpy(ifr.ifr_newname, autoname, IFNAMSIZ); 
+
+  /* Rename victim interface */
+  ret = ioctl(skfd, SIOCSIFNAME, &ifr);
+
+  if(!ret)
+    num_takeover++;
+
+  return(ret);
+}
+
+/*------------------------------------------------------------------*/
+/*
+ * Ask the kernel to change the name of an interface.
+ * That's what we want to do. All the rest is to make sure we call this
+ * appropriately.
+ */
+static int
+if_set_name(int			skfd,
+	    const char *	oldname,
+	    const char *	newname,
+	    char *		retname)
+{
+  struct ifreq	ifr;
+  char *	star;
+  int		ret;
+
+  /* The kernel doesn't check is the interface already has the correct
+   * name and may return an error, so check ourselves.
+   * In the case of wildcard, the result can be weird : if oldname='eth0'
+   * and newname='eth*', retname would be 'eth1'.
+   * So, if the oldname value matches the newname pattern, just return
+   * success. */
+  if(!if_match_ifname(newname, oldname))
+    {
+      if(verbose)
+	fprintf(stderr, "Setting : Interface `%s' already matches `%s'.\n",
+		oldname, newname);
+
+      strcpy(retname, oldname);
+      return(0);
+    }
+
+  /* Prepare request */
+  bzero(&ifr, sizeof(struct ifreq));
+  strncpy(ifr.ifr_name, oldname, IFNAMSIZ); 
+  strncpy(ifr.ifr_newname, newname, IFNAMSIZ); 
+
+  /* Check for wildcard interface name, such as 'eth*' or 'wlan*'...
+   * This require specific kernel support (2.6.2-rc1 and later).
+   * We externally use '*', but the kernel doesn't know about that,
+   * so convert it to something it knows about... */
+  star = strchr(newname, '*');
+  if(star != NULL)
+    {
+      int	slen = star - newname;
+      /* Replace '*' with '%d' in the new buffer */
+      star = ifr.ifr_newname + slen;
+      /* Size was checked in process_rename() and mapping_create() */
+      memmove(star + 2, star + 1, IFNAMSIZ - slen - 2);
+      star[0] = '%';
+      star[1] = 'd';
+    }
+
+  /* Do it */
+  ret = ioctl(skfd, SIOCSIFNAME, &ifr);
+
+  /* Takeover support : grab interface name from another interface */
+  if(ret && (errno == EEXIST) && force_takeover)
+    {
+      /* Push things around */
+      ret = if_takeover_name(skfd, newname);
+      if(!ret)
+	/* Second try */
+	ret = ioctl(skfd, SIOCSIFNAME, &ifr);
+    }
+
+  if(!ret)
+    {
+      /* Get the real new name (in case newname is a wildcard) */
+      strcpy(retname, ifr.ifr_newname);
+
+      if(verbose)
+	fprintf(stderr, "Setting : Interface `%s' renamed to `%s'.\n",
+		oldname, retname);
+    }
+
+  return(ret);
+}
+
+/************************ SELECTOR HANDLING ************************/
+/*
+ * Handle the various selector we support
+ */
+
+/*------------------------------------------------------------------*/
+/*
+ * Add a MAC address selector to a mapping
+ */
+static int
+mapping_addmac(struct if_mapping *	ifnode,
+	       int *			active,
+	       char *			string,
+	       size_t			len,
+	       struct add_extra *	extra,
+	       int			linenum)
+{
+  size_t	n;
+
+  /* Avoid "Unused parameter" warning */
+  extra = extra;
+
+  /* Verify validity of string */
+  if(len >= sizeof(ifnode->mac_filter))
+    { 
+      fprintf(stderr, "Error : MAC address too long at line %d\n", linenum);  
+      return(-1);
+    }
+  n = strspn(string, "0123456789ABCDEFabcdef:*"); 
+  if(n < len)
+    {
+      fprintf(stderr, "Error: Invalid MAC address `%s' at line %d\n",
+	      string, linenum);
+      return(-1);
+    }
+
+  /* Copy as filter in all cases */
+  memcpy(ifnode->mac_filter, string, len + 1); 
+
+  /* Check the type of MAC address */
+  if (strchr(ifnode->mac_filter, '*') != NULL)
+    {
+      /* This is a wilcard. Usual format : "01:23:45:*"
+       * Unfortunately, we can't do proper parsing. */
+      ifnode->active[SELECT_MAC] = HAS_MAC_FILTER;
+      active[SELECT_MAC] = HAS_MAC_FILTER;
+    }
+  else
+    {
+      /* Not a wildcard : "01:23:45:67:89:AB" */
+      ifnode->mac_len = iw_mac_aton(ifnode->mac_filter,
+				    ifnode->mac, MAX_MAC_LEN);
+      if(ifnode->mac_len == 0)
+	{
+	  fprintf(stderr, "Error: Invalid MAC address `%s' at line %d\n",
+		  ifnode->mac_filter, linenum);
+	  return(-1);
+	}
+
+      /* Check that it's not NULL */
+      if((ifnode->mac_len == 6) && (!memcmp(&ifnode->mac, &zero_mac, 6)))
+	{
+	  fprintf(stderr,
+		  "Warning: MAC address is null at line %d, this is dangerous...\n",
+		  linenum);
+	}
+
+      ifnode->active[SELECT_MAC] = HAS_MAC_EXACT;
+      if(active[SELECT_MAC] == 0)
+	active[SELECT_MAC] = HAS_MAC_EXACT;
+    }
+
+  if(verbose)
+    fprintf(stderr,
+	    "Parsing : Added %s MAC address `%s' from line %d.\n",
+	    ifnode->active[SELECT_MAC] == HAS_MAC_FILTER ? "filter" : "exact",
+	    ifnode->mac_filter, linenum);
+
+  return(0);
+}
+
+/*------------------------------------------------------------------*/
+/*
+ * Compare the mac address of two mappings
+ */
+static int
+mapping_cmpmac(struct if_mapping *	ifnode,
+	       struct if_mapping *	target)
+{
+  /* Check for wildcard matching */
+  if(ifnode->active[SELECT_MAC] == HAS_MAC_FILTER)
+    /* Do wildcard matching, case insensitive */
+    return(fnmatch(ifnode->mac_filter, target->mac_filter, FNM_CASEFOLD));
+  else
+    /* Exact matching, in hex */
+    return((ifnode->mac_len != target->mac_len) ||
+	   memcmp(ifnode->mac, target->mac, ifnode->mac_len));
+}
+
+/*------------------------------------------------------------------*/
+/*
+ * Extract the MAC address and Link Type of an interface
+ */
+static int
+mapping_getmac(int			skfd,
+	       const char *		ifname,
+	       struct if_mapping *	target,
+	       int			flag)
+{
+  struct ifreq	ifr;
+  int		ret;
+  int		i;
+
+  /* Get MAC address */
+  bzero(&ifr, sizeof(struct ifreq));
+  strncpy(ifr.ifr_name, ifname, IFNAMSIZ);
+  ret = ioctl(skfd, SIOCGIFHWADDR, &ifr);
+  if(ret < 0)
+    {
+      fprintf(stderr, "Error: Can't read MAC address on interface `%s' : %s\n",
+	      ifname, strerror(errno));
+      return(-1);
+    }
+
+  /* Extract ARP type */
+  target->hw_type = ifr.ifr_hwaddr.sa_family;
+  /* Calculate address length */
+  target->mac_len = 6;
+  for(i = 0; i < weird_mac_len_num; i++)
+    if(weird_mac_len[i][0] == ifr.ifr_hwaddr.sa_family)
+      {
+	target->mac_len = weird_mac_len[i][1];
+	break;
+      }
+  /* Extract MAC address bytes */
+  memcpy(target->mac, ifr.ifr_hwaddr.sa_data, target->mac_len);
+
+  /* Check the type of comparison */
+  if((flag == HAS_MAC_FILTER) || verbose)
+    {
+      /* Convert to ASCII */
+      iw_mac_ntop(target->mac, target->mac_len,
+		  target->mac_filter, sizeof(target->mac_filter));
+    }
+
+  target->active[SELECT_MAC] = flag;
+  target->active[SELECT_ARP] = 1;
+
+  if(verbose)
+    fprintf(stderr,
+	    "Querying %s : Got MAC address `%s' and ARP/Link Type `%d'.\n",
+	    ifname, target->mac_filter, target->hw_type);
+
+  return(0);
+}
+
+/*------------------------------------------------------------------*/
+/*
+ * Add a ARP/Link type selector to a mapping
+ */
+static int
+mapping_addarp(struct if_mapping *	ifnode,
+	       int *			active,
+	       char *			string,
+	       size_t			len,
+	       struct add_extra *	extra,
+	       int			linenum)
+{
+  size_t	n;
+  unsigned int	type;
+
+  /* Avoid "Unused parameter" warning */
+  extra = extra;
+
+  /* Verify validity of string, convert to int */
+  n = strspn(string, "0123456789"); 
+  if((n < len) || (sscanf(string, "%d", &type) != 1))
+    {
+      fprintf(stderr, "Error: Invalid ARP/Link Type `%s' at line %d\n",
+	      string, linenum);
+      return(-1);
+    }
+
+  ifnode->hw_type = (unsigned short) type;
+  ifnode->active[SELECT_ARP] = 1;
+  active[SELECT_ARP] = 1;
+
+  if(verbose)
+    fprintf(stderr, "Parsing : Added ARP/Link Type `%d' from line %d.\n",
+	    ifnode->hw_type, linenum);
+
+  return(0);
+}
+
+/*------------------------------------------------------------------*/
+/*
+ * Compare the ARP/Link type of two mappings
+ */
+static int
+mapping_cmparp(struct if_mapping *	ifnode,
+	       struct if_mapping *	target)
+{
+  return(!(ifnode->hw_type == target->hw_type));
+}
+
+/*------------------------------------------------------------------*/
+/*
+ * Extract the ARP/Link type of an interface
+ */
+static int
+mapping_getarp(int			skfd,
+	       const char *		ifname,
+	       struct if_mapping *	target,
+	       int			flag)
+{
+  /* We may have already extracted the MAC address */
+  if(target->active[SELECT_MAC])
+    return(0);
+
+  /* Otherwise just do it */
+  return(mapping_getmac(skfd, ifname, target, flag));
+}
+
+/*------------------------------------------------------------------*/
+/*
+ * Add a Driver name selector to a mapping
+ */
+static int
+mapping_adddriver(struct if_mapping *	ifnode,
+		  int *			active,
+		  char *		string,
+		  size_t		len,
+		  struct add_extra *	extra,
+		  int			linenum)
+{
+  /* Avoid "Unused parameter" warning */
+  extra = extra;
+
+  /* Plain string, minimal verification */
+  if(len >= sizeof(ifnode->driver))
+    { 
+      fprintf(stderr, "Error: Driver name too long at line %d\n", linenum);  
+      return(-1);
+    }
+
+  /* Copy */
+  memcpy(ifnode->driver, string, len + 1); 
+
+  /* Activate */
+  ifnode->active[SELECT_DRIVER] = 1;
+  active[SELECT_DRIVER] = 1;
+
+  if(verbose)
+    fprintf(stderr,
+	    "Parsing : Added Driver name `%s' from line %d.\n",
+	    ifnode->driver, linenum);
+
+  return(0);
+}
+
+/*------------------------------------------------------------------*/
+/*
+ * Compare the Driver name of two mappings
+ */
+static int
+mapping_cmpdriver(struct if_mapping *	ifnode,
+		  struct if_mapping *	target)
+{
+  /* Do wildcard matching, case insensitive */
+  return(fnmatch(ifnode->driver, target->driver, FNM_CASEFOLD));
+}
+
+/*------------------------------------------------------------------*/
+/*
+ * Add a Bus-Info selector to a mapping
+ */
+static int
+mapping_addbusinfo(struct if_mapping *	ifnode,
+		   int *		active,
+		   char *		string,
+		   size_t		len,
+		   struct add_extra *	extra,
+		   int			linenum)
+{
+#if 0
+  size_t	n;
+#endif
+
+  /* Avoid "Unused parameter" warning */
+  extra = extra;
+
+  /* Verify validity of string */
+  if(len >= sizeof(ifnode->bus_info))
+    { 
+      fprintf(stderr, "Bus Info too long at line %d\n", linenum);  
+      return(-1);
+    }
+#if 0
+  /* Hum... This doesn's seem true for non-PCI bus-info */
+  n = strspn(string, "0123456789ABCDEFabcdef:.*"); 
+  if(n < len)
+    {
+      fprintf(stderr, "Error: Invalid Bus Info `%s' at line %d\n",
+	      string, linenum);
+      return(-1);
+    }
+#endif
+
+  /* Copy */
+  memcpy(ifnode->bus_info, string, len + 1); 
+
+  /* Activate */
+  ifnode->active[SELECT_BUSINFO] = 1;
+  active[SELECT_BUSINFO] = 1;
+
+  if(verbose)
+    fprintf(stderr,
+	    "Parsing : Added Bus Info `%s' from line %d.\n",
+	    ifnode->bus_info, linenum);
+
+  return(0);
+}
+
+/*------------------------------------------------------------------*/
+/*
+ * Compare the Bus-Info of two mappings
+ */
+static int
+mapping_cmpbusinfo(struct if_mapping *	ifnode,
+		   struct if_mapping *	target)
+{
+  /* Do wildcard matching, case insensitive */
+  return(fnmatch(ifnode->bus_info, target->bus_info, FNM_CASEFOLD));
+}
+
+/*------------------------------------------------------------------*/
+/*
+ * Add a Firmare revision selector to a mapping
+ */
+static int
+mapping_addfirmware(struct if_mapping *	ifnode,
+		    int *		active,
+		    char *		string,
+		    size_t		len,
+		    struct add_extra *	extra,
+		    int			linenum)
+{
+  /* Avoid "Unused parameter" warning */
+  extra = extra;
+
+  /* Verify validity of string */
+  if(len >= sizeof(ifnode->fw_version))
+    { 
+      fprintf(stderr, "Firmware revision too long at line %d\n", linenum);  
+      return(-1);
+    }
+
+  /* Copy */
+  memcpy(ifnode->fw_version, string, len + 1); 
+
+  /* Activate */
+  ifnode->active[SELECT_FIRMWARE] = 1;
+  active[SELECT_FIRMWARE] = 1;
+
+  if(verbose)
+    fprintf(stderr,
+	    "Parsing : Added Firmware Revision `%s' from line %d.\n",
+	    ifnode->fw_version, linenum);
+
+  return(0);
+}
+
+/*------------------------------------------------------------------*/
+/*
+ * Compare the Bus-Info of two mappings
+ */
+static int
+mapping_cmpfirmware(struct if_mapping *	ifnode,
+		    struct if_mapping *	target)
+{
+  /* Do wildcard matching, case insensitive */
+  return(fnmatch(ifnode->fw_version, target->fw_version, FNM_CASEFOLD));
+}
+
+/*------------------------------------------------------------------*/
+/*
+ * Extract the Driver name and Bus-Info from a live interface
+ */
+static int
+mapping_getdriverbusinfo(int			skfd,
+			 const char *		ifname,
+			 struct if_mapping *	target,
+			 int			flag)
+{
+  struct ifreq	ifr;
+  struct ethtool_drvinfo drvinfo;
+  int	ret;
+
+  /* Avoid "Unused parameter" warning */
+  flag = flag;
+
+  /* We may come here twice or more, so do the job only once */
+  if(target->active[SELECT_DRIVER] || target->active[SELECT_BUSINFO]
+     || target->active[SELECT_FIRMWARE])
+    return(0);
+
+  /* Prepare request */
+  bzero(&ifr, sizeof(struct ifreq));
+  bzero(&drvinfo, sizeof(struct ethtool_drvinfo));
+  strncpy(ifr.ifr_name, ifname, IFNAMSIZ);
+  drvinfo.cmd = ETHTOOL_GDRVINFO;
+  ifr.ifr_data = (caddr_t) &drvinfo;
+
+  /* Do it */
+  ret = ioctl(skfd, SIOCETHTOOL, &ifr);
+  if(ret < 0)
+    {
+      /* Most drivers don't support that, keep quiet for now */
+      if(verbose)
+	fprintf(stderr,
+		"Error: Can't read driver/bus-info on interface `%s' : %s\n",
+		ifname, strerror(errno));
+      return(-1);
+    }
+
+  /* Copy over */
+  strcpy(target->driver, drvinfo.driver);
+  strcpy(target->bus_info, drvinfo.bus_info);
+  strcpy(target->fw_version, drvinfo.fw_version);
+
+  /* Activate */
+  target->active[SELECT_DRIVER] = 1;
+  target->active[SELECT_BUSINFO] = 1;
+  target->active[SELECT_FIRMWARE] = 1;
+
+  if(verbose)
+    fprintf(stderr,
+	    "Querying %s : Got Driver name `%s', Bus Info `%s' and Firmware `%s'.\n",
+	    ifname, target->driver, target->bus_info, target->fw_version);
+
+  return(0);
+}
+
+/*------------------------------------------------------------------*/
+/*
+ * Add a Base Address selector to a mapping
+ */
+static int
+mapping_addbaseaddr(struct if_mapping *	ifnode,
+		    int *		active,
+		    char *		string,
+		    size_t		len,
+		    struct add_extra *	extra,
+		    int			linenum)
+{
+  size_t	n;
+  unsigned int	address;
+
+  /* Avoid "Unused parameter" warning */
+  extra = extra;
+
+  /* Verify validity of string */
+  n = strspn(string, "0123456789ABCDEFabcdefx"); 
+  if((n < len) || (sscanf(string, "0x%X", &address) != 1))
+    {
+      fprintf(stderr, "Error: Invalid Base Address `%s' at line %d\n",
+	      string, linenum);
+      return(-1);
+    }
+
+  /* Copy */
+  ifnode->base_addr = (unsigned short) address;
+
+  /* Activate */
+  ifnode->active[SELECT_BASEADDR] = 1;
+  active[SELECT_BASEADDR] = 1;
+
+  if(verbose)
+    fprintf(stderr,
+	    "Parsing : Added Base Address `0x%X' from line %d.\n",
+	    ifnode->base_addr, linenum);
+
+  return(0);
+}
+
+/*------------------------------------------------------------------*/
+/*
+ * Compare the Base Address of two mappings
+ */
+static int
+mapping_cmpbaseaddr(struct if_mapping *	ifnode,
+		    struct if_mapping *	target)
+{
+  /* Do wildcard matching, case insensitive */
+  return(!(ifnode->base_addr == target->base_addr));
+}
+
+/*------------------------------------------------------------------*/
+/*
+ * Add a IRQ selector to a mapping
+ */
+static int
+mapping_addirq(struct if_mapping *	ifnode,
+	       int *			active,
+	       char *			string,
+	       size_t			len,
+	       struct add_extra *	extra,
+	       int			linenum)
+{
+  size_t	n;
+  unsigned int	irq;
+
+  /* Avoid "Unused parameter" warning */
+  extra = extra;
+
+  /* Verify validity of string */
+  n = strspn(string, "0123456789"); 
+  if((n < len) || (sscanf(string, "%d", &irq) != 1))
+    {
+      fprintf(stderr, "Error: Invalid Base Address `%s' at line %d\n",
+	      string, linenum);
+      return(-1);
+    }
+
+  /* Copy */
+  ifnode->irq = (unsigned char) irq;
+
+  /* Activate */
+  ifnode->active[SELECT_IRQ] = 1;
+  active[SELECT_IRQ] = 1;
+
+  if(verbose)
+    fprintf(stderr,
+	    "Parsing : Added IRQ `%d' from line %d.\n",
+	    ifnode->irq, linenum);
+
+  return(0);
+}
+
+/*------------------------------------------------------------------*/
+/*
+ * Compare the IRQ of two mappings
+ */
+static int
+mapping_cmpirq(struct if_mapping *	ifnode,
+	       struct if_mapping *	target)
+{
+  /* Do wildcard matching, case insensitive */
+  return(!(ifnode->irq == target->irq));
+}
+
+/*------------------------------------------------------------------*/
+/*
+ * Extract the Driver name and Bus-Info from a live interface
+ */
+static int
+mapping_getbaseaddrirq(int			skfd,
+		       const char *		ifname,
+		       struct if_mapping *	target,
+		       int			flag)
+{
+  struct ifreq	ifr;
+  struct ifmap	map;		/* hardware setup        */
+  int	ret;
+
+  /* Avoid "Unused parameter" warning */
+  flag = flag;
+
+  /* We may come here twice, so do the job only once */
+  if(target->active[SELECT_BASEADDR] || target->active[SELECT_IRQ])
+    return(0);
+
+  /* Prepare request */
+  bzero(&ifr, sizeof(struct ifreq));
+  bzero(&map, sizeof(struct ifmap));
+  strncpy(ifr.ifr_name, ifname, IFNAMSIZ);
+
+  /* Do it */
+  ret = ioctl(skfd, SIOCGIFMAP, &ifr);
+  if(ret < 0)
+    {
+      /* Don't know if every interface has that, so keep quiet... */
+      if(verbose)
+	fprintf(stderr,
+		"Error: Can't read base address/irq on interface `%s' : %s\n",
+		ifname, strerror(errno));
+      return(-1);
+    }
+
+  /* Copy over, activate */
+  if(ifr.ifr_map.base_addr >= 0x100)
+    {
+      target->base_addr = ifr.ifr_map.base_addr;
+      target->active[SELECT_BASEADDR] = 1;
+    }
+  target->irq = ifr.ifr_map.irq;
+  target->active[SELECT_IRQ] = 1;
+
+  if(verbose)
+    fprintf(stderr,
+	    "Querying %s : Got Base Address `0x%X' and IRQ `%d'.\n",
+	    ifname, target->base_addr, target->irq);
+
+  return(0);
+}
+
+/*------------------------------------------------------------------*/
+/*
+ * Add a Wireless Protocol selector to a mapping
+ */
+static int
+mapping_addiwproto(struct if_mapping *	ifnode,
+		   int *		active,
+		   char *		string,
+		   size_t		len,
+		   struct add_extra *	extra,
+		   int			linenum)
+{
+  /* Avoid "Unused parameter" warning */
+  extra = extra;
+
+  /* Verify validity of string */
+  if(len >= sizeof(ifnode->iwproto))
+    { 
+      fprintf(stderr, "Wireless Protocol too long at line %d\n", linenum);  
+      return(-1);
+    }
+
+  /* Copy */
+  memcpy(ifnode->iwproto, string, len + 1); 
+
+  /* Activate */
+  ifnode->active[SELECT_IWPROTO] = 1;
+  active[SELECT_IWPROTO] = 1;
+
+  if(verbose)
+    fprintf(stderr,
+	    "Parsing : Added Wireless Protocol `%s' from line %d.\n",
+	    ifnode->iwproto, linenum);
+
+  return(0);
+}
+
+/*------------------------------------------------------------------*/
+/*
+ * Compare the Wireless Protocol of two mappings
+ */
+static int
+mapping_cmpiwproto(struct if_mapping *	ifnode,
+		   struct if_mapping *	target)
+{
+  /* Do wildcard matching, case insensitive */
+  return(fnmatch(ifnode->iwproto, target->iwproto, FNM_CASEFOLD));
+}
+
+/*------------------------------------------------------------------*/
+/*
+ * Extract the Wireless Protocol from a live interface
+ */
+static int
+mapping_getiwproto(int			skfd,
+		   const char *		ifname,
+		   struct if_mapping *	target,
+		   int			flag)
+{
+  struct iwreq		wrq;
+
+  /* Avoid "Unused parameter" warning */
+  flag = flag;
+
+  /* Get wireless name */
+  if(iw_get_ext(skfd, ifname, SIOCGIWNAME, &wrq) < 0)
+    /* Don't complain about it, Ethernet cards will never support this */
+    return(-1);
+
+  strncpy(target->iwproto, wrq.u.name, IFNAMSIZ);
+  target->iwproto[IFNAMSIZ] = '\0';
+
+  /* Activate */
+  target->active[SELECT_IWPROTO] = 1;
+
+  if(verbose)
+    fprintf(stderr,
+	    "Querying %s : Got Wireless Protocol `%s'.\n",
+	    ifname, target->iwproto);
+
+  return(0);
+}
+
+/*------------------------------------------------------------------*/
+/*
+ * Add a Pcmcia Slot selector to a mapping
+ */
+static int
+mapping_addpcmciaslot(struct if_mapping *	ifnode,
+		      int *			active,
+		      char *			string,
+		      size_t			len,
+		      struct add_extra *	extra,
+		      int			linenum)
+{
+  size_t	n;
+
+  /* Avoid "Unused parameter" warning */
+  extra = extra;
+
+  /* Verify validity of string, convert to int */
+  n = strspn(string, "0123456789"); 
+  if((n < len) || (sscanf(string, "%d", &ifnode->pcmcia_slot) != 1))
+    {
+      fprintf(stderr, "Error: Invalid Pcmcia Slot `%s' at line %d\n",
+	      string, linenum);
+      return(-1);
+    }
+
+  ifnode->active[SELECT_PCMCIASLOT] = 1;
+  active[SELECT_PCMCIASLOT] = 1;
+
+  if(verbose)
+    fprintf(stderr, "Parsing : Added Pcmcia Slot `%d' from line %d.\n",
+	    ifnode->pcmcia_slot, linenum);
+
+  return(0);
+}
+
+/*------------------------------------------------------------------*/
+/*
+ * Compare the Pcmcia Slot of two mappings
+ */
+static int
+mapping_cmppcmciaslot(struct if_mapping *	ifnode,
+		      struct if_mapping *	target)
+{
+  return(!(ifnode->pcmcia_slot == target->pcmcia_slot));
+}
+
+/*------------------------------------------------------------------*/
+/*
+ * Extract the Pcmcia Slot of an interface
+ * Note that this works only for cards fully managed by cardmgr.
+ * With the kernel pcmcia modules, 32 bits cards (CardBus) are not managed
+ * by cardmgr, and therefore won't have a valid slot number. For those
+ * cards, you should use Bus Info (when the driver exports it).
+ * In the long term, 16 bits card as well will no longer be managed by
+ * cardmgr. Currently, Bus Info for 16 bit cards don't have any information
+ * enabling to locate their physical location on the system, but I hope that
+ * this will change.
+ * When that happen, we can drop this code...
+ */
+static int
+mapping_getpcmciaslot(int			skfd,
+		      const char *		ifname,
+		      struct if_mapping *	target,
+		      int			flag)
+{
+  FILE *	stream;
+  char *	linebuf = NULL;
+  size_t	linelen = 0; 
+  int		linenum = 0; 
+
+  /* Avoid "Unused parameter" warning */
+  skfd = skfd;
+  flag = flag;
+
+  /* Open the stab file for reading */
+  stream = fopen(PCMCIA_STAB1, "r");
+  if(!stream) 
+    {
+      /* Try again, alternate location */
+      stream = fopen(PCMCIA_STAB2, "r");
+      if(!stream) 
+	{
+	  fprintf(stderr, "Error: Can't open PCMCIA Stab file `%s' or `%s': %s\n",
+		  PCMCIA_STAB1, PCMCIA_STAB2, strerror(errno)); 
+	  return(-1);
+	}
+    }
+
+  /* Read each line of file
+   * getline is a GNU extension :-( The buffer is recycled and increased
+   * as needed by getline. */
+  while(getline(&linebuf, &linelen, stream) > 0)
+    {
+      char *			p;
+      size_t			n;
+      size_t			k;
+      int			pcmcia_slot;
+      int			i;
+
+      /* Keep track of line number */
+      linenum++;
+
+      /* Get Pcmcia socket number */
+      p = linebuf;
+      while(isspace(*p))
+	++p; 
+      if(*p == '\0')
+	continue;	/* Line ended */
+      n = strcspn(p, " \t\n");
+      k = strspn(p, "0123456789"); 
+      if((k < n) || (sscanf(p, "%d", &pcmcia_slot) != 1))
+	/* Next line */
+	continue;
+
+      /* Skip socket number */
+      /* Skip socket number ; device class ; driver name ; instance */
+      for(i = 0; i < 4; i++)
+	{
+	  /* Skip item */
+	  p += n;
+	  /* Skip space */
+	  p += strspn(p, " \t\n"); 
+	  if(*p == '\0')
+	    break;	/* Line ended */
+	  /* Next item size */
+	  n = strcspn(p, " \t\n");
+	}
+      if(*p == '\0')
+	continue;	/* Line ended */
+
+      /* Terminate dev name */
+      p[n] = '\0';
+
+      /* Compare to interface name */
+      if(!strcmp(p, ifname))
+	{
+	  /* Save */
+	  target->pcmcia_slot = pcmcia_slot;
+
+	  /* Activate */
+	  target->active[SELECT_PCMCIASLOT] = 1;
+
+	  if(verbose)
+	    fprintf(stderr,
+		    "Querying %s : Got Pcmcia Slot `%d'.\n",
+		    ifname, target->pcmcia_slot);
+	  /* Exit loop, found it */
+	  break;
+	}
+
+      /* Finished -> next line */
+    }
+
+  /* Cleanup */
+  free(linebuf);
+  fclose(stream);
+
+  return(target->active[SELECT_PCMCIASLOT] ? 0 : -1);
+}
+
+/*------------------------------------------------------------------*/
+/*
+ * Add a sysfs selector to a mapping
+ */
+static int
+mapping_addsysfs(struct if_mapping *	ifnode,
+		 int *			active,
+		 char *			string,
+		 size_t			len,
+		 struct add_extra *	extra,
+		 int			linenum)
+{
+  int		findex;	/* filename index */
+  char *	sdup;
+
+  /* Check if we have a modifier */
+  if((extra == NULL) || (extra->modif_pos == NULL))
+    { 
+      fprintf(stderr, "Error: No SYSFS filename at line %d\n", linenum);  
+      return(-1);
+    }
+
+  /* Search if the filename already exist */
+  for(findex = 0; findex < sysfs_global.filenum; findex++)
+    {
+      if(!strcmp(extra->modif_pos, sysfs_global.filename[findex]))
+	break;
+    }
+
+  /* If filename does not exist, creates it */
+  if(findex == sysfs_global.filenum)
+    {
+      if(findex == SYSFS_MAX_FILE)
+	{
+	  fprintf(stderr, "Error: Too many SYSFS filenames at line %d\n", linenum);  
+	  return(-1);
+	}
+      sdup = strndup(extra->modif_pos, extra->modif_len);
+      if(sdup == NULL)
+	{
+	  fprintf(stderr, "Error: Can't allocate SYSFS file\n");  
+	  return(-1);
+	}
+      sysfs_global.filename[findex] = sdup;
+      sysfs_global.filenum++;
+    }
+
+  /* Store value */
+  sdup = strndup(string, len);
+  if(sdup == NULL)
+    {
+      fprintf(stderr, "Error: Can't allocate SYSFS value\n");  
+      return(-1);
+    }
+  ifnode->sysfs[findex] = sdup;
+
+  /* Activate */
+  ifnode->active[SELECT_SYSFS] = 1;
+  active[SELECT_SYSFS] = 1;
+
+  if(verbose)
+    fprintf(stderr,
+	    "Parsing : Added SYSFS filename `%s' value `%s' from line %d.\n",
+	    sysfs_global.filename[findex], ifnode->sysfs[findex], linenum);
+
+  return(0);
+}
+
+/*------------------------------------------------------------------*/
+/*
+ * Compare all the sysfs values of two mappings
+ */
+static int
+mapping_cmpsysfs(struct if_mapping *	ifnode,
+		 struct if_mapping *	target)
+{
+  int		findex;	/* filename index */
+  int		match = 1;
+
+  /* Loop on all sysfs selector */
+  for(findex = 0; findex < sysfs_global.filenum; findex++)
+    {
+      /* If the mapping defines this sysfs selector.. */
+      if(ifnode->sysfs[findex] != NULL)
+	/* And if the sysfs values don't match */
+	if((target->sysfs[findex] == NULL) ||
+	   (fnmatch(ifnode->sysfs[findex], target->sysfs[findex],
+		    FNM_CASEFOLD)))
+	  /* Then the sysfs selector doesn't match */
+	  match = 0;
+    }
+
+  return(!match);
+}
+
+/*------------------------------------------------------------------*/
+/*
+ * Extract all the sysfs values of an interface
+ */
+static int
+mapping_getsysfs(int			skfd,
+		 const char *		ifname,
+		 struct if_mapping *	target,
+		 int			flag)
+{
+  FILE *	stream;
+  char *	fname;
+  int		fnsize;
+  char *	linebuf = NULL;
+  size_t	linelen = 0; 
+  char *	sdup;
+  int		findex;	/* filename index */
+
+  /* Avoid "Unused parameter" warning */
+  skfd = skfd;
+  flag = flag;
+
+  /* Check if we know the devpath of this device */
+  if(target->sysfs_devpath == NULL)
+    {
+      /* Check if we know the root of the sysfs filesystem */
+      if(sysfs_global.root == NULL)
+	{
+	  /* Open the mount file for reading */
+	  stream = fopen("/proc/mounts", "r");
+	  if(!stream) 
+	    {
+	      fprintf(stderr, "Error: Can't open /proc/mounts file: %s\n",
+		      strerror(errno)); 
+	      return(-1);
+	    }
+
+	  /* Read each line of file
+	   * getline is a GNU extension :-( The buffer is recycled and
+	   * increased as needed by getline. */
+	  while(getline(&linebuf, &linelen, stream) > 0)
+	    {
+	      int		i;
+	      char *	p;
+	      size_t	n;
+	      char *	token[3];
+	      size_t	toklen[3];
+
+	      /* The format of /proc/mounts is similar to /etc/fstab (5).
+	       * The first argument is the device. For sysfs, there is no
+	       * associated device, so this argument is ignored.
+	       * The second argument is the mount point.
+	       * The third argument is the filesystem type.
+	       */
+
+	      /* Extract the first 3 tokens */
+	      p = linebuf;
+	      for(i = 0; i < 3; i++)
+		{
+		  while(isspace(*p))
+		    ++p; 
+		  token[i] = p;
+		  n = strcspn(p, " \t\n");
+		  toklen[i] = n;
+		  p += n;
+		}
+	      /* Get the filesystem which type is "sysfs" */
+	      if((n == 5) && (!strncasecmp(token[2], "sysfs", 5)))
+		{
+		  /* Get its mount point */
+		  n = toklen[1];
+		  sdup = strndup(token[1], n);
+		  if((n == 0) || (sdup == NULL))
+		    {
+		      fprintf(stderr,
+			      "Error: Can't parse /proc/mounts file: %s\n",
+			      strerror(errno)); 
+		      return(-1);
+		    }
+		  /* Store it */
+		  sysfs_global.root = sdup;
+		  sysfs_global.rlen = n;
+		  break;
+		}
+	      /* Finished -> next line */
+	    }
+
+	  /* Cleanup */
+	  fclose(stream);
+
+	  /* Check if we found it */
+	  if(sysfs_global.root == NULL)
+	    {
+	      fprintf(stderr,
+		      "Error: Can't find sysfs in /proc/mounts file\n");
+	      free(linebuf);
+	      return(-1);
+	    }
+	}
+
+      /* Construct devpath for this interface.
+       * Reserve enough space to replace name without realloc. */
+      fnsize = (sysfs_global.rlen + 11 + IFNAMSIZ + 1);
+      fname = malloc(fnsize);
+      if(fname == NULL)
+	{
+	  fprintf(stderr, "Error: Can't allocate SYSFS devpath\n");  
+	  return(-1);
+	}
+      /* Not true devpath for 2.6.20+, but this syslink should work */
+      target->sysfs_devplen = sprintf(fname, "%s/class/net/%s",
+				      sysfs_global.root, ifname);
+      target->sysfs_devpath = fname;
+    }
+
+  /* Loop on all sysfs selector */
+  for(findex = 0; findex < sysfs_global.filenum; findex++)
+    {
+      char *	p;
+      ssize_t	n;
+
+      /* Construct complete filename for the sysfs selector */
+      fnsize = (target->sysfs_devplen + 1 +
+		strlen(sysfs_global.filename[findex]) + 1);
+      fname = malloc(fnsize);
+      if(fname == NULL)
+	{
+	  fprintf(stderr, "Error: Can't allocate SYSFS filename\n");  
+	  free(linebuf);
+	  return(-1);
+	}
+      sprintf(fname, "%s/%s", target->sysfs_devpath,
+	      sysfs_global.filename[findex]);
+
+      /* Open the sysfs file for reading */
+      stream = fopen(fname, "r");
+      if(!stream) 
+	{
+	  /* Some sysfs attribute may no exist for some interface */
+	  if(verbose)
+	    fprintf(stderr, "Error: Can't open file `%s': %s\n", fname,
+		    strerror(errno)); 
+	  /* Next sysfs selector */
+	  continue;
+	}
+
+      /* Read file. Only one line in file. */
+      n = getline(&linebuf, &linelen, stream);
+      fclose(stream);
+      if(n <= 0)
+	{
+	  /* Some attributes are just symlinks to another directory.
+	   * We can read the attributes in that other directory
+	   * just fine, but sometimes the symlink itself gives a lot
+	   * of information.
+	   * Examples : SYSFS{device} and SYSFS{device/driver}
+	   * In such cases, get the name of the directory pointed to...
+	   */
+	  /*
+	   * I must note that the API for readlink() is very bad,
+	   * which force us to have this ugly code. Yuck !
+	   */
+	  int		allocsize = 128;	/* 256 = Good start */
+	  int		retry = 16;
+	  char *	linkpath = NULL;
+	  int		pathlen;
+
+	  /* Try reading the link with increased buffer size */
+	  do
+	    {
+	      allocsize *= 2;
+	      linkpath = realloc(linkpath, allocsize);
+	      pathlen = readlink(fname, linkpath, allocsize);
+	      /* If we did not hit the buffer limit, success */
+	      if(pathlen < allocsize)
+		break;
+	    }
+	  while(retry-- > 0);
+
+	  /* Check for error, most likely ENOENT */
+	  if(pathlen > 0)
+	    /* We have a symlink ;-) Terminate the string. */
+	    linkpath[pathlen] = '\0';
+	  else
+	    {
+	      /* Error ! */
+	      free(linkpath);
+
+	      /* A lot of information in the sysfs is implicit, given
+	       * by the position of a file in the tree. It is therefore
+	       * important to be able to read the various components
+	       * of a path. For this reason, we resolve '..' to the
+	       * real name of the parent directory... */
+	      /* We have at least 11 char, see above */
+	      if(!strcmp(fname + fnsize - 4, "/.."))
+		//if(!strcmp(fname + strlen(fname) - 3, "/.."))
+		{
+		  /* This procedure to get the realpath is not very
+		   * nice, but it's the "best practice". Hmm... */
+		  int	cwd_fd = open(".", O_RDONLY);
+		  linkpath = NULL;
+		  if(cwd_fd > 0)
+		    {
+		      int	ret = chdir(fname);
+		      if(ret == 0)
+			/* Using getcwd with NULL is a GNU extension. Nice. */
+			linkpath = getcwd(NULL, 0);
+		      /* This may fail, but it's not fatal */
+		      fchdir(cwd_fd);
+		    }
+		  /* Check if we suceeded */
+		  if(!linkpath)
+		    {
+		      free(linkpath);
+		      if(verbose)
+			fprintf(stderr, "Error: Can't read parent directory `%s'\n", fname);
+		      /* Next sysfs selector */
+		      continue;
+		    }
+		}
+	      else
+		{
+		  /* Some sysfs attribute are void for some interface,
+		   * we may have a real directory, or we may have permission
+		   * issues... */
+		  if(verbose)
+		    fprintf(stderr, "Error: Can't read file `%s'\n", fname);
+		  /* Next sysfs selector */
+		  continue;
+		}
+	    }
+
+	  /* Here, we have a link name or a parent directory name */
+
+	  /* Keep only the last component of path name, save it */
+	  p = basename(linkpath);
+	  sdup = strdup(p);
+	  free(linkpath);
+	}
+      else
+	{
+	  /* This is a regular file (well, pseudo file) */
+	  /* Get content, remove trailing '/n', save it */
+	  p = linebuf;
+	  if(p[n - 1] == '\n')
+	    n--;
+	  sdup = strndup(p, n);
+	}
+      if(sdup == NULL)
+	{
+	  fprintf(stderr, "Error: Can't allocate SYSFS value\n"); 
+	  free(linebuf);
+	  return(-1);
+	}
+      target->sysfs[findex] = sdup;
+
+      /* Activate */
+      target->active[SELECT_SYSFS] = 1;
+
+      if(verbose)
+	fprintf(stderr,
+		"Querying %s : Got SYSFS filename `%s' value `%s'.\n",
+		ifname, sysfs_global.filename[findex], target->sysfs[findex]);
+
+      /* Finished : Next sysfs selector */
+    }
+
+  /* Cleanup */
+  free(linebuf);
+
+  return(target->active[SELECT_SYSFS] ? 0 : -1);
+}
+
+/*------------------------------------------------------------------*/
+/*
+ * Add a Previous Interface Name selector to a mapping
+ */
+static int
+mapping_addprevname(struct if_mapping *	ifnode,
+		   int *		active,
+		   char *		string,
+		   size_t		len,
+		   struct add_extra *	extra,
+		   int			linenum)
+{
+  /* Avoid "Unused parameter" warning */
+  extra = extra;
+
+  /* Verify validity of string */
+  if(len >= sizeof(ifnode->prevname))
+    { 
+      fprintf(stderr, "Old Interface Name too long at line %d\n", linenum);  
+      return(-1);
+    }
+
+  /* Copy */
+  memcpy(ifnode->prevname, string, len + 1); 
+
+  /* Activate */
+  ifnode->active[SELECT_PREVNAME] = 1;
+  active[SELECT_PREVNAME] = 1;
+
+  if(verbose)
+    fprintf(stderr,
+	    "Parsing : Added Old Interface Name `%s' from line %d.\n",
+	    ifnode->prevname, linenum);
+
+  return(0);
+}
+
+/*------------------------------------------------------------------*/
+/*
+ * Compare the Previous Interface Name of two mappings
+ * Note : this one is special.
+ */
+static int
+mapping_cmpprevname(struct if_mapping *	ifnode,
+		   struct if_mapping *	target)
+{
+  /* Do wildcard matching, case insensitive */
+  return(fnmatch(ifnode->prevname, target->ifname, FNM_CASEFOLD));
+}
+
+/*------------------------------------------------------------------*/
+/*
+ * Extract the Previous Interface Name from a live interface
+ */
+static int
+mapping_getprevname(int			skfd,
+		   const char *		ifname,
+		   struct if_mapping *	target,
+		   int			flag)
+{
+  /* Avoid "Unused parameter" warning */
+  skfd = skfd; ifname = ifname; flag = flag;
+
+  /* Don't do anything, it's already in target->ifname ;-) */
+
+  /* Activate */
+  target->active[SELECT_PREVNAME] = 1;
+
+  return(0);
+}
+
+
+/*********************** MAPPING MANAGEMENTS ***********************/
+/*
+ * Manage interface mappings.
+ * Each mapping tell us how to identify a specific interface name.
+ * It is composed of a bunch of selector values.
+ */
+
+/*------------------------------------------------------------------*/
+/*
+ * Create a new interface mapping and verify its name
+ */
+static struct if_mapping *
+mapping_create(char *	pos,
+	       int	len,
+	       int	linenum)
+{
+  struct if_mapping *	ifnode;
+  char *		star;
+
+  star = memchr(pos, '*', len);
+
+  /* Check overflow, need one extra char for wildcard */
+  if((len + (star != NULL)) > IFNAMSIZ)
+    {
+      fprintf(stderr, "Error: Interface name `%.*s' too long at line %d\n",
+	      (int) len, pos, linenum);  
+      return(NULL);
+    }
+
+  /* Create mapping, zero it */
+  ifnode = calloc(1, sizeof(if_mapping));
+  if(!ifnode)
+    {
+      fprintf(stderr, "Error: Can't allocate interface mapping.\n");  
+      return(NULL);
+    }
+
+  /* Set the name, terminates it */
+  memcpy(ifnode->ifname, pos, len); 
+  ifnode->ifname[len] = '\0'; 
+
+  /* Check the interface name and issue various pedantic warnings.
+   * We assume people using takeover want to force interfaces to those
+   * names and know what they are doing, so don't bother them... */
+  if((!force_takeover) &&
+     ((!strcmp(ifnode->ifname, "eth0")) || (!strcmp(ifnode->ifname, "wlan0"))))
+    fprintf(stderr,
+	    "Warning: Interface name is `%s' at line %d, can't be mapped reliably.\n",
+	    ifnode->ifname, linenum);
+  if(strchr(ifnode->ifname, ':'))
+    fprintf(stderr, "Warning: Alias device `%s' at line %d probably can't be mapped.\n",
+	    ifnode->ifname, linenum);
+
+  if(verbose)
+    fprintf(stderr, "Parsing : Added Mapping `%s' from line %d.\n",
+	    ifnode->ifname, linenum);
+
+  /* Done */
+  return(ifnode);
+}
+
+/*------------------------------------------------------------------*/
+/*
+ * Find the most appropriate selector matching a given selector name
+ */
+static inline const struct mapping_selector *
+selector_find(const char *	string,
+	      size_t		slen,
+	      int		linenum)
+{
+  const struct mapping_selector *	found = NULL;
+  int			ambig = 0;
+  int			i;
+
+  /* Go through all selectors */
+  for(i = 0; selector_list[i].name != NULL; ++i)
+    {
+      /* No match -> next one */
+      if(strncasecmp(selector_list[i].name, string, slen) != 0)
+	continue;
+
+      /* Exact match -> perfect */
+      if(slen == strlen(selector_list[i].name))
+	return &selector_list[i];
+
+      /* Partial match */
+      if(found == NULL)
+	/* First time */
+	found = &selector_list[i];
+      else
+	/* Another time */
+	if (selector_list[i].add_fn != found->add_fn)
+	  ambig = 1;
+    }
+
+  if(found == NULL)
+    {
+      fprintf(stderr, "Error: Unknown selector `%.*s' at line %d.\n",
+	      (int) slen, string, linenum);
+      return NULL;
+    }
+
+  if(ambig)
+    {
+      fprintf(stderr, "Selector `%.*s'at line %d is ambiguous.\n",
+	      (int) slen, string, linenum);
+      return NULL;
+    }
+
+  return found;
+}
+
+/*------------------------------------------------------------------*/
+/*
+ * Read the configuration file and extract all valid mappings and their
+ * selectors.
+ */
+static int
+mapping_readfile(const char *	filename)
+{
+  FILE *		stream;
+  char *		linebuf = NULL;
+  size_t		linelen = 0; 
+  int			linenum = 0; 
+  struct add_extra	extrainfo;
+
+  /* Reset the list of filters */
+  bzero(selector_active, sizeof(selector_active));
+
+  /* Check filename */
+  if(!strcmp(filename, "-"))
+    {
+      /* Read from stdin */
+      stream = stdin;
+
+    }
+  else
+    {
+      /* Open the file for reading */
+      stream = fopen(filename, "r");
+      if(!stream) 
+	{
+	  fprintf(stderr, "Error: Can't open configuration file `%s': %s\n",
+		  filename, strerror(errno)); 
+	  return(-1);
+	}
+    }
+
+  /* Read each line of file
+   * getline is a GNU extension :-( The buffer is recycled and increased
+   * as needed by getline. */
+  while(getline(&linebuf, &linelen, stream) > 0)
+    {
+      struct if_mapping *	ifnode;
+      char *			p;
+      char *			e;
+      size_t			n;
+      int			ret = -13;	/* Complain if no selectors */
+
+      /* Keep track of line number */
+      linenum++;
+
+      /* Every comments terminates parsing */
+      if((p = strchr(linebuf,'#')) != NULL)
+	*p = '\0';
+
+      /* Get interface name */
+      p = linebuf;
+      while(isspace(*p))
+	++p; 
+      if(*p == '\0')
+	continue;	/* Line ended */
+      n = strcspn(p, " \t\n");
+
+      /* Create mapping */
+      ifnode = mapping_create(p, n, linenum);
+      if(!ifnode)
+	continue;	/* Ignore this line */
+      p += n;
+      p += strspn(p, " \t\n"); 
+
+      /* Loop on all selectors */
+      while(*p != '\0')
+	{
+	  const struct mapping_selector *	selector = NULL;
+	  struct add_extra *			extra = NULL;
+
+	  /* Selector name length - stop at modifier start */
+	  n = strcspn(p, " \t\n{");
+
+	  /* Find it */
+	  selector = selector_find(p, n, linenum);
+	  if(!selector)
+	    {
+	      ret = -1;
+	      break;
+	    }
+	  p += n;
+
+	  /* Check for modifier */
+	  if(*p == '{')
+	    {
+	      p++;
+	      /* Find end of modifier */
+	      e = strchr(p, '}');
+	      if(e == NULL)
+		{
+		  fprintf(stderr,
+			  "Error: unterminated selector modifier value on line %d\n",
+			  linenum);
+		  ret = -1;
+		  break;	/* Line ended */
+		}
+	      /* Fill in struct and hook it */
+	      extrainfo.modif_pos = p;
+	      extrainfo.modif_len = e - p;
+	      extra = &extrainfo;
+	      /* Terminate modifier value */
+	      e[0] = '\0';
+	      /* Skip it */
+	      p = e + 1;
+	    }
+
+	  /* Get to selector value */
+	  p += strspn(p, " \t\n"); 
+	  if(*p == '\0')
+	    {
+	      fprintf(stderr, "Error: no value for selector `%s' on line %d\n",
+		      selector->name, linenum);
+	      ret = -1;
+	      break;	/* Line ended */
+	    }
+	  /* Check for quoted arguments */
+	  if(*p == '"')
+	    {
+	      p++;
+	      e = strchr(p, '"');
+	      if(e == NULL)
+		{
+		  fprintf(stderr,
+			  "Error: unterminated quoted value on line %d\n",
+			  linenum);
+		  ret = -1;
+		  break;	/* Line ended */
+		}
+	      n = e - p;
+	      e++;
+	    }
+	  else
+	    {
+	      /* Just end at next blank */
+	      n = strcspn(p, " \t\n");
+	      e = p + n;
+	    }
+	  /* Make 'e' point past the '\0' we are going to add */
+	  if(*e != '\0')
+	    e++;
+	  /* Terminate selector value */
+	  p[n] = '\0';
+
+	  /* Add it to the mapping */
+	  ret = selector->add_fn(ifnode, selector_active, p, n,
+				 extra, linenum);
+	  if(ret < 0)
+	    break;
+
+	  /* Go to next selector */
+	  p = e;
+	  p += strspn(p, " \t\n"); 
+	}
+
+      /* We add a mapping only if it has at least one selector and if all
+       * selectors were parsed properly. */
+      if(ret < 0)
+	{
+	  /* If we have not yet printed an error, now is a good time ;-) */
+	  if(ret == -13)
+	    fprintf(stderr, "Error: Line %d ignored, no valid selectors\n",
+		    linenum);
+	  else
+	    fprintf(stderr, "Error: Line %d ignored due to prior errors\n",
+		    linenum);
+
+	  free(ifnode);
+	}
+      else
+	{
+	  /* Link it in the list */
+	  ifnode->next = mapping_list;
+	  mapping_list = ifnode;
+	}
+    }
+
+  /* Cleanup */
+  free(linebuf);
+
+  /* Finished reading, close the file */
+  if(stream != stdin)
+    fclose(stream);
+  return(0);
+}
+
+/*------------------------------------------------------------------*/
+/*
+ * Extract all the interesting selectors for the interface in consideration
+ */
+static struct if_mapping *
+mapping_extract(int		skfd,
+		const char *	ifname)
+{
+  struct if_mapping *	target;
+  int			i;
+
+  /* Create mapping, zero it */
+  target = calloc(1, sizeof(if_mapping));
+  if(!target)
+    {
+      fprintf(stderr, "Error: Can't allocate interface mapping.\n");  
+      return(NULL);
+    }
+
+  /* Set the interface name */
+  strcpy(target->ifname, ifname);
+
+  /* Loop on all active selectors */
+  for(i = 0; i < SELECT_NUM; i++)
+    {
+      /* Check if this selector is active */
+      if(selector_active[i] != 0)
+	{
+	  /* Extract selector */
+	  selector_list[i].get_fn(skfd, ifname, target, selector_active[i]);
+
+	  /* Ignore errors. Some mapping may not need all selectors */
+	}
+    }
+
+  return(target);
+} 
+
+/*------------------------------------------------------------------*/
+/*
+ * Find the first mapping in the list matching the one we want.
+ */
+static struct if_mapping *
+mapping_find(struct if_mapping *	target)
+{
+  struct if_mapping *	ifnode;
+  int			i;
+
+  /* Look over all our mappings */
+  for(ifnode = mapping_list; ifnode != NULL; ifnode = ifnode->next)
+    {
+      int		matches = 1;
+
+      /* Look over all our selectors, all must match */
+      for(i = 0; i < SELECT_NUM; i++)
+	{
+	  /* Check if this selector is active */
+	  if(ifnode->active[i] != 0)
+	    {
+	      /* If this selector doesn't match, game over for this mapping */
+	      if((target->active[i] == 0) ||
+		 (selector_list[i].cmp_fn(ifnode, target) != 0))
+		{
+		  matches = 0;
+		  break;
+		}
+	    }
+	}
+
+      /* Check is this mapping was "the one" */
+      if(matches)
+	return(ifnode);
+    }
+
+  /* Not found */
+  return(NULL);
+} 
+
+/************************** MODULE SUPPORT **************************/
+/*
+ * Load all necessary module so that interfaces do exist.
+ * This is necessary for system that are fully modular when
+ * doing the boot time processing, because we need to run before
+ * 'ifup -a'.
+ */
+
+/*------------------------------------------------------------------*/
+/*
+ * Probe interfaces based on our list of mappings.
+ * This is the default, but usually not the best way to do it.
+ */
+static void
+probe_mappings(int		skfd)
+{
+  struct if_mapping *	ifnode;
+  struct ifreq		ifr;
+
+  /* Look over all our mappings */
+  for(ifnode = mapping_list; ifnode != NULL; ifnode = ifnode->next)
+    {
+      /* Can't load wildcards interface name :-( */
+      if(strchr(ifnode->ifname, '%') != NULL)
+	continue;
+
+      if(verbose)
+	fprintf(stderr, "Probing : Trying to load interface [%s]\n",
+		ifnode->ifname);
+
+      /* Trick the kernel into loading the interface.
+       * This allow us to not depend on the exact path and
+       * name of the '/sbin/modprobe' command.
+       * Obviously, we expect this command to 'fail', as
+       * the interface will load with the old/wrong name.
+       */
+      strncpy(ifr.ifr_name, ifnode->ifname, IFNAMSIZ);
+      ioctl(skfd, SIOCGIFHWADDR, &ifr);
+    }
+}
+
+/*------------------------------------------------------------------*/
+/*
+ * Probe interfaces based on Debian's config files.
+ * This allow to enly load modules for interfaces the user want active,
+ * all built-in interfaces that should remain unconfigured won't
+ * be probed (and can have mappings).
+ */
+static void
+probe_debian(int		skfd)
+{
+  FILE *		stream;
+  char *		linebuf = NULL;
+  size_t		linelen = 0; 
+  struct ifreq		ifr;
+
+  /* Open Debian config file */
+  stream = fopen(DEBIAN_CONFIG_FILE, "r");
+  if(stream == NULL)
+    {
+      fprintf(stderr, "Error: can't open file [%s]\n", DEBIAN_CONFIG_FILE);
+      return;
+    }
+
+  /* Read each line of file
+   * getline is a GNU extension :-( The buffer is recycled and increased
+   * as needed by getline. */
+  while(getline(&linebuf, &linelen, stream) > 0)
+    {
+      char *			p;
+      char *			e;
+      size_t			n;
+
+      /* Check for auto keyword, ignore when commented out */
+      if(!strncasecmp(linebuf, "auto ", 5))
+	{
+	  /* Skip "auto" keyword */
+	  p = linebuf + 5;
+
+	  /* Terminate at first comment */
+	  e = strchr(p, '#');
+	  if(e != NULL)
+	    *e = '\0';
+
+	  /* Loop on all interfaces given */
+	  while(*p != '\0')
+	    {
+	      /* Interface name length */
+	      n = strcspn(p, " \t\n");
+
+	      /* Look for end of interface name */
+	      e = p + n;
+	      /* Make 'e' point past the '\0' we are going to add */
+	      if(*e != '\0')
+		e++;
+	      /* Terminate interface name */
+	      p[n] = '\0';
+
+	      if(verbose)
+		fprintf(stderr, "Probing : Trying to load interface [%s]\n",
+			p);
+
+	      /* Load interface */
+	      strncpy(ifr.ifr_name, p, IFNAMSIZ);
+	      ioctl(skfd, SIOCGIFHWADDR, &ifr);
+
+	      /* Go to next interface name */
+	      p = e;
+	      p += strspn(p, " \t\n"); 
+	    }
+	}
+    }
+
+  /* Done */
+  fclose(stream);
+  return;
+}
+
+/**************************** MAIN LOGIC ****************************/
+
+/*------------------------------------------------------------------*/
+/*
+ * Rename an interface to a specified new name.
+ */
+static int
+process_rename(int	skfd,
+	       char *	ifname,
+	       char *	newname)
+{
+  char		retname[IFNAMSIZ+1];
+  int		len;
+  char *	star;
+
+  len = strlen(newname);
+  star = strchr(newname, '*');
+
+  /* Check newname length, need one extra char for wildcard */
+  if((len + (star != NULL)) > IFNAMSIZ)
+    {
+      fprintf(stderr, "Error: Interface name `%s' too long.\n",
+	      newname);  
+      return(-1);
+    }
+
+  /* Change the name of the interface */
+  if(if_set_name(skfd, ifname, newname, retname) < 0)
+    {
+      fprintf(stderr, "Error: cannot change name of %s to %s: %s\n",
+	      ifname, newname, strerror(errno)); 
+      return(-1);
+    }
+
+  /* Always print out the *new* interface name so that
+   * the calling script can pick it up and know where its interface
+   * has gone. */
+  printf("%s\n", retname);
+
+  /* Done */
+  return(0);
+}
+
+/*------------------------------------------------------------------*/
+/*
+ * Process a specified interface.
+ */
+static int
+process_ifname(int	skfd,
+	       char *	ifname,
+	       char *	args[],
+	       int	count)
+{
+  struct if_mapping *		target;
+  const struct if_mapping *	mapping;
+  char				retname[IFNAMSIZ+1];
+
+  /* Avoid "Unused parameter" warning */
+  args = args; count = count;
+
+  /* Get description of this interface */
+  target = mapping_extract(skfd, ifname);
+  if(target == NULL)
+    return(-1);
+
+  /* If udev is calling us, get the real devpath. */
+  if(udev_output)
+    {
+      const char *env;
+      /* It's passed to us as an environment variable */
+      env = getenv("DEVPATH");
+      if(env)
+	{
+	  int	env_len = strlen(env);
+	  target->sysfs_devplen = env_len;
+	  /* Make enough space for new interface name */
+	  target->sysfs_devpath = malloc(env_len + IFNAMSIZ + 1);
+	  if(target->sysfs_devpath != NULL)
+	    memcpy(target->sysfs_devpath, env, env_len + 1);
+	}
+      /* We will get a second chance is the user has some sysfs selectors */
+    }
+
+  /* Find matching mapping */
+  mapping = mapping_find(target);
+  if(mapping == NULL)
+    return(-1);
+
+  /* If user specified a new name, keep only interfaces that would
+   * match the new name... */
+  if((new_name != NULL) && (if_match_ifname(mapping->ifname, new_name) != 0))
+    return(-1);
+
+  /* Check if user want only dry-run.
+   * Note that, in the case of wildcard, we don't resolve the wildcard.
+   * That would be tricky to do... */
+  if(dry_run)
+    {
+      strcpy(retname, mapping->ifname);
+      fprintf(stderr, "Dry-run : Would rename %s to %s.\n",
+	      target->ifname, mapping->ifname);
+    }
+  else
+    {
+      /* Change the name of the interface */
+      if(if_set_name(skfd, target->ifname, mapping->ifname, retname) < 0)
+	{
+	  fprintf(stderr, "Error: cannot change name of %s to %s: %s\n",
+		  target->ifname, mapping->ifname, strerror(errno)); 
+	  return(-1);
+	}
+    }
+
+  /* Check if called with an explicit interface name */
+  if(print_newname)
+    {
+      if(!udev_output)
+	/* Always print out the *new* interface name so that
+	 * the calling script can pick it up and know where its interface
+	 * has gone. */
+	printf("%s\n", retname);
+      else
+	/* udev likes to call us as an IMPORT action. This means that
+	 * we need to return udev the environment variables changed.
+	 * Obviously, we don't want to return anything is nothing changed. */
+	if(strcmp(target->ifname, retname))
+	  {
+	    char *	pos;
+	    /* Hack */
+	    if(!target->sysfs_devpath)
+	      mapping_getsysfs(skfd, ifname, target, 0);
+	    /* Update devpath. Size is large enough. */
+	    pos = strrchr(target->sysfs_devpath, '/');
+	    if((pos != NULL) && (!strcmp(target->ifname, pos + 1)))
+	      strcpy(pos + 1, retname);
+	    /* Return new environment variables */
+	    printf("DEVPATH=%s\nINTERFACE=%s\nINTERFACE_OLD=%s\n",
+		   target->sysfs_devpath, retname, target->ifname);
+	  }
+    }
+
+  /* Done */
+  return(0);
+}
+
+/*------------------------------------------------------------------*/
+/*
+ * Process all network interface present on the system.
+ */
+static inline int
+process_iflist(int	skfd,
+	       char *	args[],
+	       int	count)
+{
+  num_takeover = 0;
+
+  /* Just do it */
+  iw_enum_devices(skfd, &process_ifname, args, count);
+
+  /* If we do any takeover, the interface list grabbed with
+   * iw_enum_devices() may get out of sync with the real interfaces,
+   * and we may miss the victim interface. So, let's go through the
+   * list again.
+   * On the other hand, we may have ping pong between two interfaces,
+   * each claiming the same name, so let's not do it forever...
+   * Two time should be enough for most configs...
+   * Jean II */
+  if(force_takeover && num_takeover)
+    /* Play it again, Sam... */
+    iw_enum_devices(skfd, &process_ifname, args, count);
+
+  /* Done */
+  return(0);
+}
+
+/******************************* MAIN *******************************/
+
+
+/*------------------------------------------------------------------*/
+/*
+ */
+static void
+usage(void)
+{
+  fprintf(stderr, "usage: ifrename [-c configurationfile] [-i ifname] [-p] [-t] [-d] [-D]\n");
+  exit(1); 
+}
+
+/*------------------------------------------------------------------*/
+/*
+ * The main !
+ */
+int
+main(int	argc,
+     char *	argv[]) 
+{
+  const char *	conf_file = DEFAULT_CONF;
+  char *	ifname = NULL;
+  int		use_probe = 0;
+  int		is_debian = 0;
+  int		skfd;
+  int		ret;
+
+  /* Loop over all command line options */
+  while(1)
+    {
+      int c = getopt_long(argc, argv, "c:dDi:n:ptuvV", long_opt, NULL);
+      if(c == -1)
+	break;
+
+      switch(c)
+	{ 
+	default:
+	case '?':
+	  usage(); 
+	case 'c':
+	  conf_file = optarg;
+	  break;
+	case 'd':
+	  is_debian = 1;
+	  break;
+	case 'D':
+	  dry_run = 1;
+	  break;
+	case 'i':
+	  ifname = optarg;
+	  break;
+	case 'n':
+	  new_name = optarg;
+	  break;
+	case 'p':
+	  use_probe = 1;
+	  break;
+	case 't':
+	  force_takeover = 1;
+	  break;
+	case 'u':
+	  udev_output = 1;
+	  break;
+	case 'v':
+	  printf("%-8.16s  Wireless-Tools version %d\n", "ifrename", WT_VERSION);
+	  return(0);
+	case 'V':
+	  verbose = 1;
+	  break;
+	}
+    }
+
+  /* Read the specified/default config file, or stdin. */
+  if(mapping_readfile(conf_file) < 0)
+    return(-1);
+
+  /* Create a channel to the NET kernel. */
+  if((skfd = iw_sockets_open()) < 0)
+    {
+      perror("socket");
+      return(-1);
+    }
+
+  /* Check if interface name was specified with -i. */
+  if(ifname != NULL)
+    {
+      /* Check is target name specified */
+      if(new_name != NULL)
+	{
+	  /* User want to simply rename an interface to a specified name */
+	  ret = process_rename(skfd, ifname, new_name);
+	}
+      else
+	{
+	  /* Rename only this interface based on mappings
+	   * Mostly used for HotPlug processing (from /etc/hotplug/net.agent)
+	   * or udev processing (from a udev IMPORT rule).
+	   * Process the network interface specified on the command line,
+	   * and return the new name on stdout.
+	   */
+	  print_newname = 1;
+	  ret = process_ifname(skfd, ifname, NULL, 0);
+	}
+    }
+  else
+    {
+      /* Load all the necesary modules */
+      if(use_probe)
+	{
+	  if(is_debian)
+	    probe_debian(skfd);
+	  else
+	    probe_mappings(skfd);
+	}
+
+      /* Rename all system interfaces
+       * Mostly used for boot time processing (from init scripts).
+       */
+      ret = process_iflist(skfd, NULL, 0);
+    }
+
+  /* Cleanup */
+  iw_sockets_close(skfd);
+  return(ret);
+} 
diff --git a/iftab.5 b/iftab.5
new file mode 100644
index 0000000..b0cc970
--- /dev/null
+++ b/iftab.5
@@ -0,0 +1,313 @@
+.\" Jean II - HPL - 2004-2007
+.\" iftab.5
+.\"
+.TH IFTAB 5 "26 February 2007" "wireless-tools" "Linux Programmer's Manual"
+.\"
+.\" NAME part
+.\"
+.SH NAME
+iftab \- static information about the network interfaces
+.\"
+.\" DESCRIPTION part
+.\"
+.SH DESCRIPTION
+The file
+.B /etc/iftab
+contains descriptive information about the various network interfaces.
+.B iftab
+is only used by the program
+.IR ifrename (8)
+to assign a consistent network interface name to each network interface.
+.PP
+.B /etc/iftab
+defines a set of
+.IR mappings .
+Each mapping contains an interface name and a set of selectors. The
+selectors allow
+.B ifrename
+to identify each network interface on the system. If a network
+interface matches all descriptors of a mapping,
+.B ifrename
+attempt to change the name of the interface to the interface name
+given by the mapping.
+.\"
+.\" MAPPINGS part
+.\"
+.SH MAPPINGS
+Each mapping is described on a separate line, it starts with an
+.IR "interface name" ,
+and contains a set of
+.IR descriptors ,
+separated by space or tabs.
+.PP
+The relationship between descriptors of a mapping is a
+.IR "logical and" .
+A mapping matches a network interface only is all the descriptors
+match. If a network interface doesn't support a specific descriptor,
+it won't match any mappings using this descriptor.
+.PP
+If you want to use alternate descriptors for an interface name
+(logical or), specify two different mappings with the same interface
+name (one on each line).
+.B Ifrename
+always use the first matching mapping starting from the
+.I end
+of
+.BR iftab ,
+therefore more restrictive mapping should be specified last.
+.\"
+.\" INTERFACE NAME part
+.\"
+.SH INTERFACE NAME
+The first part of each mapping is an interface name. If a network
+interface matches all descriptors of a mapping,
+.B ifrename
+attempt to change the name of the interface to the interface name
+given by the mapping.
+.PP
+The interface name of a mapping is either a plain interface name (such as
+.IR eth2 " or " wlan1 )
+or a interface name pattern containing a single wildcard (such as
+.IR eth* " or " wlan* ).
+In case of wildcard, the kernel replace the '*' with the lowest
+available integer making this interface name unique. Note that
+wildcard is only supported for kernel 2.6.1 and 2.4.30 and later.
+.PP
+It is discouraged to try to map interfaces to default interfaces names
+such as
+.IR eth0 ", " wlan0 " or " ppp0 .
+The kernel use those as the default name for any new interface,
+therefore most likely an interface will already use this name and
+prevent ifrename to use it. Even if you use takeover, the interface
+may already be up in some cases. Not using those name will allow you
+to immediately spot unconfigured or new interfaces.
+.br
+Good names are either totally unique and meaningfull,
+such as
+.IR mydsl " or " privatehub ,
+or use larger integer, such as
+.IR eth5 " or " wlan5 .
+The second type is usually easier to integrate in various network utilities.
+.\"
+.\" DESCRIPTORS part
+.\"
+.SH DESCRIPTORS
+Each descriptor is composed of a descriptor name and descriptor
+value. Descriptors specify a static attribute of a network interface,
+the goal is to uniquely identify each piece of hardware.
+.PP
+Most users will only use the
+.B mac
+selector despite its potential problems, other selectors are for more
+specialised setup. Most selectors accept a '*' in the selector value
+for wilcard matching, and most selectors are case insensitive.
+.TP
+.BI mac " mac address"
+Matches the MAC Address of the interface with the specified MAC
+address. The MAC address of the interface can be shown using
+.IR ifconfig (8)
+or
+.IR ip (8).
+.br
+This is the most common selector, as most interfaces have a unique MAC
+address allowing to identify network interfaces without ambiguity.
+However, some interfaces don't have a valid MAC address until they are
+brought up, in such case using this selector is tricky or impossible.
+.TP
+.BI arp " arp type"
+Matches the ARP Type (also called Link Type) of the interface with the
+specified ARP type as a number. The ARP Type of the interface can be
+shown using
+.IR ifconfig (8)
+or
+.IR ip (8),
+the
+.B link/ether
+type correspond to
+.B 1
+and the
+.B link/ieee802.11
+type correspond to
+.BR 801 .
+.br
+This selector is useful when a driver create multiple network
+interfaces for a single network card.
+.TP
+.BI driver " driver name"
+Matches the Driver Name of the interface with the specified driver
+name. The Driver Name of the interface can be shown using
+.IR "ethtool -i" (8).
+.TP
+.BI businfo " bus information"
+Matches the Bus Information of the interface with the specified bus
+information. The Bus Information of the interface can be shown using
+.IR "ethtool -i" (8).
+.TP
+.BI firmware " firmware revision"
+Matches the Firmware Revision of the interface with the firmware
+revision information. The Firmware Revision of the interface can be
+shown using
+.IR "ethtool -i" (8).
+.TP
+.BI baseaddress " base address"
+Matches the Base Address of the interface with the specified base
+address. The Base Address of the interface can be shown using
+.IR ifconfig (8).
+.br
+Because most cards use dynamic allocation of the Base Address, this
+selector is only useful for ISA and EISA cards.
+.TP
+.BI irq " irq line"
+Matches the IRQ Line (interrupt) of the interface with the specified
+IRQ line. The IRQ Line of the interface can be shown using
+.IR ifconfig (8).
+.br
+Because there are IRQ Lines may be shared, this selector is usually
+not sufficient to uniquely identify an interface.
+.TP
+.BI iwproto " wireless protocol"
+Matches the Wireless Protocol of the interface with the specified
+wireless protocol. The Wireless Protocol of the interface can be shown
+using
+.IR iwconfig (8)
+or
+.IR iwgetid (8).
+.br
+This selector is only supported on wireless interfaces and is not
+sufficient to uniquely identify an interface.
+.TP
+.BI pcmciaslot " pcmcia slot"
+Matches the Pcmcia Socket number of the interface with the specified
+slot number. Pcmcia Socket number of the interface can be shown
+using
+.IR "cardctl ident" (8).
+.br
+This selector is usually only supported on 16 bits cards, for 32 bits
+cards it is advised to use the selector
+.BR businfo .
+.TP
+.BI prevname " previous interface name"
+Matches the name of the interface prior to renaming with the specified
+oldname.
+.br
+This selector should be avoided as the previous interface name may
+vary depending on various condition. A system/kernel/driver update may
+change the original name. Then, ifrename or another tool may rename it
+prior to the execution of this selector.
+.TP
+.BI SYSFS{ filename } " value"
+Matches the content the sysfs attribute given by filename to the
+specified value. For symlinks and parents directories, match the
+actual directory name of the sysfs attribute given by filename to the
+specified value.
+.br
+A list of the most useful sysfs attributes is given in the next
+section.
+.\"
+.\" SYSFS DESCRIPTORS part
+.\"
+.SH SYSFS DESCRIPTORS
+Sysfs attributes for a specific interface are located on most systems
+in the directory named after that interface at
+.IR /sys/class/net/ .
+Most sysfs attribute are files, and their values can be read using
+.IR cat "(1) or " more (1).
+It is also possible to match attributes in subdirectories.
+.PP
+Some sysfs attributes are symlinks, pointing to another directory in
+sysfs. If the attribute filename is a symlink the sysfs attribute
+resolves to the name of the directory pointed by the symlink using
+.IR readlink (1).
+The location is a directory in the sysfs tree is also important. If
+the attribute filename ends with
+.IR /.. ,
+the sysfs attribute resolves to the real name of the parent directory
+using
+.IR pwd (1).
+.PP
+The sysfs filesystem is only supported with 2.6.X kernel and need to
+be mounted (usually in 
+.IR /sys ).
+sysfs selectors are not as efficient as other selectors, therefore
+they should be avoided for maximum performance.
+.PP
+These are common sysfs attributes and their corresponding ifrename
+descriptors.
+.TP
+.BI SYSFS{address} " value"
+Same as the
+.B mac
+descriptor.
+.TP
+.BI SYSFS{type} " value"
+Same as the
+.B arp
+descriptor.
+.TP
+.BI SYSFS{device} " value"
+Valid only up to kernel 2.6.20. Same as the
+.B businfo
+descriptor.
+.TP
+.BI SYSFS{..} " value"
+Valid only from kernel 2.6.21. Same as the
+.B businfo
+descriptor.
+.TP
+.BI SYSFS{device/driver} " value"
+Valid only up to kernel 2.6.20. Same as the
+.B driver
+descriptor.
+.TP
+.BI SYSFS{../driver} " value"
+Valid only from kernel 2.6.21. Same as the
+.B driver
+descriptor.
+.TP
+.BI SYSFS{device/irq} " value"
+Valid only up to kernel 2.6.20. Same as the
+.B irq
+descriptor.
+.TP
+.BI SYSFS{../irq} " value"
+Valid only from kernel 2.6.21. Same as the
+.B irq
+descriptor.
+.\"
+.\" EXAMPLES part
+.\"
+.SH EXAMPLES
+# This is a comment
+.br
+eth2		mac 08:00:09:DE:82:0E
+.br
+eth3		driver wavelan interrupt 15 baseaddress 0x390
+.br
+eth4		driver pcnet32 businfo 0000:02:05.0
+.br
+air*		mac 00:07:0E:* arp 1
+.br
+myvpn	SYSFS{address} 00:10:83:* SYSFS{type} 1
+.br
+bcm*		SYSFS{device} 0000:03:00.0 SYSFS{device/driver} bcm43xx
+.br
+bcm*		SYSFS{..} 0000:03:00.0 SYSFS{../driver} bcm43xx
+.\"
+.\" AUTHOR part
+.\"
+.SH AUTHOR
+Jean Tourrilhes \- jt@hpl.hp.com
+.\"
+.\" FILES part
+.\"
+.SH FILES
+.I /etc/iftab
+.\"
+.\" SEE ALSO part
+.\"
+.SH SEE ALSO
+.BR ifrename (8),
+.BR ifconfig (8),
+.BR ip (8),
+.BR ethtool (8),
+.BR iwconfig (8).
diff --git a/iwconfig.8 b/iwconfig.8
new file mode 100644
index 0000000..f43c2b8
--- /dev/null
+++ b/iwconfig.8
@@ -0,0 +1,609 @@
+.\" Jean II - HPLB - 1996 => HPL - 2004
+.\" iwconfig.8
+.\"
+.TH IWCONFIG 8 "30 March 2006" "wireless-tools" "Linux Programmer's Manual"
+.\"
+.\" NAME part
+.\"
+.SH NAME
+iwconfig \- configure a wireless network interface
+.\"
+.\" SYNOPSIS part
+.\"
+.SH SYNOPSIS
+.BI "iwconfig [" interface ]
+.br
+.BI "iwconfig " interface " [essid " X "] [nwid " N "] [mode " M "] [freq " F "]
+.br
+.BI "                   [channel " C ] [sens " S "] [ap " A "] [nick " NN ]
+.br
+.BI "                   [rate " R "] [rts " RT "] [frag " FT "] [txpower " T ]
+.br
+.BI "                   [enc " E "] [key " K "] [power " P "] [retry " R ]
+.br
+.BI "                   [modu " M "] [commit]
+.br
+.BI "iwconfig --help"
+.br
+.BI "iwconfig --version"
+.\"
+.\" DESCRIPTION part
+.\"
+.SH DESCRIPTION
+.B Iwconfig
+is similar to
+.IR ifconfig (8),
+but is dedicated to the wireless interfaces. It is used to set the
+parameters of the network interface which are specific to the wireless
+operation (for example : the frequency).
+.B Iwconfig
+may also be used to display those parameters, and the wireless
+statistics (extracted from
+.IR /proc/net/wireless ).
+.PP
+All these parameters and statistics are device dependent. Each driver
+will provide only some of them depending on hardware support, and the
+range of values may change. Please refer to the man page of each
+device for details.
+.\"
+.\" PARAMETER part
+.\"
+.SH PARAMETERS
+.TP
+.B essid
+Set the ESSID (or Network Name - in some products it may also be
+called Domain ID). The ESSID is used to identify cells which are part
+of the same virtual network.
+.br
+As opposed to the AP Address or NWID which define a single cell, the
+ESSID defines a group of cells connected via repeaters or
+infrastructure, where the user may roam transparently.
+.br
+With some cards, you may disable the ESSID checking (ESSID
+promiscuous) with
+.IR off " or " any " (and " on
+to reenable it).
+.br
+If the ESSID of your network is one of the special keywords
+.RI ( off ", " on " or " any ),
+you should use
+.I --
+to escape it.
+.br
+.B Examples :
+.br
+.I "	iwconfig eth0 essid any"
+.br
+.I "	iwconfig eth0 essid ""My Network""
+.br
+.I "	iwconfig eth0 essid -- ""ANY""
+.TP
+.BR nwid
+Set the Network ID. As all adjacent wireless networks share the same
+medium, this parameter is used to differentiate them (create logical
+colocated networks) and identify nodes belonging to the same cell.
+.br
+This parameter is only used for pre-802.11 hardware, the 802.11
+protocol uses the ESSID and AP Address for this function.
+.br
+With some cards, you may disable the Network ID checking (NWID
+promiscuous) with
+.IR off " (and " on
+to reenable it).
+.br
+.B Examples :
+.br
+.I "	iwconfig eth0 nwid AB34
+.br
+.I "	iwconfig eth0 nwid off"
+.TP
+.BR nick [name]
+Set the nickname, or the station name. Some 802.11 products do define
+it, but this is not used as far as the protocols (MAC, IP, TCP) are
+concerned and completely useless as far as configuration goes. Only
+some wireless diagnostic tools may use it.
+.br
+.B Example :
+.br
+.I "	iwconfig eth0 nickname ""My Linux Node""
+.TP
+.B mode
+Set the operating mode of the device, which depends on the network
+topology. The mode can be
+.I Ad-Hoc
+(network composed of only one cell and without Access Point),
+.I Managed
+(node connects to a network composed of many Access Points, with roaming),
+.I Master
+(the node is the synchronisation master or acts as an Access Point),
+.I Repeater
+(the node forwards packets between other wireless nodes),
+.I Secondary
+(the node acts as a backup master/repeater),
+.I Monitor
+(the node is not associated with any cell and passively monitor all
+packets on the frequency) or
+.IR Auto .
+.br
+.B Example :
+.br
+.I "	iwconfig eth0 mode Managed"
+.br
+.I "	iwconfig eth0 mode Ad-Hoc"
+.TP
+.BR freq / channel
+Set the operating frequency or channel in the device. A value below
+1000 indicates a channel number, a value greater than 1000 is a
+frequency in Hz. You may append the suffix k, M or G to the value (for
+example, "2.46G" for 2.46 GHz frequency), or add enough '0'.
+.br
+Channels are usually numbered starting at 1, and you may use
+.IR iwlist (8)
+to get the total number of channels, list the available frequencies,
+and display the current frequency as a channel. Depending on
+regulations, some frequencies/channels may not be available.
+.br
+When using Managed mode, most often the Access Point dictates the
+channel and the driver may refuse the setting of the frequency. In
+Ad-Hoc mode, the frequency setting may only be used at initial cell
+creation, and may be ignored when joining an existing cell.
+.br
+You may also use
+.I off
+or
+.I auto
+to let the card pick up the best channel (when supported).
+.br
+.B Examples :
+.br
+.I "	iwconfig eth0 freq 2422000000"
+.br
+.I "	iwconfig eth0 freq 2.422G"
+.br
+.I "	iwconfig eth0 channel 3"
+.br
+.I "	iwconfig eth0 channel auto"
+.TP
+.B ap
+Force the card to register to the Access Point given by the address,
+if it is possible. This address is the cell identity of the Access
+Point, as reported by wireless scanning, which may be different from
+its network MAC address. If the wireless link is point to point, set
+the address of the other end of the link. If the link is ad-hoc, set
+the cell identity of the ad-hoc network.
+.br
+When the quality of the connection goes too low, the driver may revert
+back to automatic mode (the card selects the best Access Point in
+range).
+.br
+You may also use
+.I off
+to re-enable automatic mode without changing the current Access Point,
+or you may use
+.I any
+or
+.I auto
+to force the card to reassociate with the currently best Access Point.
+.br
+.B Example :
+.br
+.I "	iwconfig eth0 ap 00:60:1D:01:23:45"
+.br
+.I "	iwconfig eth0 ap any"
+.br
+.I "	iwconfig eth0 ap off"
+.TP
+.BR rate / bit [rate]
+For cards supporting multiple bit rates, set the bit-rate in b/s. The
+bit-rate is the speed at which bits are transmitted over the medium,
+the user speed of the link is lower due to medium sharing and
+various overhead.
+.br
+You may append the suffix k, M or G to the value (decimal multiplier :
+10^3, 10^6 and 10^9 b/s), or add enough '0'. Values below 1000 are
+card specific, usually an index in the bit-rate list. Use
+.I auto
+to select automatic bit-rate mode (fallback to lower rate on noisy
+channels), which is the default for most cards, and
+.I fixed
+to revert back to fixed setting. If you specify a bit-rate value and append
+.IR auto ,
+the driver will use all bit-rates lower and equal than this value.
+.br
+.B Examples :
+.br
+.I "	iwconfig eth0 rate 11M"
+.br
+.I "	iwconfig eth0 rate auto"
+.br
+.I "	iwconfig eth0 rate 5.5M auto"
+.TP
+.BR txpower
+For cards supporting multiple transmit powers, sets the transmit power
+in dBm. If
+.I W
+is the power in Watt, the power in dBm is
+.IR "P = 30 + 10.log(W)" .
+If the value is postfixed by
+.IR mW ,
+it will be automatically converted to dBm.
+.br
+In addition, 
+.IR on " and " off
+enable and disable the radio, and
+.IR auto " and " fixed
+enable and disable power control (if those features are available).
+.br
+.B Examples :
+.br
+.I "	iwconfig eth0 txpower 15"
+.br
+.I "	iwconfig eth0 txpower 30mW"
+.br
+.I "	iwconfig eth0 txpower auto"
+.br
+.I "	iwconfig eth0 txpower off"
+.TP
+.B sens
+Set the sensitivity threshold. This define how sensitive is the card
+to poor operating conditions (low signal, interference). Positive
+values are assumed to be the raw value used by the hardware or a
+percentage, negative values are assumed to be dBm. Depending on the
+hardware implementation, this parameter may control various functions.
+.br
+On modern cards, this parameter usually control handover/roaming
+threshold, the lowest signal level for which the hardware remains
+associated with the current Access Point. When the signal level goes
+below this threshold the card starts looking for a new/better Access
+Point. Some cards may use the number of missed beacons to trigger
+this. For high density of Access Points, a higher threshold make sure
+the card is always associated with the best AP, for low density of
+APs, a lower threshold minimise the number of failed handoffs.
+.br
+On more ancient card this parameter usually controls the defer
+threshold, the lowest signal level for which the hardware considers
+the channel busy. Signal levels above this threshold make the hardware
+inhibits its own transmission whereas signals weaker than this are
+ignored and the hardware is free to transmit. This is usually strongly
+linked to the receive threshold, the lowest signal level for which the
+hardware attempts packet reception. Proper setting of these thresholds
+prevent the card to waste time on background noise while still
+receiving weak transmissions. Modern designs seems to control those
+thresholds automatically.
+.br
+.br
+.B Example :
+.br
+.I "	iwconfig eth0 sens -80"
+.br
+.I "	iwconfig eth0 sens 2"
+.TP
+.BR retry
+Most cards have MAC retransmissions, and some allow to set the
+behaviour of the retry mechanism.
+.br
+To set the maximum number of retries, enter
+.IR "limit `value'" .
+This is an absolute value (without unit), and the default (when
+nothing is specified).
+To set the maximum length of time the MAC should retry, enter
+.IR "lifetime `value'" .
+By defaults, this value in in seconds, append the suffix m or u to
+specify values in milliseconds or microseconds.
+.br
+You can also add the
+.IR short ", " long ", " min " and " max
+modifiers. If the card supports automatic mode, they define the bounds
+of the limit or lifetime. Some other cards define different values
+depending on packet size, for example in 802.11
+.I min limit
+is the short retry limit (non RTS/CTS packets).
+.br
+.B Examples :
+.br
+.I "	iwconfig eth0 retry 16"
+.br
+.I "	iwconfig eth0 retry lifetime 300m"
+.br
+.I "	iwconfig eth0 retry short 12"
+.br
+.I "	iwconfig eth0 retry min limit 8"
+.TP
+.BR rts [_threshold]
+RTS/CTS adds a handshake before each packet transmission to make sure
+that the channel is clear. This adds overhead, but increases
+performance in case of hidden nodes or a large number of active
+nodes. This parameter sets the size of the smallest packet for which
+the node sends RTS ; a value equal to the maximum packet size disables
+the mechanism. You may also set this parameter to
+.IR auto ", " fixed " or " off .
+.br
+.B Examples :
+.br
+.I "	iwconfig eth0 rts 250"
+.br
+.I "	iwconfig eth0 rts off"
+.TP
+.BR frag [mentation_threshold]
+Fragmentation allows to split an IP packet in a burst of smaller
+fragments transmitted on the medium. In most cases this adds overhead,
+but in a very noisy environment this reduces the error penalty and
+allow packets to get through interference bursts. This parameter sets
+the maximum fragment size which is always lower than the maximum
+packet size.
+.br
+This parameter may also control Frame Bursting available on some
+cards, the ability to send multiple IP packets together. This
+mechanism would be enabled if the fragment size is larger than the
+maximum packet size.
+.br
+You may also set this parameter to
+.IR auto ", " fixed " or " off .
+.br
+.B Examples :
+.br
+.I "	iwconfig eth0 frag 512"
+.br
+.I "	iwconfig eth0 frag off"
+.TP
+.BR key / enc [ryption]
+Used to manipulate encryption or scrambling keys and security mode.
+.br
+To set the current encryption key, just enter the key in hex digits as
+.IR XXXX-XXXX-XXXX-XXXX " or " XXXXXXXX .
+To set a key other than the current key, prepend or append
+.I [index]
+to the key itself (this won't change which is the active key). You can
+also enter the key as an ASCII string by using the
+.I s:
+prefix. Passphrase is currently not supported.
+.br
+To change which key is the currently active key, just enter
+.I [index]
+(without entering any key value).
+.br
+.IR off " and " on
+disable and reenable encryption.
+.br
+The security mode may be
+.I open
+or
+.IR restricted ,
+and its meaning depends on the card used. With most cards, in
+.I open
+mode no authentication is used and the card may also accept
+non-encrypted sessions, whereas in
+.I restricted
+mode only encrypted sessions are accepted and the card will use
+authentication if available.
+.br
+If you need to set multiple keys, or set a key and change the active
+key, you need to use multiple
+.B key
+directives. Arguments can be put in any order, the last one will take
+precedence.
+.br
+.B Examples :
+.br
+.I "	iwconfig eth0 key 0123-4567-89"
+.br
+.I "	iwconfig eth0 key [3] 0123-4567-89"
+.br
+.I "	iwconfig eth0 key s:password [2]"
+.br
+.I "	iwconfig eth0 key [2]"
+.br
+.I "	iwconfig eth0 key open"
+.br
+.I "	iwconfig eth0 key off"
+.br
+.I "	iwconfig eth0 key restricted [3] 0123456789"
+.br
+.I "	iwconfig eth0 key 01-23 key 45-67 [4] key [4]"
+.TP
+.BR power
+Used to manipulate power management scheme parameters and mode.
+.br
+To set the period between wake ups, enter
+.IR "period `value'" .
+To set the timeout before going back to sleep, enter
+.IR "timeout `value'" .
+To set the generic level of power saving, enter
+.IR "saving `value'" .
+You can also add the
+.IR min " and " max
+modifiers. By default, those values are in seconds, append the suffix
+m or u to specify values in milliseconds or microseconds. Sometimes,
+those values are without units (number of beacon periods, dwell,
+percentage or similar).
+.br
+.IR off " and " on
+disable and reenable power management. Finally, you may set the power
+management mode to
+.I all
+(receive all packets),
+.I unicast
+(receive unicast packets only, discard multicast and broadcast) and
+.I multicast
+(receive multicast and broadcast only, discard unicast packets).
+.br
+.B Examples :
+.br
+.I "	iwconfig eth0 power period 2"
+.br
+.I "	iwconfig eth0 power 500m unicast"
+.br
+.I "	iwconfig eth0 power timeout 300u all"
+.br
+.I "	iwconfig eth0 power saving 3"
+.br
+.I "	iwconfig eth0 power off"
+.br
+.I "	iwconfig eth0 power min period 2 power max period 4"
+.TP
+.BR modu [lation]
+Force the card to use a specific set of modulations. Modern cards
+support various modulations, some which are standard, such as 802.11b
+or 802.11g, and some proprietary. This command force the card to only
+use the specific set of modulations listed on the command line. This
+can be used to fix interoperability issues.
+.br
+The list of available modulations depend on the card/driver and can be
+displayed using
+.IR "iwlist modulation" .
+Note that some card/driver may not be able to select each modulation
+listed independantly, some may come as a group. You may also set this
+parameter to
+.IR auto
+let the card/driver do its best.
+.br
+.B Examples :
+.br
+.I "	iwconfig eth0 modu 11g"
+.br
+.I "	iwconfig eth0 modu CCK OFDMa"
+.br
+.I "	iwconfig eth0 modu auto"
+.TP
+.BR commit
+Some cards may not apply changes done through Wireless Extensions
+immediately (they may wait to aggregate the changes or apply it only
+when the card is brought up via
+.IR ifconfig ).
+This command (when available) forces the card to apply all pending
+changes.
+.br
+This is normally not needed, because the card will eventually apply
+the changes, but can be useful for debugging.
+.\"
+.\" DISPLAY part
+.\"
+.SH DISPLAY
+For each device which supports wireless extensions,
+.I iwconfig
+will display the name of the
+.B MAC protocol
+used (name of device for proprietary protocols), the
+.B ESSID
+(Network Name), the
+.BR NWID ,
+the
+.B frequency
+(or channel), the
+.BR sensitivity ,
+the
+.B mode
+of operation, the
+.B Access Point
+address, the
+.BR bit-rate ,
+the
+.BR "RTS threshold" ", the " "fragmentation threshold" ,
+the
+.B encryption key
+and the
+.B power management
+settings (depending on availability).
+.PP
+The parameters displayed have the same meaning and values as the
+parameters you can set, please refer to the previous part for a
+detailed explanation of them.
+.br
+Some parameters are only displayed in short/abbreviated form (such as
+encryption). You may use
+.IR iwlist (8)
+to get all the details.
+.br
+Some parameters have two modes (such as bitrate). If the value is
+prefixed by
+.RB ` = ',
+it means that the parameter is fixed and forced to that value, if it
+is prefixed by
+.RB ` : ',
+the parameter is in automatic mode and the current value is shown (and
+may change).
+.TP
+.BR "Access Point" / Cell
+An address equal to 00:00:00:00:00:00 means that the card failed to
+associate with an Access Point (most likely a configuration
+issue). The
+.B Access Point
+parameter will be shown as
+.B Cell
+in ad-hoc mode (for obvious reasons), but otherwise works the same.
+.PP
+If
+.I /proc/net/wireless
+exists,
+.I iwconfig
+will also display its content. Note that those values will depend on
+the driver and the hardware specifics, so you need to refer to your
+driver documentation for proper interpretation of those values.
+.TP
+.B Link quality
+Overall quality of the link. May be based on the level of contention
+or interference, the bit or frame error rate, how good the received
+signal is, some timing synchronisation, or other hardware metric. This
+is an aggregate value, and depends totally on the driver and hardware.
+.TP
+.B Signal level
+Received signal strength (RSSI - how strong the received signal
+is). May be arbitrary units or dBm,
+.I iwconfig
+uses driver meta information to interpret the raw value given by
+.I /proc/net/wireless
+and display the proper unit or maximum value (using 8 bit arithmetic). In
+.I Ad-Hoc
+mode, this may be undefined and you should use
+.IR iwspy .
+.TP
+.B Noise level
+Background noise level (when no packet is transmitted). Similar
+comments as for
+.BR "Signal level" .
+.TP
+.B Rx invalid nwid
+Number of packets received with a different NWID or ESSID. Used to
+detect configuration problems or adjacent network existence (on the
+same frequency).
+.TP
+.B Rx invalid crypt
+Number of packets that the hardware was unable to decrypt. This can be
+used to detect invalid encryption settings.
+.TP
+.B Rx invalid frag
+Number of packets for which the hardware was not able to properly
+re-assemble the link layer fragments (most likely one was missing).
+.TP
+.B Tx excessive retries
+Number of packets that the hardware failed to deliver. Most MAC
+protocols will retry the packet a number of times before giving up.
+.TP
+.B Invalid misc
+Other packets lost in relation with specific wireless operations.
+.TP
+.B Missed beacon
+Number of periodic beacons from the Cell or the Access Point we have
+missed. Beacons are sent at regular intervals to maintain the cell
+coordination, failure to receive them usually indicates that the card
+is out of range.
+.\"
+.\" AUTHOR part
+.\"
+.SH AUTHOR
+Jean Tourrilhes \- jt@hpl.hp.com
+.\"
+.\" FILES part
+.\"
+.SH FILES
+.I /proc/net/wireless
+.\"
+.\" SEE ALSO part
+.\"
+.SH SEE ALSO
+.BR ifconfig (8),
+.BR iwspy (8),
+.BR iwlist (8),
+.BR iwevent (8),
+.BR iwpriv (8),
+.BR wireless (7).
diff --git a/iwconfig.c b/iwconfig.c
new file mode 100644
index 0000000..d01f29a
--- /dev/null
+++ b/iwconfig.c
@@ -0,0 +1,1954 @@
+/*
+ *	Wireless Tools
+ *
+ *		Jean II - HPLB 97->99 - HPL 99->07
+ *
+ * Main code for "iwconfig". This is the generic tool for most
+ * manipulations...
+ * You need to link this code against "iwlib.c" and "-lm".
+ *
+ * This file is released under the GPL license.
+ *     Copyright (c) 1997-2007 Jean Tourrilhes <jt@hpl.hp.com>
+ */
+
+#include "iwlib.h"		/* Header */
+
+/**************************** CONSTANTS ****************************/
+
+/*
+ * Error codes defined for setting args
+ */
+#define IWERR_ARG_NUM		-2
+#define IWERR_ARG_TYPE		-3
+#define IWERR_ARG_SIZE		-4
+#define IWERR_ARG_CONFLICT	-5
+#define IWERR_SET_EXT		-6
+#define IWERR_GET_EXT		-7
+
+/**************************** VARIABLES ****************************/
+
+/*
+ * Ugly, but deal with errors in set_info() efficiently...
+ */
+static int	errarg;
+static int	errmax;
+
+/************************* DISPLAY ROUTINES **************************/
+
+/*------------------------------------------------------------------*/
+/*
+ * Get wireless informations & config from the device driver
+ * We will call all the classical wireless ioctl on the driver through
+ * the socket to know what is supported and to get the settings...
+ */
+static int
+get_info(int			skfd,
+	 char *			ifname,
+	 struct wireless_info *	info)
+{
+  struct iwreq		wrq;
+
+  memset((char *) info, 0, sizeof(struct wireless_info));
+
+  /* Get basic information */
+  if(iw_get_basic_config(skfd, ifname, &(info->b)) < 0)
+    {
+      /* If no wireless name : no wireless extensions */
+      /* But let's check if the interface exists at all */
+      struct ifreq ifr;
+
+      strncpy(ifr.ifr_name, ifname, IFNAMSIZ);
+      if(ioctl(skfd, SIOCGIFFLAGS, &ifr) < 0)
+	return(-ENODEV);
+      else
+	return(-ENOTSUP);
+    }
+
+  /* Get ranges */
+  if(iw_get_range_info(skfd, ifname, &(info->range)) >= 0)
+    info->has_range = 1;
+
+  /* Get AP address */
+  if(iw_get_ext(skfd, ifname, SIOCGIWAP, &wrq) >= 0)
+    {
+      info->has_ap_addr = 1;
+      memcpy(&(info->ap_addr), &(wrq.u.ap_addr), sizeof (sockaddr));
+    }
+
+  /* Get bit rate */
+  if(iw_get_ext(skfd, ifname, SIOCGIWRATE, &wrq) >= 0)
+    {
+      info->has_bitrate = 1;
+      memcpy(&(info->bitrate), &(wrq.u.bitrate), sizeof(iwparam));
+    }
+
+  /* Get Power Management settings */
+  wrq.u.power.flags = 0;
+  if(iw_get_ext(skfd, ifname, SIOCGIWPOWER, &wrq) >= 0)
+    {
+      info->has_power = 1;
+      memcpy(&(info->power), &(wrq.u.power), sizeof(iwparam));
+    }
+
+  /* Get stats */
+  if(iw_get_stats(skfd, ifname, &(info->stats),
+		  &info->range, info->has_range) >= 0)
+    {
+      info->has_stats = 1;
+    }
+
+#ifndef WE_ESSENTIAL
+  /* Get NickName */
+  wrq.u.essid.pointer = (caddr_t) info->nickname;
+  wrq.u.essid.length = IW_ESSID_MAX_SIZE + 1;
+  wrq.u.essid.flags = 0;
+  if(iw_get_ext(skfd, ifname, SIOCGIWNICKN, &wrq) >= 0)
+    if(wrq.u.data.length > 1)
+      info->has_nickname = 1;
+
+  if((info->has_range) && (info->range.we_version_compiled > 9))
+    {
+      /* Get Transmit Power */
+      if(iw_get_ext(skfd, ifname, SIOCGIWTXPOW, &wrq) >= 0)
+	{
+	  info->has_txpower = 1;
+	  memcpy(&(info->txpower), &(wrq.u.txpower), sizeof(iwparam));
+	}
+    }
+
+  /* Get sensitivity */
+  if(iw_get_ext(skfd, ifname, SIOCGIWSENS, &wrq) >= 0)
+    {
+      info->has_sens = 1;
+      memcpy(&(info->sens), &(wrq.u.sens), sizeof(iwparam));
+    }
+
+  if((info->has_range) && (info->range.we_version_compiled > 10))
+    {
+      /* Get retry limit/lifetime */
+      if(iw_get_ext(skfd, ifname, SIOCGIWRETRY, &wrq) >= 0)
+	{
+	  info->has_retry = 1;
+	  memcpy(&(info->retry), &(wrq.u.retry), sizeof(iwparam));
+	}
+    }
+
+  /* Get RTS threshold */
+  if(iw_get_ext(skfd, ifname, SIOCGIWRTS, &wrq) >= 0)
+    {
+      info->has_rts = 1;
+      memcpy(&(info->rts), &(wrq.u.rts), sizeof(iwparam));
+    }
+
+  /* Get fragmentation threshold */
+  if(iw_get_ext(skfd, ifname, SIOCGIWFRAG, &wrq) >= 0)
+    {
+      info->has_frag = 1;
+      memcpy(&(info->frag), &(wrq.u.frag), sizeof(iwparam));
+    }
+#endif	/* WE_ESSENTIAL */
+
+  return(0);
+}
+
+/*------------------------------------------------------------------*/
+/*
+ * Print on the screen in a neat fashion all the info we have collected
+ * on a device.
+ */
+static void
+display_info(struct wireless_info *	info,
+	     char *			ifname)
+{
+  char		buffer[128];	/* Temporary buffer */
+
+  /* One token is more of less 5 characters, 14 tokens per line */
+  int	tokens = 3;	/* For name */
+
+  /* Display device name and wireless name (name of the protocol used) */
+  printf("%-8.16s  %s  ", ifname, info->b.name);
+
+  /* Display ESSID (extended network), if any */
+  if(info->b.has_essid)
+    {
+      if(info->b.essid_on)
+	{
+	  /* Does it have an ESSID index ? */
+	  if((info->b.essid_on & IW_ENCODE_INDEX) > 1)
+	    printf("ESSID:\"%s\" [%d]  ", info->b.essid,
+		   (info->b.essid_on & IW_ENCODE_INDEX));
+	  else
+	    printf("ESSID:\"%s\"  ", info->b.essid);
+	}
+      else
+	printf("ESSID:off/any  ");
+    }
+
+#ifndef WE_ESSENTIAL
+  /* Display NickName (station name), if any */
+  if(info->has_nickname)
+    printf("Nickname:\"%s\"", info->nickname);
+#endif	/* WE_ESSENTIAL */
+
+  /* Formatting */
+  if(info->b.has_essid || info->has_nickname)
+    {
+      printf("\n          ");
+      tokens = 0;
+    }
+
+#ifndef WE_ESSENTIAL
+  /* Display Network ID */
+  if(info->b.has_nwid)
+    {
+      /* Note : should display proper number of digits according to info
+       * in range structure */
+      if(info->b.nwid.disabled)
+	printf("NWID:off/any  ");
+      else
+	printf("NWID:%X  ", info->b.nwid.value);
+      tokens +=2;
+    }
+#endif	/* WE_ESSENTIAL */
+
+  /* Display the current mode of operation */
+  if(info->b.has_mode)
+    {
+      printf("Mode:%s  ", iw_operation_mode[info->b.mode]);
+      tokens +=3;
+    }
+
+  /* Display frequency / channel */
+  if(info->b.has_freq)
+    {
+      double		freq = info->b.freq;	/* Frequency/channel */
+      int		channel = -1;		/* Converted to channel */
+      /* Some drivers insist of returning channel instead of frequency.
+       * This fixes them up. Note that, driver should still return
+       * frequency, because other tools depend on it. */
+      if(info->has_range && (freq < KILO))
+	channel = iw_channel_to_freq((int) freq, &freq, &info->range);
+      /* Display */
+      iw_print_freq(buffer, sizeof(buffer), freq, -1, info->b.freq_flags);
+      printf("%s  ", buffer);
+      tokens +=4;
+    }
+
+  /* Display the address of the current Access Point */
+  if(info->has_ap_addr)
+    {
+      /* A bit of clever formatting */
+      if(tokens > 8)
+	{
+	  printf("\n          ");
+	  tokens = 0;
+	}
+      tokens +=6;
+
+      /* Oups ! No Access Point in Ad-Hoc mode */
+      if((info->b.has_mode) && (info->b.mode == IW_MODE_ADHOC))
+	printf("Cell:");
+      else
+	printf("Access Point:");
+      printf(" %s   ", iw_sawap_ntop(&info->ap_addr, buffer));
+    }
+
+  /* Display the currently used/set bit-rate */
+  if(info->has_bitrate)
+    {
+      /* A bit of clever formatting */
+      if(tokens > 11)
+	{
+	  printf("\n          ");
+	  tokens = 0;
+	}
+      tokens +=3;
+
+      /* Display it */
+      iw_print_bitrate(buffer, sizeof(buffer), info->bitrate.value);
+      printf("Bit Rate%c%s   ", (info->bitrate.fixed ? '=' : ':'), buffer);
+    }
+
+#ifndef WE_ESSENTIAL
+  /* Display the Transmit Power */
+  if(info->has_txpower)
+    {
+      /* A bit of clever formatting */
+      if(tokens > 11)
+	{
+	  printf("\n          ");
+	  tokens = 0;
+	}
+      tokens +=3;
+
+      /* Display it */
+      iw_print_txpower(buffer, sizeof(buffer), &info->txpower);
+      printf("Tx-Power%c%s   ", (info->txpower.fixed ? '=' : ':'), buffer);
+    }
+
+  /* Display sensitivity */
+  if(info->has_sens)
+    {
+      /* A bit of clever formatting */
+      if(tokens > 10)
+	{
+	  printf("\n          ");
+	  tokens = 0;
+	}
+      tokens +=4;
+
+      /* Fixed ? */
+      printf("Sensitivity%c", info->sens.fixed ? '=' : ':');
+
+      if(info->has_range)
+	/* Display in dBm ? */
+	if(info->sens.value < 0)
+	  printf("%d dBm  ", info->sens.value);
+	else
+	  printf("%d/%d  ", info->sens.value, info->range.sensitivity);
+      else
+	printf("%d  ", info->sens.value);
+    }
+#endif	/* WE_ESSENTIAL */
+
+  printf("\n          ");
+  tokens = 0;
+
+#ifndef WE_ESSENTIAL
+  /* Display retry limit/lifetime information */
+  if(info->has_retry)
+    { 
+      printf("Retry");
+      /* Disabled ? */
+      if(info->retry.disabled)
+	printf(":off");
+      else
+	{
+	  /* Let's check the value and its type */
+	  if(info->retry.flags & IW_RETRY_TYPE)
+	    {
+	      iw_print_retry_value(buffer, sizeof(buffer),
+				   info->retry.value, info->retry.flags,
+				   info->range.we_version_compiled);
+	      printf("%s", buffer);
+	    }
+
+	  /* Let's check if nothing (simply on) */
+	  if(info->retry.flags == IW_RETRY_ON)
+	    printf(":on");
+ 	}
+      printf("   ");
+      tokens += 5;	/* Between 3 and 5, depend on flags */
+    }
+
+  /* Display the RTS threshold */
+  if(info->has_rts)
+    {
+      /* Disabled ? */
+      if(info->rts.disabled)
+	printf("RTS thr:off   ");
+      else
+	{
+	  /* Fixed ? */
+	  printf("RTS thr%c%d B   ",
+		 info->rts.fixed ? '=' : ':',
+		 info->rts.value);
+	}
+      tokens += 3;
+    }
+
+  /* Display the fragmentation threshold */
+  if(info->has_frag)
+    {
+      /* A bit of clever formatting */
+      if(tokens > 10)
+	{
+	  printf("\n          ");
+	  tokens = 0;
+	}
+      tokens +=4;
+
+      /* Disabled ? */
+      if(info->frag.disabled)
+	printf("Fragment thr:off");
+      else
+	{
+	  /* Fixed ? */
+	  printf("Fragment thr%c%d B   ",
+		 info->frag.fixed ? '=' : ':',
+		 info->frag.value);
+	}
+    }
+
+  /* Formating */
+  if(tokens > 0)
+    printf("\n          ");
+#endif	/* WE_ESSENTIAL */
+
+  /* Display encryption information */
+  /* Note : we display only the "current" key, use iwlist to list all keys */
+  if(info->b.has_key)
+    {
+      printf("Encryption key:");
+      if((info->b.key_flags & IW_ENCODE_DISABLED) || (info->b.key_size == 0))
+	printf("off");
+      else
+	{
+	  /* Display the key */
+	  iw_print_key(buffer, sizeof(buffer),
+		       info->b.key, info->b.key_size, info->b.key_flags);
+	  printf("%s", buffer);
+
+	  /* Other info... */
+	  if((info->b.key_flags & IW_ENCODE_INDEX) > 1)
+	    printf(" [%d]", info->b.key_flags & IW_ENCODE_INDEX);
+	  if(info->b.key_flags & IW_ENCODE_RESTRICTED)
+	    printf("   Security mode:restricted");
+	  if(info->b.key_flags & IW_ENCODE_OPEN)
+	    printf("   Security mode:open");
+ 	}
+      printf("\n          ");
+    }
+
+  /* Display Power Management information */
+  /* Note : we display only one parameter, period or timeout. If a device
+   * (such as HiperLan) has both, the user need to use iwlist... */
+  if(info->has_power)	/* I hope the device has power ;-) */
+    { 
+      printf("Power Management");
+      /* Disabled ? */
+      if(info->power.disabled)
+	printf(":off");
+      else
+	{
+	  /* Let's check the value and its type */
+	  if(info->power.flags & IW_POWER_TYPE)
+	    {
+	      iw_print_pm_value(buffer, sizeof(buffer),
+				info->power.value, info->power.flags,
+				info->range.we_version_compiled);
+	      printf("%s  ", buffer);
+	    }
+
+	  /* Let's check the mode */
+	  iw_print_pm_mode(buffer, sizeof(buffer), info->power.flags);
+	  printf("%s", buffer);
+
+	  /* Let's check if nothing (simply on) */
+	  if(info->power.flags == IW_POWER_ON)
+	    printf(":on");
+ 	}
+      printf("\n          ");
+    }
+
+  /* Display statistics */
+  if(info->has_stats)
+    {
+      iw_print_stats(buffer, sizeof(buffer),
+		     &info->stats.qual, &info->range, info->has_range);
+      printf("Link %s\n", buffer);
+
+      if(info->range.we_version_compiled > 11)
+	printf("          Rx invalid nwid:%d  Rx invalid crypt:%d  Rx invalid frag:%d\n          Tx excessive retries:%d  Invalid misc:%d   Missed beacon:%d\n",
+	       info->stats.discard.nwid,
+	       info->stats.discard.code,
+	       info->stats.discard.fragment,
+	       info->stats.discard.retries,
+	       info->stats.discard.misc,
+	       info->stats.miss.beacon);
+      else
+	printf("          Rx invalid nwid:%d  invalid crypt:%d  invalid misc:%d\n",
+	       info->stats.discard.nwid,
+	       info->stats.discard.code,
+	       info->stats.discard.misc);
+    }
+
+  printf("\n");
+}
+
+/*------------------------------------------------------------------*/
+/*
+ * Print on the screen in a neat fashion all the info we have collected
+ * on a device.
+ */
+static int
+print_info(int		skfd,
+	   char *	ifname,
+	   char *	args[],
+	   int		count)
+{
+  struct wireless_info	info;
+  int			rc;
+
+  /* Avoid "Unused parameter" warning */
+  args = args; count = count;
+
+  rc = get_info(skfd, ifname, &info);
+  switch(rc)
+    {
+    case 0:	/* Success */
+      /* Display it ! */
+      display_info(&info, ifname);
+      break;
+
+    case -ENOTSUP:
+      fprintf(stderr, "%-8.16s  no wireless extensions.\n\n",
+	      ifname);
+      break;
+
+    default:
+      fprintf(stderr, "%-8.16s  %s\n\n", ifname, strerror(-rc));
+    }
+  return(rc);
+}
+
+/****************** COMMAND LINE MODIFIERS PARSING ******************/
+/*
+ * Factor out the parsing of command line modifiers.
+ */
+
+/*------------------------------------------------------------------*/
+/*
+ * Map command line modifiers to the proper flags...
+ */
+typedef struct iwconfig_modifier {
+  const char *		cmd;		/* Command line shorthand */
+  __u16			flag;		/* Flags to add */
+  __u16			exclude;	/* Modifiers to exclude */
+} iwconfig_modifier;
+
+/*------------------------------------------------------------------*/
+/*
+ * Modifiers for Power
+ */
+static const struct iwconfig_modifier	iwmod_power[] = {
+  { "min",	IW_POWER_MIN,		IW_POWER_MAX },
+  { "max",	IW_POWER_MAX,		IW_POWER_MIN },
+  { "period",	IW_POWER_PERIOD,	IW_POWER_TIMEOUT | IW_POWER_SAVING },
+  { "timeout",	IW_POWER_TIMEOUT,	IW_POWER_PERIOD | IW_POWER_SAVING },
+  { "saving",	IW_POWER_SAVING,	IW_POWER_TIMEOUT | IW_POWER_PERIOD },
+};
+#define IWMOD_POWER_NUM	(sizeof(iwmod_power)/sizeof(iwmod_power[0]))
+
+/*------------------------------------------------------------------*/
+/*
+ * Modifiers for Retry
+ */
+#ifndef WE_ESSENTIAL
+static const struct iwconfig_modifier	iwmod_retry[] = {
+  { "min",	IW_RETRY_MIN,		IW_RETRY_MAX },
+  { "max",	IW_RETRY_MAX,		IW_RETRY_MIN },
+  { "short",	IW_RETRY_SHORT,		IW_RETRY_LONG },
+  { "long",	IW_RETRY_LONG,		IW_RETRY_SHORT },
+  { "limit",	IW_RETRY_LIMIT,		IW_RETRY_LIFETIME },
+  { "lifetime",	IW_RETRY_LIFETIME,	IW_RETRY_LIMIT },
+};
+#define IWMOD_RETRY_NUM	(sizeof(iwmod_retry)/sizeof(iwmod_retry[0]))
+#endif	/* WE_ESSENTIAL */
+
+/*------------------------------------------------------------------*/
+/*
+ * Parse command line modifiers.
+ * Return error or number arg parsed.
+ * Modifiers must be at the beggining of command line.
+ */
+static int
+parse_modifiers(char *		args[],		/* Command line args */
+		int		count,		/* Args count */
+		__u16 *		pout,		/* Flags to write */
+		const struct iwconfig_modifier	modifier[],
+		int		modnum)
+{
+  int		i = 0;
+  int		k = 0;
+  __u16		result = 0;	/* Default : no flag set */
+
+  /* Get all modifiers and value types on the command line */
+  do
+    {
+      for(k = 0; k < modnum; k++)
+	{
+	  /* Check if matches */
+	  if(!strcasecmp(args[i], modifier[k].cmd))
+	    {
+	      /* Check for conflicting flags */
+	      if(result & modifier[k].exclude)
+		{
+		  errarg = i;
+		  return(IWERR_ARG_CONFLICT);
+		}
+	      /* Just add it */
+	      result |= modifier[k].flag;
+	      ++i;
+	      break;
+	    }
+	}
+    }
+  /* For as long as current arg matched and not out of args */
+  while((i < count) && (k < modnum));
+
+  /* Check there remains one arg for value */
+  if(i >= count)
+    return(IWERR_ARG_NUM);
+
+  /* Return result */
+  *pout = result;
+  return(i);
+}
+
+
+/*********************** SETTING SUB-ROUTINES ***********************/
+/*
+ * The following functions are use to set some wireless parameters and
+ * are called by the set dispatcher set_info().
+ * They take as arguments the remaining of the command line, with
+ * arguments processed already removed.
+ * An error is indicated by a negative return value.
+ * 0 and positive return values indicate the number of args consumed.
+ */
+
+/*------------------------------------------------------------------*/
+/*
+ * Set ESSID
+ */
+static int
+set_essid_info(int		skfd,
+	       char *		ifname,
+	       char *		args[],		/* Command line args */
+	       int		count)		/* Args count */
+{
+  struct iwreq		wrq;
+  int			i = 1;
+  char			essid[IW_ESSID_MAX_SIZE + 1];
+  int			we_kernel_version;
+
+  if((!strcasecmp(args[0], "off")) ||
+     (!strcasecmp(args[0], "any")))
+    {
+      wrq.u.essid.flags = 0;
+      essid[0] = '\0';
+    }
+  else
+    if(!strcasecmp(args[0], "on"))
+      {
+	/* Get old essid */
+	memset(essid, '\0', sizeof(essid));
+	wrq.u.essid.pointer = (caddr_t) essid;
+	wrq.u.essid.length = IW_ESSID_MAX_SIZE + 1;
+	wrq.u.essid.flags = 0;
+	if(iw_get_ext(skfd, ifname, SIOCGIWESSID, &wrq) < 0)
+	  return(IWERR_GET_EXT);
+	wrq.u.essid.flags = 1;
+      }
+    else
+      {
+	i = 0;
+
+	/* '-' or '--' allow to escape the ESSID string, allowing
+	 * to set it to the string "any" or "off".
+	 * This is a big ugly, but it will do for now */
+	if((!strcmp(args[0], "-")) || (!strcmp(args[0], "--")))
+	  {
+	    if(++i >= count)
+	      return(IWERR_ARG_NUM);
+	  }
+
+	/* Check the size of what the user passed us to avoid
+	 * buffer overflows */
+	if(strlen(args[i]) > IW_ESSID_MAX_SIZE)
+	  {
+	    errmax = IW_ESSID_MAX_SIZE;
+	    return(IWERR_ARG_SIZE);
+	  }
+	else
+	  {
+	    int		temp;
+
+	    wrq.u.essid.flags = 1;
+	    strcpy(essid, args[i]);	/* Size checked, all clear */
+	    i++;
+
+	    /* Check for ESSID index */
+	    if((i < count) &&
+	       (sscanf(args[i], "[%i]", &temp) == 1) &&
+	       (temp > 0) && (temp < IW_ENCODE_INDEX))
+	      {
+		wrq.u.essid.flags = temp;
+		++i;
+	      }
+	  }
+      }
+
+  /* Get version from kernel, device may not have range... */
+  we_kernel_version = iw_get_kernel_we_version();
+
+  /* Finally set the ESSID value */
+  wrq.u.essid.pointer = (caddr_t) essid;
+  wrq.u.essid.length = strlen(essid);
+  if(we_kernel_version < 21)
+    wrq.u.essid.length++;
+
+  if(iw_set_ext(skfd, ifname, SIOCSIWESSID, &wrq) < 0)
+    return(IWERR_SET_EXT);
+
+  /* Var args */
+  return(i);
+}
+
+/*------------------------------------------------------------------*/
+/*
+ * Set Mode
+ */
+static int
+set_mode_info(int		skfd,
+	      char *		ifname,
+	      char *		args[],		/* Command line args */
+	      int		count)		/* Args count */
+{
+  struct iwreq		wrq;
+  unsigned int		k;		/* Must be unsigned */
+
+  /* Avoid "Unused parameter" warning */
+  count = count;
+
+  /* Check if it is a uint, otherwise get is as a string */
+  if(sscanf(args[0], "%i", &k) != 1)
+    {
+      k = 0;
+      while((k < IW_NUM_OPER_MODE) &&
+	    strncasecmp(args[0], iw_operation_mode[k], 3))
+	k++;
+    }
+  if(k >= IW_NUM_OPER_MODE)
+    {
+      errarg = 0;
+      return(IWERR_ARG_TYPE);
+    }
+
+  wrq.u.mode = k;
+  if(iw_set_ext(skfd, ifname, SIOCSIWMODE, &wrq) < 0)
+    return(IWERR_SET_EXT);
+
+  /* 1 arg */
+  return(1);
+}
+
+/*------------------------------------------------------------------*/
+/*
+ * Set frequency/channel
+ */
+static int
+set_freq_info(int		skfd,
+	      char *		ifname,
+	      char *		args[],		/* Command line args */
+	      int		count)		/* Args count */
+{
+  struct iwreq		wrq;
+  int			i = 1;
+
+  if(!strcasecmp(args[0], "auto"))
+    {
+      wrq.u.freq.m = -1;
+      wrq.u.freq.e = 0;
+      wrq.u.freq.flags = 0;
+    }
+  else
+    {
+      if(!strcasecmp(args[0], "fixed"))
+	{
+	  /* Get old frequency */
+	  if(iw_get_ext(skfd, ifname, SIOCGIWFREQ, &wrq) < 0)
+	    return(IWERR_GET_EXT);
+	  wrq.u.freq.flags = IW_FREQ_FIXED;
+	}
+      else			/* Should be a numeric value */
+	{
+	  double		freq;
+	  char *		unit;
+
+	  freq = strtod(args[0], &unit);
+	  if(unit == args[0])
+	    {
+	      errarg = 0;
+	      return(IWERR_ARG_TYPE);
+	    }
+	  if(unit != NULL)
+	    {
+	      if(unit[0] == 'G') freq *= GIGA;
+	      if(unit[0] == 'M') freq *= MEGA;
+	      if(unit[0] == 'k') freq *= KILO;
+	    }
+
+	  iw_float2freq(freq, &(wrq.u.freq));
+
+	  wrq.u.freq.flags = IW_FREQ_FIXED;
+
+	  /* Check for an additional argument */
+	  if((i < count) && (!strcasecmp(args[i], "auto")))
+	    {
+	      wrq.u.freq.flags = 0;
+	      ++i;
+	    }
+	  if((i < count) && (!strcasecmp(args[i], "fixed")))
+	    {
+	      wrq.u.freq.flags = IW_FREQ_FIXED;
+	      ++i;
+	    }
+	}
+    }
+
+  if(iw_set_ext(skfd, ifname, SIOCSIWFREQ, &wrq) < 0)
+    return(IWERR_SET_EXT);
+
+  /* Var args */
+  return(i);
+}
+
+/*------------------------------------------------------------------*/
+/*
+ * Set Bit Rate
+ */
+static int
+set_bitrate_info(int		skfd,
+		 char *		ifname,
+		 char *		args[],		/* Command line args */
+		 int		count)		/* Args count */
+{
+  struct iwreq		wrq;
+  int			i = 1;
+
+  wrq.u.bitrate.flags = 0;
+  if(!strcasecmp(args[0], "auto"))
+    {
+      wrq.u.bitrate.value = -1;
+      wrq.u.bitrate.fixed = 0;
+    }
+  else
+    {
+      if(!strcasecmp(args[0], "fixed"))
+	{
+	  /* Get old bitrate */
+	  if(iw_get_ext(skfd, ifname, SIOCGIWRATE, &wrq) < 0)
+	    return(IWERR_GET_EXT);
+	  wrq.u.bitrate.fixed = 1;
+	}
+      else			/* Should be a numeric value */
+	{
+	  double		brate;
+	  char *		unit;
+
+	  brate = strtod(args[0], &unit);
+	  if(unit == args[0])
+	    {
+	      errarg = 0;
+	      return(IWERR_ARG_TYPE);
+	    }
+	  if(unit != NULL)
+	    {
+	      if(unit[0] == 'G') brate *= GIGA;
+	      if(unit[0] == 'M') brate *= MEGA;
+	      if(unit[0] == 'k') brate *= KILO;
+	    }
+	  wrq.u.bitrate.value = (long) brate;
+	  wrq.u.bitrate.fixed = 1;
+
+	  /* Check for an additional argument */
+	  if((i < count) && (!strcasecmp(args[i], "auto")))
+	    {
+	      wrq.u.bitrate.fixed = 0;
+	      ++i;
+	    }
+	  if((i < count) && (!strcasecmp(args[i], "fixed")))
+	    {
+	      wrq.u.bitrate.fixed = 1;
+	      ++i;
+	    }
+	  if((i < count) && (!strcasecmp(args[i], "unicast")))
+	    {
+	      wrq.u.bitrate.flags |= IW_BITRATE_UNICAST;
+	      ++i;
+	    }
+	  if((i < count) && (!strcasecmp(args[i], "broadcast")))
+	    {
+	      wrq.u.bitrate.flags |= IW_BITRATE_BROADCAST;
+	      ++i;
+	    }
+	}
+    }
+
+  if(iw_set_ext(skfd, ifname, SIOCSIWRATE, &wrq) < 0)
+    return(IWERR_SET_EXT);
+
+  /* Var args */
+  return(i);
+}
+
+/*------------------------------------------------------------------*/
+/*
+ * Set encryption
+ */
+static int
+set_enc_info(int		skfd,
+	     char *		ifname,
+	     char *		args[],		/* Command line args */
+	     int		count)		/* Args count */
+{
+  struct iwreq		wrq;
+  int			i = 1;
+  unsigned char		key[IW_ENCODING_TOKEN_MAX];
+
+  if(!strcasecmp(args[0], "on"))
+    {
+      /* Get old encryption information */
+      wrq.u.data.pointer = (caddr_t) key;
+      wrq.u.data.length = IW_ENCODING_TOKEN_MAX;
+      wrq.u.data.flags = 0;
+      if(iw_get_ext(skfd, ifname, SIOCGIWENCODE, &wrq) < 0)
+	return(IWERR_GET_EXT);
+      wrq.u.data.flags &= ~IW_ENCODE_DISABLED;	/* Enable */
+    }
+  else
+    {
+      int	gotone = 0;
+      int	oldone;
+      int	keylen;
+      int	temp;
+
+      wrq.u.data.pointer = (caddr_t) NULL;
+      wrq.u.data.flags = 0;
+      wrq.u.data.length = 0;
+      i = 0;
+
+      /* Allow arguments in any order (it's safe) */
+      do
+	{
+	  oldone = gotone;
+
+	  /* -- Check for the key -- */
+	  if(i < count)
+	    {
+	      keylen = iw_in_key_full(skfd, ifname,
+				      args[i], key, &wrq.u.data.flags);
+	      if(keylen > 0)
+		{
+		  wrq.u.data.length = keylen;
+		  wrq.u.data.pointer = (caddr_t) key;
+		  ++i;
+		  gotone++;
+		}
+	    }
+
+	  /* -- Check for token index -- */
+	  if((i < count) &&
+	     (sscanf(args[i], "[%i]", &temp) == 1) &&
+	     (temp > 0) && (temp < IW_ENCODE_INDEX))
+	    {
+	      wrq.u.encoding.flags |= temp;
+	      ++i;
+	      gotone++;
+	    }
+
+	  /* -- Check the various flags -- */
+	  if((i < count) && (!strcasecmp(args[i], "off")))
+	    {
+	      wrq.u.data.flags |= IW_ENCODE_DISABLED;
+	      ++i;
+	      gotone++;
+	    }
+	  if((i < count) && (!strcasecmp(args[i], "open")))
+	    {
+	      wrq.u.data.flags |= IW_ENCODE_OPEN;
+	      ++i;
+	      gotone++;
+	    }
+	  if((i < count) && (!strncasecmp(args[i], "restricted", 5)))
+	    {
+	      wrq.u.data.flags |= IW_ENCODE_RESTRICTED;
+	      ++i;
+	      gotone++;
+	    }
+	  if((i < count) && (!strncasecmp(args[i], "temporary", 4)))
+	    {
+	      wrq.u.data.flags |= IW_ENCODE_TEMP;
+	      ++i;
+	      gotone++;
+	    }
+	}
+      while(gotone != oldone);
+
+      /* Pointer is absent in new API */
+      if(wrq.u.data.pointer == NULL)
+	wrq.u.data.flags |= IW_ENCODE_NOKEY;
+
+      /* Check if we have any invalid argument */
+      if(!gotone)
+	{
+	  errarg = 0;
+	  return(IWERR_ARG_TYPE);
+	}
+    }
+
+  if(iw_set_ext(skfd, ifname, SIOCSIWENCODE, &wrq) < 0)
+    return(IWERR_SET_EXT);
+
+  /* Var arg */
+  return(i);
+}
+
+/*------------------------------------------------------------------*/
+/*
+ * Set Power Management
+ */
+static int
+set_power_info(int		skfd,
+	       char *		ifname,
+	       char *		args[],		/* Command line args */
+	       int		count)		/* Args count */
+{
+  struct iwreq		wrq;
+  int			i = 1;
+
+  if(!strcasecmp(args[0], "off"))
+    wrq.u.power.disabled = 1;	/* i.e. max size */
+  else
+    if(!strcasecmp(args[0], "on"))
+      {
+	/* Get old Power info */
+	wrq.u.power.flags = 0;
+	if(iw_get_ext(skfd, ifname, SIOCGIWPOWER, &wrq) < 0)
+	  return(IWERR_GET_EXT);
+	wrq.u.power.disabled = 0;
+      }
+    else
+      {
+	double		value;
+	char *		unit;
+	int		gotone = 0;
+
+	/* Parse modifiers */
+	i = parse_modifiers(args, count, &wrq.u.power.flags,
+			    iwmod_power, IWMOD_POWER_NUM);
+	if(i < 0)
+	  return(i);
+
+	wrq.u.power.disabled = 0;
+
+	/* Is there any value to grab ? */
+	value = strtod(args[0], &unit);
+	if(unit != args[0])
+	  {
+	    struct iw_range	range;
+	    int			flags;
+	    /* Extract range info to handle properly 'relative' */
+	    if(iw_get_range_info(skfd, ifname, &range) < 0)
+	      memset(&range, 0, sizeof(range));
+
+	    /* Get the flags to be able to do the proper conversion */
+	    switch(wrq.u.power.flags & IW_POWER_TYPE)
+	      {
+	      case IW_POWER_SAVING:
+		flags = range.pms_flags;
+		break;
+	      case IW_POWER_TIMEOUT:
+		flags = range.pmt_flags;
+		break;
+	      default:
+		flags = range.pmp_flags;
+		break;
+	      }
+	    /* Check if time or relative */
+	    if(flags & IW_POWER_RELATIVE)
+	      {
+		if(range.we_version_compiled < 21)
+		  value *= MEGA;
+		else
+		  wrq.u.power.flags |= IW_POWER_RELATIVE;
+	      }
+	    else
+	      {
+		value *= MEGA;	/* default = s */
+		if(unit[0] == 'u') value /= MEGA;
+		if(unit[0] == 'm') value /= KILO;
+	      }
+	    wrq.u.power.value = (long) value;
+	    /* Set some default type if none */
+	    if((wrq.u.power.flags & IW_POWER_TYPE) == 0)
+	      wrq.u.power.flags |= IW_POWER_PERIOD;
+	    ++i;
+	    gotone = 1;
+	  }
+
+	/* Now, check the mode */
+	if(i < count)
+	  {
+	    if(!strcasecmp(args[i], "all"))
+	      wrq.u.power.flags |= IW_POWER_ALL_R;
+	    if(!strncasecmp(args[i], "unicast", 4))
+	      wrq.u.power.flags |= IW_POWER_UNICAST_R;
+	    if(!strncasecmp(args[i], "multicast", 5))
+	      wrq.u.power.flags |= IW_POWER_MULTICAST_R;
+	    if(!strncasecmp(args[i], "force", 5))
+	      wrq.u.power.flags |= IW_POWER_FORCE_S;
+	    if(!strcasecmp(args[i], "repeat"))
+	      wrq.u.power.flags |= IW_POWER_REPEATER;
+	    if(wrq.u.power.flags & IW_POWER_MODE)
+	      {
+		++i;
+		gotone = 1;
+	      }
+	  }
+	if(!gotone)
+	  {
+	    errarg = i;
+	    return(IWERR_ARG_TYPE);
+	  }
+      }
+
+  if(iw_set_ext(skfd, ifname, SIOCSIWPOWER, &wrq) < 0)
+    return(IWERR_SET_EXT);
+
+  /* Var args */
+  return(i);
+}
+
+#ifndef WE_ESSENTIAL
+/*------------------------------------------------------------------*/
+/*
+ * Set Nickname
+ */
+static int
+set_nick_info(int		skfd,
+	      char *		ifname,
+	      char *		args[],		/* Command line args */
+	      int		count)		/* Args count */
+{
+  struct iwreq		wrq;
+  int			we_kernel_version;
+
+  /* Avoid "Unused parameter" warning */
+  count = count;
+
+  if(strlen(args[0]) > IW_ESSID_MAX_SIZE)
+    {
+      errmax = IW_ESSID_MAX_SIZE;
+      return(IWERR_ARG_SIZE);
+    }
+
+  we_kernel_version = iw_get_kernel_we_version();
+
+  wrq.u.essid.pointer = (caddr_t) args[0];
+  wrq.u.essid.length = strlen(args[0]);
+  if(we_kernel_version < 21)
+    wrq.u.essid.length++;
+
+  if(iw_set_ext(skfd, ifname, SIOCSIWNICKN, &wrq) < 0)
+    return(IWERR_SET_EXT);
+
+  /* 1 args */
+  return(1);
+}
+
+/*------------------------------------------------------------------*/
+/*
+ * Set commit
+ */
+static int
+set_nwid_info(int		skfd,
+	      char *		ifname,
+	      char *		args[],		/* Command line args */
+	      int		count)		/* Args count */
+{
+  struct iwreq		wrq;
+  unsigned long		temp;
+
+  /* Avoid "Unused parameter" warning */
+  count = count;
+
+  if((!strcasecmp(args[0], "off")) ||
+     (!strcasecmp(args[0], "any")))
+    wrq.u.nwid.disabled = 1;
+  else
+    if(!strcasecmp(args[0], "on"))
+      {
+	/* Get old nwid */
+	if(iw_get_ext(skfd, ifname, SIOCGIWNWID, &wrq) < 0)
+	  return(IWERR_GET_EXT);
+	wrq.u.nwid.disabled = 0;
+      }
+    else
+      if(sscanf(args[0], "%lX", &(temp)) != 1)
+	{
+	  errarg = 0;
+	  return(IWERR_ARG_TYPE);
+	}
+      else
+	{
+	  wrq.u.nwid.value = temp;
+	  wrq.u.nwid.disabled = 0;
+	}
+
+  wrq.u.nwid.fixed = 1;
+
+  /* Set new nwid */
+  if(iw_set_ext(skfd, ifname, SIOCSIWNWID, &wrq) < 0)
+    return(IWERR_SET_EXT);
+
+  /* 1 arg */
+  return(1);
+}
+
+/*------------------------------------------------------------------*/
+/*
+ * Set AP Address
+ */
+static int
+set_apaddr_info(int		skfd,
+		char *		ifname,
+		char *		args[],		/* Command line args */
+		int		count)		/* Args count */
+{
+  struct iwreq		wrq;
+
+  /* Avoid "Unused parameter" warning */
+  count = count;
+
+  if((!strcasecmp(args[0], "auto")) ||
+     (!strcasecmp(args[0], "any")))
+    {
+      /* Send a broadcast address */
+      iw_broad_ether(&(wrq.u.ap_addr));
+    }
+  else
+    {
+      if(!strcasecmp(args[0], "off"))
+	{
+	  /* Send a NULL address */
+	  iw_null_ether(&(wrq.u.ap_addr));
+	}
+      else
+	{
+	  /* Get the address and check if the interface supports it */
+	  if(iw_in_addr(skfd, ifname, args[0], &(wrq.u.ap_addr)) < 0)
+	    {
+	      errarg = 0;
+	      return(IWERR_ARG_TYPE);
+	    }
+	}
+    }
+
+  if(iw_set_ext(skfd, ifname, SIOCSIWAP, &wrq) < 0)
+    return(IWERR_SET_EXT);
+
+  /* 1 args */
+  return(1);
+}
+
+/*------------------------------------------------------------------*/
+/*
+ * Set Tx Power
+ */
+static int
+set_txpower_info(int		skfd,
+		char *		ifname,
+		char *		args[],		/* Command line args */
+		int		count)		/* Args count */
+{
+  struct iwreq		wrq;
+  int			i = 1;
+
+  /* Avoid "Unused parameter" warning */
+  args = args; count = count;
+
+  /* Prepare the request */
+  wrq.u.txpower.value = -1;
+  wrq.u.txpower.fixed = 1;
+  wrq.u.txpower.disabled = 0;
+  wrq.u.txpower.flags = IW_TXPOW_DBM;
+
+  if(!strcasecmp(args[0], "off"))
+    wrq.u.txpower.disabled = 1;	/* i.e. turn radio off */
+  else
+    if(!strcasecmp(args[0], "auto"))
+      wrq.u.txpower.fixed = 0;	/* i.e. use power control */
+    else
+      {
+	if(!strcasecmp(args[0], "on"))
+	  {
+	    /* Get old tx-power */
+	    if(iw_get_ext(skfd, ifname, SIOCGIWTXPOW, &wrq) < 0)
+	      return(IWERR_GET_EXT);
+	    wrq.u.txpower.disabled = 0;
+	  }
+	else
+	  {
+	    if(!strcasecmp(args[0], "fixed"))
+	      {
+		/* Get old tx-power */
+		if(iw_get_ext(skfd, ifname, SIOCGIWTXPOW, &wrq) < 0)
+		  return(IWERR_GET_EXT);
+		wrq.u.txpower.fixed = 1;
+		wrq.u.txpower.disabled = 0;
+	      }
+	    else			/* Should be a numeric value */
+	      {
+		int		power;
+		int		ismwatt = 0;
+		struct iw_range	range;
+
+		/* Extract range info to do proper conversion */
+		if(iw_get_range_info(skfd, ifname, &range) < 0)
+		  memset(&range, 0, sizeof(range));
+
+		/* Get the value */
+		if(sscanf(args[0], "%i", &(power)) != 1)
+		  {
+		    errarg = 0;
+		    return(IWERR_ARG_TYPE);
+		  }
+
+		/* Check if milliWatt
+		 * We authorise a single 'm' as a shorthand for 'mW',
+		 * on the other hand a 'd' probably means 'dBm'... */
+		ismwatt = ((strchr(args[0], 'm') != NULL)
+			   && (strchr(args[0], 'd') == NULL));
+
+		/* We could check 'W' alone... Another time... */
+
+		/* Convert */
+		if(range.txpower_capa & IW_TXPOW_RELATIVE)
+		  {
+		    /* Can't convert */
+		    if(ismwatt)
+		      {
+			errarg = 0;
+			return(IWERR_ARG_TYPE);
+		      }
+		    wrq.u.txpower.flags = IW_TXPOW_RELATIVE;
+		  }
+		else
+		  if(range.txpower_capa & IW_TXPOW_MWATT)
+		    {
+		      if(!ismwatt)
+			power = iw_dbm2mwatt(power);
+		      wrq.u.txpower.flags = IW_TXPOW_MWATT;
+		    }
+		  else
+		    {
+		      if(ismwatt)
+			power = iw_mwatt2dbm(power);
+		      wrq.u.txpower.flags = IW_TXPOW_DBM;
+		    }
+		wrq.u.txpower.value = power;
+
+		/* Check for an additional argument */
+		if((i < count) && (!strcasecmp(args[i], "auto")))
+		  {
+		    wrq.u.txpower.fixed = 0;
+		    ++i;
+		  }
+		if((i < count) && (!strcasecmp(args[i], "fixed")))
+		  {
+		    wrq.u.txpower.fixed = 1;
+		    ++i;
+		  }
+	      }
+	  }
+      }
+
+  if(iw_set_ext(skfd, ifname, SIOCSIWTXPOW, &wrq) < 0)
+    return(IWERR_SET_EXT);
+
+  /* Var args */
+  return(i);
+}
+
+/*------------------------------------------------------------------*/
+/*
+ * Set Sensitivity
+ */
+static int
+set_sens_info(int		skfd,
+	      char *		ifname,
+	      char *		args[],		/* Command line args */
+	      int		count)		/* Args count */
+{
+  struct iwreq		wrq;
+  int			temp;
+
+  /* Avoid "Unused parameter" warning */
+  count = count;
+
+  if(sscanf(args[0], "%i", &(temp)) != 1)
+    {
+      errarg = 0;
+      return(IWERR_ARG_TYPE);
+    }
+  wrq.u.sens.value = temp;
+
+  if(iw_set_ext(skfd, ifname, SIOCSIWSENS, &wrq) < 0)
+    return(IWERR_SET_EXT);
+
+  /* 1 arg */
+  return(1);
+}
+
+/*------------------------------------------------------------------*/
+/*
+ * Set Retry Limit
+ */
+static int
+set_retry_info(int		skfd,
+	       char *		ifname,
+	       char *		args[],		/* Command line args */
+	       int		count)		/* Args count */
+{
+  struct iwreq		wrq;
+  int			i = 0;
+  double		value;
+  char *		unit;
+
+  /* Parse modifiers */
+  i = parse_modifiers(args, count, &wrq.u.retry.flags,
+		      iwmod_retry, IWMOD_RETRY_NUM);
+  if(i < 0)
+    return(i);
+
+  /* Add default type if none */
+  if((wrq.u.retry.flags & IW_RETRY_TYPE) == 0)
+    wrq.u.retry.flags |= IW_RETRY_LIMIT;
+
+  wrq.u.retry.disabled = 0;
+
+  /* Is there any value to grab ? */
+  value = strtod(args[0], &unit);
+  if(unit == args[0])
+    {
+      errarg = i;
+      return(IWERR_ARG_TYPE);
+    }
+
+  /* Limit is absolute, on the other hand lifetime is seconds */
+  if(wrq.u.retry.flags & IW_RETRY_LIFETIME)
+    {
+      struct iw_range	range;
+      /* Extract range info to handle properly 'relative' */
+      if(iw_get_range_info(skfd, ifname, &range) < 0)
+	memset(&range, 0, sizeof(range));
+
+      if(range.r_time_flags & IW_RETRY_RELATIVE)
+	{
+	  if(range.we_version_compiled < 21)
+	    value *= MEGA;
+	  else
+	    wrq.u.retry.flags |= IW_RETRY_RELATIVE;
+	}
+      else
+	{
+	  /* Normalise lifetime */
+	  value *= MEGA;	/* default = s */
+	  if(unit[0] == 'u') value /= MEGA;
+	  if(unit[0] == 'm') value /= KILO;
+	}
+    }
+  wrq.u.retry.value = (long) value;
+  ++i;
+
+  if(iw_set_ext(skfd, ifname, SIOCSIWRETRY, &wrq) < 0)
+    return(IWERR_SET_EXT);
+
+  /* Var args */
+  return(i);
+}
+
+/*------------------------------------------------------------------*/
+/*
+ * Set RTS Threshold
+ */
+static int
+set_rts_info(int		skfd,
+	     char *		ifname,
+	     char *		args[],		/* Command line args */
+	     int		count)		/* Args count */
+{
+  struct iwreq		wrq;
+
+  /* Avoid "Unused parameter" warning */
+  count = count;
+
+  wrq.u.rts.value = -1;
+  wrq.u.rts.fixed = 1;
+  wrq.u.rts.disabled = 0;
+
+  if(!strcasecmp(args[0], "off"))
+    wrq.u.rts.disabled = 1;	/* i.e. max size */
+  else
+    if(!strcasecmp(args[0], "auto"))
+      wrq.u.rts.fixed = 0;
+    else
+      {
+	if(!strcasecmp(args[0], "fixed"))
+	  {
+	    /* Get old RTS threshold */
+	    if(iw_get_ext(skfd, ifname, SIOCGIWRTS, &wrq) < 0)
+	      return(IWERR_GET_EXT);
+	    wrq.u.rts.fixed = 1;
+	  }
+	else
+	  {	/* Should be a numeric value */
+	    long	temp;
+	    if(sscanf(args[0], "%li", (unsigned long *) &(temp)) != 1)
+	      {
+		errarg = 0;
+		return(IWERR_ARG_TYPE);
+	      }
+	    wrq.u.rts.value = temp;
+	  }
+      }
+
+  if(iw_set_ext(skfd, ifname, SIOCSIWRTS, &wrq) < 0)
+    return(IWERR_SET_EXT);
+
+  /* 1 arg */
+  return(1);
+}
+
+/*------------------------------------------------------------------*/
+/*
+ * Set Fragmentation Threshold
+ */
+static int
+set_frag_info(int		skfd,
+	      char *		ifname,
+	      char *		args[],		/* Command line args */
+	      int		count)		/* Args count */
+{
+  struct iwreq		wrq;
+
+  /* Avoid "Unused parameter" warning */
+  count = count;
+
+  wrq.u.frag.value = -1;
+  wrq.u.frag.fixed = 1;
+  wrq.u.frag.disabled = 0;
+
+  if(!strcasecmp(args[0], "off"))
+    wrq.u.frag.disabled = 1;	/* i.e. max size */
+  else
+    if(!strcasecmp(args[0], "auto"))
+      wrq.u.frag.fixed = 0;
+    else
+      {
+	if(!strcasecmp(args[0], "fixed"))
+	  {
+	    /* Get old fragmentation threshold */
+	    if(iw_get_ext(skfd, ifname, SIOCGIWFRAG, &wrq) < 0)
+	      return(IWERR_GET_EXT);
+	    wrq.u.frag.fixed = 1;
+	  }
+	else
+	  {	/* Should be a numeric value */
+	    long	temp;
+	    if(sscanf(args[0], "%li", &(temp))
+	       != 1)
+	      {
+		errarg = 0;
+		return(IWERR_ARG_TYPE);
+	      }
+	    wrq.u.frag.value = temp;
+	  }
+      }
+
+  if(iw_set_ext(skfd, ifname, SIOCSIWFRAG, &wrq) < 0)
+    return(IWERR_SET_EXT);
+
+  /* 1 arg */
+  return(1);
+}
+
+/*------------------------------------------------------------------*/
+/*
+ * Set Modulation
+ */
+static int
+set_modulation_info(int		skfd,
+		    char *	ifname,
+		    char *	args[],		/* Command line args */
+		    int		count)		/* Args count */
+{
+  struct iwreq		wrq;
+  int			i = 1;
+
+  /* Avoid "Unused parameter" warning */
+  args = args; count = count;
+
+  if(!strcasecmp(args[0], "auto"))
+    wrq.u.param.fixed = 0;	/* i.e. use any modulation */
+  else
+    {
+      if(!strcasecmp(args[0], "fixed"))
+	{
+	  /* Get old modulation */
+	  if(iw_get_ext(skfd, ifname, SIOCGIWMODUL, &wrq) < 0)
+	    return(IWERR_GET_EXT);
+	  wrq.u.param.fixed = 1;
+	}
+      else
+	{
+	  int		k;
+
+	  /* Allow multiple modulations, combine them together */
+	  wrq.u.param.value = 0x0;
+	  i = 0;
+	  do
+	    {
+	      for(k = 0; k < IW_SIZE_MODUL_LIST; k++)
+		{
+		  if(!strcasecmp(args[i], iw_modul_list[k].cmd))
+		    {
+		      wrq.u.param.value |= iw_modul_list[k].mask;
+		      ++i;
+		      break;
+		    }
+		}
+	    }
+	  /* For as long as current arg matched and not out of args */
+	  while((i < count) && (k < IW_SIZE_MODUL_LIST));
+
+	  /* Check we got something */
+	  if(i == 0)
+	    {
+	      errarg = 0;
+	      return(IWERR_ARG_TYPE);
+	    }
+
+	  /* Check for an additional argument */
+	  if((i < count) && (!strcasecmp(args[i], "auto")))
+	    {
+	      wrq.u.param.fixed = 0;
+	      ++i;
+	    }
+	  if((i < count) && (!strcasecmp(args[i], "fixed")))
+	    {
+	      wrq.u.param.fixed = 1;
+	      ++i;
+	    }
+	}
+    }
+
+  if(iw_set_ext(skfd, ifname, SIOCSIWMODUL, &wrq) < 0)
+    return(IWERR_SET_EXT);
+
+  /* Var args */
+  return(i);
+}
+#endif	/* WE_ESSENTIAL */
+
+/*------------------------------------------------------------------*/
+/*
+ * Set commit
+ */
+static int
+set_commit_info(int		skfd,
+		char *		ifname,
+		char *		args[],		/* Command line args */
+		int		count)		/* Args count */
+{
+  struct iwreq		wrq;
+
+  /* Avoid "Unused parameter" warning */
+  args = args; count = count;
+
+  if(iw_set_ext(skfd, ifname, SIOCSIWCOMMIT, &wrq) < 0)
+    return(IWERR_SET_EXT);
+
+  /* No args */
+  return(0);
+}
+
+/************************** SET DISPATCHER **************************/
+/*
+ * This is a modified version of the dispatcher in iwlist.
+ * The main difference is that here we may have multiple commands per
+ * line. Also, most commands here do take arguments, and most often
+ * a variable number of them.
+ * Therefore, the handler *must* return how many args were consumed...
+ *
+ * Note that the use of multiple commands per line is not advised
+ * in scripts, as it makes error management hard. All commands before
+ * the error are executed, but commands after the error are not
+ * processed.
+ * We also try to give as much clue as possible via stderr to the caller
+ * on which command did fail, but if there are two time the same command,
+ * you don't know which one failed...
+ */
+
+/*------------------------------------------------------------------*/
+/*
+ * Map command line arguments to the proper procedure...
+ */
+typedef struct iwconfig_entry {
+  const char *		cmd;		/* Command line shorthand */
+  iw_enum_handler	fn;		/* Subroutine */
+  int			min_count;
+  int			request;	/* WE numerical ID */
+  const char *		name;		/* Human readable string */
+  const char *		argsname;	/* Args as human readable string */
+} iwconfig_cmd;
+
+static const struct iwconfig_entry iwconfig_cmds[] = {
+  { "essid",		set_essid_info,		1,	SIOCSIWESSID,
+	"Set ESSID",			"{NNN|any|on|off}" },
+  { "mode",		set_mode_info,		1,	SIOCSIWMODE,
+	"Set Mode",			"{managed|ad-hoc|master|...}" },
+  { "freq",		set_freq_info,		1,	SIOCSIWFREQ,
+	"Set Frequency",		"N.NNN[k|M|G]" },
+  { "channel",		set_freq_info,		1,	SIOCSIWFREQ,
+	"Set Frequency",		"N" },
+  { "bit",		set_bitrate_info,	1,	SIOCSIWRATE,
+	"Set Bit Rate",			"{N[k|M|G]|auto|fixed}" },
+  { "rate",		set_bitrate_info,	1,	SIOCSIWRATE,
+	"Set Bit Rate",			"{N[k|M|G]|auto|fixed}" },
+  { "enc",		set_enc_info,		1,	SIOCSIWENCODE,
+	"Set Encode",			"{NNNN-NNNN|off}" },
+  { "key",		set_enc_info,		1,	SIOCSIWENCODE,
+	"Set Encode",			"{NNNN-NNNN|off}"  },
+  { "power",		set_power_info,		1,	SIOCSIWPOWER,
+	"Set Power Management",		"{period N|timeout N|saving N|off}" },
+#ifndef WE_ESSENTIAL
+  { "nickname",		set_nick_info,		1,	SIOCSIWNICKN,
+	"Set Nickname",			"NNN" },
+  { "nwid",		set_nwid_info,		1,	SIOCSIWNWID,
+	"Set NWID",			"{NN|on|off}" },
+  { "ap",		set_apaddr_info,	1,	SIOCSIWAP,
+	"Set AP Address",		"{N|off|auto}" },
+  { "txpower",		set_txpower_info,	1,	SIOCSIWTXPOW,
+	"Set Tx Power",			"{NmW|NdBm|off|auto}" },
+  { "sens",		set_sens_info,		1,	SIOCSIWSENS,
+	"Set Sensitivity",		"N" },
+  { "retry",		set_retry_info,		1,	SIOCSIWRETRY,
+	"Set Retry Limit",		"{limit N|lifetime N}" },
+  { "rts",		set_rts_info,		1,	SIOCSIWRTS,
+	"Set RTS Threshold",		"{N|auto|fixed|off}" },
+  { "frag",		set_frag_info,		1,	SIOCSIWFRAG,
+	"Set Fragmentation Threshold",	"{N|auto|fixed|off}" },
+  { "modulation",	set_modulation_info,	1,	SIOCGIWMODUL,
+	"Set Modulation",		"{11g|11a|CCK|OFDMg|...}" },
+#endif	/* WE_ESSENTIAL */
+  { "commit",		set_commit_info,	0,	SIOCSIWCOMMIT,
+	"Commit changes",		"" },
+  { NULL, NULL, 0, 0, NULL, NULL },
+};
+
+/*------------------------------------------------------------------*/
+/*
+ * Find the most appropriate command matching the command line
+ */
+static inline const iwconfig_cmd *
+find_command(const char *	cmd)
+{
+  const iwconfig_cmd *	found = NULL;
+  int			ambig = 0;
+  unsigned int		len = strlen(cmd);
+  int			i;
+
+  /* Go through all commands */
+  for(i = 0; iwconfig_cmds[i].cmd != NULL; ++i)
+    {
+      /* No match -> next one */
+      if(strncasecmp(iwconfig_cmds[i].cmd, cmd, len) != 0)
+	continue;
+
+      /* Exact match -> perfect */
+      if(len == strlen(iwconfig_cmds[i].cmd))
+	return &iwconfig_cmds[i];
+
+      /* Partial match */
+      if(found == NULL)
+	/* First time */
+	found = &iwconfig_cmds[i];
+      else
+	/* Another time */
+	if (iwconfig_cmds[i].fn != found->fn)
+	  ambig = 1;
+    }
+
+  if(found == NULL)
+    {
+      fprintf(stderr, "iwconfig: unknown command \"%s\"\n", cmd);
+      return NULL;
+    }
+
+  if(ambig)
+    {
+      fprintf(stderr, "iwconfig: command \"%s\" is ambiguous\n", cmd);
+      return NULL;
+    }
+
+  return found;
+}
+
+/*------------------------------------------------------------------*/
+/*
+ * Set the wireless options requested on command line
+ * Find the individual commands and call the appropriate subroutine
+ */
+static int
+set_info(int		skfd,		/* The socket */
+	 char *		args[],		/* Command line args */
+	 int		count,		/* Args count */
+	 char *		ifname)		/* Dev name */
+{
+  const iwconfig_cmd *	iwcmd;
+  int			ret;
+
+  /* Loop until we run out of args... */
+  while(count > 0)
+    {
+      /* find the command matching the keyword */
+      iwcmd = find_command(args[0]);
+      if(iwcmd == NULL)
+	{
+	  /* Here we have an unrecognised arg... Error already printed out. */
+	  return(-1);
+	}
+
+      /* One arg is consumed (the command name) */
+      args++;
+      count--;
+
+      /* Check arg numbers */
+      if(count < iwcmd->min_count)
+	ret = IWERR_ARG_NUM;
+      else
+	ret = 0;
+
+      /* Call the command */
+      if(!ret)
+	ret = (*iwcmd->fn)(skfd, ifname, args, count);
+
+      /* Deal with various errors */
+      if(ret < 0)
+	{
+	  int	request = iwcmd->request;
+	  if(ret == IWERR_GET_EXT)
+	    request++;	/* Transform the SET into GET */
+
+	  fprintf(stderr, "Error for wireless request \"%s\" (%X) :\n",
+		  iwcmd->name, request);
+	  switch(ret)
+	    {
+	    case IWERR_ARG_NUM:
+	      fprintf(stderr, "    too few arguments.\n");
+	      break;
+	    case IWERR_ARG_TYPE:
+	      if(errarg < 0)
+		errarg = 0;
+	      if(errarg >= count)
+		errarg = count - 1;
+	      fprintf(stderr, "    invalid argument \"%s\".\n", args[errarg]);
+	      break;
+	    case IWERR_ARG_SIZE:
+	      fprintf(stderr, "    argument too big (max %d)\n", errmax);
+	      break;
+	    case IWERR_ARG_CONFLICT:
+	      if(errarg < 0)
+		errarg = 0;
+	      if(errarg >= count)
+		errarg = count - 1;
+	      fprintf(stderr, "    conflicting argument \"%s\".\n", args[errarg]);
+	      break;
+	    case IWERR_SET_EXT:
+	      fprintf(stderr, "    SET failed on device %-1.16s ; %s.\n",
+		      ifname, strerror(errno));
+	      break;
+	    case IWERR_GET_EXT:
+	      fprintf(stderr, "    GET failed on device %-1.16s ; %s.\n",
+		      ifname, strerror(errno));
+	      break;
+	    }
+	  /* Stop processing, we don't know if we are in a consistent state
+	   * in reading the command line */
+	  return(ret);
+	}
+
+      /* Substract consumed args from command line */
+      args += ret;
+      count -= ret;
+
+      /* Loop back */
+    }
+
+  /* Done, all done */
+  return(0);
+}
+
+/*------------------------------------------------------------------*/
+/*
+ * Display help
+ */
+static inline void
+iw_usage(void)
+{
+  int i;
+
+  fprintf(stderr,   "Usage: iwconfig [interface]\n");
+  for(i = 0; iwconfig_cmds[i].cmd != NULL; ++i)
+    fprintf(stderr, "                interface %s %s\n",
+	    iwconfig_cmds[i].cmd, iwconfig_cmds[i].argsname);
+  fprintf(stderr,   "       Check man pages for more details.\n");
+}
+
+
+/******************************* MAIN ********************************/
+
+/*------------------------------------------------------------------*/
+/*
+ * The main !
+ */
+int
+main(int	argc,
+     char **	argv)
+{
+  int skfd;		/* generic raw socket desc.	*/
+  int goterr = 0;
+
+  /* Create a channel to the NET kernel. */
+  if((skfd = iw_sockets_open()) < 0)
+    {
+      perror("socket");
+      exit(-1);
+    }
+
+  /* No argument : show the list of all device + info */
+  if(argc == 1)
+    iw_enum_devices(skfd, &print_info, NULL, 0);
+  else
+    /* Special case for help... */
+    if((!strcmp(argv[1], "-h")) || (!strcmp(argv[1], "--help")))
+      iw_usage();
+    else
+      /* Special case for version... */
+      if(!strcmp(argv[1], "-v") || !strcmp(argv[1], "--version"))
+	goterr = iw_print_version_info("iwconfig");
+      else
+	{
+	  /* '--' escape device name */
+	  if((argc > 2) && !strcmp(argv[1], "--"))
+	    {
+	      argv++;
+	      argc--;
+	    }
+
+	  /* The device name must be the first argument */
+	  if(argc == 2)
+	    print_info(skfd, argv[1], NULL, 0);
+	  else
+	    /* The other args on the line specify options to be set... */
+	    goterr = set_info(skfd, argv + 2, argc - 2, argv[1]);
+	}
+
+  /* Close the socket. */
+  iw_sockets_close(skfd);
+
+  return(goterr);
+}
diff --git a/iwevent.8 b/iwevent.8
new file mode 100644
index 0000000..02a98e0
--- /dev/null
+++ b/iwevent.8
@@ -0,0 +1,112 @@
+.\" Jean Tourrilhes - HPL - 2002 - 2004
+.\" iwevent.8
+.\"
+.TH IWEVENT 8 "23 June 2004" "net-tools" "Linux Programmer's Manual"
+.\"
+.\" NAME part
+.\"
+.SH NAME
+iwevent \- Display Wireless Events generated by drivers and setting changes
+.\"
+.\" SYNOPSIS part
+.\"
+.SH SYNOPSIS
+.BI "iwevent "
+.br
+.\"
+.\" DESCRIPTION part
+.\"
+.SH DESCRIPTION
+.B iwevent
+displays Wireless Events received through the RTNetlink socket. Each
+line displays the specific Wireless Event which describes what has
+happened on the specified wireless interface.
+.br
+This command doesn't take any arguments.
+.\"
+.\" DISPLAY part
+.\"
+.SH DISPLAY
+There are two classes of Wireless Events.
+.PP
+The first class is events related to a change of wireless settings on
+the interface (typically done through
+.B iwconfig
+or a script calling
+.BR iwconfig ).
+Only settings that could result in a disruption of connectivity are
+reported. The events currently reported are changing one of the
+following setting :
+.br
+.I "	Network ID"
+.br
+.I "	ESSID"
+.br
+.I "	Frequency"
+.br
+.I "	Mode"
+.br
+.I "	Encryption"
+.br
+All those events will be generated on all wireless interfaces by the
+kernel wireless subsystem (but only if the driver has been converted
+to the new driver API).
+.PP
+The second class of events are events generated by the hardware, when
+something happens or a task has been finished. Those events include :
+.TP
+.B New Access Point/Cell address
+The interface has joined a new Access Point or Ad-Hoc Cell, or lost
+its association with it. This is the same address that is reported
+by
+.BR iwconfig .
+.TP
+.B Scan request completed
+A scanning request has been completed, results of the scan are
+available (see
+.BR iwlist ).
+.TP
+.B Tx packet dropped
+A packet directed at this address has been dropped because the
+interface believes this node doesn't answer anymore (usually maximum
+of MAC level retry exceeded). This is usually an early indication that
+the node may have left the cell or gone out of range, but it may be
+due to fading or excessive contention.
+.TP
+.B Custom driver event
+Event specific to the driver. Please check the driver documentation.
+.TP
+.B Registered node
+The interface has successfully registered a new wireless
+client/peer. Will be generated mostly when the interface acts as an
+Access Point (mode Master).
+.TP
+.B Expired node
+The registration of the client/peer on this interface has
+expired. Will be generated mostly when the interface acts as an Access
+Point (mode Master).
+.TP
+.B Spy threshold crossed
+The signal strength for one of the addresses in the spy list went
+under the low threshold or went above the high threshold.
+.PP
+Most wireless drivers generate only a subset of those events, not all
+of them, the exact list depends on the specific hardware/driver
+combination. Please refer to driver documentation for details on when
+they are generated, and use
+.IR iwlist (8)
+to check what the driver supports.
+.\"
+.\" AUTHOR part
+.\"
+.SH AUTHOR
+Jean Tourrilhes \- jt@hpl.hp.com
+.\"
+.\" SEE ALSO part
+.\"
+.SH SEE ALSO
+.BR iwconfig (8),
+.BR iwlist (8),
+.BR iwspy (8),
+.BR iwpriv (8),
+.BR wireless (7).
diff --git a/iwevent.c b/iwevent.c
new file mode 100644
index 0000000..583b2a4
--- /dev/null
+++ b/iwevent.c
@@ -0,0 +1,903 @@
+/*
+ *	Wireless Tools
+ *
+ *		Jean II - HPL 99->04
+ *
+ * Main code for "iwevent". This listent for wireless events on rtnetlink.
+ * You need to link this code against "iwcommon.c" and "-lm".
+ *
+ * Part of this code is from Alexey Kuznetsov, part is from Casey Carter,
+ * I've just put the pieces together...
+ * By the way, if you know a way to remove the root restrictions, tell me
+ * about it...
+ *
+ * This file is released under the GPL license.
+ *     Copyright (c) 1997-2004 Jean Tourrilhes <jt@hpl.hp.com>
+ */
+
+/***************************** INCLUDES *****************************/
+
+#include "iwlib.h"		/* Header */
+#include "awf_event.h"
+
+#include <linux/netlink.h>
+#include <linux/rtnetlink.h>
+
+#include <getopt.h>
+#include <time.h>
+#include <sys/time.h>
+#include <signal.h>
+
+/* Ugly backward compatibility :-( */
+#ifndef IFLA_WIRELESS
+#define IFLA_WIRELESS	(IFLA_MASTER + 1)
+#endif /* IFLA_WIRELESS */
+
+int awf_mode = 0;
+int awf_debug_mode = 0;
+
+#define fputs(_a, _b) \
+	do {	\
+		if (!awf_mode)	\
+		{		\
+			fprintf(_b, _a);	\
+		}		\
+	} while (0)
+
+#define printf(_arg...)	\
+	do {	\
+		if (!awf_mode)	\
+		{		\
+			fprintf(stdout, _arg);	\
+		}		\
+	} while (0)
+
+
+/****************************** TYPES ******************************/
+
+/*
+ * Static information about wireless interface.
+ * We cache this info for performance reason.
+ */
+typedef struct wireless_iface
+{
+  /* Linked list */
+  struct wireless_iface *	next;
+
+  /* Interface identification */
+  int		ifindex;		/* Interface index == black magic */
+
+  /* Interface data */
+  char			ifname[IFNAMSIZ + 1];	/* Interface name */
+  struct iw_range	range;			/* Wireless static data */
+  int			has_range;
+} wireless_iface;
+
+/**************************** VARIABLES ****************************/
+
+/* Cache of wireless interfaces */
+struct wireless_iface *	interface_cache = NULL;
+
+/************************ RTNETLINK HELPERS ************************/
+/*
+ * The following code is extracted from :
+ * ----------------------------------------------
+ * libnetlink.c	RTnetlink service routines.
+ *
+ *		This program is free software; you can redistribute it and/or
+ *		modify it under the terms of the GNU General Public License
+ *		as published by the Free Software Foundation; either version
+ *		2 of the License, or (at your option) any later version.
+ *
+ * Authors:	Alexey Kuznetsov, <kuznet@ms2.inr.ac.ru>
+ * -----------------------------------------------
+ */
+
+struct rtnl_handle
+{
+	int			fd;
+	struct sockaddr_nl	local;
+	struct sockaddr_nl	peer;
+	__u32			seq;
+	__u32			dump;
+};
+
+static inline void rtnl_close(struct rtnl_handle *rth)
+{
+	close(rth->fd);
+}
+
+static inline int rtnl_open(struct rtnl_handle *rth, unsigned subscriptions)
+{
+	int addr_len;
+
+	memset(rth, 0, sizeof(rth));
+
+	rth->fd = socket(PF_NETLINK, SOCK_RAW, NETLINK_ROUTE);
+	if (rth->fd < 0) {
+		perror("Cannot open netlink socket");
+		return -1;
+	}
+
+	memset(&rth->local, 0, sizeof(rth->local));
+	rth->local.nl_family = AF_NETLINK;
+	rth->local.nl_groups = subscriptions;
+
+	if (bind(rth->fd, (struct sockaddr*)&rth->local, sizeof(rth->local)) < 0) {
+		perror("Cannot bind netlink socket");
+		return -1;
+	}
+	addr_len = sizeof(rth->local);
+	if (getsockname(rth->fd, (struct sockaddr*)&rth->local,
+			(socklen_t *) &addr_len) < 0) {
+		perror("Cannot getsockname");
+		return -1;
+	}
+	if (addr_len != sizeof(rth->local)) {
+		fprintf(stderr, "Wrong address length %d\n", addr_len);
+		return -1;
+	}
+	if (rth->local.nl_family != AF_NETLINK) {
+		fprintf(stderr, "Wrong address family %d\n", rth->local.nl_family);
+		return -1;
+	}
+	rth->seq = time(NULL);
+	return 0;
+}
+
+/******************* WIRELESS INTERFACE DATABASE *******************/
+/*
+ * We keep a few information about each wireless interface on the
+ * system. This avoid to query this info at each event, therefore
+ * reducing overhead.
+ *
+ * Each interface is indexed by the 'ifindex'. As opposed to interface
+ * names, 'ifindex' are never reused (even if you reactivate the same
+ * hardware), so the data we cache will never apply to the wrong
+ * interface.
+ * Because of that, we are pretty lazy when it come to purging the
+ * cache...
+ */
+
+/*------------------------------------------------------------------*/
+/*
+ * Get name of interface based on interface index...
+ */
+static inline int
+index2name(int		skfd,
+	   int		ifindex,
+	   char *	name)
+{
+  struct ifreq	irq;
+  int		ret = 0;
+
+  memset(name, 0, IFNAMSIZ + 1);
+
+  /* Get interface name */
+  irq.ifr_ifindex = ifindex;
+  if(ioctl(skfd, SIOCGIFNAME, &irq) < 0)
+    ret = -1;
+  else
+    strncpy(name, irq.ifr_name, IFNAMSIZ);
+
+  return(ret);
+}
+
+/*------------------------------------------------------------------*/
+/*
+ * Get interface data from cache or live interface
+ */
+static struct wireless_iface *
+iw_get_interface_data(int	ifindex)
+{
+  struct wireless_iface *	curr;
+  int				skfd = -1;	/* ioctl socket */
+
+  /* Search for it in the database */
+  curr = interface_cache;
+  while(curr != NULL)
+    {
+      /* Match ? */
+      if(curr->ifindex == ifindex)
+	{
+	  //printf("Cache : found %d-%s\n", curr->ifindex, curr->ifname);
+
+	  /* Return */
+	  return(curr);
+	}
+      /* Next entry */
+      curr = curr->next;
+    }
+
+  /* Create a channel to the NET kernel. Doesn't happen too often, so
+   * socket creation overhead is minimal... */
+  if((skfd = iw_sockets_open()) < 0)
+    {
+      perror("iw_sockets_open");
+      return(NULL);
+    }
+
+  /* Create new entry, zero, init */
+  curr = calloc(1, sizeof(struct wireless_iface));
+  if(!curr)
+    {
+      fprintf(stderr, "Malloc failed\n");
+      return(NULL);
+    }
+  curr->ifindex = ifindex;
+
+  /* Extract static data */
+  if(index2name(skfd, ifindex, curr->ifname) < 0)
+    {
+      perror("index2name");
+      free(curr);
+      return(NULL);
+    }
+  curr->has_range = (iw_get_range_info(skfd, curr->ifname, &curr->range) >= 0);
+  //printf("Cache : create %d-%s\n", curr->ifindex, curr->ifname);
+
+  /* Done */
+  iw_sockets_close(skfd);
+
+  /* Link it */
+  curr->next = interface_cache;
+  interface_cache = curr;
+
+  return(curr);
+}
+
+/*------------------------------------------------------------------*/
+/*
+ * Remove interface data from cache (if it exist)
+ */
+static void
+iw_del_interface_data(int	ifindex)
+{
+  struct wireless_iface *	curr;
+  struct wireless_iface *	prev = NULL;
+  struct wireless_iface *	next;
+
+  /* Go through the list, find the interface, kills it */
+  curr = interface_cache;
+  while(curr)
+    {
+      next = curr->next;
+
+      /* Got a match ? */
+      if(curr->ifindex == ifindex)
+	{
+	  /* Unlink. Root ? */
+	  if(!prev)
+	    interface_cache = next;
+	  else
+	    prev->next = next;
+	  //printf("Cache : purge %d-%s\n", curr->ifindex, curr->ifname);
+
+	  /* Destroy */
+	  free(curr);
+	}
+      else
+	{
+	  /* Keep as previous */
+	  prev = curr;
+	}
+
+      /* Next entry */
+      curr = next;
+    }
+}
+
+/********************* WIRELESS EVENT DECODING *********************/
+/*
+ * Parse the Wireless Event and print it out
+ */
+
+/*------------------------------------------------------------------*/
+/*
+ * Dump a buffer as a serie of hex
+ * Maybe should go in iwlib...
+ * Maybe we should have better formatting like iw_print_key...
+ */
+static char *
+iw_hexdump(char *		buf,
+	   size_t		buflen,
+	   const unsigned char *data,
+	   size_t		datalen)
+{
+  size_t	i;
+  char *	pos = buf;
+
+  for(i = 0; i < datalen; i++)
+    pos += snprintf(pos, buf + buflen - pos, "%02X", data[i]);
+  return buf;
+}
+
+/*------------------------------------------------------------------*/
+/*
+ * Print one element from the scanning results
+ */
+static inline int
+print_event_token(struct iw_event *	event,		/* Extracted token */
+		  struct iw_range *	iw_range,	/* Range info */
+		  int			has_range)
+{
+  char		buffer[128];	/* Temporary buffer */
+  char		buffer2[30];	/* Temporary buffer */
+  char *	prefix = (IW_IS_GET(event->cmd) ? "New" : "Set");
+  const struct ether_addr ether_zero = {{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }};
+  /* Now, let's decode the event */
+  switch(event->cmd)
+    {
+      /* ----- set events ----- */
+      /* Events that result from a "SET XXX" operation by the user */
+    case SIOCSIWNWID:
+      if(event->u.nwid.disabled)
+	printf("Set NWID:off/any\n");
+      else
+	printf("Set NWID:%X\n", event->u.nwid.value);
+      break;
+    case SIOCSIWFREQ:
+    case SIOCGIWFREQ:
+      {
+	double		freq;			/* Frequency/channel */
+	int		channel = -1;		/* Converted to channel */
+	freq = iw_freq2float(&(event->u.freq));
+	if(has_range)
+	  {
+	    if(freq < KILO)
+	      /* Convert channel to frequency if possible */
+	      channel = iw_channel_to_freq((int) freq, &freq, iw_range);
+	    else
+	      /* Convert frequency to channel if possible */
+	      channel = iw_freq_to_channel(freq, iw_range);
+	  }
+	iw_print_freq(buffer, sizeof(buffer),
+		      freq, channel, event->u.freq.flags);
+	printf("%s %s\n", prefix, buffer);
+      }
+      break;
+    case SIOCSIWMODE:
+      printf("Set Mode:%s\n",
+	     iw_operation_mode[event->u.mode]);
+      break;
+    case SIOCSIWESSID:
+    case SIOCGIWESSID:
+      {
+	char essid[IW_ESSID_MAX_SIZE+1];
+	memset(essid, '\0', sizeof(essid));
+	if((event->u.essid.pointer) && (event->u.essid.length))
+	  memcpy(essid, event->u.essid.pointer, event->u.essid.length);
+	if(event->u.essid.flags)
+	  {
+	    /* Does it have an ESSID index ? */
+	    if((event->u.essid.flags & IW_ENCODE_INDEX) > 1)
+	      printf("%s ESSID:\"%s\" [%d]\n", prefix, essid,
+		     (event->u.essid.flags & IW_ENCODE_INDEX));
+	    else
+	      printf("%s ESSID:\"%s\"\n", prefix, essid);
+	  }
+	else
+	  printf("%s ESSID:off/any\n", prefix);
+      }
+      break;
+    case SIOCSIWENCODE:
+      {
+	unsigned char	key[IW_ENCODING_TOKEN_MAX];
+	if(event->u.data.pointer)
+	  memcpy(key, event->u.data.pointer, event->u.data.length);
+	else
+	  event->u.data.flags |= IW_ENCODE_NOKEY;
+	printf("Set Encryption key:");
+	if(event->u.data.flags & IW_ENCODE_DISABLED)
+	  printf("off\n");
+	else
+	  {
+	    /* Display the key */
+	    iw_print_key(buffer, sizeof(buffer), key, event->u.data.length,
+			 event->u.data.flags);
+	    printf("%s", buffer);
+
+	    /* Other info... */
+	    if((event->u.data.flags & IW_ENCODE_INDEX) > 1)
+	      printf(" [%d]", event->u.data.flags & IW_ENCODE_INDEX);
+	    if(event->u.data.flags & IW_ENCODE_RESTRICTED)
+	      printf("   Security mode:restricted");
+	    if(event->u.data.flags & IW_ENCODE_OPEN)
+	      printf("   Security mode:open");
+	    printf("\n");
+	  }
+      }
+      break;
+      /* ----- driver events ----- */
+      /* Events generated by the driver when something important happens */
+    case SIOCGIWAP:
+      printf("New Access Point/Cell address:%s\n",
+	     iw_sawap_ntop(&event->u.ap_addr, buffer));
+	if(!iw_ether_cmp((struct ether_addr *)event->u.ap_addr.sa_data, &ether_zero))
+	{
+		AWF_PRINT_STATUS(DISCONNECTED);
+	}
+	else
+	{
+		AWF_PRINT_STATUS(ASSOCIATED);
+	}
+      break;
+    case SIOCGIWSCAN:
+      printf("Scan request completed\n");
+      break;
+    case IWEVTXDROP:
+      printf("Tx packet dropped:%s\n",
+	     iw_saether_ntop(&event->u.addr, buffer));
+      break;
+    case IWEVCUSTOM:
+      {
+	char custom[IW_CUSTOM_MAX+1];
+	memset(custom, '\0', sizeof(custom));
+	if((event->u.data.pointer) && (event->u.data.length))
+	  memcpy(custom, event->u.data.pointer, event->u.data.length);
+
+	if (awf_debug_mode)
+		fprintf(stderr, "Custom driver event: %s\n", custom);
+
+	if (strncmp(custom, "Conn Success", 12) == 0)
+	{
+		AWF_PRINT_STATUS(AUTHENTICATED);
+	}
+	else if (strncmp(custom, "Sup ConnSuccess", 15) == 0)
+	{
+		AWF_PRINT_STATUS(AUTHORIZED);
+	}
+	else if (strncmp(custom, "Sup WpaHandshakeFail", 20) == 0)
+	{
+		AWF_PRINT_STATUS(WPA_HANDSHAKE_FAIL);
+	}
+	// bilal: upon connecting to linksys device, this event comes instead of the auth fail, so send auth_failed!
+	else if (strncmp(custom, "Conn DisassocInd", 16) == 0)
+	{
+		AWF_PRINT_STATUS(AUTH_FAILED);
+	}
+	else if (strncmp(custom, "Conn NoNetworks", 15) == 0)
+	{
+		AWF_PRINT_STATUS(NETWORK_NOT_FOUND);
+	}
+	else if (strncmp(custom, "Conn Disassoc", 13) == 0)
+	{
+		AWF_PRINT_STATUS(DISCONNECTED);
+	}
+	else if (strncmp(custom, "Conn AuthTimeout", 16) == 0)
+	{
+		AWF_PRINT_STATUS(ASSOCIATED);
+	}
+	else if (strncmp(custom, "Conn Deauth", 11) == 0)
+	{
+		AWF_PRINT_STATUS(AUTH_FAILED);
+	}
+	else if (strncmp(custom, "Conn ConfigMismatch", 11) == 0)
+	{
+		AWF_PRINT_STATUS(CONFIG_MISMATCH);
+	}
+	else if (strncmp(custom, "Conn AuthNoAck", 14) == 0)
+	{
+		AWF_PRINT_STATUS(AUTH_FAILED);
+	}
+	else	
+	{
+		fprintf(stderr, "Custom driver event: %s\n", custom);
+	}
+      }
+      break;
+    case IWEVREGISTERED:
+      printf("Registered node:%s\n",
+	     iw_saether_ntop(&event->u.addr, buffer));
+      break;
+    case IWEVEXPIRED:
+      printf("Expired node:%s\n",
+	     iw_saether_ntop(&event->u.addr, buffer));
+      break;
+    case SIOCGIWTHRSPY:
+      {
+	struct iw_thrspy	threshold;
+	if((event->u.data.pointer) && (event->u.data.length))
+	  {
+	    memcpy(&threshold, event->u.data.pointer,
+		   sizeof(struct iw_thrspy));
+	    printf("Spy threshold crossed on address:%s\n",
+		   iw_saether_ntop(&threshold.addr, buffer));
+	    iw_print_stats(buffer, sizeof(buffer),
+			   &threshold.qual, iw_range, has_range);
+	    printf("                            Link %s\n", buffer);
+	  }
+	else
+	  printf("Invalid Spy Threshold event\n");
+      }
+      break;
+      /* ----- driver WPA events ----- */
+      /* Events generated by the driver, used for WPA operation */
+    case IWEVMICHAELMICFAILURE:
+      if(event->u.data.length >= sizeof(struct iw_michaelmicfailure))
+	{
+	  struct iw_michaelmicfailure mf;
+	  memcpy(&mf, event->u.data.pointer, sizeof(mf));
+	  printf("Michael MIC failure flags:0x%X src_addr:%s tsc:%s\n",
+		 mf.flags,
+		 iw_saether_ntop(&mf.src_addr, buffer2),
+		 iw_hexdump(buffer, sizeof(buffer),
+			    mf.tsc, IW_ENCODE_SEQ_MAX_SIZE));
+	}
+      break;
+    case IWEVASSOCREQIE:
+      printf("Association Request IEs:%s\n",
+	     iw_hexdump(buffer, sizeof(buffer),
+			event->u.data.pointer, event->u.data.length));
+      break;
+    case IWEVASSOCRESPIE:
+      printf("Association Response IEs:%s\n",
+	     iw_hexdump(buffer, sizeof(buffer),
+			event->u.data.pointer, event->u.data.length));
+      break;
+    case IWEVPMKIDCAND:
+      if(event->u.data.length >= sizeof(struct iw_pmkid_cand))
+	{
+	  struct iw_pmkid_cand cand;
+	  memcpy(&cand, event->u.data.pointer, sizeof(cand));
+	  printf("PMKID candidate flags:0x%X index:%d bssid:%s\n",
+		 cand.flags, cand.index,
+		 iw_saether_ntop(&cand.bssid, buffer));
+	}
+      break;
+      /* ----- junk ----- */
+      /* other junk not currently in use */
+    case SIOCGIWRATE:
+      iw_print_bitrate(buffer, sizeof(buffer), event->u.bitrate.value);
+      printf("New Bit Rate:%s\n", buffer);
+      break;
+    case SIOCGIWNAME:
+      printf("Protocol:%-1.16s\n", event->u.name);
+      break;
+    case IWEVQUAL:
+      {
+	event->u.qual.updated = 0x0;	/* Not that reliable, disable */
+	iw_print_stats(buffer, sizeof(buffer),
+		       &event->u.qual, iw_range, has_range);
+	printf("Link %s\n", buffer);
+	break;
+      }
+    default:
+      printf("(Unknown Wireless event 0x%04X)\n", event->cmd);
+    }	/* switch(event->cmd) */
+
+  return(0);
+}
+
+/*------------------------------------------------------------------*/
+/*
+ * Print out all Wireless Events part of the RTNetlink message
+ * Most often, there will be only one event per message, but
+ * just make sure we read everything...
+ */
+static inline int
+print_event_stream(int		ifindex,
+		   char *	data,
+		   int		len)
+{
+  struct iw_event	iwe;
+  struct stream_descr	stream;
+  int			i = 0;
+  int			ret;
+  char			buffer[64];
+  struct timeval	recv_time;
+  struct timezone	tz;
+  struct wireless_iface *	wireless_data;
+
+  /* Get data from cache */
+  wireless_data = iw_get_interface_data(ifindex);
+  if(wireless_data == NULL)
+    return(-1);
+
+  /* Print received time in readable form */
+  gettimeofday(&recv_time, &tz);
+  iw_print_timeval(buffer, sizeof(buffer), &recv_time, &tz);
+
+  iw_init_event_stream(&stream, data, len);
+  do
+    {
+      /* Extract an event and print it */
+      ret = iw_extract_event_stream(&stream, &iwe,
+				    wireless_data->range.we_version_compiled);
+      if(ret != 0)
+	{
+	  if(i++ == 0)
+	    printf("%s   %-8.16s ", buffer, wireless_data->ifname);
+	  else
+	    printf("                           ");
+	  if(ret > 0)
+	    print_event_token(&iwe,
+			      &wireless_data->range, wireless_data->has_range);
+	  else
+	    printf("(Invalid event)\n");
+	  /* Push data out *now*, in case we are redirected to a pipe */
+	  fflush(stdout);
+	}
+    }
+  while(ret > 0);
+
+  return(0);
+}
+
+/*********************** RTNETLINK EVENT DUMP***********************/
+/*
+ * Dump the events we receive from rtnetlink
+ * This code is mostly from Casey
+ */
+
+/*------------------------------------------------------------------*/
+/*
+ * Respond to a single RTM_NEWLINK event from the rtnetlink socket.
+ */
+static int
+LinkCatcher(struct nlmsghdr *nlh)
+{
+  struct ifinfomsg* ifi;
+
+#if 0
+  fprintf(stderr, "nlmsg_type = %d.\n", nlh->nlmsg_type);
+#endif
+
+  ifi = NLMSG_DATA(nlh);
+
+  /* Code is ugly, but sort of works - Jean II */
+
+  /* If interface is getting destoyed */
+  if(nlh->nlmsg_type == RTM_DELLINK)
+    {
+      /* Remove from cache (if in cache) */
+      iw_del_interface_data(ifi->ifi_index);
+      return 0;
+    }
+
+  /* Only keep add/change events */
+  if(nlh->nlmsg_type != RTM_NEWLINK)
+    return 0;
+
+  /* Check for attributes */
+  if (nlh->nlmsg_len > NLMSG_ALIGN(sizeof(struct ifinfomsg)))
+    {
+      int attrlen = nlh->nlmsg_len - NLMSG_ALIGN(sizeof(struct ifinfomsg));
+      struct rtattr *attr = (void *) ((char *) ifi +
+				      NLMSG_ALIGN(sizeof(struct ifinfomsg)));
+
+      while (RTA_OK(attr, attrlen))
+	{
+	  /* Check if the Wireless kind */
+	  if(attr->rta_type == IFLA_WIRELESS)
+	    {
+	      /* Go to display it */
+	      print_event_stream(ifi->ifi_index,
+				 (char *) attr + RTA_ALIGN(sizeof(struct rtattr)),
+				 attr->rta_len - RTA_ALIGN(sizeof(struct rtattr)));
+	    }
+	  attr = RTA_NEXT(attr, attrlen);
+	}
+    }
+
+  return 0;
+}
+
+/* ---------------------------------------------------------------- */
+/*
+ * We must watch the rtnelink socket for events.
+ * This routine handles those events (i.e., call this when rth.fd
+ * is ready to read).
+ */
+static inline void
+handle_netlink_events(struct rtnl_handle *	rth)
+{
+  while(1)
+    {
+      struct sockaddr_nl sanl;
+      socklen_t sanllen = sizeof(struct sockaddr_nl);
+
+      struct nlmsghdr *h;
+      int amt;
+      char buf[8192];
+
+      amt = recvfrom(rth->fd, buf, sizeof(buf), MSG_DONTWAIT, (struct sockaddr*)&sanl, &sanllen);
+      if(amt < 0)
+	{
+	  if(errno != EINTR && errno != EAGAIN)
+	    {
+	      fprintf(stderr, "%s: error reading netlink: %s.\n",
+		      __PRETTY_FUNCTION__, strerror(errno));
+	    }
+	  return;
+	}
+
+      if(amt == 0)
+	{
+	  fprintf(stderr, "%s: EOF on netlink??\n", __PRETTY_FUNCTION__);
+	  return;
+	}
+
+      h = (struct nlmsghdr*)buf;
+      while(amt >= (int)sizeof(*h))
+	{
+	  int len = h->nlmsg_len;
+	  int l = len - sizeof(*h);
+
+	  if(l < 0 || len > amt)
+	    {
+	      fprintf(stderr, "%s: malformed netlink message: len=%d\n", __PRETTY_FUNCTION__, len);
+	      break;
+	    }
+
+	  switch(h->nlmsg_type)
+	    {
+	    case RTM_NEWLINK:
+	    case RTM_DELLINK:
+	      LinkCatcher(h);
+	      break;
+	    default:
+#if 0
+	      fprintf(stderr, "%s: got nlmsg of type %#x.\n", __PRETTY_FUNCTION__, h->nlmsg_type);
+#endif
+	      break;
+	    }
+
+	  len = NLMSG_ALIGN(len);
+	  amt -= len;
+	  h = (struct nlmsghdr*)((char*)h + len);
+	}
+
+      if(amt > 0)
+	fprintf(stderr, "%s: remnant of size %d on netlink\n", __PRETTY_FUNCTION__, amt);
+    }
+}
+
+/**************************** MAIN LOOP ****************************/
+
+/* ---------------------------------------------------------------- */
+/*
+ * Wait until we get an event
+ */
+static inline int
+wait_for_event(struct rtnl_handle *	rth)
+{
+#if 0
+  struct timeval	tv;	/* Select timeout */
+#endif
+
+  /* Forever */
+  while(1)
+    {
+      fd_set		rfds;		/* File descriptors for select */
+      int		last_fd;	/* Last fd */
+      int		ret;
+
+      /* Guess what ? We must re-generate rfds each time */
+      FD_ZERO(&rfds);
+      FD_SET(rth->fd, &rfds);
+      last_fd = rth->fd;
+
+      /* Wait until something happens */
+      ret = select(last_fd + 1, &rfds, NULL, NULL, NULL);
+
+      /* Check if there was an error */
+      if(ret < 0)
+	{
+	  if(errno == EAGAIN || errno == EINTR)
+	    continue;
+	  fprintf(stderr, "Unhandled signal - exiting...\n");
+	  break;
+	}
+
+      /* Check if there was a timeout */
+      if(ret == 0)
+	{
+	  continue;
+	}
+
+      /* Check for interface discovery events. */
+      if(FD_ISSET(rth->fd, &rfds))
+	handle_netlink_events(rth);
+    }
+
+  return(0);
+}
+
+/******************************* MAIN *******************************/
+
+/* ---------------------------------------------------------------- */
+/*
+ * helper ;-)
+ */
+static void
+iw_usage(int status)
+{
+  fputs("Usage: iwevent [OPTIONS]\n"
+	"   Monitors and displays Wireless Events.\n"
+	"   Options are:\n"
+	"     -h,--help     Print this message.\n"
+	"     -v,--version  Show version of this program.\n",
+	status ? stderr : stdout);
+  exit(status);
+}
+/* Command line options */
+static const struct option long_opts[] = {
+  { "help", no_argument, NULL, 'h' },
+  { "version", no_argument, NULL, 'v' },
+  { NULL, 0, NULL, 0 }
+};
+
+
+void SigTermHnd(int iSignal)
+{
+	// do nothing for ctrl + C
+}
+
+/* ---------------------------------------------------------------- */
+/*
+ * main body of the program
+ */
+int
+main(int	argc,
+     char *	argv[])
+{
+  struct rtnl_handle	rth;
+  int opt;
+
+  /* Check command line options */
+  while((opt = getopt_long(argc, argv, "hvbd", long_opts, NULL)) > 0)
+    {
+      switch(opt)
+	{
+	case 'h':
+	  iw_usage(0);
+	  break;
+
+	case 'v':
+	  return(iw_print_version_info("iwevent"));
+	  break;
+
+	// bilal :)
+	case 'b':
+	  awf_mode = 1;
+	  break;
+
+	case 'd':
+	  awf_debug_mode = 1;
+	  break;
+
+	default:
+	  iw_usage(1);
+	  break;
+	}
+    }
+  if(optind < argc)
+    {
+      fputs("Too many arguments.\n", stderr);
+      iw_usage(1);
+    }
+
+  /* Open netlink channel */
+  if(rtnl_open(&rth, RTMGRP_LINK) < 0)
+    {
+      perror("Can't initialize rtnetlink socket");
+      return(1);
+    }
+
+  fprintf(stderr, "Waiting for Wireless Events from interfaces...\n");
+
+	if (awf_mode)
+	{
+		// bilal: add signal handler to prevent ^C to kill process
+		signal(SIGINT, SigTermHnd);
+	}
+
+  /* Do what we have to do */
+  wait_for_event(&rth);
+
+  /* Cleanup - only if you are pedantic */
+  rtnl_close(&rth);
+
+  return(0);
+}
diff --git a/iwgetid.8 b/iwgetid.8
new file mode 100644
index 0000000..4d4090a
--- /dev/null
+++ b/iwgetid.8
@@ -0,0 +1,115 @@
+.\" Guus Sliepen - 2001
+.\" Completed and fixed up by Jean Tourrilhes - 2002-2003
+.\" iwgetid.8
+.\"
+.TH IWGETID 8 "02 December 2003" "wireless-tools" "Linux Programmer's Manual"
+.\"
+.\" NAME part
+.\"
+.SH NAME
+iwgetid \- Report ESSID, NWID or AP/Cell Address of wireless network
+.\"
+.\" SYNOPSIS part
+.\"
+.SH SYNOPSIS
+.BI "iwgetid " [interface] " [--raw] [--scheme] [--ap] [--freq]"
+.br
+.BI "                   [--mode] [--protocol] [--channel]
+.br
+.\"
+.\" DESCRIPTION part
+.\"
+.SH DESCRIPTION
+.B iwgetid
+is used to find out the NWID, ESSID or AP/Cell Address of the wireless
+network that is currently used. The information reported is the same
+as the one shown by
+.BR iwconfig ", but " iwgetid
+is easier to integrate in various scripts.
+.br
+By default,
+.B iwgetid
+will print the
+.I ESSID
+of the device, and if the device doesn't have any ESSID it will print
+its
+.IR NWID .
+.br
+The default formatting output is pretty-print.
+.\"
+.\" OPTIONS part
+.\"
+.SH OPTIONS
+.TP
+.B --raw
+This option disables pretty-printing of the information. This option
+is orthogonal to the other options (except
+.BR --scheme ),
+so with the appropriate combination of options you can print the raw
+ESSID, AP Address or Mode.
+.br
+This format is ideal when storing the result of iwgetid as a
+variable in
+.I Shell
+or
+.I Perl
+scripts or to pass the result as an argument on the command line of
+.BR iwconfig .
+.TP
+.B --scheme
+This option is similar to the previous one, it disables
+pretty-printing of the information and removes all characters that are
+not alphanumerics (like space, punctuation and control characters).
+.br
+The resulting output is a valid Pcmcia scheme identifier (that may be
+used as an argument of the command
+.BR "cardctl scheme" ).
+This format is also ideal when using the result of iwgetid as a
+selector in
+.I Shell
+or
+.I Perl
+scripts, or as a file name.
+.TP
+.B --ap
+Display the MAC address of the Wireless
+.I Access Point
+or the
+.IR Cell .
+.TP
+.B --freq
+Display the current
+.I frequency
+or
+.I channel
+used by the interface.
+.TP
+.B --channel
+Display the current
+.I channel
+used by the interface. The channel is determined using the current
+frequency and the frequency list provided by the interface.
+.TP
+.B --mode
+Display the current
+.I mode
+of the interface.
+.TP
+.B --protocol
+Display the
+.I protocol name
+of the interface. This allows to identify all the cards that are
+compatible with each other and accept the same type of configuration.
+.br
+This can also be used to
+.I check Wireless Extension support
+on the interface, as this is the only attribute that all drivers
+supporting Wireless Extension are mandated to support.
+.\"
+.\" SEE ALSO part
+.\"
+.SH SEE ALSO
+.BR iwconfig (8),
+.BR ifconfig (8),
+.BR iwspy (8),
+.BR iwpriv (8).
diff --git a/iwgetid.c b/iwgetid.c
new file mode 100644
index 0000000..bbd48a1
--- /dev/null
+++ b/iwgetid.c
@@ -0,0 +1,581 @@
+/*
+ *	Wireless Tools
+ *
+ *		Jean II - HPL '01
+ *
+ * Just print the ESSID or NWID...
+ *
+ * This file is released under the GPL license.
+ *     Copyright (c) 1997-2004 Jean Tourrilhes <jt@hpl.hp.com>
+ */
+
+#include "iwlib.h"		/* Header */
+
+#include <getopt.h>
+
+/*
+ * Note on Pcmcia Schemes :
+ * ----------------------
+ *	The purpose of this tool is to use the ESSID discovery mechanism
+ * to select the appropriate Pcmcia Scheme. The card tell us which
+ * ESSID it has found, and we can then select the appropriate Pcmcia
+ * Scheme for this ESSID (Wireless config (encrypt keys) and IP config).
+ *	The way to do it is as follows :
+ *			cardctl scheme "essidany"
+ *			delay 100
+ *			$scheme = iwgetid --scheme
+ *			cardctl scheme $scheme
+ *	Of course, you need to add a scheme called "essidany" with the
+ * following setting :
+ *			essidany,*,*,*)
+ *				ESSID="any"
+ *				IPADDR="10.0.0.1"
+ *
+ *	This can also be integrated int he Pcmcia scripts.
+ *	Some drivers don't activate the card up to "ifconfig up".
+ * Therefore, they wont scan ESSID up to this point, so we can't
+ * read it reliably in Pcmcia scripts.
+ *	I guess the proper way to write the network script is as follows :
+ *			if($scheme == "iwgetid") {
+ *				iwconfig $name essid any
+ *				iwconfig $name nwid any
+ *				ifconfig $name up
+ *				delay 100
+ *				$scheme = iwgetid $name --scheme
+ *				ifconfig $name down
+ *			}
+ *
+ *	This is pseudo code, but you get an idea...
+ *	The "ifconfig up" activate the card.
+ *	The "delay" is necessary to let time for the card scan the
+ * frequencies and associate with the AP.
+ *	The "ifconfig down" is necessary to allow the driver to optimise
+ * the wireless parameters setting (minimise number of card resets).
+ *
+ *	Another cute idea is to have a list of Pcmcia Schemes to try
+ * and to keep the first one that associate (AP address != 0). This
+ * would be necessary for closed networks and cards that can't
+ * discover essid...
+ *
+ * Jean II - 29/3/01
+ */
+
+/**************************** CONSTANTS ****************************/
+
+#define FORMAT_DEFAULT	0	/* Nice looking display for the user */
+#define FORMAT_SCHEME	1	/* To be used as a Pcmcia Scheme */
+#define FORMAT_RAW	2	/* Raw value, for shell scripts */
+#define WTYPE_ESSID	0	/* Display ESSID or NWID */
+#define WTYPE_AP	1	/* Display AP/Cell Address */
+#define WTYPE_FREQ	2	/* Display frequency/channel */
+#define WTYPE_CHANNEL	3	/* Display channel (converted from freq) */
+#define WTYPE_MODE	4	/* Display mode */
+#define WTYPE_PROTO	5	/* Display protocol name */
+
+/************************ DISPLAY ESSID/NWID ************************/
+
+/*------------------------------------------------------------------*/
+/*
+ * Display the ESSID if possible
+ */
+static int
+print_essid(int			skfd,
+	    const char *	ifname,
+	    int			format)
+{
+  struct iwreq		wrq;
+  char			essid[IW_ESSID_MAX_SIZE + 1];	/* ESSID */
+  char			pessid[IW_ESSID_MAX_SIZE + 1];	/* Pcmcia format */
+  unsigned int		i;
+  unsigned int		j;
+
+  /* Make sure ESSID is always NULL terminated */
+  memset(essid, 0, sizeof(essid));
+
+  /* Get ESSID */
+  wrq.u.essid.pointer = (caddr_t) essid;
+  wrq.u.essid.length = IW_ESSID_MAX_SIZE + 1;
+  wrq.u.essid.flags = 0;
+  if(iw_get_ext(skfd, ifname, SIOCGIWESSID, &wrq) < 0)
+    return(-1);
+
+  switch(format)
+    {
+    case FORMAT_SCHEME:
+      /* Strip all white space and stuff */
+      j = 0;
+      for(i = 0; i < strlen(essid); i++)
+	if(isalnum(essid[i]))
+	  pessid[j++] = essid[i];
+      pessid[j] = '\0';
+      if((j == 0) || (j > 32))
+	return(-2);
+      printf("%s\n", pessid);
+      break;
+    case FORMAT_RAW:
+      printf("%s\n", essid);
+      break;
+    default:
+      printf("%-8.16s  ESSID:\"%s\"\n", ifname, essid);
+      break;
+    }
+
+  return(0);
+}
+
+/*------------------------------------------------------------------*/
+/*
+ * Display the NWID if possible
+ */
+static int
+print_nwid(int		skfd,
+	   const char *	ifname,
+	   int		format)
+{
+  struct iwreq		wrq;
+
+  /* Get network ID */
+  if(iw_get_ext(skfd, ifname, SIOCGIWNWID, &wrq) < 0)
+    return(-1);
+
+  switch(format)
+    {
+    case FORMAT_SCHEME:
+      /* Prefix with nwid to avoid name space collisions */
+      printf("nwid%X\n", wrq.u.nwid.value);
+      break;
+    case FORMAT_RAW:
+      printf("%X\n", wrq.u.nwid.value);
+      break;
+    default:
+      printf("%-8.16s  NWID:%X\n", ifname, wrq.u.nwid.value);
+      break;
+    }
+
+  return(0);
+}
+
+/**************************** AP ADDRESS ****************************/
+
+/*------------------------------------------------------------------*/
+/*
+ * Display the AP Address if possible
+ */
+static int
+print_ap(int		skfd,
+	 const char *	ifname,
+	 int		format)
+{
+  struct iwreq		wrq;
+  char			buffer[64];
+
+  /* Get AP Address */
+  if(iw_get_ext(skfd, ifname, SIOCGIWAP, &wrq) < 0)
+    return(-1);
+
+  /* Print */
+  iw_ether_ntop((const struct ether_addr *) wrq.u.ap_addr.sa_data, buffer);
+  switch(format)
+    {
+    case FORMAT_SCHEME:
+      /* I think ':' are not problematic, because Pcmcia scripts
+       * seem to handle them properly... */
+    case FORMAT_RAW:
+      printf("%s\n", buffer);
+      break;
+    default:
+      printf("%-8.16s  Access Point/Cell: %s\n", ifname, buffer);
+      break;
+    }
+
+  return(0);
+}
+
+/****************************** OTHER ******************************/
+
+/*------------------------------------------------------------------*/
+/*
+ * Display the frequency (or channel) if possible
+ */
+static int
+print_freq(int		skfd,
+	   const char *	ifname,
+	   int		format)
+{
+  struct iwreq		wrq;
+  double		freq;
+  char			buffer[64];
+
+  /* Get frequency / channel */
+  if(iw_get_ext(skfd, ifname, SIOCGIWFREQ, &wrq) < 0)
+    return(-1);
+
+  /* Print */
+  freq = iw_freq2float(&(wrq.u.freq));
+  switch(format)
+    {
+    case FORMAT_SCHEME:
+      /* Prefix with freq to avoid name space collisions */
+      printf("freq%g\n", freq);
+      break;
+    case FORMAT_RAW:
+      printf("%g\n", freq);
+      break;
+    default:
+      iw_print_freq(buffer, sizeof(buffer), freq, -1, wrq.u.freq.flags);
+      printf("%-8.16s  %s\n", ifname, buffer);
+      break;
+    }
+
+  return(0);
+}
+
+/*------------------------------------------------------------------*/
+/*
+ * Display the channel (converted from frequency) if possible
+ */
+static int
+print_channel(int		skfd,
+	      const char *	ifname,
+	      int		format)
+{
+  struct iwreq		wrq;
+  struct iw_range	range;
+  double		freq;
+  int			channel;
+
+  /* Get frequency / channel */
+  if(iw_get_ext(skfd, ifname, SIOCGIWFREQ, &wrq) < 0)
+    return(-1);
+
+  /* Convert to channel */
+  if(iw_get_range_info(skfd, ifname, &range) < 0)
+    return(-2);
+  freq = iw_freq2float(&(wrq.u.freq));
+  if(freq < KILO)
+    channel = (int) freq;
+  else
+    {
+      channel = iw_freq_to_channel(freq, &range);
+      if(channel < 0)
+	return(-3);
+    }
+
+  /* Print */
+  switch(format)
+    {
+    case FORMAT_SCHEME:
+      /* Prefix with freq to avoid name space collisions */
+      printf("channel%d\n", channel);
+      break;
+    case FORMAT_RAW:
+      printf("%d\n", channel);
+      break;
+    default:
+      printf("%-8.16s  Channel:%d\n", ifname, channel);
+      break;
+    }
+
+  return(0);
+}
+
+/*------------------------------------------------------------------*/
+/*
+ * Display the mode if possible
+ */
+static int
+print_mode(int		skfd,
+	   const char *	ifname,
+	   int		format)
+{
+  struct iwreq		wrq;
+
+  /* Get frequency / channel */
+  if(iw_get_ext(skfd, ifname, SIOCGIWMODE, &wrq) < 0)
+    return(-1);
+  if(wrq.u.mode >= IW_NUM_OPER_MODE)
+    return(-2);
+
+  /* Print */
+  switch(format)
+    {
+    case FORMAT_SCHEME:
+      /* Strip all white space and stuff */
+      if(wrq.u.mode == IW_MODE_ADHOC)
+	printf("AdHoc\n");
+      else
+	printf("%s\n", iw_operation_mode[wrq.u.mode]);
+      break;
+    case FORMAT_RAW:
+      printf("%d\n", wrq.u.mode);
+      break;
+    default:
+      printf("%-8.16s  Mode:%s\n", ifname, iw_operation_mode[wrq.u.mode]);
+      break;
+    }
+
+  return(0);
+}
+
+/*------------------------------------------------------------------*/
+/*
+ * Display the ESSID if possible
+ */
+static int
+print_protocol(int		skfd,
+	       const char *	ifname,
+	       int		format)
+{
+  struct iwreq		wrq;
+  char			proto[IFNAMSIZ + 1];	/* Protocol */
+  char			pproto[IFNAMSIZ + 1];	/* Pcmcia format */
+  unsigned int		i;
+  unsigned int		j;
+
+  /* Get Protocol name */
+  if(iw_get_ext(skfd, ifname, SIOCGIWNAME, &wrq) < 0)
+    return(-1);
+  strncpy(proto, wrq.u.name, IFNAMSIZ);
+  proto[IFNAMSIZ] = '\0';
+
+  switch(format)
+    {
+    case FORMAT_SCHEME:
+      /* Strip all white space and stuff */
+      j = 0;
+      for(i = 0; i < strlen(proto); i++)
+	if(isalnum(proto[i]))
+	  pproto[j++] = proto[i];
+      pproto[j] = '\0';
+      if((j == 0) || (j > 32))
+	return(-2);
+      printf("%s\n", pproto);
+      break;
+    case FORMAT_RAW:
+      printf("%s\n", proto);
+      break;
+    default:
+      printf("%-8.16s  Protocol Name:\"%s\"\n", ifname, proto);
+      break;
+    }
+
+  return(0);
+}
+
+/******************************* MAIN ********************************/
+
+/*------------------------------------------------------------------*/
+/*
+ * Check options and call the proper handler
+ */
+static int
+print_one_device(int		skfd,
+		 int		format,
+		 int		wtype,
+		 const char*	ifname)
+{
+  int ret;
+
+  /* Check wtype */
+  switch(wtype)
+    {
+    case WTYPE_AP:
+      /* Try to print an AP */
+      ret = print_ap(skfd, ifname, format);
+      break;
+
+    case WTYPE_CHANNEL:
+      /* Try to print channel */
+      ret = print_channel(skfd, ifname, format);
+      break;
+
+    case WTYPE_FREQ:
+      /* Try to print frequency */
+      ret = print_freq(skfd, ifname, format);
+      break;
+
+    case WTYPE_MODE:
+      /* Try to print the mode */
+      ret = print_mode(skfd, ifname, format);
+      break;
+
+    case WTYPE_PROTO:
+      /* Try to print the protocol */
+      ret = print_protocol(skfd, ifname, format);
+      break;
+
+    default:
+      /* Try to print an ESSID */
+      ret = print_essid(skfd, ifname, format);
+      if(ret < 0)
+	{
+	  /* Try to print a nwid */
+	  ret = print_nwid(skfd, ifname, format);
+	}
+    }
+
+  return(ret);
+}
+
+/*------------------------------------------------------------------*/
+/*
+ * Try the various devices until one return something we can use
+ *
+ * Note : we can't use iw_enum_devices() because we want a different
+ * behaviour :
+ *	1) Stop at the first valid wireless device
+ *	2) Only go through active devices
+ */
+static int
+scan_devices(int		skfd,
+	     int		format,
+	     int		wtype)
+{
+  char		buff[1024];
+  struct ifconf ifc;
+  struct ifreq *ifr;
+  int		i;
+
+  /* Get list of active devices */
+  ifc.ifc_len = sizeof(buff);
+  ifc.ifc_buf = buff;
+  if(ioctl(skfd, SIOCGIFCONF, &ifc) < 0)
+    {
+      perror("SIOCGIFCONF");
+      return(-1);
+    }
+  ifr = ifc.ifc_req;
+
+  /* Print the first match */
+  for(i = ifc.ifc_len / sizeof(struct ifreq); --i >= 0; ifr++)
+    {
+      if(print_one_device(skfd, format, wtype, ifr->ifr_name) >= 0)
+	return 0;
+    }
+  return(-1);
+}
+
+/*------------------------------------------------------------------*/
+/*
+ * helper
+ */
+static void
+iw_usage(int status)
+{
+  fputs("Usage iwgetid [OPTIONS] [ifname]\n"
+	"  Options are:\n"
+	"    -a,--ap       Print the access point address\n"
+	"    -c,--channel  Print the current channel\n"
+	"    -f,--freq     Print the current frequency\n"
+	"    -m,--mode     Print the current mode\n"
+	"    -p,--protocol Print the protocol name\n"
+	"    -r,--raw      Format the output as raw value for shell scripts\n"
+	"    -s,--scheme   Format the output as a PCMCIA scheme identifier\n"
+	"    -h,--help     Print this message\n",
+	status ? stderr : stdout);
+  exit(status);
+}
+
+static const struct option long_opts[] = {
+  { "ap", no_argument, NULL, 'a' },
+  { "channel", no_argument, NULL, 'c' },
+  { "freq", no_argument, NULL, 'f' },
+  { "mode", no_argument, NULL, 'm' },
+  { "protocol", no_argument, NULL, 'p' },
+  { "help", no_argument, NULL, 'h' },
+  { "raw", no_argument, NULL, 'r' },
+  { "scheme", no_argument, NULL, 's' },
+  { NULL, 0, NULL, 0 }
+};
+
+/*------------------------------------------------------------------*/
+/*
+ * The main !
+ */
+int
+main(int	argc,
+     char **	argv)
+{
+  int	skfd;			/* generic raw socket desc.	*/
+  int	format = FORMAT_DEFAULT;
+  int	wtype = WTYPE_ESSID;
+  int	opt;
+  int	ret = -1;
+
+  /* Check command line arguments */
+  while((opt = getopt_long(argc, argv, "acfhmprs", long_opts, NULL)) > 0)
+    {
+      switch(opt)
+	{
+	case 'a':
+	  /* User wants AP/Cell Address */
+	  wtype = WTYPE_AP;
+	  break;
+
+	case 'c':
+	  /* User wants channel only */
+	  wtype = WTYPE_CHANNEL;
+	  break;
+
+	case 'f':
+	  /* User wants frequency/channel */
+	  wtype = WTYPE_FREQ;
+	  break;
+
+	case 'm':
+	  /* User wants the mode */
+	  wtype = WTYPE_MODE;
+	  break;
+
+	case 'p':
+	  /* User wants the protocol */
+	  wtype = WTYPE_PROTO;
+	  break;
+
+	case 'h':
+	  iw_usage(0);
+	  break;
+
+	case 'r':
+	  /* User wants a Raw format */
+	  format = FORMAT_RAW;
+	  break;
+
+	case 's':
+	  /* User wants a Scheme format */
+	  format = FORMAT_SCHEME;
+	  break;
+
+	default:
+	  iw_usage(1);
+	  break;
+	}
+    }
+  if(optind + 1 < argc) {
+    fputs("Too many arguments.\n", stderr);
+    iw_usage(1);
+  }
+
+  /* Create a channel to the NET kernel. */
+  if((skfd = iw_sockets_open()) < 0)
+    {
+      perror("socket");
+      return(-1);
+    }
+
+  /* Check if first argument is a device name */
+  if(optind < argc)
+    {
+      /* Yes : query only this device */
+      ret = print_one_device(skfd, format, wtype, argv[optind]);
+    }
+  else
+    {
+      /* No : query all devices and print first found */
+      ret = scan_devices(skfd, format, wtype);
+    }
+
+  fflush(stdout);
+  iw_sockets_close(skfd);
+  return(ret);
+}
diff --git a/iwlib.c b/iwlib.c
new file mode 100644
index 0000000..a94fa58
--- /dev/null
+++ b/iwlib.c
@@ -0,0 +1,3215 @@
+/*
+ *	Wireless Tools
+ *
+ *		Jean II - HPLB 97->99 - HPL 99->07
+ *
+ * Common subroutines to all the wireless tools...
+ *
+ * This file is released under the GPL license.
+ *     Copyright (c) 1997-2007 Jean Tourrilhes <jt@hpl.hp.com>
+ */
+
+/***************************** INCLUDES *****************************/
+
+#include "iwlib.h"		/* Header */
+
+/************************ CONSTANTS & MACROS ************************/
+
+/*
+ * Constants fof WE-9->15
+ */
+#define IW15_MAX_FREQUENCIES	16
+#define IW15_MAX_BITRATES	8
+#define IW15_MAX_TXPOWER	8
+#define IW15_MAX_ENCODING_SIZES	8
+#define IW15_MAX_SPY		8
+#define IW15_MAX_AP		8
+
+/****************************** TYPES ******************************/
+
+/*
+ *	Struct iw_range up to WE-15
+ */
+struct	iw15_range
+{
+	__u32		throughput;
+	__u32		min_nwid;
+	__u32		max_nwid;
+	__u16		num_channels;
+	__u8		num_frequency;
+	struct iw_freq	freq[IW15_MAX_FREQUENCIES];
+	__s32		sensitivity;
+	struct iw_quality	max_qual;
+	__u8		num_bitrates;
+	__s32		bitrate[IW15_MAX_BITRATES];
+	__s32		min_rts;
+	__s32		max_rts;
+	__s32		min_frag;
+	__s32		max_frag;
+	__s32		min_pmp;
+	__s32		max_pmp;
+	__s32		min_pmt;
+	__s32		max_pmt;
+	__u16		pmp_flags;
+	__u16		pmt_flags;
+	__u16		pm_capa;
+	__u16		encoding_size[IW15_MAX_ENCODING_SIZES];
+	__u8		num_encoding_sizes;
+	__u8		max_encoding_tokens;
+	__u16		txpower_capa;
+	__u8		num_txpower;
+	__s32		txpower[IW15_MAX_TXPOWER];
+	__u8		we_version_compiled;
+	__u8		we_version_source;
+	__u16		retry_capa;
+	__u16		retry_flags;
+	__u16		r_time_flags;
+	__s32		min_retry;
+	__s32		max_retry;
+	__s32		min_r_time;
+	__s32		max_r_time;
+	struct iw_quality	avg_qual;
+};
+
+/*
+ * Union for all the versions of iwrange.
+ * Fortunately, I mostly only add fields at the end, and big-bang
+ * reorganisations are few.
+ */
+union	iw_range_raw
+{
+	struct iw15_range	range15;	/* WE 9->15 */
+	struct iw_range		range;		/* WE 16->current */
+};
+
+/*
+ * Offsets in iw_range struct
+ */
+#define iwr15_off(f)	( ((char *) &(((struct iw15_range *) NULL)->f)) - \
+			  (char *) NULL)
+#define iwr_off(f)	( ((char *) &(((struct iw_range *) NULL)->f)) - \
+			  (char *) NULL)
+
+/**************************** VARIABLES ****************************/
+
+/* Modes as human readable strings */
+const char * const iw_operation_mode[] = { "Auto",
+					"Ad-Hoc",
+					"Managed",
+					"Master",
+					"Repeater",
+					"Secondary",
+					"Monitor",
+					"Unknown/bug" };
+
+/* Modulations as human readable strings */
+const struct iw_modul_descr	iw_modul_list[] = {
+  /* Start with aggregate types, so that they display first */
+  { IW_MODUL_11AG, "11ag",
+    "IEEE 802.11a + 802.11g (2.4 & 5 GHz, up to 54 Mb/s)" },
+  { IW_MODUL_11AB, "11ab",
+    "IEEE 802.11a + 802.11b (2.4 & 5 GHz, up to 54 Mb/s)" },
+  { IW_MODUL_11G, "11g", "IEEE 802.11g (2.4 GHz, up to 54 Mb/s)" },
+  { IW_MODUL_11A, "11a", "IEEE 802.11a (5 GHz, up to 54 Mb/s)" },
+  { IW_MODUL_11B, "11b", "IEEE 802.11b (2.4 GHz, up to 11 Mb/s)" },
+
+  /* Proprietary aggregates */
+  { IW_MODUL_TURBO | IW_MODUL_11A, "turboa",
+    "Atheros turbo mode at 5 GHz (up to 108 Mb/s)" },
+  { IW_MODUL_TURBO | IW_MODUL_11G, "turbog",
+    "Atheros turbo mode at 2.4 GHz (up to 108 Mb/s)" },
+  { IW_MODUL_PBCC | IW_MODUL_11B, "11+",
+    "TI 802.11+ (2.4 GHz, up to 22 Mb/s)" },
+
+  /* Individual modulations */
+  { IW_MODUL_OFDM_G, "OFDMg",
+    "802.11g higher rates, OFDM at 2.4 GHz (up to 54 Mb/s)" },
+  { IW_MODUL_OFDM_A, "OFDMa", "802.11a, OFDM at 5 GHz (up to 54 Mb/s)" },
+  { IW_MODUL_CCK, "CCK", "802.11b higher rates (2.4 GHz, up to 11 Mb/s)" },
+  { IW_MODUL_DS, "DS", "802.11 Direct Sequence (2.4 GHz, up to 2 Mb/s)" },
+  { IW_MODUL_FH, "FH", "802.11 Frequency Hopping (2,4 GHz, up to 2 Mb/s)" },
+
+  /* Proprietary modulations */
+  { IW_MODUL_TURBO, "turbo",
+    "Atheros turbo mode, channel bonding (up to 108 Mb/s)" },
+  { IW_MODUL_PBCC, "PBCC",
+    "TI 802.11+ higher rates (2.4 GHz, up to 22 Mb/s)" },
+  { IW_MODUL_CUSTOM, "custom",
+    "Driver specific modulation (check driver documentation)" },
+};
+
+/* Disable runtime version warning in iw_get_range_info() */
+int	iw_ignore_version = 0;
+
+/************************ SOCKET SUBROUTINES *************************/
+
+/*------------------------------------------------------------------*/
+/*
+ * Open a socket.
+ * Depending on the protocol present, open the right socket. The socket
+ * will allow us to talk to the driver.
+ */
+int
+iw_sockets_open(void)
+{
+  static const int families[] = {
+    AF_INET, AF_IPX, AF_AX25, AF_APPLETALK
+  };
+  unsigned int	i;
+  int		sock;
+
+  /*
+   * Now pick any (exisiting) useful socket family for generic queries
+   * Note : don't open all the socket, only returns when one matches,
+   * all protocols might not be valid.
+   * Workaround by Jim Kaba <jkaba@sarnoff.com>
+   * Note : in 99% of the case, we will just open the inet_sock.
+   * The remaining 1% case are not fully correct...
+   */
+
+  /* Try all families we support */
+  for(i = 0; i < sizeof(families)/sizeof(int); ++i)
+    {
+      /* Try to open the socket, if success returns it */
+      sock = socket(families[i], SOCK_DGRAM, 0);
+      if(sock >= 0)
+	return sock;
+  }
+
+  return -1;
+}
+
+/*------------------------------------------------------------------*/
+/*
+ * Extract the interface name out of /proc/net/wireless or /proc/net/dev.
+ */
+static inline char *
+iw_get_ifname(char *	name,	/* Where to store the name */
+	      int	nsize,	/* Size of name buffer */
+	      char *	buf)	/* Current position in buffer */
+{
+  char *	end;
+
+  /* Skip leading spaces */
+  while(isspace(*buf))
+    buf++;
+
+#ifndef IW_RESTRIC_ENUM
+  /* Get name up to the last ':'. Aliases may contain ':' in them,
+   * but the last one should be the separator */
+  end = strrchr(buf, ':');
+#else
+  /* Get name up to ": "
+   * Note : we compare to ": " to make sure to process aliased interfaces
+   * properly. Doesn't work on /proc/net/dev, because it doesn't guarantee
+   * a ' ' after the ':'*/
+  end = strstr(buf, ": ");
+#endif
+
+  /* Not found ??? To big ??? */
+  if((end == NULL) || (((end - buf) + 1) > nsize))
+    return(NULL);
+
+  /* Copy */
+  memcpy(name, buf, (end - buf));
+  name[end - buf] = '\0';
+
+  /* Return value currently unused, just make sure it's non-NULL */
+  return(end);
+}
+
+/*------------------------------------------------------------------*/
+/*
+ * Enumerate devices and call specified routine
+ * The new way just use /proc/net/wireless, so get all wireless interfaces,
+ * whether configured or not. This is the default if available.
+ * The old way use SIOCGIFCONF, so get only configured interfaces (wireless
+ * or not).
+ */
+void
+iw_enum_devices(int		skfd,
+		iw_enum_handler	fn,
+		char *		args[],
+		int		count)
+{
+  char		buff[1024];
+  FILE *	fh;
+  struct ifconf ifc;
+  struct ifreq *ifr;
+  int		i;
+
+#ifndef IW_RESTRIC_ENUM
+  /* Check if /proc/net/dev is available */
+  fh = fopen(PROC_NET_DEV, "r");
+#else
+  /* Check if /proc/net/wireless is available */
+  fh = fopen(PROC_NET_WIRELESS, "r");
+#endif
+
+  if(fh != NULL)
+    {
+      /* Success : use data from /proc/net/wireless */
+
+      /* Eat 2 lines of header */
+      fgets(buff, sizeof(buff), fh);
+      fgets(buff, sizeof(buff), fh);
+
+      /* Read each device line */
+      while(fgets(buff, sizeof(buff), fh))
+	{
+	  char	name[IFNAMSIZ + 1];
+	  char *s;
+
+	  /* Skip empty or almost empty lines. It seems that in some
+	   * cases fgets return a line with only a newline. */
+	  if((buff[0] == '\0') || (buff[1] == '\0'))
+	    continue;
+
+	  /* Extract interface name */
+	  s = iw_get_ifname(name, sizeof(name), buff);
+
+	  if(!s)
+	    {
+	      /* Failed to parse, complain and continue */
+#ifndef IW_RESTRIC_ENUM
+	      fprintf(stderr, "Cannot parse " PROC_NET_DEV "\n");
+#else
+	      fprintf(stderr, "Cannot parse " PROC_NET_WIRELESS "\n");
+#endif
+	    }
+	  else
+	    /* Got it, print info about this interface */
+	    (*fn)(skfd, name, args, count);
+	}
+
+      fclose(fh);
+    }
+  else
+    {
+      /* Get list of configured devices using "traditional" way */
+      ifc.ifc_len = sizeof(buff);
+      ifc.ifc_buf = buff;
+      if(ioctl(skfd, SIOCGIFCONF, &ifc) < 0)
+	{
+	  fprintf(stderr, "SIOCGIFCONF: %s\n", strerror(errno));
+	  return;
+	}
+      ifr = ifc.ifc_req;
+
+      /* Print them */
+      for(i = ifc.ifc_len / sizeof(struct ifreq); --i >= 0; ifr++)
+	(*fn)(skfd, ifr->ifr_name, args, count);
+    }
+}
+
+/*********************** WIRELESS SUBROUTINES ************************/
+
+/*------------------------------------------------------------------*/
+/*
+ * Extract WE version number from /proc/net/wireless
+ * In most cases, you really want to get version information from
+ * the range info (range->we_version_compiled), see below...
+ *
+ * If we have WE-16 and later, the WE version is available at the
+ * end of the header line of the file.
+ * For version prior to that, we can only detect the change from
+ * v11 to v12, so we do an approximate job. Fortunately, v12 to v15
+ * are highly binary compatible (on the struct level).
+ */
+int
+iw_get_kernel_we_version(void)
+{
+  char		buff[1024];
+  FILE *	fh;
+  char *	p;
+  int		v;
+
+  /* Check if /proc/net/wireless is available */
+  fh = fopen(PROC_NET_WIRELESS, "r");
+
+  if(fh == NULL)
+    {
+      fprintf(stderr, "Cannot read " PROC_NET_WIRELESS "\n");
+      return(-1);
+    }
+
+  /* Read the first line of buffer */
+  fgets(buff, sizeof(buff), fh);
+
+  if(strstr(buff, "| WE") == NULL)
+    {
+      /* Prior to WE16, so explicit version not present */
+
+      /* Black magic */
+      if(strstr(buff, "| Missed") == NULL)
+	v = 11;
+      else
+	v = 15;
+      fclose(fh);
+      return(v);
+    }
+
+  /* Read the second line of buffer */
+  fgets(buff, sizeof(buff), fh);
+
+  /* Get to the last separator, to get the version */
+  p = strrchr(buff, '|');
+  if((p == NULL) || (sscanf(p + 1, "%d", &v) != 1))
+    {
+      fprintf(stderr, "Cannot parse " PROC_NET_WIRELESS "\n");
+      fclose(fh);
+      return(-1);
+    }
+
+  fclose(fh);
+  return(v);
+}
+
+/*------------------------------------------------------------------*/
+/*
+ * Print the WE versions of the interface.
+ */
+static int
+print_iface_version_info(int	skfd,
+			 char *	ifname,
+			 char *	args[],		/* Command line args */
+			 int	count)		/* Args count */
+{
+  struct iwreq		wrq;
+  char			buffer[sizeof(iwrange) * 2];	/* Large enough */
+  struct iw_range *	range;
+
+  /* Avoid "Unused parameter" warning */
+  args = args; count = count;
+
+  /* If no wireless name : no wireless extensions.
+   * This enable us to treat the SIOCGIWRANGE failure below properly. */
+  if(iw_get_ext(skfd, ifname, SIOCGIWNAME, &wrq) < 0)
+    return(-1);
+
+  /* Cleanup */
+  memset(buffer, 0, sizeof(buffer));
+
+  wrq.u.data.pointer = (caddr_t) buffer;
+  wrq.u.data.length = sizeof(buffer);
+  wrq.u.data.flags = 0;
+  if(iw_get_ext(skfd, ifname, SIOCGIWRANGE, &wrq) < 0)
+    {
+      /* Interface support WE (see above), but not IWRANGE */
+      fprintf(stderr, "%-8.16s  Driver has no Wireless Extension version information.\n\n", ifname);
+      return(0);
+    }
+
+  /* Copy stuff at the right place, ignore extra */
+  range = (struct iw_range *) buffer;
+
+  /* For new versions, we can check the version directly, for old versions
+   * we use magic. 300 bytes is a also magic number, don't touch... */
+  if(wrq.u.data.length >= 300)
+    {
+      /* Version is always at the same offset, so it's ok */
+      printf("%-8.16s  Recommend Wireless Extension v%d or later,\n",
+	     ifname, range->we_version_source);
+      printf("          Currently compiled with Wireless Extension v%d.\n\n",
+	     range->we_version_compiled);
+    }
+  else
+    {
+      fprintf(stderr, "%-8.16s  Wireless Extension version too old.\n\n",
+		      ifname);
+    }
+
+
+  return(0);
+}
+
+/*------------------------------------------------------------------*/
+/*
+ * Print the WE versions of the tools.
+ */
+int
+iw_print_version_info(const char *	toolname)
+{
+  int		skfd;			/* generic raw socket desc.	*/
+  int		we_kernel_version;
+
+  /* Create a channel to the NET kernel. */
+  if((skfd = iw_sockets_open()) < 0)
+    {
+      perror("socket");
+      return -1;
+    }
+
+  /* Information about the tools themselves */
+  if(toolname != NULL)
+    printf("%-8.16s  Wireless-Tools version %d\n", toolname, WT_VERSION);
+  printf("          Compatible with Wireless Extension v11 to v%d.\n\n",
+	 WE_MAX_VERSION);
+
+  /* Get version from kernel */
+  we_kernel_version = iw_get_kernel_we_version();
+  /* Only version >= 16 can be verified, other are guessed */
+  if(we_kernel_version > 15)
+    printf("Kernel    Currently compiled with Wireless Extension v%d.\n\n",
+	   we_kernel_version);
+
+  /* Version for each device */
+  iw_enum_devices(skfd, &print_iface_version_info, NULL, 0);
+
+  iw_sockets_close(skfd);
+
+  return 0;
+}
+
+/*------------------------------------------------------------------*/
+/*
+ * Get the range information out of the driver
+ */
+int
+iw_get_range_info(int		skfd,
+		  const char *	ifname,
+		  iwrange *	range)
+{
+  struct iwreq		wrq;
+  char			buffer[sizeof(iwrange) * 2];	/* Large enough */
+  union iw_range_raw *	range_raw;
+
+  /* Cleanup */
+  bzero(buffer, sizeof(buffer));
+
+  wrq.u.data.pointer = (caddr_t) buffer;
+  wrq.u.data.length = sizeof(buffer);
+  wrq.u.data.flags = 0;
+  if(iw_get_ext(skfd, ifname, SIOCGIWRANGE, &wrq) < 0)
+    return(-1);
+
+  /* Point to the buffer */
+  range_raw = (union iw_range_raw *) buffer;
+
+  /* For new versions, we can check the version directly, for old versions
+   * we use magic. 300 bytes is a also magic number, don't touch... */
+  if(wrq.u.data.length < 300)
+    {
+      /* That's v10 or earlier. Ouch ! Let's make a guess...*/
+      range_raw->range.we_version_compiled = 9;
+    }
+
+  /* Check how it needs to be processed */
+  if(range_raw->range.we_version_compiled > 15)
+    {
+      /* This is our native format, that's easy... */
+      /* Copy stuff at the right place, ignore extra */
+      memcpy((char *) range, buffer, sizeof(iwrange));
+    }
+  else
+    {
+      /* Zero unknown fields */
+      bzero((char *) range, sizeof(struct iw_range));
+
+      /* Initial part unmoved */
+      memcpy((char *) range,
+	     buffer,
+	     iwr15_off(num_channels));
+      /* Frequencies pushed futher down towards the end */
+      memcpy((char *) range + iwr_off(num_channels),
+	     buffer + iwr15_off(num_channels),
+	     iwr15_off(sensitivity) - iwr15_off(num_channels));
+      /* This one moved up */
+      memcpy((char *) range + iwr_off(sensitivity),
+	     buffer + iwr15_off(sensitivity),
+	     iwr15_off(num_bitrates) - iwr15_off(sensitivity));
+      /* This one goes after avg_qual */
+      memcpy((char *) range + iwr_off(num_bitrates),
+	     buffer + iwr15_off(num_bitrates),
+	     iwr15_off(min_rts) - iwr15_off(num_bitrates));
+      /* Number of bitrates has changed, put it after */
+      memcpy((char *) range + iwr_off(min_rts),
+	     buffer + iwr15_off(min_rts),
+	     iwr15_off(txpower_capa) - iwr15_off(min_rts));
+      /* Added encoding_login_index, put it after */
+      memcpy((char *) range + iwr_off(txpower_capa),
+	     buffer + iwr15_off(txpower_capa),
+	     iwr15_off(txpower) - iwr15_off(txpower_capa));
+      /* Hum... That's an unexpected glitch. Bummer. */
+      memcpy((char *) range + iwr_off(txpower),
+	     buffer + iwr15_off(txpower),
+	     iwr15_off(avg_qual) - iwr15_off(txpower));
+      /* Avg qual moved up next to max_qual */
+      memcpy((char *) range + iwr_off(avg_qual),
+	     buffer + iwr15_off(avg_qual),
+	     sizeof(struct iw_quality));
+    }
+
+  /* We are now checking much less than we used to do, because we can
+   * accomodate more WE version. But, there are still cases where things
+   * will break... */
+  if(!iw_ignore_version)
+    {
+      /* We don't like very old version (unfortunately kernel 2.2.X) */
+      if(range->we_version_compiled <= 10)
+	{
+	  fprintf(stderr, "Warning: Driver for device %s has been compiled with an ancient version\n", ifname);
+	  fprintf(stderr, "of Wireless Extension, while this program support version 11 and later.\n");
+	  fprintf(stderr, "Some things may be broken...\n\n");
+	}
+
+      /* We don't like future versions of WE, because we can't cope with
+       * the unknown */
+      if(range->we_version_compiled > WE_MAX_VERSION)
+	{
+	  fprintf(stderr, "Warning: Driver for device %s has been compiled with version %d\n", ifname, range->we_version_compiled);
+	  fprintf(stderr, "of Wireless Extension, while this program supports up to version %d.\n", WE_MAX_VERSION);
+	  fprintf(stderr, "Some things may be broken...\n\n");
+	}
+
+      /* Driver version verification */
+      if((range->we_version_compiled > 10) &&
+	 (range->we_version_compiled < range->we_version_source))
+	{
+	  fprintf(stderr, "Warning: Driver for device %s recommend version %d of Wireless Extension,\n", ifname, range->we_version_source);
+	  fprintf(stderr, "but has been compiled with version %d, therefore some driver features\n", range->we_version_compiled);
+	  fprintf(stderr, "may not be available...\n\n");
+	}
+      /* Note : we are only trying to catch compile difference, not source.
+       * If the driver source has not been updated to the latest, it doesn't
+       * matter because the new fields are set to zero */
+    }
+
+  /* Don't complain twice.
+   * In theory, the test apply to each individual driver, but usually
+   * all drivers are compiled from the same kernel. */
+  iw_ignore_version = 1;
+
+  return(0);
+}
+
+/*------------------------------------------------------------------*/
+/*
+ * Get information about what private ioctls are supported by the driver
+ *
+ * Note : there is one danger using this function. If it return 0, you
+ * still need to free() the buffer. Beware.
+ */
+int
+iw_get_priv_info(int		skfd,
+		 const char *	ifname,
+		 iwprivargs **	ppriv)
+{
+  struct iwreq		wrq;
+  iwprivargs *		priv = NULL;	/* Not allocated yet */
+  int			maxpriv = 16;	/* Minimum for compatibility WE<13 */
+  iwprivargs *		newpriv;
+
+  /* Some driver may return a very large number of ioctls. Some
+   * others a very small number. We now use a dynamic allocation
+   * of the array to satisfy everybody. Of course, as we don't know
+   * in advance the size of the array, we try various increasing
+   * sizes. Jean II */
+  do
+    {
+      /* (Re)allocate the buffer */
+      newpriv = realloc(priv, maxpriv * sizeof(priv[0]));
+      if(newpriv == NULL)
+	{
+	  fprintf(stderr, "%s: Allocation failed\n", __FUNCTION__);
+	  break;
+	}
+      priv = newpriv;
+
+      /* Ask the driver if it's large enough */
+      wrq.u.data.pointer = (caddr_t) priv;
+      wrq.u.data.length = maxpriv;
+      wrq.u.data.flags = 0;
+      if(iw_get_ext(skfd, ifname, SIOCGIWPRIV, &wrq) >= 0)
+	{
+	  /* Success. Pass the buffer by pointer */
+	  *ppriv = priv;
+	  /* Return the number of ioctls */
+	  return(wrq.u.data.length);
+	}
+
+      /* Only E2BIG means the buffer was too small, abort on other errors */
+      if(errno != E2BIG)
+	{
+	  /* Most likely "not supported". Don't barf. */
+	  break;
+	}
+
+      /* Failed. We probably need a bigger buffer. Check if the kernel
+       * gave us any hints. */
+      if(wrq.u.data.length > maxpriv)
+	maxpriv = wrq.u.data.length;
+      else
+	maxpriv *= 2;
+    }
+  while(maxpriv < 1000);
+
+  /* Cleanup */
+  if(priv)
+    free(priv);
+  *ppriv = NULL;
+
+  return(-1);
+}
+
+/*------------------------------------------------------------------*/
+/*
+ * Get essential wireless config from the device driver
+ * We will call all the classical wireless ioctl on the driver through
+ * the socket to know what is supported and to get the settings...
+ * Note : compare to the version in iwconfig, we extract only
+ * what's *really* needed to configure a device...
+ */
+int
+iw_get_basic_config(int			skfd,
+		    const char *	ifname,
+		    wireless_config *	info)
+{
+  struct iwreq		wrq;
+
+  memset((char *) info, 0, sizeof(struct wireless_config));
+
+  /* Get wireless name */
+  if(iw_get_ext(skfd, ifname, SIOCGIWNAME, &wrq) < 0)
+    /* If no wireless name : no wireless extensions */
+    return(-1);
+  else
+    {
+      strncpy(info->name, wrq.u.name, IFNAMSIZ);
+      info->name[IFNAMSIZ] = '\0';
+    }
+
+  /* Get network ID */
+  if(iw_get_ext(skfd, ifname, SIOCGIWNWID, &wrq) >= 0)
+    {
+      info->has_nwid = 1;
+      memcpy(&(info->nwid), &(wrq.u.nwid), sizeof(iwparam));
+    }
+
+  /* Get frequency / channel */
+  if(iw_get_ext(skfd, ifname, SIOCGIWFREQ, &wrq) >= 0)
+    {
+      info->has_freq = 1;
+      info->freq = iw_freq2float(&(wrq.u.freq));
+      info->freq_flags = wrq.u.freq.flags;
+    }
+
+  /* Get encryption information */
+  wrq.u.data.pointer = (caddr_t) info->key;
+  wrq.u.data.length = IW_ENCODING_TOKEN_MAX;
+  wrq.u.data.flags = 0;
+  if(iw_get_ext(skfd, ifname, SIOCGIWENCODE, &wrq) >= 0)
+    {
+      info->has_key = 1;
+      info->key_size = wrq.u.data.length;
+      info->key_flags = wrq.u.data.flags;
+    }
+
+  /* Get ESSID */
+  wrq.u.essid.pointer = (caddr_t) info->essid;
+  wrq.u.essid.length = IW_ESSID_MAX_SIZE + 1;
+  wrq.u.essid.flags = 0;
+  if(iw_get_ext(skfd, ifname, SIOCGIWESSID, &wrq) >= 0)
+    {
+      info->has_essid = 1;
+      info->essid_on = wrq.u.data.flags;
+    }
+
+  /* Get operation mode */
+  if(iw_get_ext(skfd, ifname, SIOCGIWMODE, &wrq) >= 0)
+    {
+      info->has_mode = 1;
+      /* Note : event->u.mode is unsigned, no need to check <= 0 */
+      if(wrq.u.mode < IW_NUM_OPER_MODE)
+	info->mode = wrq.u.mode;
+      else
+	info->mode = IW_NUM_OPER_MODE;	/* Unknown/bug */
+    }
+
+  return(0);
+}
+
+/*------------------------------------------------------------------*/
+/*
+ * Set essential wireless config in the device driver
+ * We will call all the classical wireless ioctl on the driver through
+ * the socket to know what is supported and to set the settings...
+ * We support only the restricted set as above...
+ */
+int
+iw_set_basic_config(int			skfd,
+		    const char *	ifname,
+		    wireless_config *	info)
+{
+  struct iwreq		wrq;
+  int			ret = 0;
+
+  /* Get wireless name (check if interface is valid) */
+  if(iw_get_ext(skfd, ifname, SIOCGIWNAME, &wrq) < 0)
+    /* If no wireless name : no wireless extensions */
+    return(-2);
+
+  /* Set the current mode of operation
+   * Mode need to be first : some settings apply only in a specific mode
+   * (such as frequency).
+   */
+  if(info->has_mode)
+    {
+      strncpy(wrq.ifr_name, ifname, IFNAMSIZ);
+      wrq.u.mode = info->mode;
+
+      if(iw_get_ext(skfd, ifname, SIOCSIWMODE, &wrq) < 0)
+	{
+	  fprintf(stderr, "SIOCSIWMODE: %s\n", strerror(errno));
+	  ret = -1;
+	}
+    }
+
+  /* Set frequency / channel */
+  if(info->has_freq)
+    {
+      iw_float2freq(info->freq, &(wrq.u.freq));
+
+      if(iw_set_ext(skfd, ifname, SIOCSIWFREQ, &wrq) < 0)
+	{
+	  fprintf(stderr, "SIOCSIWFREQ: %s\n", strerror(errno));
+	  ret = -1;
+	}
+    }
+
+  /* Set encryption information */
+  if(info->has_key)
+    {
+      int		flags = info->key_flags;
+
+      /* Check if there is a key index */
+      if((flags & IW_ENCODE_INDEX) > 0)
+	{
+	  /* Set the index */
+	  wrq.u.data.pointer = (caddr_t) NULL;
+	  wrq.u.data.flags = (flags & (IW_ENCODE_INDEX)) | IW_ENCODE_NOKEY;
+	  wrq.u.data.length = 0;
+
+	  if(iw_set_ext(skfd, ifname, SIOCSIWENCODE, &wrq) < 0)
+	    {
+	      fprintf(stderr, "SIOCSIWENCODE(%d): %s\n",
+		      errno, strerror(errno));
+	      ret = -1;
+	    }
+	}
+
+      /* Mask out index to minimise probability of reject when setting key */
+      flags = flags & (~IW_ENCODE_INDEX);
+
+      /* Set the key itself (set current key in this case) */
+      wrq.u.data.pointer = (caddr_t) info->key;
+      wrq.u.data.length = info->key_size;
+      wrq.u.data.flags = flags;
+
+      /* Compatibility with WE<13 */
+      if(flags & IW_ENCODE_NOKEY)
+	wrq.u.data.pointer = NULL;
+
+      if(iw_set_ext(skfd, ifname, SIOCSIWENCODE, &wrq) < 0)
+	{
+	  fprintf(stderr, "SIOCSIWENCODE(%d): %s\n",
+		  errno, strerror(errno));
+	  ret = -1;
+	}
+    }
+
+  /* Set Network ID, if available (this is for non-802.11 cards) */
+  if(info->has_nwid)
+    {
+      memcpy(&(wrq.u.nwid), &(info->nwid), sizeof(iwparam));
+      wrq.u.nwid.fixed = 1;	/* Hum... When in Rome... */
+
+      if(iw_set_ext(skfd, ifname, SIOCSIWNWID, &wrq) < 0)
+	{
+	  fprintf(stderr, "SIOCSIWNWID: %s\n", strerror(errno));
+	  ret = -1;
+	}
+    }
+
+  /* Set ESSID (extended network), if available.
+   * ESSID need to be last : most device re-perform the scanning/discovery
+   * when this is set, and things like encryption keys are better be
+   * defined if we want to discover the right set of APs/nodes.
+   */
+  if(info->has_essid)
+    {
+      int		we_kernel_version;
+      we_kernel_version = iw_get_kernel_we_version();
+
+      wrq.u.essid.pointer = (caddr_t) info->essid;
+      wrq.u.essid.length = strlen(info->essid);
+      wrq.u.data.flags = info->essid_on;
+      if(we_kernel_version < 21)
+	wrq.u.essid.length++;
+
+      if(iw_set_ext(skfd, ifname, SIOCSIWESSID, &wrq) < 0)
+	{
+	  fprintf(stderr, "SIOCSIWESSID: %s\n", strerror(errno));
+	  ret = -1;
+	}
+    }
+
+  return(ret);
+}
+
+/*********************** PROTOCOL SUBROUTINES ***********************/
+/*
+ * Fun stuff with protocol identifiers (SIOCGIWNAME).
+ * We assume that drivers are returning sensible values in there,
+ * which is not always the case :-(
+ */
+
+/*------------------------------------------------------------------*/
+/*
+ * Compare protocol identifiers.
+ * We don't want to know if the two protocols are the exactly same,
+ * but if they interoperate at some level, and also if they accept the
+ * same type of config (ESSID vs NWID, freq...).
+ * This is supposed to work around the alphabet soup.
+ * Return 1 if protocols are compatible, 0 otherwise
+ */
+int
+iw_protocol_compare(const char *	protocol1,
+		    const char *	protocol2)
+{
+  const char *	dot11 = "IEEE 802.11";
+  const char *	dot11_ds = "Dbg";
+  const char *	dot11_5g = "a";
+
+  /* If the strings are the same -> easy */
+  if(!strncmp(protocol1, protocol2, IFNAMSIZ))
+    return(1);
+
+  /* Are we dealing with one of the 802.11 variant ? */
+  if( (!strncmp(protocol1, dot11, strlen(dot11))) &&
+      (!strncmp(protocol2, dot11, strlen(dot11))) )
+    {
+      const char *	sub1 = protocol1 + strlen(dot11);
+      const char *	sub2 = protocol2 + strlen(dot11);
+      unsigned int	i;
+      int		isds1 = 0;
+      int		isds2 = 0;
+      int		is5g1 = 0;
+      int		is5g2 = 0;
+
+      /* Check if we find the magic letters telling it's DS compatible */
+      for(i = 0; i < strlen(dot11_ds); i++)
+	{
+	  if(strchr(sub1, dot11_ds[i]) != NULL)
+	    isds1 = 1;
+	  if(strchr(sub2, dot11_ds[i]) != NULL)
+	    isds2 = 1;
+	}
+      if(isds1 && isds2)
+	return(1);
+
+      /* Check if we find the magic letters telling it's 5GHz compatible */
+      for(i = 0; i < strlen(dot11_5g); i++)
+	{
+	  if(strchr(sub1, dot11_5g[i]) != NULL)
+	    is5g1 = 1;
+	  if(strchr(sub2, dot11_5g[i]) != NULL)
+	    is5g2 = 1;
+	}
+      if(is5g1 && is5g2)
+	return(1);
+    }
+  /* Not compatible */
+  return(0);
+}
+
+/********************** FREQUENCY SUBROUTINES ***********************/
+/*
+ * Note : the two functions below are the cause of troubles on
+ * various embeeded platforms, as they are the reason we require
+ * libm (math library).
+ * In this case, please use enable BUILD_NOLIBM in the makefile
+ *
+ * FIXME : check negative mantissa and exponent
+ */
+
+/*------------------------------------------------------------------*/
+/*
+ * Convert a floating point the our internal representation of
+ * frequencies.
+ * The kernel doesn't want to hear about floating point, so we use
+ * this custom format instead.
+ */
+void
+iw_float2freq(double	in,
+	      iwfreq *	out)
+{
+#ifdef WE_NOLIBM
+  /* Version without libm : slower */
+  out->e = 0;
+  while(in > 1e9)
+    {
+      in /= 10;
+      out->e++;
+    }
+  out->m = (long) in;
+#else	/* WE_NOLIBM */
+  /* Version with libm : faster */
+  out->e = (short) (floor(log10(in)));
+  if(out->e > 8)
+    {
+      out->m = ((long) (floor(in / pow(10,out->e - 6)))) * 100;
+      out->e -= 8;
+    }
+  else
+    {
+      out->m = (long) in;
+      out->e = 0;
+    }
+#endif	/* WE_NOLIBM */
+}
+
+/*------------------------------------------------------------------*/
+/*
+ * Convert our internal representation of frequencies to a floating point.
+ */
+double
+iw_freq2float(const iwfreq *	in)
+{
+#ifdef WE_NOLIBM
+  /* Version without libm : slower */
+  int		i;
+  double	res = (double) in->m;
+  for(i = 0; i < in->e; i++)
+    res *= 10;
+  return(res);
+#else	/* WE_NOLIBM */
+  /* Version with libm : faster */
+  return ((double) in->m) * pow(10,in->e);
+#endif	/* WE_NOLIBM */
+}
+
+/*------------------------------------------------------------------*/
+/*
+ * Output a frequency with proper scaling
+ */
+void
+iw_print_freq_value(char *	buffer,
+		    int		buflen,
+		    double	freq)
+{
+  if(freq < KILO)
+    snprintf(buffer, buflen, "%g", freq);
+  else
+    {
+      char	scale;
+      int	divisor;
+
+      if(freq >= GIGA)
+	{
+	  scale = 'G';
+	  divisor = GIGA;
+	}
+      else
+	{
+	  if(freq >= MEGA)
+	    {
+	      scale = 'M';
+	      divisor = MEGA;
+	    }
+	  else
+	    {
+	      scale = 'k';
+	      divisor = KILO;
+	    }
+	}
+      snprintf(buffer, buflen, "%g %cHz", freq / divisor, scale);
+    }
+}
+
+/*------------------------------------------------------------------*/
+/*
+ * Output a frequency with proper scaling
+ */
+void
+iw_print_freq(char *	buffer,
+	      int	buflen,
+	      double	freq,
+	      int	channel,
+	      int	freq_flags)
+{
+	//bilal: changed the seperator to ":" to get with awf
+  char	sep = ((freq_flags & IW_FREQ_FIXED) ? ':' : ':');
+  char	vbuf[16];
+
+  /* Print the frequency/channel value */
+  iw_print_freq_value(vbuf, sizeof(vbuf), freq);
+
+  /* Check if channel only */
+  if(freq < KILO)
+    snprintf(buffer, buflen, "Channel%c%s", sep, vbuf);
+  else
+    {
+      /* Frequency. Check if we have a channel as well */
+      if(channel >= 0)
+	snprintf(buffer, buflen, "Frequency%c%s (Channel %d)",
+		 sep, vbuf, channel);
+      else
+	snprintf(buffer, buflen, "Frequency%c%s", sep, vbuf);
+    }
+}
+
+/*------------------------------------------------------------------*/
+/*
+ * Convert a frequency to a channel (negative -> error)
+ */
+int
+iw_freq_to_channel(double			freq,
+		   const struct iw_range *	range)
+{
+  double	ref_freq;
+  int		k;
+
+  /* Check if it's a frequency or not already a channel */
+  if(freq < KILO)
+    return(-1);
+
+  /* We compare the frequencies as double to ignore differences
+   * in encoding. Slower, but safer... */
+  for(k = 0; k < range->num_frequency; k++)
+    {
+      ref_freq = iw_freq2float(&(range->freq[k]));
+      if(freq == ref_freq)
+	return(range->freq[k].i);
+    }
+  /* Not found */
+  return(-2);
+}
+
+/*------------------------------------------------------------------*/
+/*
+ * Convert a channel to a frequency (negative -> error)
+ * Return the channel on success
+ */
+int
+iw_channel_to_freq(int				channel,
+		   double *			pfreq,
+		   const struct iw_range *	range)
+{
+  int		has_freq = 0;
+  int		k;
+
+  /* Check if the driver support only channels or if it has frequencies */
+  for(k = 0; k < range->num_frequency; k++)
+    {
+      if((range->freq[k].e != 0) || (range->freq[k].m > (int) KILO))
+	has_freq = 1;
+    }
+  if(!has_freq)
+    return(-1);
+
+  /* Find the correct frequency in the list */
+  for(k = 0; k < range->num_frequency; k++)
+    {
+      if(range->freq[k].i == channel)
+	{
+	  *pfreq = iw_freq2float(&(range->freq[k]));
+	  return(channel);
+	}
+    }
+  /* Not found */
+  return(-2);
+}
+
+/*********************** BITRATE SUBROUTINES ***********************/
+
+/*------------------------------------------------------------------*/
+/*
+ * Output a bitrate with proper scaling
+ */
+void
+iw_print_bitrate(char *	buffer,
+		 int	buflen,
+		 int	bitrate)
+{
+  double	rate = bitrate;
+  char		scale;
+  int		divisor;
+
+  if(rate >= GIGA)
+    {
+      scale = 'G';
+      divisor = GIGA;
+    }
+  else
+    {
+      if(rate >= MEGA)
+	{
+	  scale = 'M';
+	  divisor = MEGA;
+	}
+      else
+	{
+	  scale = 'k';
+	  divisor = KILO;
+	}
+    }
+  snprintf(buffer, buflen, "%g %cb/s", rate / divisor, scale);
+}
+
+/************************ POWER SUBROUTINES *************************/
+
+/*------------------------------------------------------------------*/
+/*
+ * Convert a value in dBm to a value in milliWatt.
+ */
+int
+iw_dbm2mwatt(int	in)
+{
+#ifdef WE_NOLIBM
+  /* Version without libm : slower */
+  int		ip = in / 10;
+  int		fp = in % 10;
+  int		k;
+  double	res = 1.0;
+
+  /* Split integral and floating part to avoid accumulating rounding errors */
+  for(k = 0; k < ip; k++)
+    res *= 10;
+  for(k = 0; k < fp; k++)
+    res *= LOG10_MAGIC;
+  return((int) res);
+#else	/* WE_NOLIBM */
+  /* Version with libm : faster */
+  return((int) (floor(pow(10.0, (((double) in) / 10.0)))));
+#endif	/* WE_NOLIBM */
+}
+
+/*------------------------------------------------------------------*/
+/*
+ * Convert a value in milliWatt to a value in dBm.
+ */
+int
+iw_mwatt2dbm(int	in)
+{
+#ifdef WE_NOLIBM
+  /* Version without libm : slower */
+  double	fin = (double) in;
+  int		res = 0;
+
+  /* Split integral and floating part to avoid accumulating rounding errors */
+  while(fin > 10.0)
+    {
+      res += 10;
+      fin /= 10.0;
+    }
+  while(fin > 1.000001)	/* Eliminate rounding errors, take ceil */
+    {
+      res += 1;
+      fin /= LOG10_MAGIC;
+    }
+  return(res);
+#else	/* WE_NOLIBM */
+  /* Version with libm : faster */
+  return((int) (ceil(10.0 * log10((double) in))));
+#endif	/* WE_NOLIBM */
+}
+
+/*------------------------------------------------------------------*/
+/*
+ * Output a txpower with proper conversion
+ */
+void
+iw_print_txpower(char *			buffer,
+		 int			buflen,
+		 struct iw_param *	txpower)
+{
+  int		dbm;
+
+  /* Check if disabled */
+  if(txpower->disabled)
+    {
+      snprintf(buffer, buflen, "off");
+    }
+  else
+    {
+      /* Check for relative values */
+      if(txpower->flags & IW_TXPOW_RELATIVE)
+	{
+	  snprintf(buffer, buflen, "%d", txpower->value);
+	}
+      else
+	{
+	  /* Convert everything to dBm */
+	  if(txpower->flags & IW_TXPOW_MWATT)
+	    dbm = iw_mwatt2dbm(txpower->value);
+	  else
+	    dbm = txpower->value;
+
+	  /* Display */
+	  snprintf(buffer, buflen, "%d dBm", dbm);
+	}
+    }
+}
+
+/********************** STATISTICS SUBROUTINES **********************/
+
+/*------------------------------------------------------------------*/
+/*
+ * Read /proc/net/wireless to get the latest statistics
+ * Note : strtok not thread safe, not used in WE-12 and later.
+ */
+int
+iw_get_stats(int		skfd,
+	     const char *	ifname,
+	     iwstats *		stats,
+	     const iwrange *	range,
+	     int		has_range)
+{
+  /* Fortunately, we can always detect this condition properly */
+  if((has_range) && (range->we_version_compiled > 11))
+    {
+      struct iwreq		wrq;
+      wrq.u.data.pointer = (caddr_t) stats;
+      wrq.u.data.length = sizeof(struct iw_statistics);
+      wrq.u.data.flags = 1;		/* Clear updated flag */
+      strncpy(wrq.ifr_name, ifname, IFNAMSIZ);
+      if(iw_get_ext(skfd, ifname, SIOCGIWSTATS, &wrq) < 0)
+	return(-1);
+
+      /* Format has not changed since WE-12, no conversion */
+      return(0);
+    }
+  else
+    {
+      FILE *	f = fopen(PROC_NET_WIRELESS, "r");
+      char	buf[256];
+      char *	bp;
+      int	t;
+
+      if(f==NULL)
+	return -1;
+      /* Loop on all devices */
+      while(fgets(buf,255,f))
+	{
+	  bp=buf;
+	  while(*bp&&isspace(*bp))
+	    bp++;
+	  /* Is it the good device ? */
+	  if(strncmp(bp,ifname,strlen(ifname))==0 && bp[strlen(ifname)]==':')
+	    {
+	      /* Skip ethX: */
+	      bp=strchr(bp,':');
+	      bp++;
+	      /* -- status -- */
+	      bp = strtok(bp, " ");
+	      sscanf(bp, "%X", &t);
+	      stats->status = (unsigned short) t;
+	      /* -- link quality -- */
+	      bp = strtok(NULL, " ");
+	      if(strchr(bp,'.') != NULL)
+		stats->qual.updated |= 1;
+	      sscanf(bp, "%d", &t);
+	      stats->qual.qual = (unsigned char) t;
+	      /* -- signal level -- */
+	      bp = strtok(NULL, " ");
+	      if(strchr(bp,'.') != NULL)
+		stats->qual.updated |= 2;
+	      sscanf(bp, "%d", &t);
+	      stats->qual.level = (unsigned char) t;
+	      /* -- noise level -- */
+	      bp = strtok(NULL, " ");
+	      if(strchr(bp,'.') != NULL)
+		stats->qual.updated += 4;
+	      sscanf(bp, "%d", &t);
+	      stats->qual.noise = (unsigned char) t;
+	      /* -- discarded packets -- */
+	      bp = strtok(NULL, " ");
+	      sscanf(bp, "%d", &stats->discard.nwid);
+	      bp = strtok(NULL, " ");
+	      sscanf(bp, "%d", &stats->discard.code);
+	      bp = strtok(NULL, " ");
+	      sscanf(bp, "%d", &stats->discard.misc);
+	      fclose(f);
+	      /* No conversion needed */
+	      return 0;
+	    }
+	}
+      fclose(f);
+      return -1;
+    }
+}
+
+/*------------------------------------------------------------------*/
+/*
+ * Output the link statistics, taking care of formating
+ */
+void
+iw_print_stats(char *		buffer,
+	       int		buflen,
+	       const iwqual *	qual,
+	       const iwrange *	range,
+	       int		has_range)
+{
+  int		len;
+
+  /* People are very often confused by the 8 bit arithmetic happening
+   * here.
+   * All the values here are encoded in a 8 bit integer. 8 bit integers
+   * are either unsigned [0 ; 255], signed [-128 ; +127] or
+   * negative [-255 ; 0].
+   * Further, on 8 bits, 0x100 == 256 == 0.
+   *
+   * Relative/percent values are always encoded unsigned, between 0 and 255.
+   * Absolute/dBm values are always encoded between -192 and 63.
+   * (Note that up to version 28 of Wireless Tools, dBm used to be
+   *  encoded always negative, between -256 and -1).
+   *
+   * How do we separate relative from absolute values ?
+   * The old way is to use the range to do that. As of WE-19, we have
+   * an explicit IW_QUAL_DBM flag in updated...
+   * The range allow to specify the real min/max of the value. As the
+   * range struct only specify one bound of the value, we assume that
+   * the other bound is 0 (zero).
+   * For relative values, range is [0 ; range->max].
+   * For absolute values, range is [range->max ; 63].
+   *
+   * Let's take two example :
+   * 1) value is 75%. qual->value = 75 ; range->max_qual.value = 100
+   * 2) value is -54dBm. noise floor of the radio is -104dBm.
+   *    qual->value = -54 = 202 ; range->max_qual.value = -104 = 152
+   *
+   * Jean II
+   */
+
+  /* Just do it...
+   * The old way to detect dBm require both the range and a non-null
+   * level (which confuse the test). The new way can deal with level of 0
+   * because it does an explicit test on the flag. */
+  if(has_range && ((qual->level != 0)
+		   || (qual->updated & (IW_QUAL_DBM | IW_QUAL_RCPI))))
+    {
+      /* Check if the statistics are in RCPI (IEEE 802.11k) */
+      if(qual->updated & IW_QUAL_RCPI)
+	{
+	  /* Deal with signal level in RCPI */
+	  /* RCPI = int{(Power in dBm +110)*2} for 0dbm > Power > -110dBm */
+	  if(!(qual->updated & IW_QUAL_LEVEL_INVALID))
+	    {
+	      double	rcpilevel = (qual->level / 2.0) - 110.0;
+	      len = snprintf(buffer, buflen, "Signal level%c%g dBm  ",
+			     qual->updated & IW_QUAL_LEVEL_UPDATED ? '=' : ':',
+			     rcpilevel);
+	      buffer += len;
+	      buflen -= len;
+	    }
+
+	  /* Deal with noise level in dBm (absolute power measurement) */
+	  if(!(qual->updated & IW_QUAL_NOISE_INVALID))
+	    {
+	      double	rcpinoise = (qual->noise / 2.0) - 110.0;
+	      len = snprintf(buffer, buflen, "Noise level%c%g dBm  ",
+			     qual->updated & IW_QUAL_NOISE_UPDATED ? '=' : ':',
+			     rcpinoise);
+	    }
+	}
+      else
+	{
+	  /* Check if the statistics are in dBm */
+	  if((qual->updated & IW_QUAL_DBM)
+	     || (qual->level > range->max_qual.level))
+	    {
+	      /* Deal with signal level in dBm  (absolute power measurement) */
+	      if(!(qual->updated & IW_QUAL_LEVEL_INVALID))
+		{
+		  int	dblevel = qual->level;
+		  /* Implement a range for dBm [-192; 63] */
+		  if(qual->level >= 64)
+		    dblevel -= 0x100;
+		  len = snprintf(buffer, buflen, "Signal level%c%d dBm  ",
+				 qual->updated & IW_QUAL_LEVEL_UPDATED ? '=' : ':',
+				 dblevel);
+		  buffer += len;
+		  buflen -= len;
+		}
+
+	      /* Deal with noise level in dBm (absolute power measurement) */
+	      if(!(qual->updated & IW_QUAL_NOISE_INVALID))
+		{
+		  int	dbnoise = qual->noise;
+		  /* Implement a range for dBm [-192; 63] */
+		  if(qual->noise >= 64)
+		    dbnoise -= 0x100;
+		  len = snprintf(buffer, buflen, "Noise level%c%d dBm  ",
+				 qual->updated & IW_QUAL_NOISE_UPDATED ? '=' : ':',
+				 dbnoise);
+		}
+	    }
+	  else
+	    {
+	      /* Deal with signal level as relative value (0 -> max) */
+	      if(!(qual->updated & IW_QUAL_LEVEL_INVALID))
+		{
+		  len = snprintf(buffer, buflen, "Signal level%c%d/%d  ",
+				 qual->updated & IW_QUAL_LEVEL_UPDATED ? '=' : ':',
+				 qual->level, range->max_qual.level);
+		  buffer += len;
+		  buflen -= len;
+		}
+
+	      /* Deal with noise level as relative value (0 -> max) */
+	      if(!(qual->updated & IW_QUAL_NOISE_INVALID))
+		{
+		  len = snprintf(buffer, buflen, "Noise level%c%d/%d  ",
+				 qual->updated & IW_QUAL_NOISE_UPDATED ? '=' : ':',
+				 qual->noise, range->max_qual.noise);
+		}
+	    }
+	}
+
+      /* Deal with quality : always a relative value */
+      if(!(qual->updated & IW_QUAL_QUAL_INVALID))
+	{
+	  len = snprintf(buffer, buflen, "Quality%c%d/%d",
+			 qual->updated & IW_QUAL_QUAL_UPDATED ? '=' : ':',
+			 qual->qual, range->max_qual.qual);
+	  buffer += len;
+	  buflen -= len;
+	}
+    }
+  else
+    {
+      /* We can't read the range, so we don't know... */
+      snprintf(buffer, buflen,
+	       "Signal level:%d  Noise level:%d  Quality:%d",
+	       qual->level, qual->noise, qual->qual);
+    }
+}
+
+/*********************** ENCODING SUBROUTINES ***********************/
+
+/*------------------------------------------------------------------*/
+/*
+ * Output the encoding key, with a nice formating
+ */
+void
+iw_print_key(char *			buffer,
+	     int			buflen,
+	     const unsigned char *	key,		/* Must be unsigned */
+	     int			key_size,
+	     int			key_flags)
+{
+  int	i;
+
+  /* Check buffer size -> 1 bytes => 2 digits + 1/2 separator */
+  if((key_size * 3) > buflen)
+    {
+      snprintf(buffer, buflen, "<too big>");
+      return;
+    }
+
+  /* Is the key present ??? */
+  if(key_flags & IW_ENCODE_NOKEY)
+    {
+      /* Nope : print on or dummy */
+      if(key_size <= 0)
+	strcpy(buffer, "on");			/* Size checked */
+      else
+	{
+	  strcpy(buffer, "**");			/* Size checked */
+	  buffer +=2;
+	  for(i = 1; i < key_size; i++)
+	    {
+	      if((i & 0x1) == 0)
+		strcpy(buffer++, "-");		/* Size checked */
+	      strcpy(buffer, "**");		/* Size checked */
+	      buffer +=2;
+	    }
+	}
+    }
+  else
+    {
+      /* Yes : print the key */
+      sprintf(buffer, "%.2X", key[0]);		/* Size checked */
+      buffer +=2;
+      for(i = 1; i < key_size; i++)
+	{
+	  if((i & 0x1) == 0)
+	    strcpy(buffer++, "-");		/* Size checked */
+	  sprintf(buffer, "%.2X", key[i]);	/* Size checked */
+	  buffer +=2;
+	}
+    }
+}
+
+/*------------------------------------------------------------------*/
+/*
+ * Convert a passphrase into a key
+ * ### NOT IMPLEMENTED ###
+ * Return size of the key, or 0 (no key) or -1 (error)
+ */
+static int
+iw_pass_key(const char *	input,
+	    unsigned char *	key)
+{
+  input = input; key = key;
+  fprintf(stderr, "Error: Passphrase not implemented\n");
+  return(-1);
+}
+
+/*------------------------------------------------------------------*/
+/*
+ * Parse a key from the command line.
+ * Return size of the key, or 0 (no key) or -1 (error)
+ * If the key is too long, it's simply truncated...
+ */
+int
+iw_in_key(const char *		input,
+	  unsigned char *	key)
+{
+  int		keylen = 0;
+
+  /* Check the type of key */
+  if(!strncmp(input, "s:", 2))
+    {
+      /* First case : as an ASCII string (Lucent/Agere cards) */
+      keylen = strlen(input + 2);		/* skip "s:" */
+      if(keylen > IW_ENCODING_TOKEN_MAX)
+	keylen = IW_ENCODING_TOKEN_MAX;
+      memcpy(key, input + 2, keylen);
+    }
+  else
+    if(!strncmp(input, "p:", 2))
+      {
+	/* Second case : as a passphrase (PrismII cards) */
+	return(iw_pass_key(input + 2, key));		/* skip "p:" */
+      }
+    else
+      {
+	const char *	p;
+	int		dlen;	/* Digits sequence length */
+	unsigned char	out[IW_ENCODING_TOKEN_MAX];
+
+	/* Third case : as hexadecimal digits */
+	p = input;
+	dlen = -1;
+
+	/* Loop until we run out of chars in input or overflow the output */
+	while(*p != '\0')
+	  {
+	    int	temph;
+	    int	templ;
+	    int	count;
+	    /* No more chars in this sequence */
+	    if(dlen <= 0)
+	      {
+		/* Skip separator */
+		if(dlen == 0)
+		  p++;
+		/* Calculate num of char to next separator */
+		dlen = strcspn(p, "-:;.,");
+	      }
+	    /* Get each char separatly (and not by two) so that we don't
+	     * get confused by 'enc' (=> '0E'+'0C') and similar */
+	    count = sscanf(p, "%1X%1X", &temph, &templ);
+	    if(count < 1)
+	      return(-1);		/* Error -> non-hex char */
+	    /* Fixup odd strings such as '123' is '01'+'23' and not '12'+'03'*/
+	    if(dlen % 2)
+	      count = 1;
+	    /* Put back two chars as one byte and output */
+	    if(count == 2)
+	      templ |= temph << 4;
+	    else
+	      templ = temph;
+	    out[keylen++] = (unsigned char) (templ & 0xFF);
+	    /* Check overflow in output */
+	    if(keylen >= IW_ENCODING_TOKEN_MAX)
+	      break;
+	    /* Move on to next chars */
+	    p += count;
+	    dlen -= count;
+	  }
+	/* We use a temporary output buffer 'out' so that if there is
+	 * an error, we don't overwrite the original key buffer.
+	 * Because of the way iwconfig loop on multiple key/enc arguments
+	 * until it finds an error in here, this is necessary to avoid
+	 * silently corrupting the encryption key... */
+	memcpy(key, out, keylen);
+      }
+
+#ifdef DEBUG
+  {
+    char buf[IW_ENCODING_TOKEN_MAX * 3];
+    iw_print_key(buf, sizeof(buf), key, keylen, 0);
+    printf("Got key : %d [%s]\n", keylen, buf);
+  }
+#endif
+
+  return(keylen);
+}
+
+/*------------------------------------------------------------------*/
+/*
+ * Parse a key from the command line.
+ * Return size of the key, or 0 (no key) or -1 (error)
+ */
+int
+iw_in_key_full(int		skfd,
+	       const char *	ifname,
+	       const char *	input,
+	       unsigned char *	key,
+	       __u16 *		flags)
+{
+  int		keylen = 0;
+  char *	p;
+
+  if(!strncmp(input, "l:", 2))
+    {
+      struct iw_range	range;
+
+      /* Extra case : as a login (user:passwd - Cisco LEAP) */
+      keylen = strlen(input + 2) + 1;		/* skip "l:", add '\0' */
+      /* Most user/password is 8 char, so 18 char total, < 32 */
+      if(keylen > IW_ENCODING_TOKEN_MAX)
+	keylen = IW_ENCODING_TOKEN_MAX;
+      memcpy(key, input + 2, keylen);
+
+      /* Separate the two strings */
+      p = strchr((char *) key, ':');
+      if(p == NULL)
+	{
+	  fprintf(stderr, "Error: Invalid login format\n");
+	  return(-1);
+	}
+      *p = '\0';
+
+      /* Extract range info */
+      if(iw_get_range_info(skfd, ifname, &range) < 0)
+	/* Hum... Maybe we should return an error ??? */
+	memset(&range, 0, sizeof(range));
+
+      if(range.we_version_compiled > 15)
+	{
+
+	  printf("flags = %X, index = %X\n",
+		 *flags, range.encoding_login_index);
+	  if((*flags & IW_ENCODE_INDEX) == 0)
+	    {
+	      /* Extract range info */
+	      if(iw_get_range_info(skfd, ifname, &range) < 0)
+		memset(&range, 0, sizeof(range));
+	      printf("flags = %X, index = %X\n", *flags, range.encoding_login_index);
+	      /* Set the index the driver expects */
+	      *flags |= range.encoding_login_index & IW_ENCODE_INDEX;
+	    }
+	  printf("flags = %X, index = %X\n", *flags, range.encoding_login_index);
+	}
+    }
+  else
+    /* Simpler routine above */
+    keylen = iw_in_key(input, key);
+
+  return(keylen);
+}
+
+/******************* POWER MANAGEMENT SUBROUTINES *******************/
+
+/*------------------------------------------------------------------*/
+/*
+ * Output a power management value with all attributes...
+ */
+void
+iw_print_pm_value(char *	buffer,
+		  int		buflen,
+		  int		value,
+		  int		flags,
+		  int		we_version)
+{
+  /* Check size */
+  if(buflen < 25)
+    {
+      snprintf(buffer, buflen, "<too big>");
+      return;
+    }
+  buflen -= 25;
+
+  /* Modifiers */
+  if(flags & IW_POWER_MIN)
+    {
+      strcpy(buffer, " min");				/* Size checked */
+      buffer += 4;
+    }
+  if(flags & IW_POWER_MAX)
+    {
+      strcpy(buffer, " max");				/* Size checked */
+      buffer += 4;
+    }
+
+  /* Type */
+  if(flags & IW_POWER_TIMEOUT)
+    {
+      strcpy(buffer, " timeout:");			/* Size checked */
+      buffer += 9;
+    }
+  else
+    {
+      if(flags & IW_POWER_SAVING)
+	{
+	  strcpy(buffer, " saving:");			/* Size checked */
+	  buffer += 8;
+	}
+      else
+	{
+	  strcpy(buffer, " period:");			/* Size checked */
+	  buffer += 8;
+	}
+    }
+
+  /* Display value without units */
+  if(flags & IW_POWER_RELATIVE)
+    {
+      if(we_version < 21)
+	value /= MEGA;
+      snprintf(buffer, buflen, "%d", value);
+    }
+  else
+    {
+      /* Display value with units */
+      if(value >= (int) MEGA)
+	snprintf(buffer, buflen, "%gs", ((double) value) / MEGA);
+      else
+	if(value >= (int) KILO)
+	  snprintf(buffer, buflen, "%gms", ((double) value) / KILO);
+	else
+	  snprintf(buffer, buflen, "%dus", value);
+    }
+}
+
+/*------------------------------------------------------------------*/
+/*
+ * Output a power management mode
+ */
+void
+iw_print_pm_mode(char *	buffer,
+		 int	buflen,
+		 int	flags)
+{
+  /* Check size */
+  if(buflen < 28)
+    {
+      snprintf(buffer, buflen, "<too big>");
+      return;
+    }
+
+  /* Print the proper mode... */
+  switch(flags & IW_POWER_MODE)
+    {
+    case IW_POWER_UNICAST_R:
+      strcpy(buffer, "mode:Unicast only received");	/* Size checked */
+      break;
+    case IW_POWER_MULTICAST_R:
+      strcpy(buffer, "mode:Multicast only received");	/* Size checked */
+      break;
+    case IW_POWER_ALL_R:
+      strcpy(buffer, "mode:All packets received");	/* Size checked */
+      break;
+    case IW_POWER_FORCE_S:
+      strcpy(buffer, "mode:Force sending");		/* Size checked */
+      break;
+    case IW_POWER_REPEATER:
+      strcpy(buffer, "mode:Repeat multicasts");		/* Size checked */
+      break;
+    default:
+      strcpy(buffer, "");				/* Size checked */
+      break;
+    }
+}
+
+/***************** RETRY LIMIT/LIFETIME SUBROUTINES *****************/
+
+/*------------------------------------------------------------------*/
+/*
+ * Output a retry value with all attributes...
+ */
+void
+iw_print_retry_value(char *	buffer,
+		     int	buflen,
+		     int	value,
+		     int	flags,
+		     int	we_version)
+{
+  /* Check buffer size */
+  if(buflen < 20)
+    {
+      snprintf(buffer, buflen, "<too big>");
+      return;
+    }
+  buflen -= 20;
+
+  /* Modifiers */
+  if(flags & IW_RETRY_MIN)
+    {
+      strcpy(buffer, " min");				/* Size checked */
+      buffer += 4;
+    }
+  if(flags & IW_RETRY_MAX)
+    {
+      strcpy(buffer, " max");				/* Size checked */
+      buffer += 4;
+    }
+  if(flags & IW_RETRY_SHORT)
+    {
+      strcpy(buffer, " short");				/* Size checked */
+      buffer += 6;
+    }
+  if(flags & IW_RETRY_LONG)
+    {
+      strcpy(buffer, "  long");				/* Size checked */
+      buffer += 6;
+    }
+
+  /* Type lifetime of limit */
+  if(flags & IW_RETRY_LIFETIME)
+    {
+      strcpy(buffer, " lifetime:");			/* Size checked */
+      buffer += 10;
+
+      /* Display value without units */
+      if(flags & IW_RETRY_RELATIVE)
+	{
+	  if(we_version < 21)
+	    value /= MEGA;
+	  snprintf(buffer, buflen, "%d", value);
+	}
+      else
+	{
+	  /* Display value with units */
+	  if(value >= (int) MEGA)
+	    snprintf(buffer, buflen, "%gs", ((double) value) / MEGA);
+	  else
+	    if(value >= (int) KILO)
+	      snprintf(buffer, buflen, "%gms", ((double) value) / KILO);
+	    else
+	      snprintf(buffer, buflen, "%dus", value);
+	}
+    }
+  else
+    snprintf(buffer, buflen, " limit:%d", value);
+}
+
+/************************* TIME SUBROUTINES *************************/
+
+/*------------------------------------------------------------------*/
+/*
+ * Print timestamps
+ * Inspired from irdadump...
+ */
+void
+iw_print_timeval(char *				buffer,
+		 int				buflen,
+		 const struct timeval *		timev,
+		 const struct timezone *	tz)
+{
+        int s;
+
+	s = (timev->tv_sec - tz->tz_minuteswest * 60) % 86400;
+	snprintf(buffer, buflen, "%02d:%02d:%02d.%06u", 
+		s / 3600, (s % 3600) / 60, 
+		s % 60, (u_int32_t) timev->tv_usec);
+}
+
+/*********************** ADDRESS SUBROUTINES ************************/
+/*
+ * This section is mostly a cut & past from net-tools-1.2.0
+ * (Well... This has evolved over the years)
+ * manage address display and input...
+ */
+
+/*------------------------------------------------------------------*/
+/*
+ * Check if interface support the right MAC address type...
+ */
+int
+iw_check_mac_addr_type(int		skfd,
+		       const char *	ifname)
+{
+  struct ifreq		ifr;
+
+  /* Get the type of hardware address */
+  strncpy(ifr.ifr_name, ifname, IFNAMSIZ);
+  if((ioctl(skfd, SIOCGIFHWADDR, &ifr) < 0) ||
+     ((ifr.ifr_hwaddr.sa_family != ARPHRD_ETHER)
+      && (ifr.ifr_hwaddr.sa_family != ARPHRD_IEEE80211)))
+    {
+      /* Deep trouble... */
+      fprintf(stderr, "Interface %s doesn't support MAC addresses\n",
+	     ifname);
+      return(-1);
+    }
+
+#ifdef DEBUG
+  {
+    char buf[20];
+    printf("Hardware : %d - %s\n", ifr.ifr_hwaddr.sa_family,
+	   iw_saether_ntop(&ifr.ifr_hwaddr, buf));
+  }
+#endif
+
+  return(0);
+}
+
+
+/*------------------------------------------------------------------*/
+/*
+ * Check if interface support the right interface address type...
+ */
+int
+iw_check_if_addr_type(int		skfd,
+		      const char *	ifname)
+{
+  struct ifreq		ifr;
+
+  /* Get the type of interface address */
+  strncpy(ifr.ifr_name, ifname, IFNAMSIZ);
+  if((ioctl(skfd, SIOCGIFADDR, &ifr) < 0) ||
+     (ifr.ifr_addr.sa_family !=  AF_INET))
+    {
+      /* Deep trouble... */
+      fprintf(stderr, "Interface %s doesn't support IP addresses\n", ifname);
+      return(-1);
+    }
+
+#ifdef DEBUG
+  printf("Interface : %d - 0x%lX\n", ifr.ifr_addr.sa_family,
+	 *((unsigned long *) ifr.ifr_addr.sa_data));
+#endif
+
+  return(0);
+}
+
+#if 0
+/*------------------------------------------------------------------*/
+/*
+ * Check if interface support the right address types...
+ */
+int
+iw_check_addr_type(int		skfd,
+		   char *	ifname)
+{
+  /* Check the interface address type */
+  if(iw_check_if_addr_type(skfd, ifname) < 0)
+    return(-1);
+
+  /* Check the interface address type */
+  if(iw_check_mac_addr_type(skfd, ifname) < 0)
+    return(-1);
+
+  return(0);
+}
+#endif
+
+#if 0
+/*------------------------------------------------------------------*/
+/*
+ * Ask the kernel for the MAC address of an interface.
+ */
+int
+iw_get_mac_addr(int			skfd,
+		const char *		ifname,
+		struct ether_addr *	eth,
+		unsigned short *	ptype)
+{
+  struct ifreq	ifr;
+  int		ret;
+
+  /* Prepare request */
+  bzero(&ifr, sizeof(struct ifreq));
+  strncpy(ifr.ifr_name, ifname, IFNAMSIZ);
+
+  /* Do it */
+  ret = ioctl(skfd, SIOCGIFHWADDR, &ifr);
+
+  memcpy(eth->ether_addr_octet, ifr.ifr_hwaddr.sa_data, 6); 
+  *ptype = ifr.ifr_hwaddr.sa_family;
+  return(ret);
+}
+#endif
+
+/*------------------------------------------------------------------*/
+/*
+ * Display an arbitrary length MAC address in readable format.
+ */
+char *
+iw_mac_ntop(const unsigned char *	mac,
+	    int				maclen,
+	    char *			buf,
+	    int				buflen)
+{
+  int	i;
+
+  /* Overflow check (don't forget '\0') */
+  if(buflen < (maclen * 3 - 1 + 1))
+    return(NULL);
+
+  /* First byte */
+  sprintf(buf, "%02X", mac[0]);
+
+  /* Other bytes */
+  for(i = 1; i < maclen; i++)
+    sprintf(buf + (i * 3) - 1, ":%02X", mac[i]);
+  return(buf);
+}
+
+/*------------------------------------------------------------------*/
+/*
+ * Display an Ethernet address in readable format.
+ */
+void
+iw_ether_ntop(const struct ether_addr *	eth,
+	      char *			buf)
+{
+  sprintf(buf, "%02X:%02X:%02X:%02X:%02X:%02X",
+	  eth->ether_addr_octet[0], eth->ether_addr_octet[1],
+	  eth->ether_addr_octet[2], eth->ether_addr_octet[3],
+	  eth->ether_addr_octet[4], eth->ether_addr_octet[5]);
+}
+
+/*------------------------------------------------------------------*/
+/*
+ * Display an Wireless Access Point Socket Address in readable format.
+ * Note : 0x44 is an accident of history, that's what the Orinoco/PrismII
+ * chipset report, and the driver doesn't filter it.
+ */
+char *
+iw_sawap_ntop(const struct sockaddr *	sap,
+	      char *			buf)
+{
+  const struct ether_addr ether_zero = {{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }};
+  const struct ether_addr ether_bcast = {{ 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF }};
+  const struct ether_addr ether_hack = {{ 0x44, 0x44, 0x44, 0x44, 0x44, 0x44 }};
+  const struct ether_addr * ether_wap = (const struct ether_addr *) sap->sa_data;
+
+  if(!iw_ether_cmp(ether_wap, &ether_zero))
+    sprintf(buf, "Not-Associated");
+  else
+    if(!iw_ether_cmp(ether_wap, &ether_bcast))
+      sprintf(buf, "Invalid");
+    else
+      if(!iw_ether_cmp(ether_wap, &ether_hack))
+	sprintf(buf, "None");
+      else
+	iw_ether_ntop(ether_wap, buf);
+  return(buf);
+}
+
+/*------------------------------------------------------------------*/
+/*
+ * Input an arbitrary length MAC address and convert to binary.
+ * Return address size.
+ */
+int
+iw_mac_aton(const char *	orig,
+	    unsigned char *	mac,
+	    int			macmax)
+{
+  const char *	p = orig;
+  int		maclen = 0;
+
+  /* Loop on all bytes of the string */
+  while(*p != '\0')
+    {
+      int	temph;
+      int	templ;
+      int	count;
+      /* Extract one byte as two chars */
+      count = sscanf(p, "%1X%1X", &temph, &templ);
+      if(count != 2)
+	break;			/* Error -> non-hex chars */
+      /* Output two chars as one byte */
+      templ |= temph << 4;
+      mac[maclen++] = (unsigned char) (templ & 0xFF);
+
+      /* Check end of string */
+      p += 2;
+      if(*p == '\0')
+	{
+#ifdef DEBUG
+	  char buf[20];
+	  iw_ether_ntop((const struct ether_addr *) mac, buf);
+	  fprintf(stderr, "iw_mac_aton(%s): %s\n", orig, buf);
+#endif
+	  return(maclen);		/* Normal exit */
+	}
+
+      /* Check overflow */
+      if(maclen >= macmax)
+	{
+#ifdef DEBUG
+	  fprintf(stderr, "iw_mac_aton(%s): trailing junk!\n", orig);
+#endif
+	  errno = E2BIG;
+	  return(0);			/* Error -> overflow */
+	}
+
+      /* Check separator */
+      if(*p != ':')
+	break;
+      p++;
+    }
+
+  /* Error... */
+#ifdef DEBUG
+  fprintf(stderr, "iw_mac_aton(%s): invalid ether address!\n", orig);
+#endif
+  errno = EINVAL;
+  return(0);
+}
+
+/*------------------------------------------------------------------*/
+/*
+ * Input an Ethernet address and convert to binary.
+ */
+int
+iw_ether_aton(const char *orig, struct ether_addr *eth)
+{
+  int	maclen;
+  maclen = iw_mac_aton(orig, (unsigned char *) eth, ETH_ALEN);
+  if((maclen > 0) && (maclen < ETH_ALEN))
+    {
+      errno = EINVAL;
+      maclen = 0;
+    }
+  return(maclen);
+}
+
+/*------------------------------------------------------------------*/
+/*
+ * Input an Internet address and convert to binary.
+ */
+int
+iw_in_inet(char *name, struct sockaddr *sap)
+{
+  struct hostent *hp;
+  struct netent *np;
+  struct sockaddr_in *sain = (struct sockaddr_in *) sap;
+
+  /* Grmpf. -FvK */
+  sain->sin_family = AF_INET;
+  sain->sin_port = 0;
+
+  /* Default is special, meaning 0.0.0.0. */
+  if (!strcmp(name, "default")) {
+	sain->sin_addr.s_addr = INADDR_ANY;
+	return(1);
+  }
+
+  /* Try the NETWORKS database to see if this is a known network. */
+  if ((np = getnetbyname(name)) != (struct netent *)NULL) {
+	sain->sin_addr.s_addr = htonl(np->n_net);
+	strcpy(name, np->n_name);
+	return(1);
+  }
+
+  /* Always use the resolver (DNS name + IP addresses) */
+  if ((hp = gethostbyname(name)) == (struct hostent *)NULL) {
+	errno = h_errno;
+	return(-1);
+  }
+  memcpy((char *) &sain->sin_addr, (char *) hp->h_addr_list[0], hp->h_length);
+  strcpy(name, hp->h_name);
+  return(0);
+}
+
+/*------------------------------------------------------------------*/
+/*
+ * Input an address and convert to binary.
+ */
+int
+iw_in_addr(int		skfd,
+	   const char *	ifname,
+	   char *	bufp,
+	   struct sockaddr *sap)
+{
+  /* Check if it is a hardware or IP address */
+  if(strchr(bufp, ':') == NULL)
+    {
+      struct sockaddr	if_address;
+      struct arpreq	arp_query;
+
+      /* Check if we have valid interface address type */
+      if(iw_check_if_addr_type(skfd, ifname) < 0)
+	{
+	  fprintf(stderr, "%-8.16s  Interface doesn't support IP addresses\n", ifname);
+	  return(-1);
+	}
+
+      /* Read interface address */
+      if(iw_in_inet(bufp, &if_address) < 0)
+	{
+	  fprintf(stderr, "Invalid interface address %s\n", bufp);
+	  return(-1);
+	}
+
+      /* Translate IP addresses to MAC addresses */
+      memcpy((char *) &(arp_query.arp_pa),
+	     (char *) &if_address,
+	     sizeof(struct sockaddr));
+      arp_query.arp_ha.sa_family = 0;
+      arp_query.arp_flags = 0;
+      /* The following restrict the search to the interface only */
+      /* For old kernels which complain, just comment it... */
+      strncpy(arp_query.arp_dev, ifname, IFNAMSIZ);
+      if((ioctl(skfd, SIOCGARP, &arp_query) < 0) ||
+	 !(arp_query.arp_flags & ATF_COM))
+	{
+	  fprintf(stderr, "Arp failed for %s on %s... (%d)\nTry to ping the address before setting it.\n",
+		  bufp, ifname, errno);
+	  return(-1);
+	}
+
+      /* Store new MAC address */
+      memcpy((char *) sap,
+	     (char *) &(arp_query.arp_ha),
+	     sizeof(struct sockaddr));
+
+#ifdef DEBUG
+      {
+	char buf[20];
+	printf("IP Address %s => Hw Address = %s\n",
+	       bufp, iw_saether_ntop(sap, buf));
+      }
+#endif
+    }
+  else	/* If it's an hardware address */
+    {
+      /* Check if we have valid mac address type */
+      if(iw_check_mac_addr_type(skfd, ifname) < 0)
+	{
+	  fprintf(stderr, "%-8.16s  Interface doesn't support MAC addresses\n", ifname);
+	  return(-1);
+	}
+
+      /* Get the hardware address */
+      if(iw_saether_aton(bufp, sap) == 0)
+	{
+	  fprintf(stderr, "Invalid hardware address %s\n", bufp);
+	  return(-1);
+	}
+    }
+
+#ifdef DEBUG
+  {
+    char buf[20];
+    printf("Hw Address = %s\n", iw_saether_ntop(sap, buf));
+  }
+#endif
+
+  return(0);
+}
+
+/************************* MISC SUBROUTINES **************************/
+
+/* Size (in bytes) of various events */
+static const int priv_type_size[] = {
+	0,				/* IW_PRIV_TYPE_NONE */
+	1,				/* IW_PRIV_TYPE_BYTE */
+	1,				/* IW_PRIV_TYPE_CHAR */
+	0,				/* Not defined */
+	sizeof(__u32),			/* IW_PRIV_TYPE_INT */
+	sizeof(struct iw_freq),		/* IW_PRIV_TYPE_FLOAT */
+	sizeof(struct sockaddr),	/* IW_PRIV_TYPE_ADDR */
+	0,				/* Not defined */
+};
+
+/*------------------------------------------------------------------*/
+/*
+ * Max size in bytes of an private argument.
+ */
+int
+iw_get_priv_size(int	args)
+{
+  int	num = args & IW_PRIV_SIZE_MASK;
+  int	type = (args & IW_PRIV_TYPE_MASK) >> 12;
+
+  return(num * priv_type_size[type]);
+}
+
+/************************ EVENT SUBROUTINES ************************/
+/*
+ * The Wireless Extension API 14 and greater define Wireless Events,
+ * that are used for various events and scanning.
+ * Those functions help the decoding of events, so are needed only in
+ * this case.
+ */
+
+/* -------------------------- CONSTANTS -------------------------- */
+
+/* Type of headers we know about (basically union iwreq_data) */
+#define IW_HEADER_TYPE_NULL	0	/* Not available */
+#define IW_HEADER_TYPE_CHAR	2	/* char [IFNAMSIZ] */
+#define IW_HEADER_TYPE_UINT	4	/* __u32 */
+#define IW_HEADER_TYPE_FREQ	5	/* struct iw_freq */
+#define IW_HEADER_TYPE_ADDR	6	/* struct sockaddr */
+#define IW_HEADER_TYPE_POINT	8	/* struct iw_point */
+#define IW_HEADER_TYPE_PARAM	9	/* struct iw_param */
+#define IW_HEADER_TYPE_QUAL	10	/* struct iw_quality */
+
+/* Handling flags */
+/* Most are not implemented. I just use them as a reminder of some
+ * cool features we might need one day ;-) */
+#define IW_DESCR_FLAG_NONE	0x0000	/* Obvious */
+/* Wrapper level flags */
+#define IW_DESCR_FLAG_DUMP	0x0001	/* Not part of the dump command */
+#define IW_DESCR_FLAG_EVENT	0x0002	/* Generate an event on SET */
+#define IW_DESCR_FLAG_RESTRICT	0x0004	/* GET : request is ROOT only */
+				/* SET : Omit payload from generated iwevent */
+#define IW_DESCR_FLAG_NOMAX	0x0008	/* GET : no limit on request size */
+/* Driver level flags */
+#define IW_DESCR_FLAG_WAIT	0x0100	/* Wait for driver event */
+
+/* ---------------------------- TYPES ---------------------------- */
+
+/*
+ * Describe how a standard IOCTL looks like.
+ */
+struct iw_ioctl_description
+{
+	__u8	header_type;		/* NULL, iw_point or other */
+	__u8	token_type;		/* Future */
+	__u16	token_size;		/* Granularity of payload */
+	__u16	min_tokens;		/* Min acceptable token number */
+	__u16	max_tokens;		/* Max acceptable token number */
+	__u32	flags;			/* Special handling of the request */
+};
+
+/* -------------------------- VARIABLES -------------------------- */
+
+/*
+ * Meta-data about all the standard Wireless Extension request we
+ * know about.
+ */
+static const struct iw_ioctl_description standard_ioctl_descr[] = {
+	[SIOCSIWCOMMIT	- SIOCIWFIRST] = {
+		.header_type	= IW_HEADER_TYPE_NULL,
+	},
+	[SIOCGIWNAME	- SIOCIWFIRST] = {
+		.header_type	= IW_HEADER_TYPE_CHAR,
+		.flags		= IW_DESCR_FLAG_DUMP,
+	},
+	[SIOCSIWNWID	- SIOCIWFIRST] = {
+		.header_type	= IW_HEADER_TYPE_PARAM,
+		.flags		= IW_DESCR_FLAG_EVENT,
+	},
+	[SIOCGIWNWID	- SIOCIWFIRST] = {
+		.header_type	= IW_HEADER_TYPE_PARAM,
+		.flags		= IW_DESCR_FLAG_DUMP,
+	},
+	[SIOCSIWFREQ	- SIOCIWFIRST] = {
+		.header_type	= IW_HEADER_TYPE_FREQ,
+		.flags		= IW_DESCR_FLAG_EVENT,
+	},
+	[SIOCGIWFREQ	- SIOCIWFIRST] = {
+		.header_type	= IW_HEADER_TYPE_FREQ,
+		.flags		= IW_DESCR_FLAG_DUMP,
+	},
+	[SIOCSIWMODE	- SIOCIWFIRST] = {
+		.header_type	= IW_HEADER_TYPE_UINT,
+		.flags		= IW_DESCR_FLAG_EVENT,
+	},
+	[SIOCGIWMODE	- SIOCIWFIRST] = {
+		.header_type	= IW_HEADER_TYPE_UINT,
+		.flags		= IW_DESCR_FLAG_DUMP,
+	},
+	[SIOCSIWSENS	- SIOCIWFIRST] = {
+		.header_type	= IW_HEADER_TYPE_PARAM,
+	},
+	[SIOCGIWSENS	- SIOCIWFIRST] = {
+		.header_type	= IW_HEADER_TYPE_PARAM,
+	},
+	[SIOCSIWRANGE	- SIOCIWFIRST] = {
+		.header_type	= IW_HEADER_TYPE_NULL,
+	},
+	[SIOCGIWRANGE	- SIOCIWFIRST] = {
+		.header_type	= IW_HEADER_TYPE_POINT,
+		.token_size	= 1,
+		.max_tokens	= sizeof(struct iw_range),
+		.flags		= IW_DESCR_FLAG_DUMP,
+	},
+	[SIOCSIWPRIV	- SIOCIWFIRST] = {
+		.header_type	= IW_HEADER_TYPE_NULL,
+	},
+	[SIOCGIWPRIV	- SIOCIWFIRST] = { /* (handled directly by us) */
+		.header_type	= IW_HEADER_TYPE_NULL,
+	},
+	[SIOCSIWSTATS	- SIOCIWFIRST] = {
+		.header_type	= IW_HEADER_TYPE_NULL,
+	},
+	[SIOCGIWSTATS	- SIOCIWFIRST] = { /* (handled directly by us) */
+		.header_type	= IW_HEADER_TYPE_NULL,
+		.flags		= IW_DESCR_FLAG_DUMP,
+	},
+	[SIOCSIWSPY	- SIOCIWFIRST] = {
+		.header_type	= IW_HEADER_TYPE_POINT,
+		.token_size	= sizeof(struct sockaddr),
+		.max_tokens	= IW_MAX_SPY,
+	},
+	[SIOCGIWSPY	- SIOCIWFIRST] = {
+		.header_type	= IW_HEADER_TYPE_POINT,
+		.token_size	= sizeof(struct sockaddr) +
+				  sizeof(struct iw_quality),
+		.max_tokens	= IW_MAX_SPY,
+	},
+	[SIOCSIWTHRSPY	- SIOCIWFIRST] = {
+		.header_type	= IW_HEADER_TYPE_POINT,
+		.token_size	= sizeof(struct iw_thrspy),
+		.min_tokens	= 1,
+		.max_tokens	= 1,
+	},
+	[SIOCGIWTHRSPY	- SIOCIWFIRST] = {
+		.header_type	= IW_HEADER_TYPE_POINT,
+		.token_size	= sizeof(struct iw_thrspy),
+		.min_tokens	= 1,
+		.max_tokens	= 1,
+	},
+	[SIOCSIWAP	- SIOCIWFIRST] = {
+		.header_type	= IW_HEADER_TYPE_ADDR,
+	},
+	[SIOCGIWAP	- SIOCIWFIRST] = {
+		.header_type	= IW_HEADER_TYPE_ADDR,
+		.flags		= IW_DESCR_FLAG_DUMP,
+	},
+	[SIOCSIWMLME	- SIOCIWFIRST] = {
+		.header_type	= IW_HEADER_TYPE_POINT,
+		.token_size	= 1,
+		.min_tokens	= sizeof(struct iw_mlme),
+		.max_tokens	= sizeof(struct iw_mlme),
+	},
+	[SIOCGIWAPLIST	- SIOCIWFIRST] = {
+		.header_type	= IW_HEADER_TYPE_POINT,
+		.token_size	= sizeof(struct sockaddr) +
+				  sizeof(struct iw_quality),
+		.max_tokens	= IW_MAX_AP,
+		.flags		= IW_DESCR_FLAG_NOMAX,
+	},
+	[SIOCSIWSCAN	- SIOCIWFIRST] = {
+		.header_type	= IW_HEADER_TYPE_POINT,
+		.token_size	= 1,
+		.min_tokens	= 0,
+		.max_tokens	= sizeof(struct iw_scan_req),
+	},
+	[SIOCGIWSCAN	- SIOCIWFIRST] = {
+		.header_type	= IW_HEADER_TYPE_POINT,
+		.token_size	= 1,
+		.max_tokens	= IW_SCAN_MAX_DATA,
+		.flags		= IW_DESCR_FLAG_NOMAX,
+	},
+	[SIOCSIWESSID	- SIOCIWFIRST] = {
+		.header_type	= IW_HEADER_TYPE_POINT,
+		.token_size	= 1,
+		.max_tokens	= IW_ESSID_MAX_SIZE + 1,
+		.flags		= IW_DESCR_FLAG_EVENT,
+	},
+	[SIOCGIWESSID	- SIOCIWFIRST] = {
+		.header_type	= IW_HEADER_TYPE_POINT,
+		.token_size	= 1,
+		.max_tokens	= IW_ESSID_MAX_SIZE + 1,
+		.flags		= IW_DESCR_FLAG_DUMP,
+	},
+	[SIOCSIWNICKN	- SIOCIWFIRST] = {
+		.header_type	= IW_HEADER_TYPE_POINT,
+		.token_size	= 1,
+		.max_tokens	= IW_ESSID_MAX_SIZE + 1,
+	},
+	[SIOCGIWNICKN	- SIOCIWFIRST] = {
+		.header_type	= IW_HEADER_TYPE_POINT,
+		.token_size	= 1,
+		.max_tokens	= IW_ESSID_MAX_SIZE + 1,
+	},
+	[SIOCSIWRATE	- SIOCIWFIRST] = {
+		.header_type	= IW_HEADER_TYPE_PARAM,
+	},
+	[SIOCGIWRATE	- SIOCIWFIRST] = {
+		.header_type	= IW_HEADER_TYPE_PARAM,
+	},
+	[SIOCSIWRTS	- SIOCIWFIRST] = {
+		.header_type	= IW_HEADER_TYPE_PARAM,
+	},
+	[SIOCGIWRTS	- SIOCIWFIRST] = {
+		.header_type	= IW_HEADER_TYPE_PARAM,
+	},
+	[SIOCSIWFRAG	- SIOCIWFIRST] = {
+		.header_type	= IW_HEADER_TYPE_PARAM,
+	},
+	[SIOCGIWFRAG	- SIOCIWFIRST] = {
+		.header_type	= IW_HEADER_TYPE_PARAM,
+	},
+	[SIOCSIWTXPOW	- SIOCIWFIRST] = {
+		.header_type	= IW_HEADER_TYPE_PARAM,
+	},
+	[SIOCGIWTXPOW	- SIOCIWFIRST] = {
+		.header_type	= IW_HEADER_TYPE_PARAM,
+	},
+	[SIOCSIWRETRY	- SIOCIWFIRST] = {
+		.header_type	= IW_HEADER_TYPE_PARAM,
+	},
+	[SIOCGIWRETRY	- SIOCIWFIRST] = {
+		.header_type	= IW_HEADER_TYPE_PARAM,
+	},
+	[SIOCSIWENCODE	- SIOCIWFIRST] = {
+		.header_type	= IW_HEADER_TYPE_POINT,
+		.token_size	= 1,
+		.max_tokens	= IW_ENCODING_TOKEN_MAX,
+		.flags		= IW_DESCR_FLAG_EVENT | IW_DESCR_FLAG_RESTRICT,
+	},
+	[SIOCGIWENCODE	- SIOCIWFIRST] = {
+		.header_type	= IW_HEADER_TYPE_POINT,
+		.token_size	= 1,
+		.max_tokens	= IW_ENCODING_TOKEN_MAX,
+		.flags		= IW_DESCR_FLAG_DUMP | IW_DESCR_FLAG_RESTRICT,
+	},
+	[SIOCSIWPOWER	- SIOCIWFIRST] = {
+		.header_type	= IW_HEADER_TYPE_PARAM,
+	},
+	[SIOCGIWPOWER	- SIOCIWFIRST] = {
+		.header_type	= IW_HEADER_TYPE_PARAM,
+	},
+	[SIOCSIWMODUL	- SIOCIWFIRST] = {
+		.header_type	= IW_HEADER_TYPE_PARAM,
+	},
+	[SIOCGIWMODUL	- SIOCIWFIRST] = {
+		.header_type	= IW_HEADER_TYPE_PARAM,
+	},
+	[SIOCSIWGENIE	- SIOCIWFIRST] = {
+		.header_type	= IW_HEADER_TYPE_POINT,
+		.token_size	= 1,
+		.max_tokens	= IW_GENERIC_IE_MAX,
+	},
+	[SIOCGIWGENIE	- SIOCIWFIRST] = {
+		.header_type	= IW_HEADER_TYPE_POINT,
+		.token_size	= 1,
+		.max_tokens	= IW_GENERIC_IE_MAX,
+	},
+	[SIOCSIWAUTH	- SIOCIWFIRST] = {
+		.header_type	= IW_HEADER_TYPE_PARAM,
+	},
+	[SIOCGIWAUTH	- SIOCIWFIRST] = {
+		.header_type	= IW_HEADER_TYPE_PARAM,
+	},
+	[SIOCSIWENCODEEXT - SIOCIWFIRST] = {
+		.header_type	= IW_HEADER_TYPE_POINT,
+		.token_size	= 1,
+		.min_tokens	= sizeof(struct iw_encode_ext),
+		.max_tokens	= sizeof(struct iw_encode_ext) +
+				  IW_ENCODING_TOKEN_MAX,
+	},
+	[SIOCGIWENCODEEXT - SIOCIWFIRST] = {
+		.header_type	= IW_HEADER_TYPE_POINT,
+		.token_size	= 1,
+		.min_tokens	= sizeof(struct iw_encode_ext),
+		.max_tokens	= sizeof(struct iw_encode_ext) +
+				  IW_ENCODING_TOKEN_MAX,
+	},
+	[SIOCSIWPMKSA - SIOCIWFIRST] = {
+		.header_type	= IW_HEADER_TYPE_POINT,
+		.token_size	= 1,
+		.min_tokens	= sizeof(struct iw_pmksa),
+		.max_tokens	= sizeof(struct iw_pmksa),
+	},
+};
+static const unsigned int standard_ioctl_num = (sizeof(standard_ioctl_descr) /
+						sizeof(struct iw_ioctl_description));
+
+/*
+ * Meta-data about all the additional standard Wireless Extension events
+ * we know about.
+ */
+static const struct iw_ioctl_description standard_event_descr[] = {
+	[IWEVTXDROP	- IWEVFIRST] = {
+		.header_type	= IW_HEADER_TYPE_ADDR,
+	},
+	[IWEVQUAL	- IWEVFIRST] = {
+		.header_type	= IW_HEADER_TYPE_QUAL,
+	},
+	[IWEVCUSTOM	- IWEVFIRST] = {
+		.header_type	= IW_HEADER_TYPE_POINT,
+		.token_size	= 1,
+		.max_tokens	= IW_CUSTOM_MAX,
+	},
+	[IWEVREGISTERED	- IWEVFIRST] = {
+		.header_type	= IW_HEADER_TYPE_ADDR,
+	},
+	[IWEVEXPIRED	- IWEVFIRST] = {
+		.header_type	= IW_HEADER_TYPE_ADDR, 
+	},
+	[IWEVGENIE	- IWEVFIRST] = {
+		.header_type	= IW_HEADER_TYPE_POINT,
+		.token_size	= 1,
+		.max_tokens	= IW_GENERIC_IE_MAX,
+	},
+	[IWEVMICHAELMICFAILURE	- IWEVFIRST] = {
+		.header_type	= IW_HEADER_TYPE_POINT, 
+		.token_size	= 1,
+		.max_tokens	= sizeof(struct iw_michaelmicfailure),
+	},
+	[IWEVASSOCREQIE	- IWEVFIRST] = {
+		.header_type	= IW_HEADER_TYPE_POINT,
+		.token_size	= 1,
+		.max_tokens	= IW_GENERIC_IE_MAX,
+	},
+	[IWEVASSOCRESPIE	- IWEVFIRST] = {
+		.header_type	= IW_HEADER_TYPE_POINT,
+		.token_size	= 1,
+		.max_tokens	= IW_GENERIC_IE_MAX,
+	},
+	[IWEVPMKIDCAND	- IWEVFIRST] = {
+		.header_type	= IW_HEADER_TYPE_POINT,
+		.token_size	= 1,
+		.max_tokens	= sizeof(struct iw_pmkid_cand),
+	},
+};
+static const unsigned int standard_event_num = (sizeof(standard_event_descr) /
+						sizeof(struct iw_ioctl_description));
+
+/* Size (in bytes) of various events */
+static const int event_type_size[] = {
+	IW_EV_LCP_PK_LEN,	/* IW_HEADER_TYPE_NULL */
+	0,
+	IW_EV_CHAR_PK_LEN,	/* IW_HEADER_TYPE_CHAR */
+	0,
+	IW_EV_UINT_PK_LEN,	/* IW_HEADER_TYPE_UINT */
+	IW_EV_FREQ_PK_LEN,	/* IW_HEADER_TYPE_FREQ */
+	IW_EV_ADDR_PK_LEN,	/* IW_HEADER_TYPE_ADDR */
+	0,
+	IW_EV_POINT_PK_LEN,	/* Without variable payload */
+	IW_EV_PARAM_PK_LEN,	/* IW_HEADER_TYPE_PARAM */
+	IW_EV_QUAL_PK_LEN,	/* IW_HEADER_TYPE_QUAL */
+};
+
+/*------------------------------------------------------------------*/
+/*
+ * Initialise the struct stream_descr so that we can extract
+ * individual events from the event stream.
+ */
+void
+iw_init_event_stream(struct stream_descr *	stream,	/* Stream of events */
+		     char *			data,
+		     int			len)
+{
+  /* Cleanup */
+  memset((char *) stream, '\0', sizeof(struct stream_descr));
+
+  /* Set things up */
+  stream->current = data;
+  stream->end = data + len;
+}
+
+/*------------------------------------------------------------------*/
+/*
+ * Extract the next event from the event stream.
+ */
+int
+iw_extract_event_stream(struct stream_descr *	stream,	/* Stream of events */
+			struct iw_event *	iwe,	/* Extracted event */
+			int			we_version)
+{
+  const struct iw_ioctl_description *	descr = NULL;
+  int		event_type = 0;
+  unsigned int	event_len = 1;		/* Invalid */
+  char *	pointer;
+  /* Don't "optimise" the following variable, it will crash */
+  unsigned	cmd_index;		/* *MUST* be unsigned */
+
+  /* Check for end of stream */
+  if((stream->current + IW_EV_LCP_PK_LEN) > stream->end)
+    return(0);
+
+#ifdef DEBUG
+  printf("DBG - stream->current = %p, stream->value = %p, stream->end = %p\n",
+	 stream->current, stream->value, stream->end);
+#endif
+
+  /* Extract the event header (to get the event id).
+   * Note : the event may be unaligned, therefore copy... */
+  memcpy((char *) iwe, stream->current, IW_EV_LCP_PK_LEN);
+
+#ifdef DEBUG
+  printf("DBG - iwe->cmd = 0x%X, iwe->len = %d\n",
+	 iwe->cmd, iwe->len);
+#endif
+
+  /* Check invalid events */
+  if(iwe->len <= IW_EV_LCP_PK_LEN)
+    return(-1);
+
+  /* Get the type and length of that event */
+  if(iwe->cmd <= SIOCIWLAST)
+    {
+      cmd_index = iwe->cmd - SIOCIWFIRST;
+      if(cmd_index < standard_ioctl_num)
+	descr = &(standard_ioctl_descr[cmd_index]);
+    }
+  else
+    {
+      cmd_index = iwe->cmd - IWEVFIRST;
+      if(cmd_index < standard_event_num)
+	descr = &(standard_event_descr[cmd_index]);
+    }
+  if(descr != NULL)
+    event_type = descr->header_type;
+  /* Unknown events -> event_type=0 => IW_EV_LCP_PK_LEN */
+  event_len = event_type_size[event_type];
+  /* Fixup for earlier version of WE */
+  if((we_version <= 18) && (event_type == IW_HEADER_TYPE_POINT))
+    event_len += IW_EV_POINT_OFF;
+
+  /* Check if we know about this event */
+  if(event_len <= IW_EV_LCP_PK_LEN)
+    {
+      /* Skip to next event */
+      stream->current += iwe->len;
+      return(2);
+    }
+  event_len -= IW_EV_LCP_PK_LEN;
+
+  /* Set pointer on data */
+  if(stream->value != NULL)
+    pointer = stream->value;			/* Next value in event */
+  else
+    pointer = stream->current + IW_EV_LCP_PK_LEN;	/* First value in event */
+
+#ifdef DEBUG
+  printf("DBG - event_type = %d, event_len = %d, pointer = %p\n",
+	 event_type, event_len, pointer);
+#endif
+
+  /* Copy the rest of the event (at least, fixed part) */
+  if((pointer + event_len) > stream->end)
+    {
+      /* Go to next event */
+      stream->current += iwe->len;
+      return(-2);
+    }
+  /* Fixup for WE-19 and later : pointer no longer in the stream */
+  /* Beware of alignement. Dest has local alignement, not packed */
+  if((we_version > 18) && (event_type == IW_HEADER_TYPE_POINT))
+    memcpy((char *) iwe + IW_EV_LCP_LEN + IW_EV_POINT_OFF,
+	   pointer, event_len);
+  else
+    memcpy((char *) iwe + IW_EV_LCP_LEN, pointer, event_len);
+
+  /* Skip event in the stream */
+  pointer += event_len;
+
+  /* Special processing for iw_point events */
+  if(event_type == IW_HEADER_TYPE_POINT)
+    {
+      /* Check the length of the payload */
+      unsigned int	extra_len = iwe->len - (event_len + IW_EV_LCP_PK_LEN);
+      if(extra_len > 0)
+	{
+	  /* Set pointer on variable part (warning : non aligned) */
+	  iwe->u.data.pointer = pointer;
+
+	  /* Check that we have a descriptor for the command */
+	  if(descr == NULL)
+	    /* Can't check payload -> unsafe... */
+	    iwe->u.data.pointer = NULL;	/* Discard paylod */
+	  else
+	    {
+	      /* Those checks are actually pretty hard to trigger,
+	       * because of the checks done in the kernel... */
+
+	      unsigned int	token_len = iwe->u.data.length * descr->token_size;
+
+	      /* Ugly fixup for alignement issues.
+	       * If the kernel is 64 bits and userspace 32 bits,
+	       * we have an extra 4+4 bytes.
+	       * Fixing that in the kernel would break 64 bits userspace. */
+	      if((token_len != extra_len) && (extra_len >= 4))
+		{
+		  __u16		alt_dlen = *((__u16 *) pointer);
+		  unsigned int	alt_token_len = alt_dlen * descr->token_size;
+		  if((alt_token_len + 8) == extra_len)
+		    {
+#ifdef DEBUG
+		      printf("DBG - alt_token_len = %d\n", alt_token_len);
+#endif
+		      /* Ok, let's redo everything */
+		      pointer -= event_len;
+		      pointer += 4;
+		      /* Dest has local alignement, not packed */
+		      memcpy((char *) iwe + IW_EV_LCP_LEN + IW_EV_POINT_OFF,
+			     pointer, event_len);
+		      pointer += event_len + 4;
+		      iwe->u.data.pointer = pointer;
+		      token_len = alt_token_len;
+		    }
+		}
+
+	      /* Discard bogus events which advertise more tokens than
+	       * what they carry... */
+	      if(token_len > extra_len)
+		iwe->u.data.pointer = NULL;	/* Discard paylod */
+	      /* Check that the advertised token size is not going to
+	       * produce buffer overflow to our caller... */
+	      if((iwe->u.data.length > descr->max_tokens)
+		 && !(descr->flags & IW_DESCR_FLAG_NOMAX))
+		iwe->u.data.pointer = NULL;	/* Discard paylod */
+	      /* Same for underflows... */
+	      if(iwe->u.data.length < descr->min_tokens)
+		iwe->u.data.pointer = NULL;	/* Discard paylod */
+#ifdef DEBUG
+	      printf("DBG - extra_len = %d, token_len = %d, token = %d, max = %d, min = %d\n",
+		     extra_len, token_len, iwe->u.data.length, descr->max_tokens, descr->min_tokens);
+#endif
+	    }
+	}
+      else
+	/* No data */
+	iwe->u.data.pointer = NULL;
+
+      /* Go to next event */
+      stream->current += iwe->len;
+    }
+  else
+    {
+      /* Ugly fixup for alignement issues.
+       * If the kernel is 64 bits and userspace 32 bits,
+       * we have an extra 4 bytes.
+       * Fixing that in the kernel would break 64 bits userspace. */
+      if((stream->value == NULL)
+	 && ((((iwe->len - IW_EV_LCP_PK_LEN) % event_len) == 4)
+	     || ((iwe->len == 12) && ((event_type == IW_HEADER_TYPE_UINT) ||
+				      (event_type == IW_HEADER_TYPE_QUAL))) ))
+	{
+#ifdef DEBUG
+	  printf("DBG - alt iwe->len = %d\n", iwe->len - 4);
+#endif
+	  pointer -= event_len;
+	  pointer += 4;
+	  /* Beware of alignement. Dest has local alignement, not packed */
+	  memcpy((char *) iwe + IW_EV_LCP_LEN, pointer, event_len);
+	  pointer += event_len;
+	}
+
+      /* Is there more value in the event ? */
+      if((pointer + event_len) <= (stream->current + iwe->len))
+	/* Go to next value */
+	stream->value = pointer;
+      else
+	{
+	  /* Go to next event */
+	  stream->value = NULL;
+	  stream->current += iwe->len;
+	}
+    }
+  return(1);
+}
+
+/*********************** SCANNING SUBROUTINES ***********************/
+/*
+ * The Wireless Extension API 14 and greater define Wireless Scanning.
+ * The normal API is complex, this is an easy API that return
+ * a subset of the scanning results. This should be enough for most
+ * applications that want to use Scanning.
+ * If you want to have use the full/normal API, check iwlist.c...
+ *
+ * Precaution when using scanning :
+ * The scanning operation disable normal network traffic, and therefore
+ * you should not abuse of scan.
+ * The scan need to check the presence of network on other frequencies.
+ * While you are checking those other frequencies, you can *NOT* be on
+ * your normal frequency to listen to normal traffic in the cell.
+ * You need typically in the order of one second to actively probe all
+ * 802.11b channels (do the maths). Some cards may do that in background,
+ * to reply to scan commands faster, but they still have to do it.
+ * Leaving the cell for such an extended period of time is pretty bad.
+ * Any kind of streaming/low latency traffic will be impacted, and the
+ * user will perceive it (easily checked with telnet). People trying to
+ * send traffic to you will retry packets and waste bandwidth. Some
+ * applications may be sensitive to those packet losses in weird ways,
+ * and tracing those weird behavior back to scanning may take time.
+ * If you are in ad-hoc mode, if two nodes scan approx at the same
+ * time, they won't see each other, which may create associations issues.
+ * For those reasons, the scanning activity should be limited to
+ * what's really needed, and continuous scanning is a bad idea.
+ * Jean II
+ */
+
+/*------------------------------------------------------------------*/
+/*
+ * Process/store one element from the scanning results in wireless_scan
+ */
+static inline struct wireless_scan *
+iw_process_scanning_token(struct iw_event *		event,
+			  struct wireless_scan *	wscan)
+{
+  struct wireless_scan *	oldwscan;
+
+  /* Now, let's decode the event */
+  switch(event->cmd)
+    {
+    case SIOCGIWAP:
+      /* New cell description. Allocate new cell descriptor, zero it. */
+      oldwscan = wscan;
+      wscan = (struct wireless_scan *) malloc(sizeof(struct wireless_scan));
+      if(wscan == NULL)
+	return(wscan);
+      /* Link at the end of the list */
+      if(oldwscan != NULL)
+	oldwscan->next = wscan;
+
+      /* Reset it */
+      bzero(wscan, sizeof(struct wireless_scan));
+
+      /* Save cell identifier */
+      wscan->has_ap_addr = 1;
+      memcpy(&(wscan->ap_addr), &(event->u.ap_addr), sizeof (sockaddr));
+      break;
+    case SIOCGIWNWID:
+      wscan->b.has_nwid = 1;
+      memcpy(&(wscan->b.nwid), &(event->u.nwid), sizeof(iwparam));
+      break;
+    case SIOCGIWFREQ:
+      wscan->b.has_freq = 1;
+      wscan->b.freq = iw_freq2float(&(event->u.freq));
+      wscan->b.freq_flags = event->u.freq.flags;
+      break;
+    case SIOCGIWMODE:
+      wscan->b.mode = event->u.mode;
+      if((wscan->b.mode < IW_NUM_OPER_MODE) && (wscan->b.mode >= 0))
+	wscan->b.has_mode = 1;
+      break;
+    case SIOCGIWESSID:
+      wscan->b.has_essid = 1;
+      wscan->b.essid_on = event->u.data.flags;
+      memset(wscan->b.essid, '\0', IW_ESSID_MAX_SIZE+1);
+      if((event->u.essid.pointer) && (event->u.essid.length))
+	memcpy(wscan->b.essid, event->u.essid.pointer, event->u.essid.length);
+      break;
+    case SIOCGIWENCODE:
+      wscan->b.has_key = 1;
+      wscan->b.key_size = event->u.data.length;
+      wscan->b.key_flags = event->u.data.flags;
+      if(event->u.data.pointer)
+	memcpy(wscan->b.key, event->u.essid.pointer, event->u.data.length);
+      else
+	wscan->b.key_flags |= IW_ENCODE_NOKEY;
+      break;
+    case IWEVQUAL:
+      /* We don't get complete stats, only qual */
+      wscan->has_stats = 1;
+      memcpy(&wscan->stats.qual, &event->u.qual, sizeof(struct iw_quality));
+      break;
+    case SIOCGIWRATE:
+      /* Scan may return a list of bitrates. As we have space for only
+       * a single bitrate, we only keep the largest one. */
+      if((!wscan->has_maxbitrate) ||
+	 (event->u.bitrate.value > wscan->maxbitrate.value))
+	{
+	  wscan->has_maxbitrate = 1;
+	  memcpy(&(wscan->maxbitrate), &(event->u.bitrate), sizeof(iwparam));
+	}
+    case IWEVCUSTOM:
+      /* How can we deal with those sanely ? Jean II */
+    default:
+      break;
+   }	/* switch(event->cmd) */
+
+  return(wscan);
+}
+
+/*------------------------------------------------------------------*/
+/*
+ * Initiate the scan procedure, and process results.
+ * This is a non-blocking procedure and it will return each time
+ * it would block, returning the amount of time the caller should wait
+ * before calling again.
+ * Return -1 for error, delay to wait for (in ms), or 0 for success.
+ * Error code is in errno
+ */
+int
+iw_process_scan(int			skfd,
+		char *			ifname,
+		int			we_version,
+		wireless_scan_head *	context)
+{
+  struct iwreq		wrq;
+  unsigned char *	buffer = NULL;		/* Results */
+  int			buflen = IW_SCAN_MAX_DATA; /* Min for compat WE<17 */
+  unsigned char *	newbuf;
+
+  /* Don't waste too much time on interfaces (150 * 100 = 15s) */
+  context->retry++;
+  if(context->retry > 150)
+    {
+      errno = ETIME;
+      return(-1);
+    }
+
+  /* If we have not yet initiated scanning on the interface */
+  if(context->retry == 1)
+    {
+      /* Initiate Scan */
+      wrq.u.data.pointer = NULL;		/* Later */
+      wrq.u.data.flags = 0;
+      wrq.u.data.length = 0;
+      /* Remember that as non-root, we will get an EPERM here */
+      if((iw_set_ext(skfd, ifname, SIOCSIWSCAN, &wrq) < 0)
+	 && (errno != EPERM))
+	return(-1);
+      /* Success : now, just wait for event or results */
+      return(250);	/* Wait 250 ms */
+    }
+
+ realloc:
+  /* (Re)allocate the buffer - realloc(NULL, len) == malloc(len) */
+  newbuf = realloc(buffer, buflen);
+  if(newbuf == NULL)
+    {
+      /* man says : If realloc() fails the original block is left untouched */
+      if(buffer)
+	free(buffer);
+      errno = ENOMEM;
+      return(-1);
+    }
+  buffer = newbuf;
+
+  /* Try to read the results */
+  wrq.u.data.pointer = buffer;
+  wrq.u.data.flags = 0;
+  wrq.u.data.length = buflen;
+  if(iw_get_ext(skfd, ifname, SIOCGIWSCAN, &wrq) < 0)
+    {
+      /* Check if buffer was too small (WE-17 only) */
+      if((errno == E2BIG) && (we_version > 16))
+	{
+	  /* Some driver may return very large scan results, either
+	   * because there are many cells, or because they have many
+	   * large elements in cells (like IWEVCUSTOM). Most will
+	   * only need the regular sized buffer. We now use a dynamic
+	   * allocation of the buffer to satisfy everybody. Of course,
+	   * as we don't know in advance the size of the array, we try
+	   * various increasing sizes. Jean II */
+
+	  /* Check if the driver gave us any hints. */
+	  if(wrq.u.data.length > buflen)
+	    buflen = wrq.u.data.length;
+	  else
+	    buflen *= 2;
+
+	  /* Try again */
+	  goto realloc;
+	}
+
+      /* Check if results not available yet */
+      if(errno == EAGAIN)
+	{
+	  free(buffer);
+	  /* Wait for only 100ms from now on */
+	  return(100);	/* Wait 100 ms */
+	}
+
+      free(buffer);
+      /* Bad error, please don't come back... */
+      return(-1);
+    }
+
+  /* We have the results, process them */
+  if(wrq.u.data.length)
+    {
+      struct iw_event		iwe;
+      struct stream_descr	stream;
+      struct wireless_scan *	wscan = NULL;
+      int			ret;
+#ifdef DEBUG
+      /* Debugging code. In theory useless, because it's debugged ;-) */
+      int	i;
+      printf("Scan result [%02X", buffer[0]);
+      for(i = 1; i < wrq.u.data.length; i++)
+	printf(":%02X", buffer[i]);
+      printf("]\n");
+#endif
+
+      /* Init */
+      iw_init_event_stream(&stream, (char *) buffer, wrq.u.data.length);
+      /* This is dangerous, we may leak user data... */
+      context->result = NULL;
+
+      /* Look every token */
+      do
+	{
+	  /* Extract an event and print it */
+	  ret = iw_extract_event_stream(&stream, &iwe, we_version);
+	  if(ret > 0)
+	    {
+	      /* Convert to wireless_scan struct */
+	      wscan = iw_process_scanning_token(&iwe, wscan);
+	      /* Check problems */
+	      if(wscan == NULL)
+		{
+		  free(buffer);
+		  errno = ENOMEM;
+		  return(-1);
+		}
+	      /* Save head of list */
+	      if(context->result == NULL)
+		context->result = wscan;
+	    }
+	}
+      while(ret > 0);
+    }
+
+  /* Done with this interface - return success */
+  free(buffer);
+  return(0);
+}
+
+/*------------------------------------------------------------------*/
+/*
+ * Perform a wireless scan on the specified interface.
+ * This is a blocking procedure and it will when the scan is completed
+ * or when an error occur.
+ *
+ * The scan results are given in a linked list of wireless_scan objects.
+ * The caller *must* free the result himself (by walking the list).
+ * If there is an error, -1 is returned and the error code is available
+ * in errno.
+ *
+ * The parameter we_version can be extracted from the range structure
+ * (range.we_version_compiled - see iw_get_range_info()), or using
+ * iw_get_kernel_we_version(). For performance reason, you should
+ * cache this parameter when possible rather than querying it every time.
+ *
+ * Return -1 for error and 0 for success.
+ */
+int
+iw_scan(int			skfd,
+	char *			ifname,
+	int			we_version,
+	wireless_scan_head *	context)
+{
+  int		delay;		/* in ms */
+
+  /* Clean up context. Potential memory leak if(context.result != NULL) */
+  context->result = NULL;
+  context->retry = 0;
+
+  /* Wait until we get results or error */
+  while(1)
+    {
+      /* Try to get scan results */
+      delay = iw_process_scan(skfd, ifname, we_version, context);
+
+      /* Check termination */
+      if(delay <= 0)
+	break;
+
+      /* Wait a bit */
+      usleep(delay * 1000);
+    }
+
+  /* End - return -1 or 0 */
+  return(delay);
+}
diff --git a/iwlib.h b/iwlib.h
new file mode 100644
index 0000000..ab93773
--- /dev/null
+++ b/iwlib.h
@@ -0,0 +1,603 @@
+/*
+ *	Wireless Tools
+ *
+ *		Jean II - HPLB 97->99 - HPL 99->07
+ *
+ * Common header for the Wireless Extension library...
+ *
+ * This file is released under the GPL license.
+ *     Copyright (c) 1997-2007 Jean Tourrilhes <jt@hpl.hp.com>
+ */
+
+#ifndef IWLIB_H
+#define IWLIB_H
+
+/*#include "CHANGELOG.h"*/
+
+/***************************** INCLUDES *****************************/
+
+/* Standard headers */
+#include <sys/types.h>
+#include <sys/ioctl.h>
+#include <stdio.h>
+#include <math.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <ctype.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <netdb.h>		/* gethostbyname, getnetbyname */
+#include <net/ethernet.h>	/* struct ether_addr */
+#include <sys/time.h>		/* struct timeval */
+#include <unistd.h>
+
+/* This is our header selection. Try to hide the mess and the misery :-(
+ * Don't look, you would go blind ;-)
+ * Note : compatibility with *old* distributions has been removed,
+ * you will need Glibc 2.2 and older to compile (which means 
+ * Mandrake 8.0, Debian 2.3, RH 7.1 or older).
+ */
+
+/* Set of headers proposed by Dr. Michael Rietz <rietz@mail.amps.de>, 27.3.2 */
+#include <net/if_arp.h>		/* For ARPHRD_ETHER */
+#include <sys/socket.h>		/* For AF_INET & struct sockaddr */
+#include <netinet/in.h>         /* For struct sockaddr_in */
+#include <netinet/if_ether.h>
+
+/* Fixup to be able to include kernel includes in userspace.
+ * Basically, kill the sparse annotations... Jean II */
+#ifndef __user
+#define __user
+#endif
+
+#include <linux/types.h>		/* for "caddr_t" et al		*/
+
+/* Glibc systems headers are supposedly less problematic than kernel ones */
+#include <sys/socket.h>			/* for "struct sockaddr" et al	*/
+#include <net/if.h>			/* for IFNAMSIZ and co... */
+
+/* Private copy of Wireless extensions (in this directoty) */
+#include "wireless.h"
+
+/* Make gcc understant that when we say inline, we mean it.
+ * I really hate when the compiler is trying to be more clever than me,
+ * because in this case gcc is not able to figure out functions with a
+ * single call site, so not only I have to tag those functions inline
+ * by hand, but then it refuse to inline them properly.
+ * Total saving for iwevent : 150B = 0.7%.
+ * Fortunately, in gcc 3.4, they now automatically inline static functions
+ * with a single call site. Hurrah !
+ * Jean II */
+#undef IW_GCC_HAS_BROKEN_INLINE
+#if __GNUC__ == 3
+#if __GNUC_MINOR__ >= 1 && __GNUC_MINOR__ < 4
+#define IW_GCC_HAS_BROKEN_INLINE	1
+#endif	/* __GNUC_MINOR__ */
+#endif	/* __GNUC__ */
+/* However, gcc 4.0 has introduce a new "feature", when compiling with
+ * '-Os', it does not want to inline iw_ether_cmp() and friends.
+ * So, we need to fix inline again !
+ * Jean II */
+#if __GNUC__ == 4
+#define IW_GCC_HAS_BROKEN_INLINE	1
+#endif	/* __GNUC__ */
+/* Now, really fix the inline */
+#ifdef IW_GCC_HAS_BROKEN_INLINE
+#ifdef inline
+#undef inline
+#endif	/* inline */
+#define inline		inline		__attribute__((always_inline))
+#endif	/* IW_GCC_HAS_BROKEN_INLINE */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/****************************** DEBUG ******************************/
+
+//#define DEBUG 1
+
+/************************ CONSTANTS & MACROS ************************/
+
+/* Various versions information */
+/* Recommended Wireless Extension version */
+#define WE_VERSION	21
+/* Maximum forward compatibility built in this version of WT */
+#define WE_MAX_VERSION	22
+/* Version of Wireless Tools */
+#define WT_VERSION	29
+
+/* Paths */
+#define PROC_NET_WIRELESS	"/proc/net/wireless"
+#define PROC_NET_DEV		"/proc/net/dev"
+
+/* Some usefull constants */
+#define KILO	1e3
+#define MEGA	1e6
+#define GIGA	1e9
+/* For doing log10/exp10 without libm */
+#define LOG10_MAGIC	1.25892541179
+
+/* Backward compatibility for network headers */
+#ifndef ARPHRD_IEEE80211
+#define ARPHRD_IEEE80211 801		/* IEEE 802.11			*/
+#endif /* ARPHRD_IEEE80211 */
+
+#ifndef IW_EV_LCP_PK_LEN
+/* Size of the Event prefix when packed in stream */
+#define IW_EV_LCP_PK_LEN	(4)
+/* Size of the various events when packed in stream */
+#define IW_EV_CHAR_PK_LEN	(IW_EV_LCP_PK_LEN + IFNAMSIZ)
+#define IW_EV_UINT_PK_LEN	(IW_EV_LCP_PK_LEN + sizeof(__u32))
+#define IW_EV_FREQ_PK_LEN	(IW_EV_LCP_PK_LEN + sizeof(struct iw_freq))
+#define IW_EV_PARAM_PK_LEN	(IW_EV_LCP_PK_LEN + sizeof(struct iw_param))
+#define IW_EV_ADDR_PK_LEN	(IW_EV_LCP_PK_LEN + sizeof(struct sockaddr))
+#define IW_EV_QUAL_PK_LEN	(IW_EV_LCP_PK_LEN + sizeof(struct iw_quality))
+#define IW_EV_POINT_PK_LEN	(IW_EV_LCP_PK_LEN + 4)
+
+struct iw_pk_event
+{
+	__u16		len;			/* Real lenght of this stuff */
+	__u16		cmd;			/* Wireless IOCTL */
+	union iwreq_data	u;		/* IOCTL fixed payload */
+} __attribute__ ((packed));
+struct	iw_pk_point
+{
+  void __user	*pointer;	/* Pointer to the data  (in user space) */
+  __u16		length;		/* number of fields or size in bytes */
+  __u16		flags;		/* Optional params */
+} __attribute__ ((packed));
+
+#define IW_EV_LCP_PK2_LEN	(sizeof(struct iw_pk_event) - sizeof(union iwreq_data))
+#define IW_EV_POINT_PK2_LEN	(IW_EV_LCP_PK2_LEN + sizeof(struct iw_pk_point) - IW_EV_POINT_OFF)
+
+#endif	/* IW_EV_LCP_PK_LEN */
+
+/****************************** TYPES ******************************/
+
+/* Shortcuts */
+typedef struct iw_statistics	iwstats;
+typedef struct iw_range		iwrange;
+typedef struct iw_param		iwparam;
+typedef struct iw_freq		iwfreq;
+typedef struct iw_quality	iwqual;
+typedef struct iw_priv_args	iwprivargs;
+typedef struct sockaddr		sockaddr;
+
+/* Structure for storing all wireless information for each device
+ * This is a cut down version of the one above, containing only
+ * the things *truly* needed to configure a card.
+ * Don't add other junk, I'll remove it... */
+typedef struct wireless_config
+{
+  char		name[IFNAMSIZ + 1];	/* Wireless/protocol name */
+  int		has_nwid;
+  iwparam	nwid;			/* Network ID */
+  int		has_freq;
+  double	freq;			/* Frequency/channel */
+  int		freq_flags;
+  int		has_key;
+  unsigned char	key[IW_ENCODING_TOKEN_MAX];	/* Encoding key used */
+  int		key_size;		/* Number of bytes */
+  int		key_flags;		/* Various flags */
+  int		has_essid;
+  int		essid_on;
+  char		essid[IW_ESSID_MAX_SIZE + 1];	/* ESSID (extended network) */
+  int		has_mode;
+  int		mode;			/* Operation mode */
+} wireless_config;
+
+/* Structure for storing all wireless information for each device
+ * This is pretty exhaustive... */
+typedef struct wireless_info
+{
+  struct wireless_config	b;	/* Basic information */
+
+  int		has_sens;
+  iwparam	sens;			/* sensitivity */
+  int		has_nickname;
+  char		nickname[IW_ESSID_MAX_SIZE + 1]; /* NickName */
+  int		has_ap_addr;
+  sockaddr	ap_addr;		/* Access point address */
+  int		has_bitrate;
+  iwparam	bitrate;		/* Bit rate in bps */
+  int		has_rts;
+  iwparam	rts;			/* RTS threshold in bytes */
+  int		has_frag;
+  iwparam	frag;			/* Fragmentation threshold in bytes */
+  int		has_power;
+  iwparam	power;			/* Power management parameters */
+  int		has_txpower;
+  iwparam	txpower;		/* Transmit Power in dBm */
+  int		has_retry;
+  iwparam	retry;			/* Retry limit or lifetime */
+
+  /* Stats */
+  iwstats	stats;
+  int		has_stats;
+  iwrange	range;
+  int		has_range;
+
+  /* Auth params for WPA/802.1x/802.11i */
+  int		auth_key_mgmt;
+  int		has_auth_key_mgmt;
+  int		auth_cipher_pairwise;
+  int		has_auth_cipher_pairwise;
+  int		auth_cipher_group;
+  int		has_auth_cipher_group;
+} wireless_info;
+
+/* Structure for storing an entry of a wireless scan.
+ * This is only a subset of all possible information, the flexible
+ * structure of scan results make it impossible to capture all
+ * information in such a static structure. */
+typedef struct wireless_scan
+{
+  /* Linked list */
+  struct wireless_scan *	next;
+
+  /* Cell identifiaction */
+  int		has_ap_addr;
+  sockaddr	ap_addr;		/* Access point address */
+
+  /* Other information */
+  struct wireless_config	b;	/* Basic information */
+  iwstats	stats;			/* Signal strength */
+  int		has_stats;
+  iwparam	maxbitrate;		/* Max bit rate in bps */
+  int		has_maxbitrate;
+} wireless_scan;
+
+/*
+ * Context used for non-blocking scan.
+ */
+typedef struct wireless_scan_head
+{
+  wireless_scan *	result;		/* Result of the scan */
+  int			retry;		/* Retry level */
+} wireless_scan_head;
+
+/* Structure used for parsing event streams, such as Wireless Events
+ * and scan results */
+typedef struct stream_descr
+{
+  char *	end;		/* End of the stream */
+  char *	current;	/* Current event in stream of events */
+  char *	value;		/* Current value in event */
+} stream_descr;
+
+/* Prototype for handling display of each single interface on the
+ * system - see iw_enum_devices() */
+typedef int (*iw_enum_handler)(int	skfd,
+			       char *	ifname,
+			       char *	args[],
+			       int	count);
+
+/* Describe a modulation */
+typedef struct iw_modul_descr
+{
+  unsigned int		mask;		/* Modulation bitmask */
+  char			cmd[8];		/* Short name */
+  char *		verbose;	/* Verbose description */
+} iw_modul_descr;
+
+/**************************** PROTOTYPES ****************************/
+/*
+ * All the functions in iwcommon.c
+ */
+
+/* ---------------------- SOCKET SUBROUTINES -----------------------*/
+int
+	iw_sockets_open(void);
+void
+	iw_enum_devices(int		skfd,
+			iw_enum_handler fn,
+			char *		args[],
+			int		count);
+/* --------------------- WIRELESS SUBROUTINES ----------------------*/
+int
+	iw_get_kernel_we_version(void);
+int
+	iw_print_version_info(const char *	toolname);
+int
+	iw_get_range_info(int		skfd,
+			  const char *	ifname,
+			  iwrange *	range);
+int
+	iw_get_priv_info(int		skfd,
+			 const char *	ifname,
+			 iwprivargs **	ppriv);
+int
+	iw_get_basic_config(int			skfd,
+			    const char *	ifname,
+			    wireless_config *	info);
+int
+	iw_set_basic_config(int			skfd,
+			    const char *	ifname,
+			    wireless_config *	info);
+/* --------------------- PROTOCOL SUBROUTINES --------------------- */
+int
+	iw_protocol_compare(const char *	protocol1,
+			    const char *	protocol2);
+/* -------------------- FREQUENCY SUBROUTINES --------------------- */
+void
+	iw_float2freq(double	in,
+		      iwfreq *	out);
+double
+	iw_freq2float(const iwfreq *	in);
+void
+	iw_print_freq_value(char *	buffer,
+			    int		buflen,
+			    double	freq);
+void
+	iw_print_freq(char *	buffer,
+		      int	buflen,
+		      double	freq,
+		      int	channel,
+		      int	freq_flags);
+int
+	iw_freq_to_channel(double			freq,
+			   const struct iw_range *	range);
+int
+	iw_channel_to_freq(int				channel,
+			   double *			pfreq,
+			   const struct iw_range *	range);
+void
+	iw_print_bitrate(char *	buffer,
+			 int	buflen,
+			 int	bitrate);
+/* ---------------------- POWER SUBROUTINES ----------------------- */
+int
+	iw_dbm2mwatt(int	in);
+int
+	iw_mwatt2dbm(int	in);
+void
+	iw_print_txpower(char *			buffer,
+			 int			buflen,
+			 struct iw_param *	txpower);
+/* -------------------- STATISTICS SUBROUTINES -------------------- */
+int
+	iw_get_stats(int		skfd,
+		     const char *	ifname,
+		     iwstats *		stats,
+		     const iwrange *	range,
+		     int		has_range);
+void
+	iw_print_stats(char *		buffer,
+		       int		buflen,
+		       const iwqual *	qual,
+		       const iwrange *	range,
+		       int		has_range);
+/* --------------------- ENCODING SUBROUTINES --------------------- */
+void
+	iw_print_key(char *			buffer,
+		     int			buflen,
+		     const unsigned char *	key,
+		     int			key_size,
+		     int			key_flags);
+int
+	iw_in_key(const char *		input,
+		  unsigned char *	key);
+int
+	iw_in_key_full(int		skfd,
+		       const char *	ifname,
+		       const char *	input,
+		       unsigned char *	key,
+		       __u16 *		flags);
+/* ----------------- POWER MANAGEMENT SUBROUTINES ----------------- */
+void
+	iw_print_pm_value(char *	buffer,
+			  int		buflen,
+			  int		value,
+			  int		flags,
+			  int		we_version);
+void
+	iw_print_pm_mode(char *		buffer,
+			 int		buflen,
+			 int		flags);
+/* --------------- RETRY LIMIT/LIFETIME SUBROUTINES --------------- */
+void
+	iw_print_retry_value(char *	buffer,
+			     int	buflen,
+			     int	value,
+			     int	flags,
+			     int	we_version);
+/* ----------------------- TIME SUBROUTINES ----------------------- */
+void
+	iw_print_timeval(char *				buffer,
+			 int				buflen,
+			 const struct timeval *		time,
+			 const struct timezone *	tz);
+/* --------------------- ADDRESS SUBROUTINES ---------------------- */
+int
+	iw_check_mac_addr_type(int		skfd,
+			       const char *	ifname);
+int
+	iw_check_if_addr_type(int		skfd,
+			      const char *	ifname);
+#if 0
+int
+	iw_check_addr_type(int		skfd,
+			   const char *	ifname);
+#endif
+#if 0
+int
+	iw_get_mac_addr(int			skfd,
+			const char *		name,
+			struct ether_addr *	eth,
+			unsigned short *	ptype);
+#endif
+char *
+	iw_mac_ntop(const unsigned char *	mac,
+		    int				maclen,
+		    char *			buf,
+		    int				buflen);
+void
+	iw_ether_ntop(const struct ether_addr *	eth,
+		      char *			buf);
+char *
+	iw_sawap_ntop(const struct sockaddr *	sap,
+		      char *			buf);
+int
+	iw_mac_aton(const char *	orig,
+		    unsigned char *	mac,
+		    int			macmax);
+int
+	iw_ether_aton(const char* bufp, struct ether_addr* eth);
+int
+	iw_in_inet(char *bufp, struct sockaddr *sap);
+int
+	iw_in_addr(int			skfd,
+		   const char *		ifname,
+		   char *		bufp,
+		   struct sockaddr *	sap);
+/* ----------------------- MISC SUBROUTINES ------------------------ */
+int
+	iw_get_priv_size(int		args);
+
+/* ---------------------- EVENT SUBROUTINES ---------------------- */
+void
+	iw_init_event_stream(struct stream_descr *	stream,
+			     char *			data,
+			     int			len);
+int
+	iw_extract_event_stream(struct stream_descr *	stream,
+				struct iw_event *	iwe,
+				int			we_version);
+/* --------------------- SCANNING SUBROUTINES --------------------- */
+int
+	iw_process_scan(int			skfd,
+			char *			ifname,
+			int			we_version,
+			wireless_scan_head *	context);
+int
+	iw_scan(int			skfd,
+		char *			ifname,
+		int			we_version,
+		wireless_scan_head *	context);
+
+/**************************** VARIABLES ****************************/
+
+/* Modes as human readable strings */
+extern const char * const	iw_operation_mode[];
+#define IW_NUM_OPER_MODE	7
+#define IW_NUM_OPER_MODE_EXT	8
+
+/* Modulations as human readable strings */
+extern const struct iw_modul_descr	iw_modul_list[];
+#define IW_SIZE_MODUL_LIST	16
+
+/************************* INLINE FUNTIONS *************************/
+/*
+ * Functions that are so simple that it's more efficient inlining them
+ */
+
+/*
+ * Note : I've defined wrapper for the ioctl request so that
+ * it will be easier to migrate to other kernel API if needed
+ */
+
+/*------------------------------------------------------------------*/
+/*
+ * Wrapper to push some Wireless Parameter in the driver
+ */
+static inline int
+iw_set_ext(int			skfd,		/* Socket to the kernel */
+	   const char *		ifname,		/* Device name */
+	   int			request,	/* WE ID */
+	   struct iwreq *	pwrq)		/* Fixed part of the request */
+{
+  /* Set device name */
+  strncpy(pwrq->ifr_name, ifname, IFNAMSIZ);
+  /* Do the request */
+  return(ioctl(skfd, request, pwrq));
+}
+
+/*------------------------------------------------------------------*/
+/*
+ * Wrapper to extract some Wireless Parameter out of the driver
+ */
+static inline int
+iw_get_ext(int			skfd,		/* Socket to the kernel */
+	   const char *		ifname,		/* Device name */
+	   int			request,	/* WE ID */
+	   struct iwreq *	pwrq)		/* Fixed part of the request */
+{
+  /* Set device name */
+  strncpy(pwrq->ifr_name, ifname, IFNAMSIZ);
+  /* Do the request */
+  return(ioctl(skfd, request, pwrq));
+}
+
+/*------------------------------------------------------------------*/
+/*
+ * Close the socket used for ioctl.
+ */
+static inline void
+iw_sockets_close(int	skfd)
+{
+  close(skfd);
+}
+
+/*------------------------------------------------------------------*/
+/*
+ * Display an Ethernet Socket Address in readable format.
+ */
+static inline char *
+iw_saether_ntop(const struct sockaddr *sap, char* bufp)
+{
+  iw_ether_ntop((const struct ether_addr *) sap->sa_data, bufp);
+  return bufp;
+}
+/*------------------------------------------------------------------*/
+/*
+ * Input an Ethernet Socket Address and convert to binary.
+ */
+static inline int
+iw_saether_aton(const char *bufp, struct sockaddr *sap)
+{
+  sap->sa_family = ARPHRD_ETHER;
+  return iw_ether_aton(bufp, (struct ether_addr *) sap->sa_data);
+}
+
+/*------------------------------------------------------------------*/
+/*
+ * Create an Ethernet broadcast address
+ */
+static inline void
+iw_broad_ether(struct sockaddr *sap)
+{
+  sap->sa_family = ARPHRD_ETHER;
+  memset((char *) sap->sa_data, 0xFF, ETH_ALEN);
+}
+
+/*------------------------------------------------------------------*/
+/*
+ * Create an Ethernet NULL address
+ */
+static inline void
+iw_null_ether(struct sockaddr *sap)
+{
+  sap->sa_family = ARPHRD_ETHER;
+  memset((char *) sap->sa_data, 0x00, ETH_ALEN);
+}
+
+/*------------------------------------------------------------------*/
+/*
+ * Compare two ethernet addresses
+ */
+static inline int
+iw_ether_cmp(const struct ether_addr* eth1, const struct ether_addr* eth2)
+{
+  return memcmp(eth1, eth2, sizeof(*eth1));
+}
+
+#ifdef __cplusplus
+}
+#endif
+
+//bilal: important addition
+#define	bzero(X,Y)	memset(X,0,Y)
+
+#endif	/* IWLIB_H */
diff --git a/iwlist.8 b/iwlist.8
new file mode 100644
index 0000000..2f0020e
--- /dev/null
+++ b/iwlist.8
@@ -0,0 +1,151 @@
+.\" Jean II - HPLB - 96
+.\" iwlist.8
+.\"
+.TH IWLIST 8 "13 April 2006" "wireless-tools" "Linux Programmer's Manual"
+.\"
+.\" NAME part
+.\"
+.SH NAME
+iwlist \- Get more detailed wireless information from a wireless interface
+.\"
+.\" SYNOPSIS part
+.\"
+.SH SYNOPSIS
+.BI "iwlist [" interface "] scanning"
+.br
+.BI "iwlist [" interface "] frequency"
+.br
+.BI "iwlist [" interface "] rate"
+.br
+.BI "iwlist [" interface "] keys"
+.br
+.BI "iwlist [" interface "] power"
+.br
+.BI "iwlist [" interface "] txpower"
+.br
+.BI "iwlist [" interface "] retry"
+.br
+.BI "iwlist [" interface "] event"
+.br
+.BI "iwlist [" interface "] auth"
+.br
+.BI "iwlist [" interface "] wpakeys"
+.br
+.BI "iwlist [" interface "] genie"
+.br
+.BI "iwlist [" interface "] modulation"
+.br
+.BI "iwlist --help"
+.br
+.BI "iwlist --version"
+.\"
+.\" DESCRIPTION part
+.\"
+.SH DESCRIPTION
+.B Iwlist
+is used to display some additional information from a wireless network
+interface that is not displayed by
+.IR iwconfig (8).
+The main argument is used
+to select a category of information,
+.B iwlist
+displays in detailed form all information related to this category,
+including information already shown by
+.IR iwconfig (8).
+.\"
+.\" PARAMETER part
+.\"
+.SH PARAMETERS
+.TP
+.BR scan [ning]
+Give the list of Access Points and Ad-Hoc cells in range, and
+optionally a whole bunch of information about them (ESSID, Quality,
+Frequency, Mode...). The type of information returned depends on what
+the card supports.
+.br
+Triggering scanning is a privileged operation
+.RI ( root
+only) and normal users can only read left-over scan results. By
+default, the way scanning is done (the scope of the scan) is dependant
+on the card and card settings.
+.br
+This command take optional arguments, however most drivers will ignore
+those. The option
+.B essid
+is used to specify a scan on a specific ESSID. The option
+.B last
+do not trigger a scan and read left-over scan results.
+.TP
+.BR freq [uency]/ channel
+Give the list of available frequencies in the device and the number of
+defined channels. Please note that usually the driver returns the
+total number of channels and only the frequencies available in the
+present locale, so there is no one-to-one mapping between frequencies
+displayed and channel numbers.
+.TP
+.BR rate / bit [rate]
+List the bit-rates supported by the device.
+.TP
+.BR keys / enc [ryption]
+List the encryption key sizes supported and list all the encryption
+keys set in the device.
+.TP
+.B power
+List the various Power Management attributes and modes of the device.
+.TP
+.B txpower
+List the various Transmit Powers available on the device.
+.TP
+.B retry
+List the transmit retry limits and retry lifetime on the device.
+.TP
+.BR ap / accesspoint / peers
+Give the list of Access Points in range, and optionally the quality of
+link to them. This feature is
+.B obsolete
+and now deprecated in favor of scanning support (above), and most
+drivers don't support it.
+.br
+Some drivers may use this command to return a specific list of Peers
+or Access Points, such as the list of Peers associated/registered with
+the card. See your driver documentation for details.
+.TP
+.B event
+List the wireless events supported by the device.
+.TP
+.B auth
+List the WPA authentication parametes curently set.
+.TP
+.BR wpa [keys]
+List all the WPA encryption keys set in the device.
+.TP
+.B genie
+List the Generic Information Elements set in the device (used for WPA
+support).
+.TP
+.BR modu [lation]
+List the modulations supported by the device and the modulations
+currently enabled.
+.TP
+.B --version
+Display the version of the tools, as well as the recommended and
+current Wireless Extensions version for the tool and the various
+wireless interfaces.
+.TP
+.B --help
+Display short help message.
+.\"
+.\" FILES part
+.\"
+.SH FILES
+.I /proc/net/wireless
+.\"
+.\" SEE ALSO part
+.\"
+.SH SEE ALSO
+.BR iwconfig (8),
+.BR iwspy (8).
+.BR iwevent (8),
+.BR iwpriv (8),
+.BR wireless (7).
+
diff --git a/iwlist.c b/iwlist.c
new file mode 100644
index 0000000..0575c1d
--- /dev/null
+++ b/iwlist.c
@@ -0,0 +1,2610 @@
+/*
+ *	Wireless Tools
+ *
+ *		Jean II - HPLB '99 - HPL 99->07
+ *
+ * This tool can access various piece of information on the card
+ * not part of iwconfig...
+ * You need to link this code against "iwlist.c" and "-lm".
+ *
+ * This file is released under the GPL license.
+ *     Copyright (c) 1997-2007 Jean Tourrilhes <jt@hpl.hp.com>
+ */
+
+#include "iwlib.h"		/* Header */
+#include <sys/time.h>
+
+/****************************** TYPES ******************************/
+
+/*
+ * Scan state and meta-information, used to decode events...
+ */
+typedef struct iwscan_state
+{
+  /* State */
+  int			ap_num;		/* Access Point number 1->N */
+  int			val_index;	/* Value in table 0->(N-1) */
+} iwscan_state;
+
+/*
+ * Bit to name mapping
+ */
+typedef struct iwmask_name
+{
+  unsigned int	mask;	/* bit mask for the value */
+  const char *	name;	/* human readable name for the value */
+} iwmask_name;
+
+/*
+ * Types of authentication parameters
+ */
+typedef struct iw_auth_descr
+{
+  int				value;		/* Type of auth value */
+  const char *			label;		/* User readable version */
+  const struct iwmask_name *	names;		/* Names for this value */
+  const int			num_names;	/* Number of names */
+} iw_auth_descr;
+
+/**************************** CONSTANTS ****************************/
+
+#define IW_SCAN_HACK		0x8000
+
+#define IW_EXTKEY_SIZE	(sizeof(struct iw_encode_ext) + IW_ENCODING_TOKEN_MAX)
+
+/* ------------------------ WPA CAPA NAMES ------------------------ */
+/*
+ * This is the user readable name of a bunch of WPA constants in wireless.h
+ * Maybe this should go in iwlib.c ?
+ */
+
+#ifndef WE_ESSENTIAL
+#define IW_ARRAY_LEN(x) (sizeof(x)/sizeof((x)[0]))
+
+//static const struct iwmask_name iw_enc_mode_name[] = {
+//  { IW_ENCODE_RESTRICTED,	"restricted" },
+//  { IW_ENCODE_OPEN,		"open" },
+//};
+//#define	IW_ENC_MODE_NUM		IW_ARRAY_LEN(iw_enc_mode_name)
+
+static const struct iwmask_name iw_auth_capa_name[] = {
+  { IW_ENC_CAPA_WPA,		"WPA" },
+  { IW_ENC_CAPA_WPA2,		"WPA2" },
+  { IW_ENC_CAPA_CIPHER_TKIP,	"CIPHER-TKIP" },
+  { IW_ENC_CAPA_CIPHER_CCMP,	"CIPHER-CCMP" },
+};
+#define	IW_AUTH_CAPA_NUM	IW_ARRAY_LEN(iw_auth_capa_name)
+
+static const struct iwmask_name iw_auth_cypher_name[] = {
+  { IW_AUTH_CIPHER_NONE,	"none" },
+  { IW_AUTH_CIPHER_WEP40,	"WEP-40" },
+  { IW_AUTH_CIPHER_TKIP,	"TKIP" },
+  { IW_AUTH_CIPHER_CCMP,	"CCMP" },
+  { IW_AUTH_CIPHER_WEP104,	"WEP-104" },
+};
+#define	IW_AUTH_CYPHER_NUM	IW_ARRAY_LEN(iw_auth_cypher_name)
+
+static const struct iwmask_name iw_wpa_ver_name[] = {
+  { IW_AUTH_WPA_VERSION_DISABLED,	"disabled" },
+  { IW_AUTH_WPA_VERSION_WPA,		"WPA" },
+  { IW_AUTH_WPA_VERSION_WPA2,		"WPA2" },
+};
+#define	IW_WPA_VER_NUM		IW_ARRAY_LEN(iw_wpa_ver_name)
+
+static const struct iwmask_name iw_auth_key_mgmt_name[] = {
+  { IW_AUTH_KEY_MGMT_802_1X,	"802.1x" },
+  { IW_AUTH_KEY_MGMT_PSK,	"PSK" },
+};
+#define	IW_AUTH_KEY_MGMT_NUM	IW_ARRAY_LEN(iw_auth_key_mgmt_name)
+
+static const struct iwmask_name iw_auth_alg_name[] = {
+  { IW_AUTH_ALG_OPEN_SYSTEM,	"open" },
+  { IW_AUTH_ALG_SHARED_KEY,	"shared-key" },
+  { IW_AUTH_ALG_LEAP,		"LEAP" },
+};
+#define	IW_AUTH_ALG_NUM		IW_ARRAY_LEN(iw_auth_alg_name)
+
+static const struct iw_auth_descr	iw_auth_settings[] = {
+  { IW_AUTH_WPA_VERSION, "WPA version", iw_wpa_ver_name, IW_WPA_VER_NUM },
+  { IW_AUTH_KEY_MGMT, "Key management", iw_auth_key_mgmt_name, IW_AUTH_KEY_MGMT_NUM },
+  { IW_AUTH_CIPHER_PAIRWISE, "Pairwise cipher", iw_auth_cypher_name, IW_AUTH_CYPHER_NUM },
+  { IW_AUTH_CIPHER_GROUP, "Pairwise cipher", iw_auth_cypher_name, IW_AUTH_CYPHER_NUM },
+  { IW_AUTH_TKIP_COUNTERMEASURES, "TKIP countermeasures", NULL, 0 },
+  { IW_AUTH_DROP_UNENCRYPTED, "Drop unencrypted", NULL, 0 },
+  { IW_AUTH_80211_AUTH_ALG, "Authentication algorithm", iw_auth_alg_name, IW_AUTH_ALG_NUM },
+  { IW_AUTH_RX_UNENCRYPTED_EAPOL, "Receive unencrypted EAPOL", NULL, 0 },
+  { IW_AUTH_ROAMING_CONTROL, "Roaming control", NULL, 0 },
+  { IW_AUTH_PRIVACY_INVOKED, "Privacy invoked", NULL, 0 },
+};
+#define	IW_AUTH_SETTINGS_NUM		IW_ARRAY_LEN(iw_auth_settings)
+
+/* Values for the IW_ENCODE_ALG_* returned by SIOCSIWENCODEEXT */
+static const char *	iw_encode_alg_name[] = {
+	"none",
+	"WEP",
+	"TKIP",
+	"CCMP",
+	"unknown"
+};
+#define	IW_ENCODE_ALG_NUM		IW_ARRAY_LEN(iw_encode_alg_name)
+
+#ifndef IW_IE_CIPHER_NONE
+/* Cypher values in GENIE (pairwise and group) */
+#define IW_IE_CIPHER_NONE	0
+#define IW_IE_CIPHER_WEP40	1
+#define IW_IE_CIPHER_TKIP	2
+#define IW_IE_CIPHER_WRAP	3
+#define IW_IE_CIPHER_CCMP	4
+#define IW_IE_CIPHER_WEP104	5
+/* Key management in GENIE */
+#define IW_IE_KEY_MGMT_NONE	0
+#define IW_IE_KEY_MGMT_802_1X	1
+#define IW_IE_KEY_MGMT_PSK	2
+#endif	/* IW_IE_CIPHER_NONE */
+
+/* Values for the IW_IE_CIPHER_* in GENIE */
+static const char *	iw_ie_cypher_name[] = {
+	"none",
+	"WEP-40",
+	"TKIP",
+	"WRAP",
+	"CCMP",
+	"WEP-104",
+};
+#define	IW_IE_CYPHER_NUM	IW_ARRAY_LEN(iw_ie_cypher_name)
+
+/* Values for the IW_IE_KEY_MGMT_* in GENIE */
+static const char *	iw_ie_key_mgmt_name[] = {
+	"none",
+	"802.1x",
+	"PSK",
+};
+#define	IW_IE_KEY_MGMT_NUM	IW_ARRAY_LEN(iw_ie_key_mgmt_name)
+
+#endif	/* WE_ESSENTIAL */
+
+/************************* WPA SUBROUTINES *************************/
+
+#ifndef WE_ESSENTIAL
+/*------------------------------------------------------------------*/
+/*
+ * Print all names corresponding to a mask.
+ * This may want to be used in iw_print_retry_value() ?
+ */
+static void 
+iw_print_mask_name(unsigned int			mask,
+		   const struct iwmask_name	names[],
+		   const unsigned int		num_names,
+		   const char *			sep)
+{
+  unsigned int	i;
+
+  /* Print out all names for the bitmask */
+  for(i = 0; i < num_names; i++)
+    {
+      if(mask & names[i].mask)
+	{
+	  /* Print out */
+	  printf("%s%s", sep, names[i].name);
+	  /* Remove the bit from the mask */
+	  mask &= ~names[i].mask;
+	}
+    }
+  /* If there is unconsumed bits... */
+  if(mask != 0)
+    printf("%sUnknown", sep);
+}
+
+/*------------------------------------------------------------------*/
+/*
+ * Print the name corresponding to a value, with overflow check.
+ */
+static void
+iw_print_value_name(unsigned int		value,
+		    const char *		names[],
+		    const unsigned int		num_names)
+{
+  if(value >= num_names)
+    printf(" unknown (%d)", value);
+  else
+    printf(" %s", names[value]);
+}
+
+/*------------------------------------------------------------------*/
+/*
+ * Parse, and display the results of an unknown IE.
+ *
+ */
+static void 
+iw_print_ie_unknown(unsigned char *	iebuf,
+		    int			buflen)
+{
+  int	ielen = iebuf[1] + 2;
+  int	i;
+
+  if(ielen > buflen)
+    ielen = buflen;
+
+  printf("Unknown: ");
+  for(i = 0; i < ielen; i++)
+    printf("%02X", iebuf[i]);
+  printf("\n");
+}
+
+/*------------------------------------------------------------------*/
+/*
+ * WSC debug and parse functions follow.
+ * - Firat Birlik <cloud@cloudrain.org>
+ */
+struct wsc_hdr {
+    u_int16_t type;
+    u_int16_t size;
+};
+
+#ifndef WSC_DEBUG
+#define wsc_lookup(arg...)
+#else
+int wsc_lookup(u_int16_t code)
+{
+    int ret = 1;
+
+    printf("type = %.4x (", code);
+
+    switch(code) {
+
+        case 0x1001:
+        printf("WSC_ID_AP_CHANNEL");
+        break;
+        case 0x1002:
+        printf("WSC_ID_ASSOC_STATE");
+        break;
+        case 0x1003:
+        printf("WSC_ID_AUTH_TYPE");
+        break;
+        case 0x1004:
+        printf("WSC_ID_AUTH_TYPE_FLAGS");
+        break;
+        case 0x1005:
+        printf("WSC_ID_AUTHENTICATOR");
+        break;
+        case 0x1008:
+        printf("WSC_ID_CONFIG_METHODS");
+        break;
+        case 0x1009:
+        printf("WSC_ID_CONFIG_ERROR");
+        break;
+        case 0x100A:
+        printf("WSC_ID_CONF_URL4");
+        break;
+        case 0x100B:
+        printf("WSC_ID_CONF_URL6");
+        break;
+        case 0x100C:
+        printf("WSC_ID_CONN_TYPE");
+        break;
+        case 0x100D:
+        printf("WSC_ID_CONN_TYPE_FLAGS");
+        break;
+        case 0x100E:
+        printf("WSC_ID_CREDENTIAL");
+        break;
+        case 0x1011:
+        printf("WSC_ID_DEVICE_NAME");
+        break;
+        case 0x1012:
+        printf("WSC_ID_DEVICE_PWD_ID");
+        break;
+        case 0x1014:
+        printf("WSC_ID_E_HASH1");
+        break;
+        case 0x1015:
+        printf("WSC_ID_E_HASH2");
+        break;
+        case 0x1016:
+        printf("WSC_ID_E_SNONCE1");
+        break;
+        case 0x1017:
+        printf("WSC_ID_E_SNONCE2");
+        break;
+        case 0x1018:
+        printf("WSC_ID_ENCR_SETTINGS");
+        break;
+        case 0x100F:
+        printf("WSC_ID_ENCR_TYPE");
+        break;
+        case 0x1010:
+        printf("WSC_ID_ENCR_TYPE_FLAGS");
+        break;
+        case 0x101A:
+        printf("WSC_ID_ENROLLEE_NONCE");
+        break;
+        case 0x101B:
+        printf("WSC_ID_FEATURE_ID");
+        break;
+        case 0x101C:
+        printf("WSC_ID_IDENTITY");
+        break;
+        case 0x101D:
+        printf("WSC_ID_IDENTITY_PROOF");
+        break;
+        case 0x101E:
+        printf("WSC_ID_KEY_WRAP_AUTH");
+        break;
+        case 0x101F:
+        printf("WSC_ID_KEY_IDENTIFIER");
+        break;
+        case 0x1020:
+        printf("WSC_ID_MAC_ADDR");
+        break;
+        case 0x1021:
+        printf("WSC_ID_MANUFACTURER");
+        break;
+        case 0x1022:
+        printf("WSC_ID_MSG_TYPE");
+        break;
+        case 0x1023:
+        printf("WSC_ID_MODEL_NAME");
+        break;
+        case 0x1024:
+        printf("WSC_ID_MODEL_NUMBER");
+        break;
+        case 0x1026:
+        printf("WSC_ID_NW_INDEX");
+        break;
+        case 0x1027:
+        printf("WSC_ID_NW_KEY");
+        break;
+        case 0x1028:
+        printf("WSC_ID_NW_KEY_INDEX");
+        break;
+        case 0x1029:
+        printf("WSC_ID_NEW_DEVICE_NAME");
+        break;
+        case 0x102A:
+        printf("WSC_ID_NEW_PWD");
+        break;
+        case 0x102C:
+        printf("WSC_ID_OOB_DEV_PWD");
+        break;
+        case 0x102D:
+        printf("WSC_ID_OS_VERSION");
+        break;
+        case 0x102F:
+        printf("WSC_ID_POWER_LEVEL");
+        break;
+        case 0x1030:
+        printf("WSC_ID_PSK_CURRENT");
+        break;
+        case 0x1031:
+        printf("WSC_ID_PSK_MAX");
+        break;
+        case 0x1032:
+        printf("WSC_ID_PUBLIC_KEY");
+        break;
+        case 0x1033:
+        printf("WSC_ID_RADIO_ENABLED");
+        break;
+        case 0x1034:
+        printf("WSC_ID_REBOOT");
+        break;
+        case 0x1035:
+        printf("WSC_ID_REGISTRAR_CURRENT");
+        break;
+        case 0x1036:
+        printf("WSC_ID_REGISTRAR_ESTBLSHD");
+        break;
+        case 0x1037:
+        printf("WSC_ID_REGISTRAR_LIST");
+        break;
+        case 0x1038:
+        printf("WSC_ID_REGISTRAR_MAX");
+        break;
+        case 0x1039:
+        printf("WSC_ID_REGISTRAR_NONCE");
+        break;
+        case 0x103A:
+        printf("WSC_ID_REQ_TYPE");
+        break;
+        case 0x103B:
+        printf("WSC_ID_RESP_TYPE");
+        break;
+        case 0x103C:
+        printf("WSC_ID_RF_BAND");
+        break;
+        case 0x103D:
+        printf("WSC_ID_R_HASH1");
+        break;
+        case 0x103E:
+        printf("WSC_ID_R_HASH2");
+        break;
+        case 0x103F:
+        printf("WSC_ID_R_SNONCE1");
+        break;
+        case 0x1040:
+        printf("WSC_ID_R_SNONCE2");
+        break;
+        case 0x1041:
+        printf("WSC_ID_SEL_REGISTRAR");
+        break;
+        case 0x1042:
+        printf("WSC_ID_SERIAL_NUM");
+        break;
+        case 0x1044:
+        printf("WSC_ID_SC_STATE");
+        break;
+        case 0x1045:
+        printf("WSC_ID_SSID");
+        break;
+        case 0x1046:
+        printf("WSC_ID_TOT_NETWORKS");
+        break;
+        case 0x1047:
+        printf("WSC_ID_UUID_E");
+        break;
+        case 0x1048:
+        printf("WSC_ID_UUID_R");
+        break;
+        case 0x1049:
+        printf("WSC_ID_VENDOR_EXT");
+        break;
+        case 0x104A:
+        printf("WSC_ID_VERSION");
+        break;
+        case 0x104B:
+        printf("WSC_ID_X509_CERT_REQ");
+        break;
+        case 0x104C:
+        printf("WSC_ID_X509_CERT");
+        break;
+        case 0x104D:
+        printf("WSC_ID_EAP_IDENTITY");
+        break;
+        case 0x104E:
+        printf("WSC_ID_MSG_COUNTER");
+        break;
+        case 0x104F:
+        printf("WSC_ID_PUBKEY_HASH");
+        break;
+        case 0x1050:
+        printf("WSC_ID_REKEY_KEY");
+        break;
+        case 0x1051:
+        printf("WSC_ID_KEY_LIFETIME");
+        break;
+        case 0x1052:
+        printf("WSC_ID_PERM_CFG_METHODS");
+        break;
+        case 0x1053:
+        printf("WSC_ID_SEL_REG_CFG_METHODS");
+        break;
+        case 0x1054:
+        printf("WSC_ID_PRIM_DEV_TYPE");
+        break;
+        case 0x1055:
+        printf("WSC_ID_SEC_DEV_TYPE_LIST");
+        break;
+        case 0x1056:
+        printf("WSC_ID_PORTABLE_DEVICE");
+        break;
+        case 0x1057:
+        printf("WSC_ID_AP_SETUP_LOCKED");
+        break;
+        case 0x1058:
+        printf("WSC_ID_APP_LIST");
+        break;
+        case 0x1059:
+        printf("WSC_ID_EAP_TYPE");
+        break;
+        case 0x1060:
+        printf("WSC_ID_INIT_VECTOR");
+        break;
+        case 0x1061:
+        printf("WSC_ID_KEY_PROVIDED_AUTO");
+        break;
+        case 0x1062:
+        printf("WSC_ID_8021X_ENABLED");
+        break;
+
+        default:
+        printf("unknown");
+        ret = 0;
+    }
+    printf("}\n");
+    return ret;
+}
+#endif
+
+#ifndef WSC_DEBUG
+#define process_wsc(arg...)
+#else
+int process_wsc(u_int8_t* buf, int len)
+{
+    u_int8_t *ptr = buf, *e_ptr = buf + len;
+    struct wsc_hdr w;
+    int i;
+    int error = 0;
+    int unknown = 0;
+
+    while(ptr < e_ptr) {
+	memcpy(&w, ptr, sizeof(struct wsc_hdr));
+	w.type = htons(w.type);
+	w.size = htons(w.size);
+
+        // w = (struct wsc_hdr*)ptr;
+        if (!wsc_lookup(w.type)) {
+            unknown++;
+        }
+        printf("size = %.4x (%i)\n", w.size, w.size);
+
+        ptr += 4;
+
+        printf("content = { ");
+        for (i = 0; i < w.size && ptr < e_ptr; i++) {
+            if (i % 16 == 0) {
+                printf("\n%3i:\t", i);
+            }
+            else if (i % 4 == 0) {
+                printf("  ");
+            }
+            printf("%.2x ", (u_int8_t)*ptr);
+            ptr++;
+        }
+
+        if (i < w.size) {
+            printf("... TRUNCATED %i bytes...\n", w.size - i);
+            error = 1;
+        }  
+
+        printf("\n}\n\n");
+    }
+    if (error) {
+        printf("== parse failed due to overflow (%i unknown fields) ==\n", unknown);
+    }
+    else {
+        printf("== parse completed with %i unknown fields ==\n", unknown);
+    }
+}
+#endif
+
+/*------------------------------------------------------------------*/
+/*
+ * Parse, and display the results of a WSC IE.
+ *
+ */
+static void 
+iw_print_ie_wsc(unsigned char *	iebuf,
+		int		buflen)
+{
+  unsigned char *ptr = iebuf + 6, *e_ptr = iebuf + buflen;
+  struct wsc_hdr {
+    u_int16_t type;
+    u_int16_t size;
+  } w;
+
+#define WSC_ID_SEL_REGISTRAR    0x1041
+
+  int ret = 0;
+  unsigned char reg_sel_val = 0;
+
+  while(ptr < e_ptr) 
+	{
+	  /**
+	   *  don't ever cast wsc_hdr on top of ptr to avoid
+	   *  strange alignment issues in arm processors
+	   *  - Firat
+	   */
+	  memcpy(&w, ptr, sizeof(struct wsc_hdr));
+	  w.type = htons(w.type);
+	  w.size = htons(w.size);
+
+	  if ((w.type) == WSC_ID_SEL_REGISTRAR) 
+	    {
+		if (w.size != 1) {
+		  ret = 0;
+	    	}
+		else {
+		  memcpy( &reg_sel_val, ptr + sizeof(struct wsc_hdr), sizeof(u_int8_t));
+		  ret = reg_sel_val;
+		}
+		goto out;
+	    }
+	  ptr += 4 + w.size;
+	}
+
+out:
+  printf("WPS(enabled=%i, button=%i)\n", 1, reg_sel_val);
+}
+
+/*------------------------------------------------------------------*/
+/*
+ * Parse, and display the results of a WPA or WPA2 IE.
+ *
+ */
+static inline void 
+iw_print_ie_wpa(unsigned char *	iebuf,
+		int		buflen)
+{
+  int			ielen = iebuf[1] + 2;
+  int			offset = 2;	/* Skip the IE id, and the length. */
+  unsigned char		wpa1_oui[3] = {0x00, 0x50, 0xf2};
+  unsigned char		wpa2_oui[3] = {0x00, 0x0f, 0xac};
+  unsigned char *	wpa_oui;
+  int			i;
+  uint16_t		ver = 0;
+  uint16_t		cnt = 0;
+
+  if(ielen > buflen)
+    ielen = buflen;
+
+#ifdef DEBUG
+  /* Debugging code. In theory useless, because it's debugged ;-) */
+  printf("IE raw value %d [%02X", buflen, iebuf[0]);
+  for(i = 1; i < buflen; i++)
+    printf(":%02X", iebuf[i]);
+  printf("]\n");
+#endif
+
+  switch(iebuf[0])
+    {
+    case 0x30:		/* WPA2 */
+      /* Check if we have enough data */
+      if(ielen < 4)
+	{
+	  iw_print_ie_unknown(iebuf, buflen);
+ 	  return;
+	}
+
+      wpa_oui = wpa2_oui;
+      break;
+
+    case 0xdd:		/* WPA or else */
+      wpa_oui = wpa1_oui;
+ 
+      /* Not all IEs that start with 0xdd are WPA. 
+       * So check that the OUI is valid. Note : offset==2 */
+      if((ielen < 8)
+	 || (memcmp(&iebuf[offset], wpa_oui, 3) != 0))
+ 	{
+	  iw_print_ie_unknown(iebuf, buflen);
+ 	  return;
+ 	}
+      else if (iebuf[offset + 3] == 0x04) 
+	{
+	  iw_print_ie_wsc(iebuf, buflen);
+ 	  return;
+	}
+      else if (iebuf[offset + 3] != 0x01) 
+	{
+	  iw_print_ie_unknown(iebuf, buflen);
+ 	  return;
+	}
+
+      /* Skip the OUI type */
+      offset += 4;
+      break;
+
+    default:
+      return;
+    }
+  
+  /* Pick version number (little endian) */
+  ver = iebuf[offset] | (iebuf[offset + 1] << 8);
+  offset += 2;
+
+  if(iebuf[0] == 0xdd)
+    printf("WPA Version %d\n", ver);
+  if(iebuf[0] == 0x30)
+    printf("IEEE 802.11i/WPA2 Version %d\n", ver);
+
+  /* From here, everything is technically optional. */
+
+  /* Check if we are done */
+  if(ielen < (offset + 4))
+    {
+      /* We have a short IE.  So we should assume TKIP/TKIP. */
+      printf("                        Group Cipher : TKIP\n");
+      printf("                        Pairwise Cipher : TKIP\n");
+      return;
+    }
+ 
+  /* Next we have our group cipher. */
+  if(memcmp(&iebuf[offset], wpa_oui, 3) != 0)
+    {
+      printf("                        Group Cipher : Proprietary\n");
+    }
+  else
+    {
+      printf("                        Group Cipher :");
+      iw_print_value_name(iebuf[offset+3],
+			  iw_ie_cypher_name, IW_IE_CYPHER_NUM);
+      printf("\n");
+    }
+  offset += 4;
+
+  /* Check if we are done */
+  if(ielen < (offset + 2))
+    {
+      /* We don't have a pairwise cipher, or auth method. Assume TKIP. */
+      printf("                        Pairwise Ciphers : TKIP\n");
+      return;
+    }
+
+  /* Otherwise, we have some number of pairwise ciphers. */
+  cnt = iebuf[offset] | (iebuf[offset + 1] << 8);
+  offset += 2;
+  printf("                        Pairwise Ciphers (%d) :", cnt);
+
+  if(ielen < (offset + 4*cnt))
+    return;
+
+  for(i = 0; i < cnt; i++)
+    {
+      if(memcmp(&iebuf[offset], wpa_oui, 3) != 0)
+ 	{
+ 	  printf(" Proprietary");
+ 	}
+      else
+	{
+	  iw_print_value_name(iebuf[offset+3],
+			      iw_ie_cypher_name, IW_IE_CYPHER_NUM);
+ 	}
+      offset+=4;
+    }
+  printf("\n");
+ 
+  /* Check if we are done */
+  if(ielen < (offset + 2))
+    return;
+
+  /* Now, we have authentication suites. */
+  cnt = iebuf[offset] | (iebuf[offset + 1] << 8);
+  offset += 2;
+  printf("                        Authentication Suites (%d) :", cnt);
+
+  if(ielen < (offset + 4*cnt))
+    return;
+
+  for(i = 0; i < cnt; i++)
+    {
+      if(memcmp(&iebuf[offset], wpa_oui, 3) != 0)
+ 	{
+ 	  printf(" Proprietary");
+ 	}
+      else
+	{
+	  iw_print_value_name(iebuf[offset+3],
+			      iw_ie_key_mgmt_name, IW_IE_KEY_MGMT_NUM);
+ 	}
+       offset+=4;
+     }
+  printf("\n");
+ 
+  /* Check if we are done */
+  if(ielen < (offset + 1))
+    return;
+
+  /* Otherwise, we have capabilities bytes.
+   * For now, we only care about preauth which is in bit position 1 of the
+   * first byte.  (But, preauth with WPA version 1 isn't supposed to be 
+   * allowed.) 8-) */
+  if(iebuf[offset] & 0x01)
+    {
+      printf("                       Preauthentication Supported\n");
+    }
+}
+ 
+/*------------------------------------------------------------------*/
+/*
+ * Process a generic IE and display the info in human readable form
+ * for some of the most interesting ones.
+ * For now, we only decode the WPA IEs.
+ */
+static inline void
+iw_print_gen_ie(unsigned char *	buffer,
+		int		buflen)
+{
+  int offset = 0;
+
+  /* Loop on each IE, each IE is minimum 2 bytes */
+  while(offset <= (buflen - 2))
+    {
+      printf("                    IE: ");
+
+      /* Check IE type */
+      switch(buffer[offset])
+	{
+	case 0xdd:	/* WPA1 (and other) */
+	case 0x30:	/* WPA2 */
+	  iw_print_ie_wpa(buffer + offset, buflen);
+	  break;
+	default:
+	  iw_print_ie_unknown(buffer + offset, buflen);
+	}
+      /* Skip over this IE to the next one in the list. */
+      offset += buffer[offset+1] + 2;
+    }
+}
+#endif	/* WE_ESSENTIAL */
+
+/***************************** SCANNING *****************************/
+/*
+ * This one behave quite differently from the others
+ *
+ * Note that we don't use the scanning capability of iwlib (functions
+ * iw_process_scan() and iw_scan()). The main reason is that
+ * iw_process_scan() return only a subset of the scan data to the caller,
+ * for example custom elements and bitrates are ommited. Here, we
+ * do the complete job...
+ */
+
+/*------------------------------------------------------------------*/
+/*
+ * Print one element from the scanning results
+ */
+static inline void
+print_scanning_token(struct stream_descr *	stream,	/* Stream of events */
+		     struct iw_event *		event,	/* Extracted token */
+		     struct iwscan_state *	state,
+		     struct iw_range *	iw_range,	/* Range info */
+		     int		has_range)
+{
+  char		buffer[128];	/* Temporary buffer */
+
+  /* Now, let's decode the event */
+  switch(event->cmd)
+    {
+    case SIOCGIWAP:
+      printf("          Cell %02d - Address: %s\n", state->ap_num,
+	     iw_saether_ntop(&event->u.ap_addr, buffer));
+      state->ap_num++;
+      break;
+    case SIOCGIWNWID:
+      if(event->u.nwid.disabled)
+	printf("                    NWID:off/any\n");
+      else
+	printf("                    NWID:%X\n", event->u.nwid.value);
+      break;
+    case SIOCGIWFREQ:
+      {
+	double		freq;			/* Frequency/channel */
+	int		channel = -1;		/* Converted to channel */
+	freq = iw_freq2float(&(event->u.freq));
+	/* Convert to channel if possible */
+	if(has_range)
+	  channel = iw_freq_to_channel(freq, iw_range);
+	iw_print_freq(buffer, sizeof(buffer),
+		      freq, channel, event->u.freq.flags);
+	printf("                    %s\n", buffer);
+      }
+      break;
+    case SIOCGIWMODE:
+      /* Note : event->u.mode is unsigned, no need to check <= 0 */
+      if(event->u.mode >= IW_NUM_OPER_MODE)
+	event->u.mode = IW_NUM_OPER_MODE;
+      printf("                    Mode:%s\n",
+	     iw_operation_mode[event->u.mode]);
+      break;
+    case SIOCGIWNAME:
+      printf("                    Protocol:%-1.16s\n", event->u.name);
+      break;
+    case SIOCGIWESSID:
+      {
+	char essid[IW_ESSID_MAX_SIZE+1];
+	memset(essid, '\0', sizeof(essid));
+	if((event->u.essid.pointer) && (event->u.essid.length))
+	  memcpy(essid, event->u.essid.pointer, event->u.essid.length);
+	if(event->u.essid.flags)
+	  {
+	    /* Does it have an ESSID index ? */
+	    if((event->u.essid.flags & IW_ENCODE_INDEX) > 1)
+	      printf("                    ESSID:\"%s\" [%d]\n", essid,
+		     (event->u.essid.flags & IW_ENCODE_INDEX));
+	    else
+	      printf("                    ESSID:\"%s\"\n", essid);
+	  }
+	else
+	  printf("                    ESSID:off/any/hidden\n");
+      }
+      break;
+    case SIOCGIWENCODE:
+      {
+	unsigned char	key[IW_ENCODING_TOKEN_MAX];
+	if(event->u.data.pointer)
+	  memcpy(key, event->u.data.pointer, event->u.data.length);
+	else
+	  event->u.data.flags |= IW_ENCODE_NOKEY;
+	printf("                    Encryption key:");
+	if(event->u.data.flags & IW_ENCODE_DISABLED)
+	  printf("off\n");
+	else
+	  {
+	    /* Display the key */
+	    iw_print_key(buffer, sizeof(buffer), key, event->u.data.length,
+			 event->u.data.flags);
+	    printf("%s", buffer);
+
+	    /* Other info... */
+	    if((event->u.data.flags & IW_ENCODE_INDEX) > 1)
+	      printf(" [%d]", event->u.data.flags & IW_ENCODE_INDEX);
+	    if(event->u.data.flags & IW_ENCODE_RESTRICTED)
+	      printf("   Security mode:restricted");
+	    if(event->u.data.flags & IW_ENCODE_OPEN)
+	      printf("   Security mode:open");
+	    printf("\n");
+	  }
+      }
+      break;
+    case SIOCGIWRATE:
+      if(state->val_index == 0)
+	printf("                    Bit Rates:");
+      else
+	if((state->val_index % 5) == 0)
+	  printf("\n                              ");
+	else
+	  printf("; ");
+      iw_print_bitrate(buffer, sizeof(buffer), event->u.bitrate.value);
+      printf("%s", buffer);
+      /* Check for termination */
+      if(stream->value == NULL)
+	{
+	  printf("\n");
+	  state->val_index = 0;
+	}
+      else
+	state->val_index++;
+      break;
+    case SIOCGIWMODUL:
+      {
+	unsigned int	modul = event->u.param.value;
+	int		i;
+	int		n = 0;
+	printf("                    Modulations :");
+	for(i = 0; i < IW_SIZE_MODUL_LIST; i++)
+	  {
+	    if((modul & iw_modul_list[i].mask) == iw_modul_list[i].mask)
+	      {
+		if((n++ % 8) == 7)
+		  printf("\n                        ");
+		else
+		  printf(" ; ");
+		printf("%s", iw_modul_list[i].cmd);
+	      }
+	  }
+	printf("\n");
+      }
+      break;
+    case IWEVQUAL:
+      iw_print_stats(buffer, sizeof(buffer),
+		     &event->u.qual, iw_range, has_range);
+      printf("                    %s\n", buffer);
+      break;
+#ifndef WE_ESSENTIAL
+    case IWEVGENIE:
+      /* Informations Elements are complex, let's do only some of them */
+      iw_print_gen_ie(event->u.data.pointer, event->u.data.length);
+      break;
+#endif	/* WE_ESSENTIAL */
+    case IWEVCUSTOM:
+      {
+	char custom[IW_CUSTOM_MAX+1];
+	if((event->u.data.pointer) && (event->u.data.length))
+	  memcpy(custom, event->u.data.pointer, event->u.data.length);
+	custom[event->u.data.length] = '\0';
+	printf("                    Extra:%s\n", custom);
+      }
+      break;
+    default:
+      printf("                    (Unknown Wireless Token 0x%04X)\n",
+	     event->cmd);
+   }	/* switch(event->cmd) */
+}
+
+/*------------------------------------------------------------------*/
+/*
+ * Perform a scanning on one device
+ */
+static int
+print_scanning_info(int		skfd,
+		    char *	ifname,
+		    char *	args[],		/* Command line args */
+		    int		count)		/* Args count */
+{
+  struct iwreq		wrq;
+  struct iw_scan_req    scanopt;		/* Options for 'set' */
+  int			scanflags = 0;		/* Flags for scan */
+  unsigned char *	buffer = NULL;		/* Results */
+  int			buflen = IW_SCAN_MAX_DATA; /* Min for compat WE<17 */
+  struct iw_range	range;
+  int			has_range;
+  struct timeval	tv;				/* Select timeout */
+  int			timeout = 15000000;		/* 15s */
+
+  /* Avoid "Unused parameter" warning */
+  args = args; count = count;
+
+  /* Debugging stuff */
+  if((IW_EV_LCP_PK2_LEN != IW_EV_LCP_PK_LEN) || (IW_EV_POINT_PK2_LEN != IW_EV_POINT_PK_LEN))
+    {
+      fprintf(stderr, "*** Please report to jt@hpl.hp.com your platform details\n");
+      fprintf(stderr, "*** and the following line :\n");
+      fprintf(stderr, "*** IW_EV_LCP_PK2_LEN = %zu ; IW_EV_POINT_PK2_LEN = %zu\n\n",
+	      IW_EV_LCP_PK2_LEN, IW_EV_POINT_PK2_LEN);
+    }
+
+  /* Get range stuff */
+  has_range = (iw_get_range_info(skfd, ifname, &range) >= 0);
+
+  /* Check if the interface could support scanning. */
+  if((!has_range) || (range.we_version_compiled < 14))
+    {
+      fprintf(stderr, "%-8.16s  Interface doesn't support scanning.\n\n",
+	      ifname);
+      return(-1);
+    }
+
+  /* Init timeout value -> 250ms between set and first get */
+  tv.tv_sec = 0;
+  tv.tv_usec = 500000;
+
+  /* Clean up set args */
+  memset(&scanopt, 0, sizeof(scanopt));
+
+  /* Parse command line arguments and extract options.
+   * Note : when we have enough options, we should use the parser
+   * from iwconfig... */
+  while(count > 0)
+    {
+      /* One arg is consumed (the option name) */
+      count--;
+      
+      /*
+       * Check for Active Scan (scan with specific essid)
+       */
+      if(!strncmp(args[0], "essid", 5))
+	{
+	  if(count < 1)
+	    {
+	      fprintf(stderr, "Too few arguments for scanning option [%s]\n",
+		      args[0]);
+	      return(-1);
+	    }
+	  args++;
+	  count--;
+
+	  /* Store the ESSID in the scan options */
+	  scanopt.essid_len = strlen(args[0]);
+	  memcpy(scanopt.essid, args[0], scanopt.essid_len);
+	  /* Initialise BSSID as needed */
+	  if(scanopt.bssid.sa_family == 0)
+	    {
+	      scanopt.bssid.sa_family = ARPHRD_ETHER;
+	      memset(scanopt.bssid.sa_data, 0xff, ETH_ALEN);
+	    }
+	  /* Scan only this ESSID */
+	  scanflags |= IW_SCAN_THIS_ESSID;
+	}
+      else
+	/* Check for last scan result (do not trigger scan) */
+	if(!strncmp(args[0], "last", 4))
+	  {
+	    /* Hack */
+	    scanflags |= IW_SCAN_HACK;
+	  }
+	else
+	  {
+	    fprintf(stderr, "Invalid scanning option [%s]\n", args[0]);
+	    return(-1);
+	  }
+
+      /* Next arg */
+      args++;
+    }
+
+  /* Check if we have scan options */
+  if(scanflags)
+    {
+      wrq.u.data.pointer = (caddr_t) &scanopt;
+      wrq.u.data.length = sizeof(scanopt);
+      wrq.u.data.flags = scanflags;
+    }
+  else
+    {
+      wrq.u.data.pointer = NULL;
+      wrq.u.data.flags = 0;
+      wrq.u.data.length = 0;
+    }
+
+  /* If only 'last' was specified on command line, don't trigger a scan */
+  if(scanflags == IW_SCAN_HACK)
+    {
+      /* Skip waiting */
+      tv.tv_usec = 0;
+    }
+  else
+    {
+      /* Initiate Scanning */
+      if(iw_set_ext(skfd, ifname, SIOCSIWSCAN, &wrq) < 0)
+	{
+	  if((errno != EPERM) || (scanflags != 0))
+	    {
+	      fprintf(stderr, "%-8.16s  Interface doesn't support scanning : %s\n\n",
+		      ifname, strerror(errno));
+	      return(-1);
+	    }
+	  /* If we don't have the permission to initiate the scan, we may
+	   * still have permission to read left-over results.
+	   * But, don't wait !!! */
+#if 0
+	  /* Not cool, it display for non wireless interfaces... */
+	  fprintf(stderr, "%-8.16s  (Could not trigger scanning, just reading left-over results)\n", ifname);
+#endif
+	  tv.tv_usec = 0;
+	}
+    }
+  timeout -= tv.tv_usec;
+
+  /* Forever */
+  while(1)
+    {
+      fd_set		rfds;		/* File descriptors for select */
+      int		last_fd;	/* Last fd */
+      int		ret;
+
+      /* Guess what ? We must re-generate rfds each time */
+      FD_ZERO(&rfds);
+      last_fd = -1;
+
+      /* In here, add the rtnetlink fd in the list */
+
+      /* Wait until something happens */
+      ret = select(last_fd + 1, &rfds, NULL, NULL, &tv);
+
+      /* Check if there was an error */
+      if(ret < 0)
+	{
+	  if(errno == EAGAIN || errno == EINTR)
+	    continue;
+	  fprintf(stderr, "Unhandled signal - exiting...\n");
+	  return(-1);
+	}
+
+      /* Check if there was a timeout */
+      if(ret == 0)
+	{
+	  unsigned char *	newbuf;
+
+	realloc:
+	  /* (Re)allocate the buffer - realloc(NULL, len) == malloc(len) */
+	  newbuf = realloc(buffer, buflen);
+	  if(newbuf == NULL)
+	    {
+	      if(buffer)
+		free(buffer);
+	      fprintf(stderr, "%s: Allocation failed\n", __FUNCTION__);
+	      return(-1);
+	    }
+	  buffer = newbuf;
+
+	  /* Try to read the results */
+	  wrq.u.data.pointer = buffer;
+	  wrq.u.data.flags = 0;
+	  wrq.u.data.length = buflen;
+	  if(iw_get_ext(skfd, ifname, SIOCGIWSCAN, &wrq) < 0)
+	    {
+	      /* Check if buffer was too small (WE-17 only) */
+	      if((errno == E2BIG) && (range.we_version_compiled > 16))
+		{
+		  /* Some driver may return very large scan results, either
+		   * because there are many cells, or because they have many
+		   * large elements in cells (like IWEVCUSTOM). Most will
+		   * only need the regular sized buffer. We now use a dynamic
+		   * allocation of the buffer to satisfy everybody. Of course,
+		   * as we don't know in advance the size of the array, we try
+		   * various increasing sizes. Jean II */
+
+		  /* Check if the driver gave us any hints. */
+		  if(wrq.u.data.length > buflen)
+		    buflen = wrq.u.data.length;
+		  else
+		    buflen *= 2;
+
+		  /* Try again */
+		  goto realloc;
+		}
+
+	      /* Check if results not available yet */
+	      if(errno == EAGAIN)
+		{
+		  /* Restart timer for only 100ms*/
+		  tv.tv_sec = 0;
+		  tv.tv_usec = 500000;
+		  timeout -= tv.tv_usec;
+		  if(timeout > 0)
+		    continue;	/* Try again later */
+		}
+
+	      /* Bad error */
+	      free(buffer);
+	      fprintf(stderr, "%-8.16s  Failed to read scan data : %s\n\n",
+		      ifname, strerror(errno));
+	      return(-2);
+	    }
+	  else
+	    /* We have the results, go to process them */
+	    break;
+	}
+
+      /* In here, check if event and event type
+       * if scan event, read results. All errors bad & no reset timeout */
+    }
+
+  if(wrq.u.data.length)
+    {
+      struct iw_event		iwe;
+      struct stream_descr	stream;
+      struct iwscan_state	state = { .ap_num = 1, .val_index = 0 };
+      int			ret;
+      
+#ifdef DEBUG
+      /* Debugging code. In theory useless, because it's debugged ;-) */
+      int	i;
+      printf("Scan result %d [%02X", wrq.u.data.length, buffer[0]);
+      for(i = 1; i < wrq.u.data.length; i++)
+	printf(":%02X", buffer[i]);
+      printf("]\n");
+#endif
+      printf("%-8.16s  Scan completed :\n", ifname);
+      iw_init_event_stream(&stream, (char *) buffer, wrq.u.data.length);
+      do
+	{
+	  /* Extract an event and print it */
+	  ret = iw_extract_event_stream(&stream, &iwe,
+					range.we_version_compiled);
+	  if(ret > 0)
+	    print_scanning_token(&stream, &iwe, &state,
+				 &range, has_range);
+	}
+      while(ret > 0);
+      printf("\n");
+    }
+  else
+    printf("%-8.16s  No scan results\n\n", ifname);
+
+  free(buffer);
+  return(0);
+}
+
+/*********************** FREQUENCIES/CHANNELS ***********************/
+
+/*------------------------------------------------------------------*/
+/*
+ * Print the number of channels and available frequency for the device
+ */
+static int
+print_freq_info(int		skfd,
+		char *		ifname,
+		char *		args[],		/* Command line args */
+		int		count)		/* Args count */
+{
+  struct iwreq		wrq;
+  struct iw_range	range;
+  double		freq;
+  int			k;
+  int			channel;
+  char			buffer[128];	/* Temporary buffer */
+
+  /* Avoid "Unused parameter" warning */
+  args = args; count = count;
+
+  /* Get list of frequencies / channels */
+  if(iw_get_range_info(skfd, ifname, &range) < 0)
+      fprintf(stderr, "%-8.16s  no frequency information.\n\n",
+		      ifname);
+  else
+    {
+      if(range.num_frequency > 0)
+	{
+	  printf("%-8.16s  %d channels in total; available frequencies :\n",
+		 ifname, range.num_channels);
+	  /* Print them all */
+	  for(k = 0; k < range.num_frequency; k++)
+	    {
+	      freq = iw_freq2float(&(range.freq[k]));
+	      iw_print_freq_value(buffer, sizeof(buffer), freq);
+	      printf("          Channel %.2d : %s\n",
+		     range.freq[k].i, buffer);
+	    }
+	}
+      else
+	printf("%-8.16s  %d channels\n",
+	       ifname, range.num_channels);
+
+      /* Get current frequency / channel and display it */
+      if(iw_get_ext(skfd, ifname, SIOCGIWFREQ, &wrq) >= 0)
+	{
+	  freq = iw_freq2float(&(wrq.u.freq));
+	  channel = iw_freq_to_channel(freq, &range);
+	  iw_print_freq(buffer, sizeof(buffer),
+			freq, channel, wrq.u.freq.flags);
+	  printf("          Current %s\n\n", buffer);
+	}
+    }
+  return(0);
+}
+
+/***************************** BITRATES *****************************/
+
+/*------------------------------------------------------------------*/
+/*
+ * Print the number of available bitrates for the device
+ */
+static int
+print_bitrate_info(int		skfd,
+		   char *	ifname,
+		   char *	args[],		/* Command line args */
+		   int		count)		/* Args count */
+{
+  struct iwreq		wrq;
+  struct iw_range	range;
+  int			k;
+  char			buffer[128];
+
+  /* Avoid "Unused parameter" warning */
+  args = args; count = count;
+
+  /* Extract range info */
+  if(iw_get_range_info(skfd, ifname, &range) < 0)
+      fprintf(stderr, "%-8.16s  no bit-rate information.\n\n",
+		      ifname);
+  else
+    {
+      if((range.num_bitrates > 0) && (range.num_bitrates <= IW_MAX_BITRATES))
+	{
+	  printf("%-8.16s  %d available bit-rates :\n",
+		 ifname, range.num_bitrates);
+	  /* Print them all */
+	  for(k = 0; k < range.num_bitrates; k++)
+	    {
+	      iw_print_bitrate(buffer, sizeof(buffer), range.bitrate[k]);
+	      /* Maybe this should be %10s */
+	      printf("\t  %s\n", buffer);
+	    }
+	}
+      else
+	printf("%-8.16s  unknown bit-rate information.\n", ifname);
+
+      /* Get current bit rate */
+      if(iw_get_ext(skfd, ifname, SIOCGIWRATE, &wrq) >= 0)
+	{
+	  iw_print_bitrate(buffer, sizeof(buffer), wrq.u.bitrate.value);
+	  printf("          Current Bit Rate%c%s\n",
+		 (wrq.u.bitrate.fixed ? '=' : ':'), buffer);
+	}
+
+      /* Try to get the broadcast bitrate if it exist... */
+      if(range.bitrate_capa & IW_BITRATE_BROADCAST)
+	{
+	  wrq.u.bitrate.flags = IW_BITRATE_BROADCAST;
+	  if(iw_get_ext(skfd, ifname, SIOCGIWRATE, &wrq) >= 0)
+	    {
+	      iw_print_bitrate(buffer, sizeof(buffer), wrq.u.bitrate.value);
+	      printf("          Broadcast Bit Rate%c%s\n",
+		     (wrq.u.bitrate.fixed ? '=' : ':'), buffer);
+	    }
+	}
+
+      printf("\n");
+    }
+  return(0);
+}
+
+/************************* ENCRYPTION KEYS *************************/
+
+/*------------------------------------------------------------------*/
+/*
+ * Print all the available encryption keys for the device
+ */
+static int
+print_keys_info(int		skfd,
+		char *		ifname,
+		char *		args[],		/* Command line args */
+		int		count)		/* Args count */
+{
+  struct iwreq		wrq;
+  struct iw_range	range;
+  unsigned char		key[IW_ENCODING_TOKEN_MAX];
+  unsigned int		k;
+  char			buffer[128];
+
+  /* Avoid "Unused parameter" warning */
+  args = args; count = count;
+
+  /* Extract range info */
+  if(iw_get_range_info(skfd, ifname, &range) < 0)
+      fprintf(stderr, "%-8.16s  no encryption keys information.\n\n",
+		      ifname);
+  else
+    {
+      printf("%-8.16s  ", ifname);
+      /* Print key sizes */
+      if((range.num_encoding_sizes > 0) &&
+	 (range.num_encoding_sizes < IW_MAX_ENCODING_SIZES))
+	{
+	  printf("%d key sizes : %d", range.num_encoding_sizes,
+		 range.encoding_size[0] * 8);
+	  /* Print them all */
+	  for(k = 1; k < range.num_encoding_sizes; k++)
+	    printf(", %d", range.encoding_size[k] * 8);
+	  printf("bits\n          ");
+	}
+      /* Print the keys and associate mode */
+      printf("%d keys available :\n", range.max_encoding_tokens);
+      for(k = 1; k <= range.max_encoding_tokens; k++)
+	{
+	  wrq.u.data.pointer = (caddr_t) key;
+	  wrq.u.data.length = IW_ENCODING_TOKEN_MAX;
+	  wrq.u.data.flags = k;
+	  if(iw_get_ext(skfd, ifname, SIOCGIWENCODE, &wrq) < 0)
+	    {
+	      fprintf(stderr, "Error reading wireless keys (SIOCGIWENCODE): %s\n", strerror(errno));
+	      break;
+	    }
+	  if((wrq.u.data.flags & IW_ENCODE_DISABLED) ||
+	     (wrq.u.data.length == 0))
+	    printf("\t\t[%d]: off\n", k);
+	  else
+	    {
+	      /* Display the key */
+	      iw_print_key(buffer, sizeof(buffer),
+			   key, wrq.u.data.length, wrq.u.data.flags);
+	      printf("\t\t[%d]: %s", k, buffer);
+
+	      /* Other info... */
+	      printf(" (%d bits)", wrq.u.data.length * 8);
+	      printf("\n");
+	    }
+	}
+      /* Print current key index and mode */
+      wrq.u.data.pointer = (caddr_t) key;
+      wrq.u.data.length = IW_ENCODING_TOKEN_MAX;
+      wrq.u.data.flags = 0;	/* Set index to zero to get current */
+      if(iw_get_ext(skfd, ifname, SIOCGIWENCODE, &wrq) >= 0)
+	{
+	  /* Note : if above fails, we have already printed an error
+	   * message int the loop above */
+	  printf("          Current Transmit Key: [%d]\n",
+		 wrq.u.data.flags & IW_ENCODE_INDEX);
+	  if(wrq.u.data.flags & IW_ENCODE_RESTRICTED)
+	    printf("          Security mode:restricted\n");
+	  if(wrq.u.data.flags & IW_ENCODE_OPEN)
+	    printf("          Security mode:open\n");
+	}
+
+      printf("\n\n");
+    }
+  return(0);
+}
+
+/************************* POWER MANAGEMENT *************************/
+
+/*------------------------------------------------------------------*/
+/*
+ * Print Power Management info for each device
+ */
+static int
+get_pm_value(int		skfd,
+	     char *		ifname,
+	     struct iwreq *	pwrq,
+	     int		flags,
+	     char *		buffer,
+	     int		buflen,
+	     int		we_version_compiled)
+{
+  /* Get Another Power Management value */
+  pwrq->u.power.flags = flags;
+  if(iw_get_ext(skfd, ifname, SIOCGIWPOWER, pwrq) >= 0)
+    {
+      /* Let's check the value and its type */
+      if(pwrq->u.power.flags & IW_POWER_TYPE)
+	{
+	  iw_print_pm_value(buffer, buflen,
+			    pwrq->u.power.value, pwrq->u.power.flags,
+			    we_version_compiled);
+	  printf("\n                 %s", buffer);
+	}
+    }
+  return(pwrq->u.power.flags);
+}
+
+/*------------------------------------------------------------------*/
+/*
+ * Print Power Management range for each type
+ */
+static void
+print_pm_value_range(char *		name,
+		     int		mask,
+		     int		iwr_flags,
+		     int		iwr_min,
+		     int		iwr_max,
+		     char *		buffer,
+		     int		buflen,
+		     int		we_version_compiled)
+{
+  if(iwr_flags & mask)
+    {
+      int	flags = (iwr_flags & ~(IW_POWER_MIN | IW_POWER_MAX));
+      /* Display if auto or fixed */
+      printf("%s %s ; ",
+	     (iwr_flags & IW_POWER_MIN) ? "Auto " : "Fixed",
+	     name);
+      /* Print the range */
+      iw_print_pm_value(buffer, buflen,
+			iwr_min, flags | IW_POWER_MIN,
+			we_version_compiled);
+      printf("%s\n                          ", buffer);
+      iw_print_pm_value(buffer, buflen,
+			iwr_max, flags | IW_POWER_MAX,
+			we_version_compiled);
+      printf("%s\n          ", buffer);
+    }
+}
+
+/*------------------------------------------------------------------*/
+/*
+ * Power Management types of values
+ */
+static const unsigned int pm_type_flags[] = {
+  IW_POWER_PERIOD,
+  IW_POWER_TIMEOUT,
+  IW_POWER_SAVING,
+};
+static const int pm_type_flags_size = (sizeof(pm_type_flags)/sizeof(pm_type_flags[0]));
+
+/*------------------------------------------------------------------*/
+/*
+ * Print Power Management info for each device
+ */
+static int
+print_pm_info(int		skfd,
+	      char *		ifname,
+	      char *		args[],		/* Command line args */
+	      int		count)		/* Args count */
+{
+  struct iwreq		wrq;
+  struct iw_range	range;
+  char			buffer[128];
+
+  /* Avoid "Unused parameter" warning */
+  args = args; count = count;
+
+  /* Extract range info */
+  if((iw_get_range_info(skfd, ifname, &range) < 0) ||
+     (range.we_version_compiled < 10))
+      fprintf(stderr, "%-8.16s  no power management information.\n\n",
+		      ifname);
+  else
+    {
+      printf("%-8.16s  ", ifname);
+
+      /* Display modes availables */
+      if(range.pm_capa & IW_POWER_MODE)
+	{
+	  printf("Supported modes :\n          ");
+	  if(range.pm_capa & (IW_POWER_UNICAST_R | IW_POWER_MULTICAST_R))
+	    printf("\t\to Receive all packets (unicast & multicast)\n          ");
+	  if(range.pm_capa & IW_POWER_UNICAST_R)
+	    printf("\t\to Receive Unicast only (discard multicast)\n          ");
+	  if(range.pm_capa & IW_POWER_MULTICAST_R)
+	    printf("\t\to Receive Multicast only (discard unicast)\n          ");
+	  if(range.pm_capa & IW_POWER_FORCE_S)
+	    printf("\t\to Force sending using Power Management\n          ");
+	  if(range.pm_capa & IW_POWER_REPEATER)
+	    printf("\t\to Repeat multicast\n          ");
+	}
+      /* Display min/max period availables */
+      print_pm_value_range("period ", IW_POWER_PERIOD,
+			   range.pmp_flags, range.min_pmp, range.max_pmp,
+			   buffer, sizeof(buffer), range.we_version_compiled);
+      /* Display min/max timeout availables */
+      print_pm_value_range("timeout", IW_POWER_TIMEOUT,
+			   range.pmt_flags, range.min_pmt, range.max_pmt,
+			   buffer, sizeof(buffer), range.we_version_compiled);
+      /* Display min/max saving availables */
+      print_pm_value_range("saving ", IW_POWER_SAVING,
+			   range.pms_flags, range.min_pms, range.max_pms,
+			   buffer, sizeof(buffer), range.we_version_compiled);
+
+      /* Get current Power Management settings */
+      wrq.u.power.flags = 0;
+      if(iw_get_ext(skfd, ifname, SIOCGIWPOWER, &wrq) >= 0)
+	{
+	  int	flags = wrq.u.power.flags;
+
+	  /* Is it disabled ? */
+	  if(wrq.u.power.disabled)
+	    printf("Current mode:off\n");
+	  else
+	    {
+	      unsigned int	pm_type = 0;
+	      unsigned int	pm_mask = 0;
+	      unsigned int	remain_mask = range.pm_capa & IW_POWER_TYPE;
+	      int		i = 0;
+
+	      /* Let's check the mode */
+	      iw_print_pm_mode(buffer, sizeof(buffer), flags);
+	      printf("Current %s", buffer);
+
+	      /* Let's check if nothing (simply on) */
+	      if((flags & IW_POWER_MODE) == IW_POWER_ON)
+		printf("mode:on");
+
+	      /* Let's check the value and its type */
+	      if(wrq.u.power.flags & IW_POWER_TYPE)
+		{
+		  iw_print_pm_value(buffer, sizeof(buffer),
+				    wrq.u.power.value, wrq.u.power.flags,
+				    range.we_version_compiled);
+		  printf("\n                 %s", buffer);
+		}
+
+	      while(1)
+		{
+		  /* Deal with min/max for the current value */
+		  pm_mask = 0;
+		  /* If we have been returned a MIN value, ask for the MAX */
+		  if(flags & IW_POWER_MIN)
+		    pm_mask = IW_POWER_MAX;
+		  /* If we have been returned a MAX value, ask for the MIN */
+		  if(flags & IW_POWER_MAX)
+		    pm_mask = IW_POWER_MIN;
+		  /* If we have something to ask for... */
+		  if(pm_mask)
+		    {
+		      pm_mask |= pm_type;
+		      get_pm_value(skfd, ifname, &wrq, pm_mask,
+				   buffer, sizeof(buffer),
+				   range.we_version_compiled);
+		    }
+
+		  /* Remove current type from mask */
+		  remain_mask &= ~(wrq.u.power.flags);
+
+		  /* Check what other types we still have to read */
+		  while(i < pm_type_flags_size)
+		    {
+		      pm_type = remain_mask & pm_type_flags[i];
+		      if(pm_type)
+			break;
+		      i++;
+		    }
+		  /* Nothing anymore : exit the loop */
+		  if(!pm_type)
+		    break;
+
+		  /* Ask for this other type of value */
+		  flags = get_pm_value(skfd, ifname, &wrq, pm_type,
+				       buffer, sizeof(buffer),
+				       range.we_version_compiled);
+		  /* Loop back for min/max */
+		}
+	      printf("\n");
+	    }
+	}
+      printf("\n");
+    }
+  return(0);
+}
+
+#ifndef WE_ESSENTIAL
+/************************** TRANSMIT POWER **************************/
+
+/*------------------------------------------------------------------*/
+/*
+ * Print the number of available transmit powers for the device
+ */
+static int
+print_txpower_info(int		skfd,
+		   char *	ifname,
+		   char *	args[],		/* Command line args */
+		   int		count)		/* Args count */
+{
+  struct iwreq		wrq;
+  struct iw_range	range;
+  int			dbm;
+  int			mwatt;
+  int			k;
+
+  /* Avoid "Unused parameter" warning */
+  args = args; count = count;
+
+  /* Extract range info */
+  if((iw_get_range_info(skfd, ifname, &range) < 0) ||
+     (range.we_version_compiled < 10))
+      fprintf(stderr, "%-8.16s  no transmit-power information.\n\n",
+		      ifname);
+  else
+    {
+      if((range.num_txpower <= 0) || (range.num_txpower > IW_MAX_TXPOWER))
+	printf("%-8.16s  unknown transmit-power information.\n\n", ifname);
+      else
+	{
+	  printf("%-8.16s  %d available transmit-powers :\n",
+		 ifname, range.num_txpower);
+	  /* Print them all */
+	  for(k = 0; k < range.num_txpower; k++)
+	    {
+	      /* Check for relative values */
+	      if(range.txpower_capa & IW_TXPOW_RELATIVE)
+		{
+		  printf("\t  %d (no units)\n", range.txpower[k]);
+		}
+	      else
+		{
+		  if(range.txpower_capa & IW_TXPOW_MWATT)
+		    {
+		      dbm = iw_mwatt2dbm(range.txpower[k]);
+		      mwatt = range.txpower[k];
+		    }
+		  else
+		    {
+		      dbm = range.txpower[k];
+		      mwatt = iw_dbm2mwatt(range.txpower[k]);
+		    }
+		  printf("\t  %d dBm  \t(%d mW)\n", dbm, mwatt);
+		}
+	    }
+	}
+
+      /* Get current Transmit Power */
+      if(iw_get_ext(skfd, ifname, SIOCGIWTXPOW, &wrq) >= 0)
+	{
+	  printf("          Current Tx-Power");
+	  /* Disabled ? */
+	  if(wrq.u.txpower.disabled)
+	    printf(":off\n\n");
+	  else
+	    {
+	      /* Fixed ? */
+	      if(wrq.u.txpower.fixed)
+		printf("=");
+	      else
+		printf(":");
+	      /* Check for relative values */
+	      if(wrq.u.txpower.flags & IW_TXPOW_RELATIVE)
+		{
+		  /* I just hate relative value, because they are
+		   * driver specific, so not very meaningfull to apps.
+		   * But, we have to support that, because
+		   * this is the way hardware is... */
+		  printf("\t  %d (no units)\n", wrq.u.txpower.value);
+		}
+	      else
+		{
+		  if(wrq.u.txpower.flags & IW_TXPOW_MWATT)
+		    {
+		      dbm = iw_mwatt2dbm(wrq.u.txpower.value);
+		      mwatt = wrq.u.txpower.value;
+		    }
+		  else
+		    {
+		      dbm = wrq.u.txpower.value;
+		      mwatt = iw_dbm2mwatt(wrq.u.txpower.value);
+		    }
+		  printf("%d dBm  \t(%d mW)\n\n", dbm, mwatt);
+		}
+	    }
+	}
+    }
+  return(0);
+}
+
+/*********************** RETRY LIMIT/LIFETIME ***********************/
+
+/*------------------------------------------------------------------*/
+/*
+ * Print one retry value
+ */
+static int
+get_retry_value(int		skfd,
+		char *		ifname,
+		struct iwreq *	pwrq,
+		int		flags,
+		char *		buffer,
+		int		buflen,
+		int		we_version_compiled)
+{
+  /* Get Another retry value */
+  pwrq->u.retry.flags = flags;
+  if(iw_get_ext(skfd, ifname, SIOCGIWRETRY, pwrq) >= 0)
+    {
+      /* Let's check the value and its type */
+      if(pwrq->u.retry.flags & IW_RETRY_TYPE)
+	{
+	  iw_print_retry_value(buffer, buflen,
+			       pwrq->u.retry.value, pwrq->u.retry.flags,
+			       we_version_compiled);
+	  printf("%s\n                 ", buffer);
+	}
+    }
+  return(pwrq->u.retry.flags);
+}
+
+/*------------------------------------------------------------------*/
+/*
+ * Print Power Management range for each type
+ */
+static void
+print_retry_value_range(char *		name,
+			int		mask,
+			int		iwr_flags,
+			int		iwr_min,
+			int		iwr_max,
+			char *		buffer,
+			int		buflen,
+			int		we_version_compiled)
+{
+  if(iwr_flags & mask)
+    {
+      int	flags = (iwr_flags & ~(IW_RETRY_MIN | IW_RETRY_MAX));
+      /* Display if auto or fixed */
+      printf("%s %s ; ",
+	     (iwr_flags & IW_POWER_MIN) ? "Auto " : "Fixed",
+	     name);
+      /* Print the range */
+      iw_print_retry_value(buffer, buflen,
+			   iwr_min, flags | IW_POWER_MIN,
+			   we_version_compiled);
+      printf("%s\n                           ", buffer);
+      iw_print_retry_value(buffer, buflen,
+			   iwr_max, flags | IW_POWER_MAX,
+			   we_version_compiled);
+      printf("%s\n          ", buffer);
+    }
+}
+
+/*------------------------------------------------------------------*/
+/*
+ * Print Retry info for each device
+ */
+static int
+print_retry_info(int		skfd,
+		 char *		ifname,
+		 char *		args[],		/* Command line args */
+		 int		count)		/* Args count */
+{
+  struct iwreq		wrq;
+  struct iw_range	range;
+  char			buffer[128];
+
+  /* Avoid "Unused parameter" warning */
+  args = args; count = count;
+
+  /* Extract range info */
+  if((iw_get_range_info(skfd, ifname, &range) < 0) ||
+     (range.we_version_compiled < 11))
+    fprintf(stderr, "%-8.16s  no retry limit/lifetime information.\n\n",
+	    ifname);
+  else
+    {
+      printf("%-8.16s  ", ifname);
+
+      /* Display min/max limit availables */
+      print_retry_value_range("limit   ", IW_RETRY_LIMIT, range.retry_flags,
+			      range.min_retry, range.max_retry,
+			      buffer, sizeof(buffer),
+			      range.we_version_compiled);
+      /* Display min/max lifetime availables */
+      print_retry_value_range("lifetime", IW_RETRY_LIFETIME, 
+			      range.r_time_flags,
+			      range.min_r_time, range.max_r_time,
+			      buffer, sizeof(buffer),
+			      range.we_version_compiled);
+
+      /* Get current retry settings */
+      wrq.u.retry.flags = 0;
+      if(iw_get_ext(skfd, ifname, SIOCGIWRETRY, &wrq) >= 0)
+	{
+	  int	flags = wrq.u.retry.flags;
+
+	  /* Is it disabled ? */
+	  if(wrq.u.retry.disabled)
+	    printf("Current mode:off\n          ");
+	  else
+	    {
+	      unsigned int	retry_type = 0;
+	      unsigned int	retry_mask = 0;
+	      unsigned int	remain_mask = range.retry_capa & IW_RETRY_TYPE;
+
+	      /* Let's check the mode */
+	      printf("Current mode:on\n                 ");
+
+	      /* Let's check the value and its type */
+	      if(wrq.u.retry.flags & IW_RETRY_TYPE)
+		{
+		  iw_print_retry_value(buffer, sizeof(buffer),
+				       wrq.u.retry.value, wrq.u.retry.flags,
+				       range.we_version_compiled);
+		  printf("%s\n                 ", buffer);
+		}
+
+	      while(1)
+		{
+		  /* Deal with min/max/short/long for the current value */
+		  retry_mask = 0;
+		  /* If we have been returned a MIN value, ask for the MAX */
+		  if(flags & IW_RETRY_MIN)
+		    retry_mask = IW_RETRY_MAX;
+		  /* If we have been returned a MAX value, ask for the MIN */
+		  if(flags & IW_RETRY_MAX)
+		    retry_mask = IW_RETRY_MIN;
+		  /* Same for SHORT and LONG */
+		  if(flags & IW_RETRY_SHORT)
+		    retry_mask = IW_RETRY_LONG;
+		  if(flags & IW_RETRY_LONG)
+		    retry_mask = IW_RETRY_SHORT;
+		  /* If we have something to ask for... */
+		  if(retry_mask)
+		    {
+		      retry_mask |= retry_type;
+		      get_retry_value(skfd, ifname, &wrq, retry_mask,
+				      buffer, sizeof(buffer),
+				      range.we_version_compiled);
+		    }
+
+		  /* And if we have both a limit and a lifetime,
+		   * ask the other one */
+		  remain_mask &= ~(wrq.u.retry.flags);
+		  retry_type = remain_mask;
+		  /* Nothing anymore : exit the loop */
+		  if(!retry_type)
+		    break;
+
+		  /* Ask for this other type of value */
+		  flags = get_retry_value(skfd, ifname, &wrq, retry_type,
+					  buffer, sizeof(buffer),
+					  range.we_version_compiled);
+		  /* Loop back for min/max/short/long */
+		}
+	    }
+	}
+      printf("\n");
+    }
+  return(0);
+}
+
+/************************ ACCESS POINT LIST ************************/
+/*
+ * Note : now that we have scanning support, this is depracted and
+ * won't survive long. Actually, next version it's out !
+ */
+
+/*------------------------------------------------------------------*/
+/*
+ * Display the list of ap addresses and the associated stats
+ * Exacly the same as the spy list, only with different IOCTL and messages
+ */
+static int
+print_ap_info(int	skfd,
+	      char *	ifname,
+	      char *	args[],		/* Command line args */
+	      int	count)		/* Args count */
+{
+  struct iwreq		wrq;
+  char		buffer[(sizeof(struct iw_quality) +
+			sizeof(struct sockaddr)) * IW_MAX_AP];
+  char		temp[128];
+  struct sockaddr *	hwa;
+  struct iw_quality *	qual;
+  iwrange	range;
+  int		has_range = 0;
+  int		has_qual = 0;
+  int		n;
+  int		i;
+
+  /* Avoid "Unused parameter" warning */
+  args = args; count = count;
+
+  /* Collect stats */
+  wrq.u.data.pointer = (caddr_t) buffer;
+  wrq.u.data.length = IW_MAX_AP;
+  wrq.u.data.flags = 0;
+  if(iw_get_ext(skfd, ifname, SIOCGIWAPLIST, &wrq) < 0)
+    {
+      fprintf(stderr, "%-8.16s  Interface doesn't have a list of Peers/Access-Points\n\n", ifname);
+      return(-1);
+    }
+
+  /* Number of addresses */
+  n = wrq.u.data.length;
+  has_qual = wrq.u.data.flags;
+
+  /* The two lists */
+  hwa = (struct sockaddr *) buffer;
+  qual = (struct iw_quality *) (buffer + (sizeof(struct sockaddr) * n));
+
+  /* Check if we have valid mac address type */
+  if(iw_check_mac_addr_type(skfd, ifname) < 0)
+    {
+      fprintf(stderr, "%-8.16s  Interface doesn't support MAC addresses\n\n", ifname);
+      return(-2);
+    }
+
+  /* Get range info if we can */
+  if(iw_get_range_info(skfd, ifname, &(range)) >= 0)
+    has_range = 1;
+
+  /* Display it */
+  if(n == 0)
+    printf("%-8.16s  No Peers/Access-Point in range\n", ifname);
+  else
+    printf("%-8.16s  Peers/Access-Points in range:\n", ifname);
+  for(i = 0; i < n; i++)
+    {
+      if(has_qual)
+	{
+	  /* Print stats for this address */
+	  printf("    %s : ", iw_saether_ntop(&hwa[i], temp));
+	  iw_print_stats(temp, sizeof(buffer), &qual[i], &range, has_range);
+	  printf("%s\n", temp);
+	}
+      else
+	/* Only print the address */
+	printf("    %s\n", iw_saether_ntop(&hwa[i], temp));
+    }
+  printf("\n");
+  return(0);
+}
+
+/******************** WIRELESS EVENT CAPABILITY ********************/
+
+static const char *	event_capa_req[] =
+{
+  [SIOCSIWNWID	- SIOCIWFIRST] = "Set NWID (kernel generated)",
+  [SIOCSIWFREQ	- SIOCIWFIRST] = "Set Frequency/Channel (kernel generated)",
+  [SIOCGIWFREQ	- SIOCIWFIRST] = "New Frequency/Channel",
+  [SIOCSIWMODE	- SIOCIWFIRST] = "Set Mode (kernel generated)",
+  [SIOCGIWTHRSPY - SIOCIWFIRST] = "Spy threshold crossed",
+  [SIOCGIWAP	- SIOCIWFIRST] = "New Access Point/Cell address - roaming",
+  [SIOCGIWSCAN	- SIOCIWFIRST] = "Scan request completed",
+  [SIOCSIWESSID	- SIOCIWFIRST] = "Set ESSID (kernel generated)",
+  [SIOCGIWESSID	- SIOCIWFIRST] = "New ESSID",
+  [SIOCGIWRATE	- SIOCIWFIRST] = "New bit-rate",
+  [SIOCSIWENCODE - SIOCIWFIRST] = "Set Encoding (kernel generated)",
+  [SIOCGIWPOWER	- SIOCIWFIRST] = NULL,
+};
+
+static const char *	event_capa_evt[] =
+{
+  [IWEVTXDROP	- IWEVFIRST] = "Tx packet dropped - retry exceeded",
+  [IWEVCUSTOM	- IWEVFIRST] = "Custom driver event",
+  [IWEVREGISTERED - IWEVFIRST] = "Registered node",
+  [IWEVEXPIRED	- IWEVFIRST] = "Expired node",
+};
+
+/*------------------------------------------------------------------*/
+/*
+ * Print the event capability for the device
+ */
+static int
+print_event_capa_info(int		skfd,
+		      char *		ifname,
+		      char *		args[],		/* Command line args */
+		      int		count)		/* Args count */
+{
+  struct iw_range	range;
+  int			cmd;
+
+  /* Avoid "Unused parameter" warning */
+  args = args; count = count;
+
+  /* Extract range info */
+  if((iw_get_range_info(skfd, ifname, &range) < 0) ||
+     (range.we_version_compiled < 10))
+      fprintf(stderr, "%-8.16s  no wireless event capability information.\n\n",
+		      ifname);
+  else
+    {
+#ifdef DEBUG
+      /* Debugging ;-) */
+      for(cmd = 0x8B00; cmd < 0x8C0F; cmd++)
+	{
+	  int idx = IW_EVENT_CAPA_INDEX(cmd);
+	  int mask = IW_EVENT_CAPA_MASK(cmd);
+	  printf("0x%X - %d - %X\n", cmd, idx, mask);
+	}
+#endif
+
+      printf("%-8.16s  Wireless Events supported :\n", ifname);
+
+      for(cmd = SIOCIWFIRST; cmd <= SIOCGIWPOWER; cmd++)
+	{
+	  int idx = IW_EVENT_CAPA_INDEX(cmd);
+	  int mask = IW_EVENT_CAPA_MASK(cmd);
+	  if(range.event_capa[idx] & mask)
+	    printf("          0x%04X : %s\n",
+		   cmd, event_capa_req[cmd - SIOCIWFIRST]);
+	}
+      for(cmd = IWEVFIRST; cmd <= IWEVEXPIRED; cmd++)
+	{
+	  int idx = IW_EVENT_CAPA_INDEX(cmd);
+	  int mask = IW_EVENT_CAPA_MASK(cmd);
+	  if(range.event_capa[idx] & mask)
+	    printf("          0x%04X : %s\n",
+		   cmd, event_capa_evt[cmd - IWEVFIRST]);
+	}
+      printf("\n");
+    }
+  return(0);
+}
+
+/*************************** WPA SUPPORT ***************************/
+
+/*------------------------------------------------------------------*/
+/*
+ * Print the authentication parameters for the device
+ */
+static int
+print_auth_info(int		skfd,
+		char *		ifname,
+		char *		args[],		/* Command line args */
+		int		count)		/* Args count */
+{
+  struct iwreq		wrq;
+  struct iw_range	range;
+  unsigned int		k;
+
+  /* Avoid "Unused parameter" warning */
+  args = args; count = count;
+
+  /* Extract range info */
+  if((iw_get_range_info(skfd, ifname, &range) < 0) ||
+     (range.we_version_compiled < 18))
+      fprintf(stderr, "%-8.16s  no authentication information.\n\n",
+		      ifname);
+  else
+    {
+      /* Print WPA/802.1x/802.11i security parameters */
+      if(!range.enc_capa)
+	{
+	printf("%-8.16s  unknown authentication information.\n\n", ifname);
+	}
+      else
+	{
+	  /* Display advanced encryption capabilities */
+	  printf("%-8.16s  Authentication capabilities :", ifname);
+	  iw_print_mask_name(range.enc_capa,
+			     iw_auth_capa_name, IW_AUTH_CAPA_NUM,
+				 "\n\t\t");
+	  printf("\n");
+
+	  /* Extract all auth settings */
+	  for(k = 0; k < IW_AUTH_SETTINGS_NUM; k++)
+	    { 
+	      wrq.u.param.flags = iw_auth_settings[k].value;
+	      if(iw_get_ext(skfd, ifname, SIOCGIWAUTH, &wrq) >= 0)
+		{
+		  printf("          Current %s :", iw_auth_settings[k].label);
+		  if(iw_auth_settings[k].names != NULL)
+		    iw_print_mask_name(wrq.u.param.value,
+				       iw_auth_settings[k].names,
+				       iw_auth_settings[k].num_names,
+				       "\n\t\t");
+		  else
+		    printf((wrq.u.param.value) ? " yes" : " no");
+		  printf("\n");
+		}
+	    }
+	}
+
+      printf("\n\n");
+    }
+  return(0);
+}
+
+/*------------------------------------------------------------------*/
+/*
+ * Print all the available wpa keys for the device
+ */
+static int
+print_wpakeys_info(int		skfd,
+		   char *	ifname,
+		   char *	args[],		/* Command line args */
+		   int		count)		/* Args count */
+{
+  struct iwreq		wrq;
+  struct iw_range	range;
+  unsigned char         extbuf[IW_EXTKEY_SIZE];
+  struct iw_encode_ext  *extinfo;
+  unsigned int		k;
+  char			buffer[128];
+
+  /* Avoid "Unused parameter" warning */
+  args = args; count = count;
+
+  /* This always point to the same place */
+  extinfo = (struct iw_encode_ext *) extbuf;
+
+  /* Extract range info */
+  if(iw_get_range_info(skfd, ifname, &range) < 0)
+      fprintf(stderr, "%-8.16s  no wpa key information.\n\n",
+		      ifname);
+  else
+    {
+      printf("%-8.16s  ", ifname);
+      /* Print key sizes */
+      if((range.num_encoding_sizes > 0) &&
+	 (range.num_encoding_sizes < IW_MAX_ENCODING_SIZES))
+	{
+	  printf("%d key sizes : %d", range.num_encoding_sizes,
+		 range.encoding_size[0] * 8);
+	  /* Print them all */
+	  for(k = 1; k < range.num_encoding_sizes; k++)
+	    printf(", %d", range.encoding_size[k] * 8);
+	  printf("bits\n          ");
+	}
+
+      /* Print the keys */
+      printf("%d keys available :\n", range.max_encoding_tokens);
+      for(k = 1; k <= range.max_encoding_tokens; k++)
+	{
+	  /* Cleanup. Driver may not fill everything */
+	  memset(extbuf, '\0', IW_EXTKEY_SIZE);
+
+	  /* Get whole struct containing one WPA key */
+	  wrq.u.data.pointer = (caddr_t) extbuf;
+	  wrq.u.data.length = IW_EXTKEY_SIZE;
+	  wrq.u.data.flags = k;
+	  if(iw_get_ext(skfd, ifname, SIOCGIWENCODEEXT, &wrq) < 0)
+	    {
+	      fprintf(stderr, "Error reading wpa keys (SIOCGIWENCODEEXT): %s\n", strerror(errno));
+	      break;
+	    }
+
+	  /* Sanity check */
+	  if(wrq.u.data.length < 
+	     (sizeof(struct iw_encode_ext) + extinfo->key_len))
+	    break;
+
+	  /* Check if key is disabled */
+	  if((wrq.u.data.flags & IW_ENCODE_DISABLED) ||
+	     (extinfo->key_len == 0))
+	    printf("\t\t[%d]: off\n", k);
+	  else
+	    {
+	      /* Display the key */
+	      iw_print_key(buffer, sizeof(buffer),
+			   extinfo->key, extinfo->key_len, wrq.u.data.flags);
+	      printf("\t\t[%d]: %s", k, buffer);
+
+	      /* Key size */
+	      printf(" (%d bits)", extinfo->key_len * 8);
+	      printf("\n");
+
+	      /* Other info... */
+	      printf("\t\t     Address: %s\n",
+		     iw_saether_ntop(&extinfo->addr, buffer));
+
+	      printf("\t\t     Algorithm:");
+	      iw_print_value_name(extinfo->alg,
+				  iw_encode_alg_name, IW_ENCODE_ALG_NUM);
+
+	      printf("\n\t\t     Flags: 0x%08x\n", extinfo->ext_flags);
+	      if (extinfo->ext_flags & IW_ENCODE_EXT_TX_SEQ_VALID)
+		printf("\t\t        tx-seq-valid\n");
+	      if (extinfo->ext_flags & IW_ENCODE_EXT_RX_SEQ_VALID)
+		printf("\t\t        rx-seq-valid\n");
+	      if (extinfo->ext_flags & IW_ENCODE_EXT_GROUP_KEY)
+		printf("\t\t        group-key\n");
+	    }
+	}
+      /* Print current key index and mode */
+      wrq.u.data.pointer = (caddr_t) extbuf;
+      wrq.u.data.length = IW_EXTKEY_SIZE;
+      wrq.u.data.flags = 0;	/* Set index to zero to get current */
+      if(iw_get_ext(skfd, ifname, SIOCGIWENCODEEXT, &wrq) >= 0)
+	{
+	  /* Note : if above fails, we have already printed an error
+	   * message int the loop above */
+	  printf("          Current Transmit Key: [%d]\n",
+		 wrq.u.data.flags & IW_ENCODE_INDEX);
+	  if(wrq.u.data.flags & IW_ENCODE_RESTRICTED)
+	    printf("          Security mode:restricted\n");
+	  if(wrq.u.data.flags & IW_ENCODE_OPEN)
+	    printf("          Security mode:open\n");
+	}
+
+      printf("\n\n");
+    }
+  return(0);
+}
+
+/*------------------------------------------------------------------*/
+/*
+ * Print the Generic IE for the device
+ * Note : indentation is broken. We need to fix that.
+ */
+static int
+print_gen_ie_info(int		skfd,
+		  char *	ifname,
+		  char *	args[],		/* Command line args */
+		  int		count)		/* Args count */
+{
+  struct iwreq		wrq;
+  unsigned char         buf[IW_GENERIC_IE_MAX];
+
+  /* Avoid "Unused parameter" warning */
+  args = args; count = count;
+
+  wrq.u.data.pointer = (caddr_t)buf;
+  wrq.u.data.length = IW_GENERIC_IE_MAX;
+  wrq.u.data.flags = 0;
+
+  if(iw_get_ext(skfd, ifname, SIOCGIWGENIE, &wrq) < 0)
+    fprintf(stderr, "%-8.16s  no generic IE (%s).\n\n",
+	    ifname, strerror(errno));
+  else
+    {
+      fprintf(stderr, "%-8.16s\n", ifname);
+      if(wrq.u.data.length == 0)
+	printf("          empty generic IE\n");
+      else
+	iw_print_gen_ie(buf, wrq.u.data.length);
+      printf("\n");
+    }
+  return(0);
+}
+
+/**************************** MODULATION ****************************/
+
+/*------------------------------------------------------------------*/
+/*
+ * Print Modulation info for each device
+ */
+static int
+print_modul_info(int		skfd,
+		 char *		ifname,
+		 char *		args[],		/* Command line args */
+		 int		count)		/* Args count */
+{
+  struct iwreq		wrq;
+  struct iw_range	range;
+
+  /* Avoid "Unused parameter" warning */
+  args = args; count = count;
+
+  /* Extract range info */
+  if((iw_get_range_info(skfd, ifname, &range) < 0) ||
+     (range.we_version_compiled < 11))
+    fprintf(stderr, "%-8.16s  no modulation information.\n\n",
+	    ifname);
+  else
+    {
+      if(range.modul_capa == 0x0)
+	printf("%-8.16s  unknown modulation information.\n\n", ifname);
+      else
+	{
+	  int i;
+	  printf("%-8.16s  Modulations available :\n", ifname);
+
+	  /* Display each modulation available */
+	  for(i = 0; i < IW_SIZE_MODUL_LIST; i++)
+	    {
+	      if((range.modul_capa & iw_modul_list[i].mask)
+		 == iw_modul_list[i].mask)
+		printf("              %-8s: %s\n",
+		       iw_modul_list[i].cmd, iw_modul_list[i].verbose);
+	    }
+
+	  /* Get current modulations settings */
+	  wrq.u.param.flags = 0;
+	  if(iw_get_ext(skfd, ifname, SIOCGIWMODUL, &wrq) >= 0)
+	    {
+	      unsigned int	modul = wrq.u.param.value;
+	      int		n = 0;
+
+	      printf("          Current modulations %c",
+		     wrq.u.param.fixed ? '=' : ':');
+
+	      /* Display each modulation enabled */
+	      for(i = 0; i < IW_SIZE_MODUL_LIST; i++)
+		{
+		  if((modul & iw_modul_list[i].mask) == iw_modul_list[i].mask)
+		    {
+		      if((n++ % 8) == 0)
+			printf("\n              ");
+		      else
+			printf(" ; ");
+		      printf("%s", iw_modul_list[i].cmd);
+		    }
+		}
+
+	      printf("\n");
+	    }
+	  printf("\n");
+	}
+    }
+  return(0);
+}
+#endif	/* WE_ESSENTIAL */
+
+/************************* COMMON UTILITIES *************************/
+/*
+ * This section was initially written by Michael Tokarev <mjt@tls.msk.ru>
+ * but heavily modified by me ;-)
+ */
+
+/*------------------------------------------------------------------*/
+/*
+ * Map command line arguments to the proper procedure...
+ */
+typedef struct iwlist_entry {
+  const char *		cmd;		/* Command line shorthand */
+  iw_enum_handler	fn;		/* Subroutine */
+  int			max_count;
+  const char *		argsname;	/* Args as human readable string */
+} iwlist_cmd;
+
+static const struct iwlist_entry iwlist_cmds[] = {
+  { "scanning",		print_scanning_info,	-1, "[essid NNN] [last]" },
+  { "frequency",	print_freq_info,	0, NULL },
+  { "channel",		print_freq_info,	0, NULL },
+  { "bitrate",		print_bitrate_info,	0, NULL },
+  { "rate",		print_bitrate_info,	0, NULL },
+  { "encryption",	print_keys_info,	0, NULL },
+  { "keys",		print_keys_info,	0, NULL },
+  { "power",		print_pm_info,		0, NULL },
+#ifndef WE_ESSENTIAL
+  { "txpower",		print_txpower_info,	0, NULL },
+  { "retry",		print_retry_info,	0, NULL },
+  { "ap",		print_ap_info,		0, NULL },
+  { "accesspoints",	print_ap_info,		0, NULL },
+  { "peers",		print_ap_info,		0, NULL },
+  { "event",		print_event_capa_info,	0, NULL },
+  { "auth",		print_auth_info,	0, NULL },
+  { "wpakeys",		print_wpakeys_info,	0, NULL },
+  { "genie",		print_gen_ie_info,	0, NULL },
+  { "modulation",	print_modul_info,	0, NULL },
+#endif	/* WE_ESSENTIAL */
+  { NULL, NULL, 0, 0 },
+};
+
+/*------------------------------------------------------------------*/
+/*
+ * Find the most appropriate command matching the command line
+ */
+static inline const iwlist_cmd *
+find_command(const char *	cmd)
+{
+  const iwlist_cmd *	found = NULL;
+  int			ambig = 0;
+  unsigned int		len = strlen(cmd);
+  int			i;
+
+  /* Go through all commands */
+  for(i = 0; iwlist_cmds[i].cmd != NULL; ++i)
+    {
+      /* No match -> next one */
+      if(strncasecmp(iwlist_cmds[i].cmd, cmd, len) != 0)
+	continue;
+
+      /* Exact match -> perfect */
+      if(len == strlen(iwlist_cmds[i].cmd))
+	return &iwlist_cmds[i];
+
+      /* Partial match */
+      if(found == NULL)
+	/* First time */
+	found = &iwlist_cmds[i];
+      else
+	/* Another time */
+	if (iwlist_cmds[i].fn != found->fn)
+	  ambig = 1;
+    }
+
+  if(found == NULL)
+    {
+      fprintf(stderr, "iwlist: unknown command `%s' (check 'iwlist --help').\n", cmd);
+      return NULL;
+    }
+
+  if(ambig)
+    {
+      fprintf(stderr, "iwlist: command `%s' is ambiguous (check 'iwlist --help').\n", cmd);
+      return NULL;
+    }
+
+  return found;
+}
+
+/*------------------------------------------------------------------*/
+/*
+ * Display help
+ */
+static void iw_usage(int status)
+{
+  FILE *		f = status ? stderr : stdout;
+  int			i;
+
+  for(i = 0; iwlist_cmds[i].cmd != NULL; ++i)
+    {
+      fprintf(f, "%s [interface] %s %s\n",
+	      (i ? "             " : "Usage: iwlist"),
+	      iwlist_cmds[i].cmd,
+	      iwlist_cmds[i].argsname ? iwlist_cmds[i].argsname : "");
+    }
+
+  exit(status);
+}
+
+/******************************* MAIN ********************************/
+
+/*------------------------------------------------------------------*/
+/*
+ * The main !
+ */
+int
+main(int	argc,
+     char **	argv)
+{
+  int skfd;			/* generic raw socket desc.	*/
+  char *dev;			/* device name			*/
+  char *cmd;			/* command			*/
+  char **args;			/* Command arguments */
+  int count;			/* Number of arguments */
+  const iwlist_cmd *iwcmd;
+
+  if(argc < 2)
+    iw_usage(1);
+
+  /* Those don't apply to all interfaces */
+  if((argc == 2) && (!strcmp(argv[1], "-h") || !strcmp(argv[1], "--help")))
+    iw_usage(0);
+  if((argc == 2) && (!strcmp(argv[1], "-v") || !strcmp(argv[1], "--version")))
+    return(iw_print_version_info("iwlist"));
+
+  if(argc == 2)
+    {
+      cmd = argv[1];
+      dev = NULL;
+      args = NULL;
+      count = 0;
+    }
+  else
+    {
+      cmd = argv[2];
+      dev = argv[1];
+      args = argv + 3;
+      count = argc - 3;
+    }
+
+  /* find a command */
+  iwcmd = find_command(cmd);
+  if(iwcmd == NULL)
+    return 1;
+
+  /* Check arg numbers */
+  if((iwcmd->max_count >= 0) && (count > iwcmd->max_count))
+    {
+      fprintf(stderr, "iwlist: command `%s' needs fewer arguments (max %d)\n",
+	      iwcmd->cmd, iwcmd->max_count);
+      return 1;
+    }
+
+  /* Create a channel to the NET kernel. */
+  if((skfd = iw_sockets_open()) < 0)
+    {
+      perror("socket");
+      return -1;
+    }
+
+  /* do the actual work */
+  if (dev)
+    (*iwcmd->fn)(skfd, dev, args, count);
+  else
+    iw_enum_devices(skfd, iwcmd->fn, args, count);
+
+  /* Close the socket. */
+  iw_sockets_close(skfd);
+
+  return 0;
+}
diff --git a/iwmulticall.c b/iwmulticall.c
new file mode 100644
index 0000000..72f1a22
--- /dev/null
+++ b/iwmulticall.c
@@ -0,0 +1,143 @@
+/*
+ *	Wireless Tools
+ *
+ *		Jean II - HPL 04
+ *
+ * Main code for "iwmulticall". This is a wrapper for the multicall version
+ * of the wireless tools.
+ * You need to link this code against "-lm".
+ * Thanks to Ned Ludd <solar@gentoo.org> for the inspiration...
+ *
+ * This file is released under the GPL license.
+ *     Copyright (c) 1997-2004 Jean Tourrilhes <jt@hpl.hp.com>
+ */
+
+/***************************** INCLUDES *****************************/
+
+#include <libgen.h>	/* Basename */
+
+/**************************** PROTOTYPES ****************************/
+
+/* Prototypes of the main of each tool */
+extern int
+	main_iwconfig(int	argc,
+		      char **	argv);
+extern int
+	main_iwlist(int	argc,
+		    char **	argv);
+extern int
+	main_iwspy(int	argc,
+		   char **	argv);
+extern int
+	main_iwpriv(int	argc,
+		    char **	argv);
+extern int
+	main_iwgetid(int	argc,
+		     char **	argv);
+
+/************************** MULTICALL HACK **************************/
+/*
+ * The idea for multicall is to put all the tools and the library in
+ * the same binary. This way, you can save the overhead of the library,
+ * of each tool, can better optimise the code and throw away the stuff
+ * you don't need from the library.
+ * This almost divide the size of the tools by two (without stripping).
+ * On the down side, you no longer have the libiw for other tools to
+ * use, but for the target systems (embedded), this doesn't matter
+ * much, as they just need to configure the card...
+ * Note that splitting the lib and the multicall tools would not
+ * make sense, as most gains are found in the inclusion of the lib...
+ *
+ * Our strategy is to include directly the *.c, rather than compile
+ * them separatly. This allow to simplify compilation and hide the
+ * multicall tweaks from the other tools.
+ * Yeah, this leads to a bit a preprocessor abuse...
+ * Jean II
+ */
+
+/* We need the library */
+#include "iwlib.c"
+
+/* Get iwconfig in there. Mandatory. */
+#define main(args...) main_iwconfig(args)
+#define iw_usage(args...) iwconfig_usage(args)
+#define find_command(args...) iwconfig_find_command(args)
+#include "iwconfig.c"
+#undef find_command
+#undef iw_usage
+#undef main
+
+/* Get iwlist in there. Scanning support is pretty sweet. */
+#define main(args...) main_iwlist(args)
+#define iw_usage(args...) iwlist_usage(args)
+#define find_command(args...) iwlist_find_command(args)
+#include "iwlist.c"
+#undef find_command
+#undef iw_usage
+#undef main
+
+#ifndef WE_ESSENTIAL
+/* Get iwspy in there, it's not that big. */
+#define main(args...) main_iwspy(args)
+#include "iwspy.c"
+#undef main
+#endif	/* WE_ESSENTIAL */
+
+/* Get iwpriv in there. Mandatory for HostAP and some other drivers. */
+#define main(args...) main_iwpriv(args)
+#define iw_usage(args...) iwpriv_usage(args)
+#include "iwpriv.c"
+#undef iw_usage
+#undef main
+
+/* Do we really need iwgetid ? Well, it's not like it's a big one */
+#define main(args...) main_iwgetid(args)
+#define iw_usage(args...) iwgetid_usage(args)
+#include "iwgetid.c"
+#undef iw_usage
+#undef main
+
+/* iwevent is useless for most people, don't grab it ? */
+
+/* ifrename is big and useless for those systems */
+
+
+/******************************* MAIN ********************************/
+
+/*------------------------------------------------------------------*/
+/*
+ * The main !
+ */
+int
+main(int	argc,
+     char **	argv)
+{
+  char *	call_name = basename(argv[0]);	/* Strip path */
+
+  /* This is a testing hack */
+  if(!strcmp(call_name, "iwmulticall") && (argc > 0))
+    {
+      argv++;
+      argc--;
+      call_name = basename(argv[0]);
+    }
+
+  /* Just check the name under which we were called... */
+
+  if(!strcmp(call_name, "iwconfig"))
+    return(main_iwconfig(argc, argv));
+  if(!strcmp(call_name, "iwlist"))
+    return(main_iwlist(argc, argv));
+#ifndef WE_ESSENTIAL
+  if(!strcmp(call_name, "iwspy"))
+    return(main_iwspy(argc, argv));
+#endif	/* WE_ESSENTIAL */
+  if(!strcmp(call_name, "iwpriv"))
+    return(main_iwpriv(argc, argv));
+  if(!strcmp(call_name, "iwgetid"))
+    return(main_iwgetid(argc, argv));
+
+  /* Uh oh... Not supposed to come here. */
+  printf("iwmulticall : you are not supposed to call me this way...\n");
+  return(0);
+}
diff --git a/iwpriv.8 b/iwpriv.8
new file mode 100644
index 0000000..11244a7
--- /dev/null
+++ b/iwpriv.8
@@ -0,0 +1,118 @@
+.\" Jean II - HPLB - 96
+.\" iwpriv.8
+.\"
+.TH IWPRIV 8 "31 October 1996" "net-tools" "Linux Programmer's Manual"
+.\"
+.\" NAME part
+.\"
+.SH NAME
+iwpriv \- configure optionals (private) parameters of a wireless
+network interface
+.\"
+.\" SYNOPSIS part
+.\"
+.SH SYNOPSIS
+.BI "iwpriv [" interface ]
+.br
+.BI "iwpriv " "interface private-command " "[" private-parameters ]
+.br
+.BI "iwpriv " "interface private-command " [ I "] [" private-parameters ]
+.br
+.BI "iwpriv " interface " --all"
+.\"
+.\" DESCRIPTION part
+.\"
+.SH DESCRIPTION
+.B Iwpriv
+is the companion tool to
+.IR iwconfig (8).
+.B Iwpriv
+deals with parameters and setting specific to each driver (as opposed to
+.I iwconfig
+which deals with generic ones).
+.PP
+Without any argument,
+.B iwpriv
+list the available private commands available on each interface, and
+the parameters that they require. Using this information, the user may
+apply those interface specific commands on the specified interface.
+.PP
+In theory, the documentation of each device driver should indicate how
+to use those interface specific commands and their effect.
+.\"
+.\" PARAMETER part
+.\"
+.SH PARAMETERS
+.TP
+.IR private-command " [" private-parameters ]
+Execute the specified
+.I private-command
+on the interface.
+.br
+The command may optionally take or require arguments, and may display
+information. Therefore, the command line parameters may or may not be
+needed and should match the command expectations. The list of commands
+that
+.B iwpriv
+displays (when called without argument) should give you some hints
+about those parameters.
+.br
+However you should refer to the device driver documentation for
+information on how to properly use the command and the effect.
+.TP
+.IR "private-command " [ I "] [" private-parameters ]
+Idem, except that
+.I I
+(an integer) is passed to the command as a
+.IR "Token Index" .
+Only some command will use the Token Index (most will ignore it), and
+the driver documentation should tell you when it's needed.
+.TP
+.BR -a / --all
+Execute and display all the private commands that don't take any
+arguments (i.e.  read only).
+.\"
+.\" DISPLAY part
+.\"
+.SH DISPLAY
+For each device which support private commands,
+.I iwpriv
+will display the list of private commands available.
+.PP
+This include the name of the private command, the number or arguments
+that may be set and their type, and the number or arguments that may
+be display and their type.
+.PP
+For example, you may have the following display :
+.br
+.B "eth0      Available private ioctl :"
+.br
+.B "          setqualthr (89F0) : set   1 byte & get   0"
+.br
+.B "          gethisto (89F7) : set   0      & get  16 int"
+.PP
+This indicate that you may set the quality threshold and display an
+histogram of up to 16 values with the following commands :
+.br
+.I "  iwpriv eth0 setqualthr 20"
+.br
+.I "  iwpriv eth0 gethisto"
+.\"
+.\" AUTHOR part
+.\"
+.SH AUTHOR
+Jean Tourrilhes \- jt@hpl.hp.com
+.\"
+.\" FILES part
+.\"
+.SH FILES
+.I /proc/net/wireless
+.\"
+.\" SEE ALSO part
+.\"
+.SH SEE ALSO
+.BR iwconfig (8),
+.BR iwlist (8),
+.BR iwevent (8),
+.BR iwspy (8),
+.BR wireless (7).
diff --git a/iwpriv.c b/iwpriv.c
new file mode 100644
index 0000000..4172fe2
--- /dev/null
+++ b/iwpriv.c
@@ -0,0 +1,977 @@
+/*
+ *	Wireless Tools
+ *
+ *		Jean II - HPLB 97->99 - HPL 99->07
+ *
+ * Main code for "iwconfig". This is the generic tool for most
+ * manipulations...
+ * You need to link this code against "iwlib.c" and "-lm".
+ *
+ * This file is released under the GPL license.
+ *     Copyright (c) 1997-2007 Jean Tourrilhes <jt@hpl.hp.com>
+ */
+
+#include "iwlib.h"		/* Header */
+
+/************************** DOCUMENTATION **************************/
+
+/*
+ * BASIC PRINCIPLE
+ * ---------------
+ *	Wireless Extension recognise that each wireless device has some
+ * specific features not covered by the standard wireless extensions.
+ * Private wireless ioctls/requests allow a device to export the control
+ * of those device specific features, and allow users to directly interact
+ * with your driver.
+ *	There are many other ways you can implement such functionality :
+ *		o module parameters
+ *		o netlink socket
+ *		o file system (/proc/ or /sysfs/)
+ *		o extra character device (/dev/)
+ *	Private wireless ioctls is one of the simplest implementation,
+ * however it is limited, so you may want to check the alternatives.
+ *
+ *	Like for standard Wireless Extensions, each private wireless
+ * request is identified by an IOCTL NUMBER and carry a certain number
+ * of arguments (SET or GET).
+ *	The driver exports a description of those requests (ioctl number,
+ * request name, set and get arguments). Then, iwpriv uses those request
+ * descriptions to call the appropriate request and handle the
+ * arguments.
+ *
+ * IOCTL RANGES :
+ * ------------
+ *	The initial implementation of iwpriv was using the SIOCDEVPRIVATE
+ * ioctl range (up to 16 ioctls - driver specific). However, this was
+ * causing some compatibility problems with other usages of those
+ * ioctls, and those ioctls are supposed to be removed.
+ *	Therefore, I created a new ioctl range, at SIOCIWFIRSTPRIV. Those
+ * ioctls are specific to Wireless Extensions, so you don't have to
+ * worry about collisions with other usages. On the other hand, in the
+ * new range, the SET convention is enforced (see below).
+ *	The differences are :		SIOCDEVPRIVATE	SIOCIWFIRSTPRIV
+ *		o availability		<= 2.5.X	WE > 11 (>= 2.4.13)
+ *		o collisions		yes		no
+ *		o SET convention	optional	enforced
+ *		o number		16		32
+ *
+ * NEW DRIVER API :
+ * --------------
+ *	Wireless Extension 13 introduces a new driver API. Wireless
+ * Extensions requests can be handled via a iw_handler table instead
+ * of through the regular ioctl handler.
+ *	The new driver API can be handled only with the new ioctl range
+ * and enforces the GET convention (see below).
+ *	The differences are :		old API		new API
+ *		o handler		do_ioctl()	struct iw_handler_def
+ *		o SIOCIWFIRSTPRIV	WE > 11		yes
+ *		o SIOCDEVPRIVATE	yes		no
+ *		o GET convention	optional	enforced
+ *	Note that the new API before Wireless Extension 15 contains bugs
+ * when handling sub-ioctls and addr/float data types.
+ *
+ * INLINING vs. POINTER :
+ * --------------------
+ *	One of the tricky aspect of the old driver API is how the data
+ * is handled, which is how the driver is supposed to extract the data
+ * passed to it by iwpriv.
+ *	1) If the data has a fixed size (private ioctl definition
+ * has the flag IW_PRIV_SIZE_FIXED) and the byte size of the data is
+ * lower than 16 bytes, the data will be inlined. The driver can extract
+ * data in the field 'u.name' of the struct iwreq.
+ *	2) If the if the data doesn't have a fixed size or is larger than
+ * 16 bytes, the data is passed by pointer. struct iwreq contains a
+ * struct iwpoint with a user space pointer to the data. Appropriate
+ * copy_from/to_user() function should be used.
+ *	
+ *	With the new API, this is handled transparently, the data is
+ * always available as the fourth argument of the request handler
+ * (usually called 'extra').
+ *
+ * SET/GET CONVENTION :
+ * ------------------
+ *	Simplistic summary :
+ *	o even numbered ioctls are SET, restricted to root, and should not
+ * return arguments (get_args = 0).
+ *	o odd numbered ioctls are GET, authorised to anybody, and should
+ * not expect any arguments (set_args = 0).
+ *
+ *	The regular Wireless Extensions use the SET/GET convention, where
+ * the low order bit identify a SET (0) or a GET (1) request. The private
+ * Wireless Extension is not as restrictive, but still has some
+ * limitations.
+ *	The new ioctl range enforces the SET convention : SET request will
+ * be available to root only and can't return any arguments. If you don't
+ * like that, just use every other two ioctl.
+ *	The new driver API enforce the GET convention : GET request won't
+ * be able to accept any arguments (except if its fits within (union
+ * iwreq_data)). If you don't like that, you can either use the Token Index
+ * support or the old API (aka the ioctl handler).
+ *	In any case, it's a good idea to not have ioctl with both SET
+ * and GET arguments. If the GET arguments doesn't fit within
+ * (union iwreq_data) and SET do, or vice versa, the current code in iwpriv
+ * won't work. One exception is if both SET and GET arguments fit within
+ * (union iwreq_data), this case should be handled safely in a GET
+ * request.
+ *	If you don't fully understand those limitations, just follow the
+ * rules of the simplistic summary ;-)
+ *
+ * SUB-IOCTLS :
+ * ----------
+ *	Wireless Extension 15 introduces sub-ioctls. For some applications,
+ * 32 ioctls is not enough, and this simple mechanism allows to increase
+ * the number of ioctls by adding a sub-ioctl index to some of the ioctls
+ * (so basically it's a two level addressing).
+ *	One might argue that at the point, some other mechanisms might be
+ * better, like using a real filesystem abstraction (/proc, driverfs, ...),
+ * but sub-ioctls are simple enough and don't have much drawbacks (which
+ * means that it's a quick and dirty hack ;-).
+ *
+ *	There are two slightly different variations of the sub-ioctl scheme :
+ *	1) If the payload fits within (union iwreq_data), the first int
+ * (4 bytes) is reserved as the sub-ioctl number and the regular payload
+ * shifted by 4 bytes. The handler must extract the sub-ioctl number,
+ * increment the data pointer and then use it in the usual way.
+ *	2) If the ioctl uses (struct iw_point), the sub-ioctl number is
+ * set in the flags member of the structure. In this case, the handler
+ * should simply get the sub-ioctl number from the flags and process the
+ * data in the usual way.
+ *
+ *	Sub-ioctls are declared normally in the private definition table,
+ * with cmd (first arg) being the sub-ioctl number. Then, you should
+ * declare the real ioctl, which will process the sub-ioctls, with
+ * the SAME ARGUMENTS and a EMPTY NAME.
+ *	Here's an example of how it could look like :
+ * --------------------------------------------
+	// --- sub-ioctls handlers ---
+	{ 0x8BE0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "" },
+	{ 0x8BE1, 0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, "" },
+	// --- sub-ioctls definitions ---
+	{ 1, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "set_param1" },
+	{ 1, 0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, "get_param1" },
+	{ 2, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "set_param2" },
+	{ 2, 0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, "get_param2" },
+	// --- Raw access to sub-ioctl handlers ---
+	{ 0x8BE0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 2, 0, "set_paramN" },
+	{ 0x8BE1, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
+	  IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, "get_paramN" },
+ * --------------------------------------------
+ *	And iwpriv should do the rest for you ;-)
+ *
+ *	Note that versions of iwpriv up to v24 (included) expect at most
+ * 16 ioctls definitions and will likely crash when given more.
+ *	There is no fix that I can see, apart from recommending your users
+ * to upgrade their Wireless Tools. Wireless Extensions 15 will check this
+ * condition, so another workaround is restricting those extra definitions
+ * to WE-15.
+ *
+ *	Another problem is that the new API before Wireless Extension 15
+ * has a bug when passing fixed arguments of 12-15 bytes. It will
+ * try to get them inline instead of by pointer. You can fool the new API
+ * to do the right thing using fake ioctl definitions (but remember that
+ * you will be more likely to hit the limit of 16 ioctl definitions).
+ *	To play safe, use the old-style ioctl handler before v15.
+ *
+ * NEW DATA TYPES (ADDR/FLOAT) :
+ * ---------------------------
+ *	Wireless Tools 25 introduce two new data types, addr and float,
+ * corresponding to struct sockaddr and struct iwfreq.
+ *	Those types are properly handled with Wireless Extensions 15.
+ * However, the new API before v15 won't handle them properly.
+ *
+ *	The first problem is that the new API won't know their size, so
+ * it won't copy them. This can be workaround with a fake ioctl definition.
+ *	The second problem is that a fixed single addr won't be inlined
+ * in struct iwreq and will be passed as a pointer. This is due to an
+ * off-by-one error, where all fixed data of 16 bytes is considered too
+ * big to fit in struct iwreq.
+ *
+ *	For those reasons, I would recommend to use the ioctl handler
+ * before v15 when manipulating those data.
+ *
+ * TOKEN INDEX :
+ * -----------
+ *	Token index is very similar to sub-ioctl. It allows the user
+ * to specify an integer index in front of a bunch of other arguments
+ * (addresses, strings, ...). It's specified in square brackets on the
+ * iwpriv command line before other arguments.
+ *		> iwpriv eth0 [index] args...
+ *	Token index works only when the data is passed as pointer, and
+ * is otherwise ignored. If your data would fit within struct iwreq, you
+ * should declare the command *without* IW_PRIV_SIZE_FIXED to force
+ * this to happen (and check arg number yourself).
+ * --------------------------------------------
+	// --- Commands that would fit in struct iwreq ---
+	{ 0x8BE0, IW_PRIV_TYPE_ADDR | 1, 0, "set_param_with_token" },
+	// --- No problem here (bigger than struct iwreq) ---
+	{ 0x8BE1, IW_PRIV_TYPE_ADDR | IW_PRIV_SIZE_FIXED | 2, 0, "again" },
+ * --------------------------------------------
+ *	The token index feature is pretty transparent, the token index
+ * will just be in the flags member of (struct iw_point). Default value
+ * (if the user doesn't specify it) will be 0. Token index itself will
+ * work with any version of Wireless Extensions.
+ *	Token index is not compatible with sub-ioctl (both use the same
+ * field of struct iw_point). However, the token index can be used to offer
+ * raw access to the sub-ioctl handlers (if it uses struct iw_point) :
+ * --------------------------------------------
+	// --- sub-ioctls handler ---
+	{ 0x8BE0, IW_PRIV_TYPE_ADDR | IW_PRIV_SIZE_FIXED | 1, 0, "" },
+	// --- sub-ioctls definitions ---
+	{ 0, IW_PRIV_TYPE_ADDR | IW_PRIV_SIZE_FIXED | 1, 0, "setaddr" },
+	{ 1, IW_PRIV_TYPE_ADDR | IW_PRIV_SIZE_FIXED | 1, 0, "deladdr" },
+	// --- raw access with token index (+ iwreq workaround) ---
+	{ 0x8BE0, IW_PRIV_TYPE_ADDR | 1, 0, "rawaddr" },
+ * --------------------------------------------
+ *
+ * Jean II
+ */
+
+/**************************** CONSTANTS ****************************/
+
+static const char *	argtype[] = {
+  "     ", "byte ", "char ", "", "int  ", "float", "addr " };
+
+/************************* MISC SUBROUTINES **************************/
+
+/*------------------------------------------------------------------*/
+/*
+ * Print usage string
+ */
+static void
+iw_usage(void)
+{
+  fprintf(stderr, "Usage: iwpriv interface [private-command [private-arguments]]\n");
+}
+
+/************************* SETTING ROUTINES **************************/
+
+/*------------------------------------------------------------------*/
+/*
+ * Execute a private command on the interface
+ */
+static int
+set_private_cmd(int		skfd,		/* Socket */
+		char *		args[],		/* Command line args */
+		int		count,		/* Args count */
+		char *		ifname,		/* Dev name */
+		char *		cmdname,	/* Command name */
+		iwprivargs *	priv,		/* Private ioctl description */
+		int		priv_num)	/* Number of descriptions */
+{
+  struct iwreq	wrq;
+  u_char	buffer[4096];	/* Only that big in v25 and later */
+  int		i = 0;		/* Start with first command arg */
+  int		k;		/* Index in private description table */
+  int		temp;
+  int		subcmd = 0;	/* sub-ioctl index */
+  int		offset = 0;	/* Space for sub-ioctl index */
+
+  /* Check if we have a token index.
+   * Do it now so that sub-ioctl takes precedence, and so that we
+   * don't have to bother with it later on... */
+  if((count >= 1) && (sscanf(args[0], "[%i]", &temp) == 1))
+    {
+      subcmd = temp;
+      args++;
+      count--;
+    }
+
+  /* Search the correct ioctl */
+  k = -1;
+  while((++k < priv_num) && strcmp(priv[k].name, cmdname));
+
+  /* If not found... */
+  if(k == priv_num)
+    {
+      fprintf(stderr, "Invalid command : %s\n", cmdname);
+      return(-1);
+    }
+	  
+  /* Watch out for sub-ioctls ! */
+  if(priv[k].cmd < SIOCDEVPRIVATE)
+    {
+      int	j = -1;
+
+      /* Find the matching *real* ioctl */
+      while((++j < priv_num) && ((priv[j].name[0] != '\0') ||
+				 (priv[j].set_args != priv[k].set_args) ||
+				 (priv[j].get_args != priv[k].get_args)));
+
+      /* If not found... */
+      if(j == priv_num)
+	{
+	  fprintf(stderr, "Invalid private ioctl definition for : %s\n",
+		  cmdname);
+	  return(-1);
+	}
+
+      /* Save sub-ioctl number */
+      subcmd = priv[k].cmd;
+      /* Reserve one int (simplify alignment issues) */
+      offset = sizeof(__u32);
+      /* Use real ioctl definition from now on */
+      k = j;
+
+#if 0
+      printf("<mapping sub-ioctl %s to cmd 0x%X-%d>\n", cmdname,
+	     priv[k].cmd, subcmd);
+#endif
+    }
+
+  /* If we have to set some data */
+  if((priv[k].set_args & IW_PRIV_TYPE_MASK) &&
+     (priv[k].set_args & IW_PRIV_SIZE_MASK))
+    {
+      switch(priv[k].set_args & IW_PRIV_TYPE_MASK)
+	{
+	case IW_PRIV_TYPE_BYTE:
+	  /* Number of args to fetch */
+	  wrq.u.data.length = count;
+	  if(wrq.u.data.length > (priv[k].set_args & IW_PRIV_SIZE_MASK))
+	    wrq.u.data.length = priv[k].set_args & IW_PRIV_SIZE_MASK;
+
+	  /* Fetch args */
+	  for(; i < wrq.u.data.length; i++) {
+	    sscanf(args[i], "%i", &temp);
+	    buffer[i] = (char) temp;
+	  }
+	  break;
+
+	case IW_PRIV_TYPE_INT:
+	  /* Number of args to fetch */
+	  wrq.u.data.length = count;
+	  if(wrq.u.data.length > (priv[k].set_args & IW_PRIV_SIZE_MASK))
+	    wrq.u.data.length = priv[k].set_args & IW_PRIV_SIZE_MASK;
+
+	  /* Fetch args */
+	  for(; i < wrq.u.data.length; i++) {
+	    sscanf(args[i], "%i", &temp);
+	    ((__s32 *) buffer)[i] = (__s32) temp;
+	  }
+	  break;
+
+	case IW_PRIV_TYPE_CHAR:
+	  if(i < count)
+	    {
+	      /* Size of the string to fetch */
+	      wrq.u.data.length = strlen(args[i]) + 1;
+	      if(wrq.u.data.length > (priv[k].set_args & IW_PRIV_SIZE_MASK))
+		wrq.u.data.length = priv[k].set_args & IW_PRIV_SIZE_MASK;
+
+	      /* Fetch string */
+	      memcpy(buffer, args[i], wrq.u.data.length);
+	      buffer[sizeof(buffer) - 1] = '\0';
+	      i++;
+	    }
+	  else
+	    {
+	      wrq.u.data.length = 1;
+	      buffer[0] = '\0';
+	    }
+	  break;
+
+	case IW_PRIV_TYPE_FLOAT:
+	  /* Number of args to fetch */
+	  wrq.u.data.length = count;
+	  if(wrq.u.data.length > (priv[k].set_args & IW_PRIV_SIZE_MASK))
+	    wrq.u.data.length = priv[k].set_args & IW_PRIV_SIZE_MASK;
+
+	  /* Fetch args */
+	  for(; i < wrq.u.data.length; i++) {
+	    double		freq;
+	    if(sscanf(args[i], "%lg", &(freq)) != 1)
+	      {
+		printf("Invalid float [%s]...\n", args[i]);
+		return(-1);
+	      }    
+	    if(strchr(args[i], 'G')) freq *= GIGA;
+	    if(strchr(args[i], 'M')) freq *= MEGA;
+	    if(strchr(args[i], 'k')) freq *= KILO;
+	    sscanf(args[i], "%i", &temp);
+	    iw_float2freq(freq, ((struct iw_freq *) buffer) + i);
+	  }
+	  break;
+
+	case IW_PRIV_TYPE_ADDR:
+	  /* Number of args to fetch */
+	  wrq.u.data.length = count;
+	  if(wrq.u.data.length > (priv[k].set_args & IW_PRIV_SIZE_MASK))
+	    wrq.u.data.length = priv[k].set_args & IW_PRIV_SIZE_MASK;
+
+	  /* Fetch args */
+	  for(; i < wrq.u.data.length; i++) {
+	    if(iw_in_addr(skfd, ifname, args[i],
+			  ((struct sockaddr *) buffer) + i) < 0)
+	      {
+		printf("Invalid address [%s]...\n", args[i]);
+		return(-1);
+	      }
+	  }
+	  break;
+
+	default:
+	  fprintf(stderr, "Not implemented...\n");
+	  return(-1);
+	}
+	  
+      if((priv[k].set_args & IW_PRIV_SIZE_FIXED) &&
+	 (wrq.u.data.length != (priv[k].set_args & IW_PRIV_SIZE_MASK)))
+	{
+	  printf("The command %s needs exactly %d argument(s)...\n",
+		 cmdname, priv[k].set_args & IW_PRIV_SIZE_MASK);
+	  return(-1);
+	}
+    }	/* if args to set */
+  else
+    {
+      wrq.u.data.length = 0L;
+    }
+
+  strncpy(wrq.ifr_name, ifname, IFNAMSIZ);
+
+  /* Those two tests are important. They define how the driver
+   * will have to handle the data */
+  if((priv[k].set_args & IW_PRIV_SIZE_FIXED) &&
+      ((iw_get_priv_size(priv[k].set_args) + offset) <= IFNAMSIZ))
+    {
+      /* First case : all SET args fit within wrq */
+      if(offset)
+	wrq.u.mode = subcmd;
+      memcpy(wrq.u.name + offset, buffer, IFNAMSIZ - offset);
+    }
+  else
+    {
+      if((priv[k].set_args == 0) &&
+	 (priv[k].get_args & IW_PRIV_SIZE_FIXED) &&
+	 (iw_get_priv_size(priv[k].get_args) <= IFNAMSIZ))
+	{
+	  /* Second case : no SET args, GET args fit within wrq */
+	  if(offset)
+	    wrq.u.mode = subcmd;
+	}
+      else
+	{
+	  /* Third case : args won't fit in wrq, or variable number of args */
+	  wrq.u.data.pointer = (caddr_t) buffer;
+	  wrq.u.data.flags = subcmd;
+	}
+    }
+
+  /* Perform the private ioctl */
+  if(ioctl(skfd, priv[k].cmd, &wrq) < 0)
+    {
+      fprintf(stderr, "Interface doesn't accept private ioctl...\n");
+      fprintf(stderr, "%s (%X): %s\n", cmdname, priv[k].cmd, strerror(errno));
+      return(-1);
+    }
+
+  /* If we have to get some data */
+  if((priv[k].get_args & IW_PRIV_TYPE_MASK) &&
+     (priv[k].get_args & IW_PRIV_SIZE_MASK))
+    {
+      int	j;
+      int	n = 0;		/* number of args */
+
+      printf("%-8.16s  %s:", ifname, cmdname);
+
+      /* Check where is the returned data */
+      if((priv[k].get_args & IW_PRIV_SIZE_FIXED) &&
+	 (iw_get_priv_size(priv[k].get_args) <= IFNAMSIZ))
+	{
+	  memcpy(buffer, wrq.u.name, IFNAMSIZ);
+	  n = priv[k].get_args & IW_PRIV_SIZE_MASK;
+	}
+      else
+	n = wrq.u.data.length;
+
+      switch(priv[k].get_args & IW_PRIV_TYPE_MASK)
+	{
+	case IW_PRIV_TYPE_BYTE:
+	  /* Display args */
+	  for(j = 0; j < n; j++)
+	    printf("%d  ", buffer[j]);
+	  printf("\n");
+	  break;
+
+	case IW_PRIV_TYPE_INT:
+	  /* Display args */
+	  for(j = 0; j < n; j++)
+	    printf("%d  ", ((__s32 *) buffer)[j]);
+	  printf("\n");
+	  break;
+
+	case IW_PRIV_TYPE_CHAR:
+	  /* Display args */
+	  buffer[n] = '\0';
+	  printf("%s\n", buffer);
+	  break;
+
+	case IW_PRIV_TYPE_FLOAT:
+	  {
+	    double		freq;
+	    /* Display args */
+	    for(j = 0; j < n; j++)
+	      {
+		freq = iw_freq2float(((struct iw_freq *) buffer) + j);
+		if(freq >= GIGA)
+		  printf("%gG  ", freq / GIGA);
+		else
+		  if(freq >= MEGA)
+		  printf("%gM  ", freq / MEGA);
+		else
+		  printf("%gk  ", freq / KILO);
+	      }
+	    printf("\n");
+	  }
+	  break;
+
+	case IW_PRIV_TYPE_ADDR:
+	  {
+	    char		scratch[128];
+	    struct sockaddr *	hwa;
+	    /* Display args */
+	    for(j = 0; j < n; j++)
+	      {
+		hwa = ((struct sockaddr *) buffer) + j;
+		if(j)
+		  printf("           %.*s", 
+			 (int) strlen(cmdname), "                ");
+		printf("%s\n", iw_saether_ntop(hwa, scratch));
+	      }
+	  }
+	  break;
+
+	default:
+	  fprintf(stderr, "Not yet implemented...\n");
+	  return(-1);
+	}
+    }	/* if args to set */
+
+  return(0);
+}
+
+/*------------------------------------------------------------------*/
+/*
+ * Execute a private command on the interface
+ */
+static inline int
+set_private(int		skfd,		/* Socket */
+	    char *	args[],		/* Command line args */
+	    int		count,		/* Args count */
+	    char *	ifname)		/* Dev name */
+{
+  iwprivargs *	priv;
+  int		number;		/* Max of private ioctl */
+  int		ret;
+
+  /* Read the private ioctls */
+  number = iw_get_priv_info(skfd, ifname, &priv);
+
+  /* Is there any ? */
+  if(number <= 0)
+    {
+      /* Should I skip this message ? */
+      fprintf(stderr, "%-8.16s  no private ioctls.\n\n",
+	      ifname);
+      if(priv)
+	free(priv);
+      return(-1);
+    }
+
+  /* Do it */
+  ret = set_private_cmd(skfd, args + 1, count - 1, ifname, args[0],
+			priv, number);
+
+  free(priv);
+  return(ret);
+}
+
+/************************ CATALOG FUNCTIONS ************************/
+
+/*------------------------------------------------------------------*/
+/*
+ * Print on the screen in a neat fashion the list of private ioctls
+ * for the device.
+ */
+static int
+print_priv_info(int		skfd,
+		char *		ifname,
+		char *		args[],
+		int		count)
+{
+  int		k;
+  iwprivargs *	priv;
+  int		n;
+
+  /* Avoid "Unused parameter" warning */
+  args = args; count = count;
+
+  /* Read the private ioctls */
+  n = iw_get_priv_info(skfd, ifname, &priv);
+
+  /* Is there any ? */
+  if(n <= 0)
+    {
+      /* Should I skip this message ? */
+      fprintf(stderr, "%-8.16s  no private ioctls.\n\n",
+	      ifname);
+    }
+  else
+    {
+      printf("%-8.16s  Available private ioctls :\n", ifname);
+      /* Print them all */
+      for(k = 0; k < n; k++)
+	if(priv[k].name[0] != '\0')
+	  printf("          %-16.16s (%.4X) : set %3d %s & get %3d %s\n",
+		 priv[k].name, priv[k].cmd,
+		 priv[k].set_args & IW_PRIV_SIZE_MASK,
+		 argtype[(priv[k].set_args & IW_PRIV_TYPE_MASK) >> 12],
+		 priv[k].get_args & IW_PRIV_SIZE_MASK,
+		 argtype[(priv[k].get_args & IW_PRIV_TYPE_MASK) >> 12]);
+      printf("\n");
+    }
+
+  /* Cleanup */
+  if(priv)
+    free(priv);
+  return(0);
+}
+
+/*------------------------------------------------------------------*/
+/*
+ * Print on the screen in a neat fashion the list of private GET ioctl
+ * data for the device and data returned by those.
+ */
+static int
+print_priv_all(int		skfd,
+	       char *		ifname,
+	       char *		args[],
+	       int		count)
+{
+  int		k;
+  iwprivargs *	priv;
+  int		n;
+
+  /* Avoid "Unused parameter" warning */
+  args = args; count = count;
+
+  /* Read the private ioctls */
+  n = iw_get_priv_info(skfd, ifname, &priv);
+
+  /* Is there any ? */
+  if(n <= 0)
+    {
+      /* Should I skip this message ? */
+      fprintf(stderr, "%-8.16s  no private ioctls.\n\n",
+	      ifname);
+    }
+  else
+    {
+      printf("%-8.16s  Available read-only private ioctl :\n", ifname);
+      /* Print them all */
+      for(k = 0; k < n; k++)
+	/* We call all ioctls that don't have a null name, don't require
+	 * args and return some (avoid triggering "reset" commands) */
+	if((priv[k].name[0] != '\0') && (priv[k].set_args == 0) &&
+	   (priv[k].get_args != 0))
+	  set_private_cmd(skfd, NULL, 0, ifname, priv[k].name,
+			  priv, n);
+      printf("\n");
+    }
+
+  /* Cleanup */
+  if(priv)
+    free(priv);
+  return(0);
+}
+
+/********************** PRIVATE IOCTLS MANIPS ***********************/
+/*
+ * Convenient access to some private ioctls of some devices
+ */
+
+#if 0
+/*------------------------------------------------------------------*/
+/*
+ * Set roaming mode on and off
+ * Found in wavelan_cs driver
+ * Note : this is obsolete, most 802.11 devices should use the
+ * SIOCSIWAP request.
+ */
+static int
+set_roaming(int		skfd,		/* Socket */
+	    char *	args[],		/* Command line args */
+	    int		count,		/* Args count */
+	    char *	ifname)		/* Dev name */
+{
+  u_char	buffer[1024];
+  struct iwreq		wrq;
+  int		i = 0;		/* Start with first arg */
+  int		k;
+  iwprivargs *	priv;
+  int		number;
+  int		roamcmd;
+  char		RoamState;		/* buffer to hold new roam state */
+  char		ChangeRoamState=0;	/* whether or not we are going to
+					   change roam states */
+
+  /* Read the private ioctls */
+  number = iw_get_priv_info(skfd, ifname, &priv);
+
+  /* Is there any ? */
+  if(number <= 0)
+    {
+      /* Should I skip this message ? */
+      fprintf(stderr, "%-8.16s  no private ioctls.\n\n",
+	      ifname);
+      if(priv)
+	free(priv);
+      return(-1);
+    }
+
+  /* Get the ioctl number */
+  k = -1;
+  while((++k < number) && strcmp(priv[k].name, "setroam"));
+  if(k == number)
+    {
+      fprintf(stderr, "This device doesn't support roaming\n");
+      free(priv);
+      return(-1);
+    }
+  roamcmd = priv[k].cmd;
+
+  /* Cleanup */
+  free(priv);
+
+  if(count != 1)
+    {
+      iw_usage();
+      return(-1);
+    }
+
+  if(!strcasecmp(args[i], "on"))
+    {
+      printf("%-8.16s  enable roaming\n", ifname);
+      if(!number)
+	{
+	  fprintf(stderr, "This device doesn't support roaming\n");
+	  return(-1);
+	}
+      ChangeRoamState=1;
+      RoamState=1;
+    }
+  else
+    if(!strcasecmp(args[i], "off"))
+      {
+	i++;
+	printf("%-8.16s  disable roaming\n",  ifname);
+	if(!number)
+	  {
+	    fprintf(stderr, "This device doesn't support roaming\n");
+	    return(-1);
+	  }
+	ChangeRoamState=1;
+	RoamState=0;
+      }
+    else
+      {
+	iw_usage();
+	return(-1);
+      }
+
+  if(ChangeRoamState)
+    {
+      strncpy(wrq.ifr_name, ifname, IFNAMSIZ);
+
+      buffer[0]=RoamState;
+
+      memcpy(wrq.u.name, &buffer, IFNAMSIZ);
+
+      if(ioctl(skfd, roamcmd, &wrq) < 0)
+	{
+	  fprintf(stderr, "Roaming support is broken.\n");
+	  return(-1);
+	}
+    }
+
+  return(0);
+}
+
+/*------------------------------------------------------------------*/
+/*
+ * Get and set the port type
+ * Found in wavelan2_cs and wvlan_cs drivers
+ * TODO : Add support for HostAP ?
+ */
+static int
+port_type(int		skfd,		/* Socket */
+	  char *	args[],		/* Command line args */
+	  int		count,		/* Args count */
+	  char *	ifname)		/* Dev name */
+{
+  struct iwreq	wrq;
+  int		i = 0;		/* Start with first arg */
+  int		k;
+  iwprivargs *	priv;
+  int		number;
+  char		ptype = 0;
+  char *	modes[] = { "invalid", "managed (BSS)", "reserved", "ad-hoc" };
+
+  /* Read the private ioctls */
+  number = iw_get_priv_info(skfd, ifname, &priv);
+
+  /* Is there any ? */
+  if(number <= 0)
+    {
+      /* Should I skip this message ? */
+      fprintf(stderr, "%-8.16s  no private ioctls.\n\n", ifname);
+      if(priv)
+	free(priv);
+      return(-1);
+    }
+
+  /* Arguments ? */
+  if(count == 0)
+    {
+      /* So, we just want to see the current value... */
+      k = -1;
+      while((++k < number) && strcmp(priv[k].name, "gport_type") &&
+	     strcmp(priv[k].name, "get_port"));
+      if(k == number)
+	{
+	  fprintf(stderr, "This device doesn't support getting port type\n");
+	  goto err;
+	}
+      strncpy(wrq.ifr_name, ifname, IFNAMSIZ);
+
+      /* Get it */
+      if(ioctl(skfd, priv[k].cmd, &wrq) < 0)
+	{
+	  fprintf(stderr, "Port type support is broken.\n");
+	  goto err;
+	}
+      ptype = *wrq.u.name;
+
+      /* Display it */
+      printf("%-8.16s  Current port mode is %s <port type is %d>.\n\n",
+	     ifname, modes[(int) ptype], ptype);
+
+      free(priv);
+      return(0);
+    }
+
+  if(count != 1)
+    {
+      iw_usage();
+      goto err;
+    }
+
+  /* Read it */
+  /* As a string... */
+  k = 0;
+  while((k < 4) && strncasecmp(args[i], modes[k], 2))
+    k++;
+  if(k < 4)
+    ptype = k;
+  else
+    /* ...or as an integer */
+    if(sscanf(args[i], "%i", (int *) &ptype) != 1)
+      {
+	iw_usage();
+	goto err;
+      }
+  
+  k = -1;
+  while((++k < number) && strcmp(priv[k].name, "sport_type") &&
+	strcmp(priv[k].name, "set_port"));
+  if(k == number)
+    {
+      fprintf(stderr, "This device doesn't support setting port type\n");
+      goto err;
+    }
+  strncpy(wrq.ifr_name, ifname, IFNAMSIZ);
+
+  *(wrq.u.name) = ptype;
+
+  if(ioctl(skfd, priv[k].cmd, &wrq) < 0)
+    {
+      fprintf(stderr, "Invalid port type (or setting not allowed)\n");
+      goto err;
+    }
+
+  free(priv);
+  return(0);
+
+ err:
+  free(priv);
+  return(-1);
+}
+#endif
+
+/******************************* MAIN ********************************/
+
+/*------------------------------------------------------------------*/
+/*
+ * The main !
+ */
+int
+main(int	argc,
+     char **	argv)
+{
+  int skfd;		/* generic raw socket desc.	*/
+  int goterr = 0;
+
+  /* Create a channel to the NET kernel. */
+  if((skfd = iw_sockets_open()) < 0)
+    {
+      perror("socket");
+      return(-1);
+    }
+
+  /* No argument : show the list of all devices + ioctl list */
+  if(argc == 1)
+    iw_enum_devices(skfd, &print_priv_info, NULL, 0);
+  else
+    /* Special cases take one... */
+    /* All */
+    if((!strncmp(argv[1], "-a", 2)) || (!strcmp(argv[1], "--all")))
+      iw_enum_devices(skfd, &print_priv_all, NULL, 0);
+    else
+      /* Help */
+      if((!strncmp(argv[1], "-h", 2)) || (!strcmp(argv[1], "--help")))
+	iw_usage();
+      else
+	/* Version */
+	if (!strcmp(argv[1], "-v") || !strcmp(argv[1], "--version"))
+	  goterr = iw_print_version_info("iwpriv");
+	else
+	  /* The device name must be the first argument */
+	  /* Name only : show for that device only */
+	  if(argc == 2)
+	    print_priv_info(skfd, argv[1], NULL, 0);
+	  else
+	    /* Special cases take two... */
+	    /* All */
+	    if((!strncmp(argv[2], "-a", 2)) ||
+	       (!strcmp(argv[2], "--all")))
+	      print_priv_all(skfd, argv[1], NULL, 0);
+	    else
+#if 0
+	      /* Roaming */
+	      if(!strncmp(argv[2], "roam", 4))
+		goterr = set_roaming(skfd, argv + 3, argc - 3, argv[1]);
+	      else
+		/* Port type */
+		if(!strncmp(argv[2], "port", 4))
+		  goterr = port_type(skfd, argv + 3, argc - 3, argv[1]);
+		else
+#endif
+		  /*-------------*/
+		  /* Otherwise, it's a private ioctl */
+		  goterr = set_private(skfd, argv + 2, argc - 2, argv[1]);
+
+  /* Close the socket. */
+  iw_sockets_close(skfd);
+
+  return(goterr);
+}
diff --git a/iwspy.8 b/iwspy.8
new file mode 100644
index 0000000..fb148f5
--- /dev/null
+++ b/iwspy.8
@@ -0,0 +1,111 @@
+.\" Jean II - HPLB - 96
+.\" iwspy.8
+.\"
+.TH IWSPY 8 "31 October 1996" "net-tools" "Linux Programmer's Manual"
+.\"
+.\" NAME part
+.\"
+.SH NAME
+iwspy \- Get wireless statistics from specific nodes
+.\"
+.\" SYNOPSIS part
+.\"
+.SH SYNOPSIS
+.BI "iwspy [" interface ]
+.br
+.BI "iwspy " interface " [+] " DNSNAME " | " IPADDR " | " HWADDR " [...]"
+.br
+.BI "iwspy " interface " off"
+.br
+.BI "iwspy " interface " setthr " "low high"
+.br
+.BI "iwspy " interface " getthr"
+.\"
+.\" DESCRIPTION part
+.\"
+.SH DESCRIPTION
+.B Iwspy
+is used to set a list of addresses to monitor in a wireless network
+interface and to read back quality of link information for each of
+those. This information is the same as the one available in
+.I /proc/net/wireless
+: quality of the link, signal strength and noise level.
+.PP
+This information is updated each time a new packet is received, so
+each address of the list adds some overhead in the driver.
+.PP
+Note that this functionality works only for nodes part of the current
+wireless cell, you can not monitor Access Points you are not
+associated with (you can use Scanning for that) and nodes in other
+cells. In Managed mode, in most case packets are relayed by the Access
+Point, in this case you will get the signal strength of the Access
+Point. For those reasons this functionality is mostly useful in Ad-Hoc
+and Master mode.
+.\"
+.\" PARAMETER part
+.\"
+.SH PARAMETERS
+You may set any number of addresses up to 8.
+.TP
+.BR DNSNAME " | " IPADDR
+Set an IP address, or in some cases a DNS name (using the name
+resolver). As the hardware works with hardware addresses,
+.B iwspy
+will translate this IP address through
+.IR ARP .
+In some case, this address might not be in the ARP cache and
+.B iwspy
+will fail. In those case,
+.IR ping (8)
+this name/address and retry.
+.TP
+.B HWADDR
+Set a hardware (MAC) address (this address is not translated & checked
+like the IP one). The address must contain a colon
+.RB ( : )
+to be recognised as a hardware address.
+.TP
+.B +
+Add the new set of addresses at the end of the current list instead of
+replacing it. The address list is unique for each device, so each user
+should use this option to avoid conflicts.
+.TP
+.B off
+Remove the current list of addresses and disable the spy functionality
+.TP
+.B setthr
+Set the
+.I low
+and
+.I high
+signal strength threshold for the iwspy event (for drivers that
+support it).
+.br
+Every time the signal strength for any of the address monitored
+with iwspy goes lower than the low threshold or goes higher than the
+high threshold, a Wireless Event will be generated.
+.br
+This can be used to monitor link outages without having to run iwspy
+periodically.
+.TP
+.B getthr
+Retrieve the current
+.I low
+and
+.I high
+signal strength threshold for the iwspy event.
+\"
+.\" FILES part
+.\"
+.SH FILES
+.I /proc/net/wireless
+.\"
+.\" SEE ALSO part
+.\"
+.SH SEE ALSO
+.BR iwconfig (8),
+.BR iwlist (8),
+.BR iwevent (8),
+.BR iwpriv (8),
+.BR wireless (7).
+
diff --git a/iwspy.c b/iwspy.c
new file mode 100644
index 0000000..9d10d38
--- /dev/null
+++ b/iwspy.c
@@ -0,0 +1,376 @@
+/*
+ *	Wireless Tools
+ *
+ *		Jean II - HPLB '99 - HPL 99->04
+ *
+ * This tool can manipulate the spy list : add addresses and display stat
+ * You need to link this code against "iwlib.c" and "-lm".
+ *
+ * This file is released under the GPL license.
+ *     Copyright (c) 1997-2004 Jean Tourrilhes <jt@hpl.hp.com>
+ */
+
+#include "iwlib.h"		/* Header */
+
+/************************* DISPLAY ROUTINES **************************/
+
+/*------------------------------------------------------------------*/
+/*
+ * Display the spy list of addresses and the associated stats
+ */
+static int
+print_spy_info(int	skfd,
+	       char *	ifname,
+	       char *	args[],
+	       int	count)
+{
+  struct iwreq		wrq;
+  char		buffer[(sizeof(struct iw_quality) +
+			sizeof(struct sockaddr)) * IW_MAX_SPY];
+  char		temp[128];
+  struct sockaddr *	hwa;
+  struct iw_quality *	qual;
+  iwrange	range;
+  int		has_range = 0;
+  int		n;
+  int		i;
+
+  /* Avoid "Unused parameter" warning */
+  args = args; count = count;
+
+  /* Collect stats */
+  wrq.u.data.pointer = (caddr_t) buffer;
+  wrq.u.data.length = IW_MAX_SPY;
+  wrq.u.data.flags = 0;
+  if(iw_get_ext(skfd, ifname, SIOCGIWSPY, &wrq) < 0)
+    {
+      fprintf(stderr, "%-8.16s  Interface doesn't support wireless statistic collection\n\n", ifname);
+      return(-1);
+    }
+
+  /* Number of addresses */
+  n = wrq.u.data.length;
+
+  /* Check if we have valid mac address type */
+  if(iw_check_mac_addr_type(skfd, ifname) < 0)
+    {
+      fprintf(stderr, "%-8.16s  Interface doesn't support MAC addresses\n\n", ifname);
+      return(-2);
+    }
+
+  /* Get range info if we can */
+  if(iw_get_range_info(skfd, ifname, &(range)) >= 0)
+    has_range = 1;
+
+  /* Display it */
+  if(n == 0)
+    printf("%-8.16s  No statistics to collect\n", ifname);
+  else
+    printf("%-8.16s  Statistics collected:\n", ifname);
+ 
+  /* The two lists */
+  hwa = (struct sockaddr *) buffer;
+  qual = (struct iw_quality *) (buffer + (sizeof(struct sockaddr) * n));
+
+  for(i = 0; i < n; i++)
+    {
+      /* Print stats for each address */
+      printf("    %s : ", iw_saether_ntop(&hwa[i], temp));
+      iw_print_stats(temp, sizeof(temp), &qual[i], &range, has_range);
+      printf("%s\n", temp);
+    }
+
+  if((n > 0) && (has_range) && (range.we_version_compiled > 11))
+    {
+      iwstats	stats;
+
+      /* Get /proc/net/wireless */
+      if(iw_get_stats(skfd, ifname, &stats, &range, has_range) >= 0)
+	{
+	  iw_print_stats(temp, sizeof(temp), &stats.qual, &range, has_range);
+	  printf("    Link/Cell/AP      : %s\n", temp);
+	  /* Display the static data */
+	  iw_print_stats(temp, sizeof(temp),
+			 &range.avg_qual, &range, has_range);
+	  printf("    Typical/Reference : %s\n", temp);
+	}
+    }
+
+  printf("\n");
+  return(0);
+}
+
+/*------------------------------------------------------------------*/
+/*
+ * Get spy thresholds from the driver and display
+ */
+static int
+get_spy_threshold(int		skfd,		/* The socket */
+		  char *	ifname,		/* Dev name */
+		  char *	args[],		/* Command line args */
+		  int		count)		/* Args count */
+{
+  struct iwreq		wrq;
+  struct iw_thrspy	threshold;
+  iwrange	range;
+  int			has_range = 0;
+
+  /* Avoid "Unused parameter" warning */
+  args = args; count = count;
+
+  /* Time to send thresholds to the driver */
+  wrq.u.data.pointer = (caddr_t) &threshold;
+  wrq.u.data.length = 1;
+  wrq.u.data.flags = 0;
+  if(iw_set_ext(skfd, ifname, SIOCGIWTHRSPY, &wrq) < 0)
+    {
+      fprintf(stderr, "Interface doesn't support thresholds...\n");
+      fprintf(stderr, "SIOCGIWTHRSPY: %s\n", strerror(errno));
+      return(-1);
+    }
+
+  /* Get range info if we can */
+  if(iw_get_range_info(skfd, ifname, &(range)) >= 0)
+    has_range = 1;
+
+  /* Display thresholds */
+  if((has_range) && (threshold.low.level))
+    {
+      /* If the statistics are in dBm */
+      if(threshold.low.level > range.max_qual.level)
+	{
+	  /* Statistics are in dBm (absolute power measurement) */
+	  printf("%-8.16s  Low threshold:%d dBm  High threshold:%d dBm\n\n",
+		 ifname,
+		 threshold.low.level - 0x100, threshold.high.level - 0x100);
+	}
+      else
+	{
+	  /* Statistics are relative values (0 -> max) */
+	  printf("%-8.16s  Low threshold:%d/%d  High threshold:%d/%d\n\n",
+		 ifname,
+		 threshold.low.level, range.max_qual.level,
+		 threshold.high.level, range.max_qual.level);
+	}
+    }
+  else
+    {
+      /* We can't read the range, so we don't know... */
+      printf("%-8.16s  Low threshold:%d  High threshold:%d\n\n",
+	     ifname,
+	     threshold.low.level, threshold.high.level);
+    }
+
+  return(0);
+}
+
+/************************* SETTING ROUTINES **************************/
+
+/*------------------------------------------------------------------*/
+/*
+ * Set list of addresses specified on command line in the driver.
+ */
+static int
+set_spy_info(int		skfd,		/* The socket */
+	     char *		ifname,		/* Dev name */
+	     char *		args[],		/* Command line args */
+	     int		count)		/* Args count */
+{
+  struct iwreq		wrq;
+  int			i;
+  int			nbr;		/* Number of valid addresses */
+  struct sockaddr	hw_address[IW_MAX_SPY];
+
+  /* Read command line */
+  i = 0;	/* first arg to read */
+  nbr = 0;	/* Number of args read so far */
+
+  /* "off" : disable functionality (set 0 addresses) */
+  if(!strcmp(args[0], "off"))
+    i = 1;	/* skip the "off" */
+  else
+    {
+      /* "+" : add all addresses already in the driver */
+      if(!strcmp(args[0], "+"))
+	{
+	  char	buffer[(sizeof(struct iw_quality) +
+			sizeof(struct sockaddr)) * IW_MAX_SPY];
+
+	  /* Check if we have valid mac address type */
+	  if(iw_check_mac_addr_type(skfd, ifname) < 0)
+	    {
+	      fprintf(stderr, "%-8.16s  Interface doesn't support MAC addresses\n", ifname);
+	      return(-1);
+	    }
+
+	  wrq.u.data.pointer = (caddr_t) buffer;
+	  wrq.u.data.length = IW_MAX_SPY;
+	  wrq.u.data.flags = 0;
+	  if(iw_get_ext(skfd, ifname, SIOCGIWSPY, &wrq) < 0)
+	    {
+	      fprintf(stderr, "Interface doesn't accept reading addresses...\n");
+	      fprintf(stderr, "SIOCGIWSPY: %s\n", strerror(errno));
+	      return(-1);
+	    }
+
+	  /* Copy old addresses */
+	  nbr = wrq.u.data.length;
+	  memcpy(hw_address, buffer, nbr * sizeof(struct sockaddr));
+
+	  i = 1;	/* skip the "+" */
+	}
+
+      /* Read other args on command line */
+      while((i < count) && (nbr < IW_MAX_SPY))
+	{
+	  /* Get the address and check if the interface supports it */
+	  if(iw_in_addr(skfd, ifname, args[i++], &(hw_address[nbr])) < 0)
+	    continue;
+	  nbr++;
+	}
+
+      /* Check the number of addresses */
+      if(nbr == 0)
+	{
+	  fprintf(stderr, "No valid addresses found : exiting...\n");
+	  return(-1);
+	}
+    }
+
+  /* Check if there is some remaining arguments */
+  if(i < count)
+    {
+      fprintf(stderr, "Got only the first %d arguments, remaining discarded\n", i);
+    }
+
+  /* Time to do send addresses to the driver */
+  wrq.u.data.pointer = (caddr_t) hw_address;
+  wrq.u.data.length = nbr;
+  wrq.u.data.flags = 0;
+  if(iw_set_ext(skfd, ifname, SIOCSIWSPY, &wrq) < 0)
+    {
+      fprintf(stderr, "Interface doesn't accept addresses...\n");
+      fprintf(stderr, "SIOCSIWSPY: %s\n", strerror(errno));
+      return(-1);
+    }
+
+  return(0);
+}
+
+/*------------------------------------------------------------------*/
+/*
+ * Set spy thresholds in the driver from command line
+ */
+static int
+set_spy_threshold(int		skfd,		/* The socket */
+		  char *	ifname,		/* Dev name */
+		  char *	args[],		/* Command line args */
+		  int		count)		/* Args count */
+{
+  struct iwreq		wrq;
+  struct iw_thrspy	threshold;
+  int			low_thr;
+  int			high_thr;
+
+  /* Init */
+  memset(&threshold, '\0', sizeof(threshold));
+
+  /* "off" : disable functionality (set 0 addresses) */
+  if(!strcmp(args[0], "off"))
+    {
+      /* Just send null threshold, will disable it */
+    }
+  else
+    {
+      /* Try to get our threshold */
+      if(count < 2)
+	{
+	  fprintf(stderr, "%-8.16s  Need two threshold values\n", ifname);
+	  return(-1);
+	}
+      if((sscanf(args[0], "%i", &low_thr) != 1) ||
+	 (sscanf(args[1], "%i", &high_thr) != 1))
+	{
+	  fprintf(stderr, "%-8.16s  Invalid threshold values\n", ifname);
+	  return(-1);
+	}
+      /* Basic sanity check */
+      if(high_thr < low_thr)
+	{
+	  fprintf(stderr, "%-8.16s  Inverted threshold range\n", ifname);
+	  return(-1);
+	}
+      /* Copy thresholds */
+      threshold.low.level = low_thr;
+      threshold.low.updated = 0x2;
+      threshold.high.level = high_thr;
+      threshold.high.updated = 0x2;
+    }
+
+  /* Time to send thresholds to the driver */
+  wrq.u.data.pointer = (caddr_t) &threshold;
+  wrq.u.data.length = 1;
+  wrq.u.data.flags = 0;
+  if(iw_set_ext(skfd, ifname, SIOCSIWTHRSPY, &wrq) < 0)
+    {
+      fprintf(stderr, "Interface doesn't accept thresholds...\n");
+      fprintf(stderr, "SIOCSIWTHRSPY: %s\n", strerror(errno));
+      return(-1);
+    }
+
+  return(0);
+}
+
+/******************************* MAIN ********************************/
+
+/*------------------------------------------------------------------*/
+/*
+ * The main !
+ */
+int
+main(int	argc,
+     char **	argv)
+{
+  int skfd;			/* generic raw socket desc.	*/
+  int goterr = 0;
+
+  /* Create a channel to the NET kernel. */
+  if((skfd = iw_sockets_open()) < 0)
+    {
+      perror("socket");
+      return(-1);
+    }
+
+  /* No argument : show the list of all device + info */
+  if(argc == 1)
+    iw_enum_devices(skfd, &print_spy_info, NULL, 0);
+  else
+    /* Special cases take one... */
+    /* Help */
+    if((!strcmp(argv[1], "-h")) || (!strcmp(argv[1], "--help")))
+      fprintf(stderr, "Usage: iwspy interface [+] [MAC address] [IP address]\n");
+    else
+      /* Version */
+      if (!strcmp(argv[1], "-v") || !strcmp(argv[1], "--version"))
+	goterr = iw_print_version_info("iwspy");
+      else
+	/* The device name must be the first argument */
+	/* Name only : show spy list for that device only */
+	if(argc == 2)
+	  print_spy_info(skfd, argv[1], NULL, 0);
+	else
+	  /* Special commands */
+	  if(!strcmp(argv[2], "setthr"))
+	    goterr = set_spy_threshold(skfd, argv[1], argv + 3, argc - 3);
+	  else
+	    if(!strcmp(argv[2], "getthr"))
+	      goterr = get_spy_threshold(skfd, argv[1], argv + 3, argc - 3);
+	    else
+	      /* Otherwise, it's a list of address to set in the spy list */
+	      goterr = set_spy_info(skfd, argv[1], argv + 2, argc - 2);
+
+  /* Close the socket. */
+  iw_sockets_close(skfd);
+
+  return(goterr);
+}
diff --git a/macaddr.c b/macaddr.c
new file mode 100644
index 0000000..f32110c
--- /dev/null
+++ b/macaddr.c
@@ -0,0 +1,54 @@
+/*
+ *	macaddr
+ *
+ *	Program to return the MAC address of an Ethernet
+ *	adapter.  This was written to help configure the
+ *	adapter based on the MAC address rather than the
+ *	name.
+ *
+ *	Version 1.0	Eric Dittman	2001-10-19
+ *
+ *	This is released unther the GPL license.
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <sys/ioctl.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+
+#include "iwlib.h"
+
+int main(int argc, char** argv)
+{
+
+	int devsock;
+	struct ifreq ifbuffer;
+	char buf[20];
+
+	if ((argc != 2) || (argv[1][0] == '-')) {
+		printf("Usage: macaddr interface\n");
+		exit(1);
+	}
+
+	devsock = socket(AF_INET, SOCK_STREAM, 0);
+
+	if (devsock == -1) {
+		perror("Failed opening socket");
+		exit (1);
+	}
+
+	memset(&ifbuffer, 0, sizeof(ifbuffer));
+	strncpy(ifbuffer.ifr_name, argv[1], sizeof(ifbuffer.ifr_name));
+	if (ioctl(devsock, SIOCGIFHWADDR, &ifbuffer) == -1) {
+		fprintf(stderr, "There is no MACADDR for %s\n", argv[1]);
+		exit(1);
+	}
+	close(devsock);
+
+	puts(iw_saether_ntop(&ifbuffer.ifr_ifru.ifru_hwaddr, buf));
+
+	exit(0);
+}
diff --git a/sample_enc.c b/sample_enc.c
new file mode 100644
index 0000000..a1a90e2
--- /dev/null
+++ b/sample_enc.c
@@ -0,0 +1,191 @@
+/* Note : this particular snipset of code is available under
+ * the LGPL, MPL or BSD license (at your choice).
+ * Jean II
+ */
+
+/* --------------------------- INCLUDE --------------------------- */
+
+#define MAX_KEY_SIZE	16
+#define	MAX_KEYS	8
+int	key_on = 0;
+int	key_open = 1;
+int	key_current = 0;
+char	key_table[MAX_KEYS][MAX_KEY_SIZE];
+int	key_size[MAX_KEYS];
+
+/* --------------------------- HANDLERS --------------------------- */
+
+static int ioctl_set_encode(struct net_device *dev,
+			    struct iw_request_info *info,
+			    struct iw_point *erq,
+			    char *key)
+{
+  int	index = (erq->flags & IW_ENCODE_INDEX) - 1;
+
+  if (erq->length > 0)
+    {
+      /* Check the size of the key */
+      if(erq->length > MAX_KEY_SIZE)
+	return(-EINVAL);
+
+      /* Check the index */
+      if((index < 0) || (index >= MAX_KEYS))
+	index = key_current;
+
+      /* Copy the key in the driver */
+      memcpy(key_table[index], key, erq->length);
+      key_size[index] = erq->length;
+      key_on = 1;
+    }
+  else
+    {
+      /* Do we want to just set the current key ? */
+      if((index >= 0) && (index < MAX_KEYS))
+	{
+	  if(key_size[index] > 0)
+	    {
+	      key_current = index;
+	      key_on = 1;
+	    }
+	  else
+	    return(-EINVAL);
+	}
+    }
+
+  /* Read the flags */
+  if(erq->flags & IW_ENCODE_DISABLED)
+    key_on = 0;		/* disable encryption */
+  if(erq->flags & IW_ENCODE_RESTRICTED)
+    key_open = 0;	/* disable open mode */
+  if(erq->flags & IW_ENCODE_OPEN)
+    key_open = 1;	/* enable open mode */
+
+  return(0);
+}
+
+static int ioctl_get_encode(struct net_device *dev,
+			    struct iw_request_info *info,
+			    struct iw_point *erq,
+			    char *key)
+{
+  int	index = (erq->flags & IW_ENCODE_INDEX) - 1;
+
+  /* Set the flags */
+  erq->flags = 0;
+  if(key_on == 0)
+    erq->flags |= IW_ENCODE_DISABLED;
+  if(key_open == 0)
+    erq->flags |= IW_ENCODE_RESTRICTED;
+  else
+    erq->flags |= IW_ENCODE_OPEN;
+
+  /* Which key do we want */
+  if((index < 0) || (index >= MAX_KEYS))
+    index = key_current;
+  erq->flags |= index + 1;
+
+  /* Copy the key to the user buffer */
+  erq->length = key_size[index];
+  memcpy(key, key_table[index], key_size[index]);
+
+  return(0);
+}
+
+static int ioctl_get_range(struct net_device *dev,
+			   struct iw_request_info *info,
+			   struct iw_point *rrq,
+			   char *extra)
+{
+  struct iw_range *range = (struct iw_range *) extra;
+
+  rrq->length = sizeof(struct iw_range);
+
+  memset(range, 0, sizeof(struct iw_range));
+
+#if WIRELESS_EXT > 10
+  /* Version we are compiled with */
+  range->we_version_compiled = WIRELESS_EXT;
+  /* Minimum version we recommend */
+  range->we_version_source = 8;
+#endif /* WIRELESS_EXT > 10 */
+
+#if WIRELESS_EXT > 8
+  range->encoding_size[0] = 8;	/* DES = 64 bits key */
+  range->encoding_size[1] = 16;
+  range->num_encoding_sizes = 2;
+  range->max_encoding_tokens = 8;
+#endif /* WIRELESS_EXT > 8 */
+  return(0);
+}
+
+/* --------------------------- BINDING --------------------------- */
+
+#if WIRELESS_EXT > 12
+static const iw_handler		handler_table[] =
+{
+	...
+	(iw_handler) ioctl_set_encode,		/* SIOCSIWENCODE */
+	(iw_handler) ioctl_get_encode,		/* SIOCGIWENCODE */
+};
+#else	/* WIRELESS_EXT < 12 */
+static int
+do_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)
+{
+  struct iwreq *wrq = (struct iwreq *) ifr;
+  int		err = 0;
+
+  switch (cmd)
+    {
+#if WIRELESS_EXT > 8
+    case SIOCSIWENCODE:
+      {
+	char keybuf[MAX_KEY_SIZE];
+	if(wrq->u.encoding.pointer)
+	  {
+	    /* We actually have a key to set */
+	    if(wrq->u.encoding.length > MAX_KEY_SIZE)
+	      {
+		err = -E2BIG;
+		break;
+	      }
+	    if(copy_from_user(keybuf, wrq->u.encoding.pointer,
+			      wrq->u.encoding.length))
+	      {
+		err = -EFAULT;
+		break;
+	      }
+	  }
+	else
+	  if(wrq->u.encoding.length != 0)
+	    {
+	      err = -EINVAL;
+	      break;
+	    }
+	err = ioctl_set_encode(dev, NULL, &(wrq->u.encoding), keybuf);
+      }
+      break;
+
+    case SIOCGIWENCODE:
+      /* only super-user can see encryption key */
+      if(! capable(CAP_NET_ADMIN))
+	{
+	  err = -EPERM;
+	  break;
+	}
+      {
+	char keybuf[MAX_KEY_SIZE];
+	err = ioctl_get_encode(dev, NULL, &(wrq->u.encoding), keybuf);
+	if(wrq->u.encoding.pointer)
+	  {
+	    if (copy_to_user(wrq->u.encoding.pointer, keybuf,
+			     wrq->u.encoding.length))
+	      err= -EFAULT;
+	  }
+      }
+      break;
+#endif	/* WIRELESS_EXT > 8 */
+    }
+  return(err);
+}
+#endif	/* WIRELESS_EXT < 12 */
+
diff --git a/sample_pm.c b/sample_pm.c
new file mode 100644
index 0000000..ac9cb80
--- /dev/null
+++ b/sample_pm.c
@@ -0,0 +1,234 @@
+/* Note : this particular snipset of code is available under
+ * the LGPL, MPL or BSD license (at your choice).
+ * Jean II
+ */
+
+/* --------------------------- INCLUDE --------------------------- */
+
+/* Backward compatibility for Wireless Extension 9 */
+#ifndef IW_POWER_MODIFIER
+#define IW_POWER_MODIFIER	0x000F	/* Modify a parameter */
+#define IW_POWER_MIN		0x0001	/* Value is a minimum  */
+#define IW_POWER_MAX		0x0002	/* Value is a maximum */
+#define IW_POWER_RELATIVE	0x0004	/* Value is not in seconds/ms/us */
+#endif IW_POWER_MODIFIER
+
+struct net_local {
+  int		pm_on;		// Power Management enabled
+  int		pm_multi;	// Receive multicasts
+  int		pm_period;	// Power Management period
+  int		pm_period_auto;	// Power Management auto mode
+  int		pm_max_period;	// Power Management max period
+  int		pm_min_period;	// Power Management min period
+  int		pm_timeout;	// Power Management timeout
+};
+
+/* --------------------------- HANDLERS --------------------------- */
+
+static int ioctl_set_power(struct net_device *dev,
+			   struct iw_request_info *info,
+			   struct iw_param *prq,
+			   char *extra)
+{
+  /* Disable it ? */
+  if(prq->disabled)
+    {
+      local->pm_on = 0;
+    }
+  else
+    {
+      /* Check mode */
+      switch(prq->flags & IW_POWER_MODE)
+	{
+	case IW_POWER_UNICAST_R:
+	  local->pm_multi = 0;
+	  local->need_commit = 1;
+	  break;
+	case IW_POWER_ALL_R:
+	  local->pm_multi = 1;
+	  local->need_commit = 1;
+	  break;
+	case IW_POWER_ON:	/* None = ok */
+	  break;
+	default:	/* Invalid */
+	  return(-EINVAL);
+	}
+      /* Set period */
+      if(prq->flags & IW_POWER_PERIOD)
+	{
+	  int	period = prq->value;
+#if WIRELESS_EXT < 21
+	  period /= 1000000;
+#endif
+	  /* Hum: check if within bounds... */
+
+	  /* Activate PM */
+	  local->pm_on = 1;
+	  local->need_commit = 1;
+
+	  /* Check min value */
+	  if(prq->flags & IW_POWER_MIN)
+	    {
+	      local->pm_min_period = period;
+	      local->pm_period_auto = 1;
+	    }
+	  else
+	    /* Check max value */
+	    if(prq->flags & IW_POWER_MAX)
+	      {
+		local->pm_max_period = period;
+		local->pm_period_auto = 1;
+	      }
+	    else
+	      {
+		/* Fixed value */
+		local->pm_period = period;
+		local->pm_period_auto = 0;
+	      }
+	}
+      /* Set timeout */
+      if(prq->flags & IW_POWER_TIMEOUT)
+	{
+	  /* Activate PM */
+	  local->pm_on = 1;
+	  local->need_commit = 1;
+	  /* Fixed value in ms */
+	  local->pm_timeout = prq->value/1000;
+	}
+    }
+
+  return(0);
+}
+
+static int ioctl_get_power(struct net_device *dev,
+			   struct iw_request_info *info,
+			   struct iw_param *prq,
+			   char *extra)
+{
+  prq->disabled = !local->pm_on;
+  /* By default, display the period */
+  if(!(prq->flags & IW_POWER_TIMEOUT))
+    {
+      int	inc_flags = prq->flags;
+      prq->flags = IW_POWER_PERIOD | IW_POWER_RELATIVE;
+      /* Check if auto */
+      if(local->pm_period_auto)
+	{
+	  /* By default, the min */
+	  if(!(inc_flags & IW_POWER_MAX))
+	    {
+	      prq->value = local->pm_min_period;
+#if WIRELESS_EXT < 21
+	      prq->value *= 1000000;
+#endif
+	      prq->flags |= IW_POWER_MIN;
+	    }
+	  else
+	    {
+	      prq->value = local->pm_max_period;
+#if WIRELESS_EXT < 21
+	      prq->value *= 1000000;
+#endif
+	      prq->flags |= IW_POWER_MAX;
+	    }
+	}
+      else
+	{
+	  /* Fixed value. Check the flags */
+	  if(inc_flags & (IW_POWER_MIN | IW_POWER_MAX))
+	    return(-EINVAL);
+	  else
+	    {
+	      prq->value = local->pm_period;
+#if WIRELESS_EXT < 21
+	      prq->value *= 1000000;
+#endif
+	    }
+	}
+    }
+  else
+    {
+      /* Deal with the timeout - always fixed */
+      prq->flags = IW_POWER_TIMEOUT;
+      prq->value = local->pm_timeout * 1000;
+    }
+  if(local->pm_multi)
+    prq->flags |= IW_POWER_ALL_R;
+  else
+    prq->flags |= IW_POWER_UNICAST_R;
+
+  return(0);
+}
+
+static int ioctl_get_range(struct net_device *dev,
+			   struct iw_request_info *info,
+			   struct iw_point *rrq,
+			   char *extra)
+{
+  struct iw_range *range = (struct iw_range *) extra;
+
+  rrq->length = sizeof(struct iw_range);
+
+  memset(range, 0, sizeof(struct iw_range));
+
+#if WIRELESS_EXT > 10
+  /* Version we are compiled with */
+  range->we_version_compiled = WIRELESS_EXT;
+  /* Minimum version we recommend */
+  range->we_version_source = 8;
+#endif /* WIRELESS_EXT > 10 */
+
+#if WIRELESS_EXT > 9
+#if WIRELESS_EXT < 21
+      range.min_pmp = 1000000;	/* 1 units */
+      range.max_pmp = 12000000;	/* 12 units */
+#else
+      range.min_pmp = 1;	/* 1 units */
+      range.max_pmp = 12;	/* 12 units */
+#endif
+      range.min_pmt = 1000;	/* 1 ms */
+      range.max_pmt = 1000000;	/* 1 s */
+      range.pmp_flags = IW_POWER_PERIOD | IW_POWER_RELATIVE |
+        IW_POWER_MIN | IW_POWER_MAX;
+      range.pmt_flags = IW_POWER_TIMEOUT;
+      range.pm_capa = IW_POWER_PERIOD | IW_POWER_TIMEOUT | IW_POWER_UNICAST_R;
+#endif /* WIRELESS_EXT > 9 */
+  return(0);
+}
+
+/* --------------------------- BINDING --------------------------- */
+
+#if WIRELESS_EXT > 12
+/* Use the new driver API, save overhead */
+static const iw_handler		handler_table[] =
+{
+	...
+	(iw_handler) ioctl_set_power,		/* SIOCSIWPOWER */
+	(iw_handler) ioctl_get_power,		/* SIOCGIWPOWER */
+};
+#else	/* WIRELESS_EXT < 12 */
+/* Use old API in the ioctl handler */
+static int
+do_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)
+{
+  struct iwreq *wrq = (struct iwreq *) ifr;
+  int		err = 0;
+
+  switch (cmd)
+    {
+#if WIRELESS_EXT > 8
+      /* Set the desired Power Management mode */
+    case SIOCSIWPOWER:
+      err = ioctl_set_power(dev, NULL, &(wrq->u.power), NULL);
+      break;
+
+      /* Get the power management settings */
+    case SIOCGIWPOWER:
+      err = ioctl_get_power(dev, NULL, &(wrq->u.power), NULL);
+      break;
+#endif	/* WIRELESS_EXT > 8 */
+    }
+  return(err);
+}
+#endif	/* WIRELESS_EXT < 12 */
+
diff --git a/sample_priv_addr.c b/sample_priv_addr.c
new file mode 100644
index 0000000..fd5793d
--- /dev/null
+++ b/sample_priv_addr.c
@@ -0,0 +1,210 @@
+/* Note : this particular snipset of code is available under
+ * the LGPL, MPL or BSD license (at your choice).
+ * Jean II
+ */
+
+// Require Wireless Tools 25 for sub-ioctl and addr support
+
+/* --------------------------- INCLUDE --------------------------- */
+
+#if WIRELESS_EXT <= 12
+/* Wireless extensions backward compatibility */
+
+/* We need the full definition for private ioctls */
+struct iw_request_info
+{
+	__u16		cmd;		/* Wireless Extension command */
+	__u16		flags;		/* More to come ;-) */
+};
+#endif /* WIRELESS_EXT <= 12 */
+
+#ifndef IW_PRIV_TYPE_ADDR
+#define IW_PRIV_TYPE_ADDR	0x6000
+#endif	/* IW_PRIV_TYPE_ADDR */
+
+/* --------------------------- HANDLERS --------------------------- */
+
+/* First method : using sub-ioctls.
+ * Note that sizeof(int + struct sockaddr) = 20 > 16, therefore the
+ * data is passed in (char *) extra, and sub-ioctl in data->flags. */
+static int sample_ioctl_set_mac(struct net_device *dev,
+				struct iw_request_info *info,
+				struct iw_point *data,
+				struct sockaddr *mac_addr)
+{
+	unsigned char *	addr = (char *) &mac_addr->sa_data;
+
+	switch(data->flags) {
+	case 0:
+		printk(KERN_DEBUG "%s: mac_add %02X:%02X:%02X:%02X:%02X:%02X\n", dev->name, addr[0], addr[1], addr[2], addr[3], addr[4], addr[5]);
+		break;
+	case 1:
+		printk(KERN_DEBUG "%s: mac_del %02X:%02X:%02X:%02X:%02X:%02X\n", dev->name, addr[0], addr[1], addr[2], addr[3], addr[4], addr[5]);
+		break;
+	case 2:
+		printk(KERN_DEBUG "%s: mac_kick %02X:%02X:%02X:%02X:%02X:%02X\n", dev->name, addr[0], addr[1], addr[2], addr[3], addr[4], addr[5]);
+		break;
+	default:
+		printk(KERN_DEBUG "%s: mac_undefined %02X:%02X:%02X:%02X:%02X:%02X\n", dev->name, addr[0], addr[1], addr[2], addr[3], addr[4], addr[5]);
+		break;
+	}
+
+	return 0;
+}
+
+/* Second method : bind single handler to multiple ioctls.
+ * Note that sizeof(struct sockaddr) = 16 <= 16, therefore the
+ * data is passed in (struct iwreq) (and also mapped in extra).
+ */
+static int sample_ioctl_set_addr(struct net_device *dev,
+				 struct iw_request_info *info,
+				 struct sockaddr *mac_addr, char *extra)
+{
+	unsigned char *	addr = (char *) &mac_addr->sa_data;
+
+	switch(info->cmd) {
+	case SIOCIWFIRSTPRIV + 28:
+		printk(KERN_DEBUG "%s: addr_add %02X:%02X:%02X:%02X:%02X:%02X\n", dev->name, addr[0], addr[1], addr[2], addr[3], addr[4], addr[5]);
+		break;
+	case SIOCIWFIRSTPRIV + 30:
+		printk(KERN_DEBUG "%s: addr_del %02X:%02X:%02X:%02X:%02X:%02X\n", dev->name, addr[0], addr[1], addr[2], addr[3], addr[4], addr[5]);
+		break;
+	default:
+		printk(KERN_DEBUG "%s: mac_undefined %02X:%02X:%02X:%02X:%02X:%02X\n", dev->name, addr[0], addr[1], addr[2], addr[3], addr[4], addr[5]);
+		break;
+	}
+
+	return 0;
+}
+
+// Extra fun for testing
+static int sample_ioctl_get_mac(struct net_device *dev,
+				struct iw_request_info *info,
+				struct iw_point *data,
+				struct sockaddr *mac_addr)
+{
+	unsigned char	fake_addr[6];
+	int		i;
+	int		j;
+
+	for(i = 0; i < 16; i++) {
+		/* Create a fake address */
+		for(j = 0; j < 6; j++)
+			fake_addr[j] = (unsigned char) ((j << 4) + i);
+		/* Put in in the table */
+		memcpy(&(mac_addr[i]).sa_data, fake_addr, ETH_ALEN);
+		mac_addr[i].sa_family = ARPHRD_ETHER;
+	}
+	data->length = 16;
+
+	return 0;
+}
+
+static int sample_ioctl_set_float(struct net_device *dev,
+				  struct iw_request_info *info,
+				  struct iw_freq *freq, char *extra)
+{
+	printk(KERN_DEBUG "%s: set_float %d;%d\n",
+	       dev->name, freq->m, freq->e);
+
+	return 0;
+}
+
+/* --------------------------- BINDING --------------------------- */
+
+static const struct iw_priv_args sample_priv[] = {
+	// *** Method 1 : using sub-ioctls ***
+	/* --- sub-ioctls handler --- */
+	{ SIOCIWFIRSTPRIV + 0,
+	  IW_PRIV_TYPE_ADDR | IW_PRIV_SIZE_FIXED | 1, 0, "" },
+	/* --- sub-ioctls definitions --- */
+	{ 0,
+	  IW_PRIV_TYPE_ADDR | IW_PRIV_SIZE_FIXED | 1, 0, "macadd" },
+	{ 1,
+	  IW_PRIV_TYPE_ADDR | IW_PRIV_SIZE_FIXED | 1, 0, "macdel" },
+	{ 2,
+	  IW_PRIV_TYPE_ADDR | IW_PRIV_SIZE_FIXED | 1, 0, "mackick" },
+	// *** Method 2 : binding one handler to multiple ioctls ***
+	{ SIOCIWFIRSTPRIV + 2,
+	  IW_PRIV_TYPE_ADDR | IW_PRIV_SIZE_FIXED | 1, 0, "addradd" },
+	{ SIOCIWFIRSTPRIV + 4,
+	  IW_PRIV_TYPE_ADDR | IW_PRIV_SIZE_FIXED | 1, 0, "addrdel" },
+	// *** Extra fun ***
+	{ SIOCIWFIRSTPRIV + 1,
+	  0, IW_PRIV_TYPE_ADDR | 16, "macget" },
+	{ SIOCIWFIRSTPRIV + 6,
+	  IW_PRIV_TYPE_FLOAT | IW_PRIV_SIZE_FIXED | 1, 0, "setfloat" },
+};
+
+static const iw_handler sample_private_handler[] =
+{							/* SIOCIWFIRSTPRIV + */
+#if WIRELESS_EXT >= 15
+	/* Various little annoying bugs in the new API before
+	 * version 15 make it difficult to use the new API for those ioctls.
+	 * For example, it doesn't know about the new data type.
+	 * Rather than littering the code with workarounds,
+	 * let's use the regular ioctl handler. - Jean II */
+	(iw_handler) sample_ioctl_set_mac,		/* 0 */
+	(iw_handler) sample_ioctl_get_mac,		/* 1 */
+	(iw_handler) sample_ioctl_set_addr,		/* 2 */
+	(iw_handler) NULL,				/* 3 */
+	(iw_handler) sample_ioctl_set_addr,		/* 4 */
+	(iw_handler) NULL,				/* 5 */
+	(iw_handler) sample_ioctl_set_float,		/* 6 */
+#endif	/* WIRELESS_EXT >= 15 */
+};
+
+#if WIRELESS_EXT < 15
+		/* Various little annoying bugs in the new API before
+		 * version 15 make it difficult to use those ioctls.
+		 * For example, it doesn't know about the new data type.
+		 * Rather than littering the code with workarounds,
+		 * let's use this code that just works. - Jean II */
+	case SIOCIWFIRSTPRIV + 0:
+		if (wrq->u.data.length > 1)
+			ret = -E2BIG;
+		else if (wrq->u.data.pointer) {
+			struct sockaddr mac_addr;
+			if (copy_from_user(&mac_addr, wrq->u.data.pointer,
+					   sizeof(struct sockaddr))) {
+				ret = -EFAULT;
+				break;
+			}
+			ret = sample_ioctl_set_mac(dev, NULL, &wrq->u.data,
+						   &mac_addr);
+		}
+		break;
+	case SIOCIWFIRSTPRIV + 2:
+	case SIOCIWFIRSTPRIV + 4:
+		if (!capable(CAP_NET_ADMIN))
+			ret = -EPERM;
+		else {
+			struct iw_request_info info;
+			info.cmd = cmd;
+			ret = sample_ioctl_set_addr(dev, &info,
+						    &wrq->u.ap_addr,
+						    NULL);
+		}
+		break;
+	case SIOCIWFIRSTPRIV + 1:
+		if (wrq->u.essid.pointer) {
+			struct sockaddr mac_addr[16];
+			char nickbuf[IW_ESSID_MAX_SIZE + 1];
+			ret = sample_ioctl_get_mac(dev, NULL, &wrq->u.data,
+						   mac_addr);
+			if (copy_to_user(wrq->u.data.pointer, nickbuf,
+					 wrq->u.data.length *
+					 sizeof(struct sockaddr)))
+				ret = -EFAULT;
+		}
+		break;
+	case SIOCIWFIRSTPRIV + 6:
+		if (!capable(CAP_NET_ADMIN))
+			ret = -EPERM;
+		else {
+			ret = sample_ioctl_set_float(dev, NULL,
+						     &wrq->u.freq,
+						     NULL);
+		}
+		break;
+#endif	/* WIRELESS_EXT < 15 */
diff --git a/udev.import_devpath.diff b/udev.import_devpath.diff
new file mode 100644
index 0000000..87c954b
--- /dev/null
+++ b/udev.import_devpath.diff
@@ -0,0 +1,39 @@
+diff -u -p udev-106/udev_rules.j1.c udev-106/udev_rules.c
+--- udev-106/udev_rules.j1.c	2007-03-15 10:07:51.000000000 -0700
++++ udev-106/udev_rules.c	2007-03-15 10:09:50.000000000 -0700
+@@ -186,7 +186,16 @@ static int import_keys_into_env(struct u
+ 		linepos = line;
+ 		if (get_key(&linepos, &variable, &value) == 0) {
+ 			dbg("import '%s=%s'", variable, value);
+-			name_list_key_add(&udev->env_list, variable, value);
++			/* handle device, renamed by external tool,
++			 * returning new path */
++			if (strcmp(variable, "DEVPATH") == 0) {
++				info("updating devpath from '%s' to '%s'",
++				     udev->dev->devpath, value);
++				sysfs_device_set_values(udev->dev, value,
++							NULL, NULL);
++			} else
++				name_list_key_add(&udev->env_list,
++						  variable, value);
+ 			setenv(variable, value, 1);
+ 		}
+ 	}
+diff -u -p udev-106/udevtest.j1.c udev-106/udevtest.c
+--- udev-106/udevtest.j1.c	2007-03-15 10:39:16.000000000 -0700
++++ udev-106/udevtest.c	2007-03-15 10:42:09.000000000 -0700
+@@ -59,8 +59,13 @@ int main(int argc, char *argv[], char *e
+ 
+ 	info("version %s", UDEV_VERSION);
+ 	udev_config_init();
+-	if (udev_log_priority < LOG_INFO)
++	if (udev_log_priority < LOG_INFO) {
++		char priority[32];
++
+ 		udev_log_priority = LOG_INFO;
++		sprintf(priority, "%i", udev_log_priority);
++		setenv("UDEV_LOG", priority, 1);
++	}
+ 
+ 	for (i = 1 ; i < argc; i++) {
+ 		char *arg = argv[i];
diff --git a/wireless.10.h b/wireless.10.h
new file mode 100644
index 0000000..c552ff2
--- /dev/null
+++ b/wireless.10.h
@@ -0,0 +1,479 @@
+/*
+ * This file define a set of standard wireless extensions
+ *
+ * Version :	9	16.10.99
+ *
+ * Authors :	Jean Tourrilhes - HPL - <jt@hpl.hp.com>
+ */
+
+#ifndef _LINUX_WIRELESS_H
+#define _LINUX_WIRELESS_H
+
+/************************** DOCUMENTATION **************************/
+/*
+ * Basically, the wireless extensions are for now a set of standard ioctl
+ * call + /proc/net/wireless
+ *
+ * The entry /proc/net/wireless give statistics and information on the
+ * driver.
+ * This is better than having each driver having its entry because
+ * its centralised and we may remove the driver module safely.
+ *
+ * Ioctl are used to configure the driver and issue commands.  This is
+ * better than command line options of insmod because we may want to
+ * change dynamically (while the driver is running) some parameters.
+ *
+ * The ioctl mechanimsm are copied from standard devices ioctl.
+ * We have the list of command plus a structure descibing the
+ * data exchanged...
+ * Note that to add these ioctl, I was obliged to modify :
+ *	net/core/dev.c (two place + add include)
+ *	net/ipv4/af_inet.c (one place + add include)
+ *
+ * /proc/net/wireless is a copy of /proc/net/dev.
+ * We have a structure for data passed from the driver to /proc/net/wireless
+ * Too add this, I've modified :
+ *	net/core/dev.c (two other places)
+ *	include/linux/netdevice.h (one place)
+ *	include/linux/proc_fs.h (one place)
+ *
+ * Do not add here things that are redundant with other mechanisms
+ * (drivers init, ifconfig, /proc/net/dev, ...) and with are not
+ * wireless specific.
+ *
+ * These wireless extensions are not magic : each driver has to provide
+ * support for them...
+ *
+ * IMPORTANT NOTE : As everything in the kernel, this is very much a
+ * work in progress. Contact me if you have ideas of improvements...
+ */
+
+/***************************** INCLUDES *****************************/
+
+#include <linux/types.h>		/* for "caddr_t" et al		*/
+#include <linux/socket.h>		/* for "struct sockaddr" et al	*/
+#include <linux/if.h>			/* for IFNAMSIZ and co... */
+
+/**************************** CONSTANTS ****************************/
+
+/* --------------------------- VERSION --------------------------- */
+/*
+ * This constant is used to know the availability of the wireless
+ * extensions and to know which version of wireless extensions it is
+ * (there is some stuff that will be added in the future...)
+ * I just plan to increment with each new version.
+ */
+#define WIRELESS_EXT	10
+
+/*
+ * Changes :
+ *
+ * V2 to V3
+ * --------
+ *	Alan Cox start some incompatibles changes. I've integrated a bit more.
+ *	- Encryption renamed to Encode to avoid US regulation problems
+ *	- Frequency changed from float to struct to avoid problems on old 386
+ *
+ * V3 to V4
+ * --------
+ *	- Add sensitivity
+ *
+ * V4 to V5
+ * --------
+ *	- Missing encoding definitions in range
+ *	- Access points stuff
+ *
+ * V5 to V6
+ * --------
+ *	- 802.11 support (ESSID ioctls)
+ *
+ * V6 to V7
+ * --------
+ *	- define IW_ESSID_MAX_SIZE and IW_MAX_AP
+ *
+ * V7 to V8
+ * --------
+ *	- Changed my e-mail address
+ *	- More 802.11 support (nickname, rate, rts, frag)
+ *	- List index in frequencies
+ *
+ * V8 to V9
+ * --------
+ *	- Support for 'mode of operation' (ad-hoc, managed...)
+ *	- Support for unicast and multicast power saving
+ *	- Change encoding to support larger tokens (>64 bits)
+ *	- Updated iw_params (disable, flags) and use it for NWID
+ *	- Extracted iw_point from iwreq for clarity
+ *
+ * V9 to V10
+ * ---------
+ *	- Add PM capability to range structure
+ *	- Add PM modifier : MAX/MIN/RELATIVE
+ *	- Add encoding option : IW_ENCODE_NOKEY
+ *	- Add TxPower ioctls (work like TxRate)
+ */
+
+/* -------------------------- IOCTL LIST -------------------------- */
+
+/* Basic operations */
+#define SIOCSIWNAME	0x8B00		/* Unused */
+#define SIOCGIWNAME	0x8B01		/* get name == wireless protocol */
+#define SIOCSIWNWID	0x8B02		/* set network id (the cell) */
+#define SIOCGIWNWID	0x8B03		/* get network id */
+#define SIOCSIWFREQ	0x8B04		/* set channel/frequency (Hz) */
+#define SIOCGIWFREQ	0x8B05		/* get channel/frequency (Hz) */
+#define SIOCSIWMODE	0x8B06		/* set operation mode */
+#define SIOCGIWMODE	0x8B07		/* get operation mode */
+#define SIOCSIWSENS	0x8B08		/* set sensitivity (dBm) */
+#define SIOCGIWSENS	0x8B09		/* get sensitivity (dBm) */
+
+/* Informative stuff */
+#define SIOCSIWRANGE	0x8B0A		/* Unused */
+#define SIOCGIWRANGE	0x8B0B		/* Get range of parameters */
+#define SIOCSIWPRIV	0x8B0C		/* Unused */
+#define SIOCGIWPRIV	0x8B0D		/* get private ioctl interface info */
+
+/* Mobile IP support */
+#define SIOCSIWSPY	0x8B10		/* set spy addresses */
+#define SIOCGIWSPY	0x8B11		/* get spy info (quality of link) */
+
+/* Access Point manipulation */
+#define SIOCSIWAP	0x8B14		/* set access point MAC addresses */
+#define SIOCGIWAP	0x8B15		/* get access point MAC addresses */
+#define SIOCGIWAPLIST	0x8B17		/* get list of access point in range */
+
+/* 802.11 specific support */
+#define SIOCSIWESSID	0x8B1A		/* set ESSID (network name) */
+#define SIOCGIWESSID	0x8B1B		/* get ESSID */
+#define SIOCSIWNICKN	0x8B1C		/* set node name/nickname */
+#define SIOCGIWNICKN	0x8B1D		/* get node name/nickname */
+/* As the ESSID and NICKN are strings up to 32 bytes long, it doesn't fit
+ * within the 'iwreq' structure, so we need to use the 'data' member to
+ * point to a string in user space, like it is done for RANGE...
+ * The "flags" member indicate if the ESSID is active or not (promiscuous).
+ */
+
+/* Other parameters usefull in 802.11 and some other devices */
+#define SIOCSIWRATE	0x8B20		/* set default bit rate (bps) */
+#define SIOCGIWRATE	0x8B21		/* get default bit rate (bps) */
+#define SIOCSIWRTS	0x8B22		/* set RTS/CTS threshold (bytes) */
+#define SIOCGIWRTS	0x8B23		/* get RTS/CTS threshold (bytes) */
+#define SIOCSIWFRAG	0x8B24		/* set fragmentation thr (bytes) */
+#define SIOCGIWFRAG	0x8B25		/* get fragmentation thr (bytes) */
+#define SIOCSIWTXPOW	0x8B26		/* set transmit power (dBm) */
+#define SIOCGIWTXPOW	0x8B27		/* get transmit power (dBm) */
+
+/* Encoding stuff (scrambling, hardware security, WEP...) */
+#define SIOCSIWENCODE	0x8B2A		/* set encoding token & mode */
+#define SIOCGIWENCODE	0x8B2B		/* get encoding token & mode */
+/* Power saving stuff (power management, unicast and multicast) */
+#define SIOCSIWPOWER	0x8B2C		/* set Power Management settings */
+#define SIOCGIWPOWER	0x8B2D		/* get Power Management settings */
+
+/* ------------------------- IOCTL STUFF ------------------------- */
+
+/* The first and the last (range) */
+#define SIOCIWFIRST	0x8B00
+#define SIOCIWLAST	0x8B30
+
+/* Even : get (world access), odd : set (root access) */
+#define IW_IS_SET(cmd)	(!((cmd) & 0x1))
+#define IW_IS_GET(cmd)	((cmd) & 0x1)
+
+/* ------------------------- PRIVATE INFO ------------------------- */
+/*
+ * The following is used with SIOCGIWPRIV. It allow a driver to define
+ * the interface (name, type of data) for its private ioctl.
+ * Privates ioctl are SIOCDEVPRIVATE -> SIOCDEVPRIVATE + 0xF
+ */
+
+#define IW_PRIV_TYPE_MASK	0x7000	/* Type of arguments */
+#define IW_PRIV_TYPE_NONE	0x0000
+#define IW_PRIV_TYPE_BYTE	0x1000	/* Char as number */
+#define IW_PRIV_TYPE_CHAR	0x2000	/* Char as character */
+#define IW_PRIV_TYPE_INT	0x4000	/* 32 bits int */
+#define IW_PRIV_TYPE_FLOAT	0x5000
+
+#define IW_PRIV_SIZE_FIXED	0x0800	/* Variable or fixed nuber of args */
+
+#define IW_PRIV_SIZE_MASK	0x07FF	/* Max number of those args */
+
+/*
+ * Note : if the number of args is fixed and the size < 16 octets,
+ * instead of passing a pointer we will put args in the iwreq struct...
+ */
+
+/* ----------------------- OTHER CONSTANTS ----------------------- */
+
+/* Maximum frequencies in the range struct */
+#define IW_MAX_FREQUENCIES	16
+/* Note : if you have something like 80 frequencies,
+ * don't increase this constant and don't fill the frequency list.
+ * The user will be able to set by channel anyway... */
+
+/* Maximum bit rates in the range struct */
+#define IW_MAX_BITRATES		8
+
+/* Maximum tx powers in the range struct */
+#define IW_MAX_TXPOWER		8
+
+/* Maximum of address that you may set with SPY */
+#define IW_MAX_SPY		8
+
+/* Maximum of address that you may get in the
+   list of access points in range */
+#define IW_MAX_AP		8
+
+/* Maximum size of the ESSID and NICKN strings */
+#define IW_ESSID_MAX_SIZE	32
+
+/* Modes of operation */
+#define IW_MODE_AUTO	0	/* Let the driver decides */
+#define IW_MODE_ADHOC	1	/* Single cell network */
+#define IW_MODE_INFRA	2	/* Multi cell network, roaming, ... */
+#define IW_MODE_MASTER	3	/* Synchronisation master or Access Point */
+#define IW_MODE_REPEAT	4	/* Wireless Repeater (forwarder) */
+#define IW_MODE_SECOND	5	/* Secondary master/repeater (backup) */
+
+/* Maximum number of size of encoding token available
+ * they are listed in the range structure */
+#define IW_MAX_ENCODING_SIZES	8
+
+/* Maximum size of the encoding token in bytes */
+#define IW_ENCODING_TOKEN_MAX	32	/* 256 bits (for now) */
+
+/* Flags for encoding (along with the token) */
+#define IW_ENCODE_INDEX		0x00FF	/* Token index (if needed) */
+#define IW_ENCODE_FLAGS		0xFF00	/* Flags defined below */
+#define IW_ENCODE_MODE		0xF000	/* Modes defined below */
+#define IW_ENCODE_DISABLED	0x8000	/* Encoding disabled */
+#define IW_ENCODE_ENABLED	0x0000	/* Encoding enabled */
+#define IW_ENCODE_RESTRICTED	0x4000	/* Refuse non-encoded packets */
+#define IW_ENCODE_OPEN		0x2000	/* Accept non-encoded packets */
+#define IW_ENCODE_NOKEY         0x0800  /* Key is write only, so not present */
+
+/* Power management flags available (along with the value, if any) */
+#define IW_POWER_ON		0x0000	/* No details... */
+#define IW_POWER_TYPE		0xF000	/* Type of parameter */
+#define IW_POWER_PERIOD		0x1000	/* Value is a period/duration of  */
+#define IW_POWER_TIMEOUT	0x2000	/* Value is a timeout (to go asleep) */
+#define IW_POWER_MODE		0x0F00	/* Power Management mode */
+#define IW_POWER_UNICAST_R	0x0100	/* Receive only unicast messages */
+#define IW_POWER_MULTICAST_R	0x0200	/* Receive only multicast messages */
+#define IW_POWER_ALL_R		0x0300	/* Receive all messages though PM */
+#define IW_POWER_FORCE_S	0x0400	/* Force PM procedure for sending unicast */
+#define IW_POWER_REPEATER	0x0800	/* Repeat broadcast messages in PM period */
+#define IW_POWER_MODIFIER	0x000F	/* Modify a parameter */
+#define IW_POWER_MIN		0x0001	/* Value is a minimum  */
+#define IW_POWER_MAX		0x0002	/* Value is a maximum */
+#define IW_POWER_RELATIVE	0x0004	/* Value is not in seconds/ms/us */
+
+/* Transmit Power flags available */
+#define IW_TXPOW_DBM		0x0000	/* Value is in dBm */
+#define IW_TXPOW_MWATT		0x0001	/* Value is in mW */
+
+/****************************** TYPES ******************************/
+
+/* --------------------------- SUBTYPES --------------------------- */
+/*
+ *	Generic format for most parameters that fit in an int
+ */
+struct	iw_param
+{
+  __s32		value;		/* The value of the parameter itself */
+  __u8		fixed;		/* Hardware should not use auto select */
+  __u8		disabled;	/* Disable the feature */
+  __u16		flags;		/* Various specifc flags (if any) */
+};
+
+/*
+ *	For all data larger than 16 octets, we need to use a
+ *	pointer to memory alocated in user space.
+ */
+struct	iw_point
+{
+  caddr_t	pointer;	/* Pointer to the data  (in user space) */
+  __u16		length;		/* number of fields or size in bytes */
+  __u16		flags;		/* Optional params */
+};
+
+/*
+ *	A frequency
+ *	For numbers lower than 10^9, we encode the number in 'm' and
+ *	set 'e' to 0
+ *	For number greater than 10^9, we divide it by the lowest power
+ *	of 10 to get 'm' lower than 10^9, with 'm'= f / (10^'e')...
+ *	The power of 10 is in 'e', the result of the division is in 'm'.
+ */
+struct	iw_freq
+{
+	__u32		m;		/* Mantissa */
+	__u16		e;		/* Exponent */
+	__u8		i;		/* List index (when in range struct) */
+};
+
+/*
+ *	Quality of the link
+ */
+struct	iw_quality
+{
+	__u8		qual;		/* link quality (%retries, SNR or better...) */
+	__u8		level;		/* signal level */
+	__u8		noise;		/* noise level */
+	__u8		updated;	/* Flags to know if updated */
+};
+
+/*
+ *	Packet discarded in the wireless adapter due to
+ *	"wireless" specific problems...
+ */
+struct	iw_discarded
+{
+	__u32		nwid;		/* Wrong nwid */
+	__u32		code;		/* Unable to code/decode */
+	__u32		misc;		/* Others cases */
+};
+
+/* ------------------------ WIRELESS STATS ------------------------ */
+/*
+ * Wireless statistics (used for /proc/net/wireless)
+ */
+struct	iw_statistics
+{
+	__u16		status;		/* Status
+					 * - device dependent for now */
+
+	struct iw_quality	qual;		/* Quality of the link
+						 * (instant/mean/max) */
+	struct iw_discarded	discard;	/* Packet discarded counts */
+};
+
+/* ------------------------ IOCTL REQUEST ------------------------ */
+/*
+ * The structure to exchange data for ioctl.
+ * This structure is the same as 'struct ifreq', but (re)defined for
+ * convenience...
+ *
+ * Note that it should fit on the same memory footprint !
+ * You should check this when increasing the above structures (16 octets)
+ * 16 octets = 128 bits. Warning, pointers might be 64 bits wide...
+ */
+struct	iwreq 
+{
+	union
+	{
+		char	ifrn_name[IFNAMSIZ];	/* if name, e.g. "eth0" */
+	} ifr_ifrn;
+
+	/* Data part */
+	union
+	{
+		/* Config - generic */
+		char		name[IFNAMSIZ];
+		/* Name : used to verify the presence of  wireless extensions.
+		 * Name of the protocol/provider... */
+
+		struct iw_point	essid;	/* Extended network name */
+		struct iw_param	nwid;	/* network id (or domain - the cell) */
+		struct iw_freq	freq;	/* frequency or channel :
+					 * 0-1000 = channel
+					 * > 1000 = frequency in Hz */
+
+		struct iw_param	sens;		/* signal level threshold */
+		struct iw_param	bitrate;	/* default bit rate */
+		struct iw_param	txpower;	/* default transmit power */
+		struct iw_param	rts;		/* RTS threshold threshold */
+		struct iw_param	frag;		/* Fragmentation threshold */
+		__u32		mode;		/* Operation mode */
+
+		struct iw_point	encoding;	/* Encoding stuff : tokens */
+		struct iw_param	power;		/* PM duration/timeout */
+
+		struct sockaddr	ap_addr;	/* Access point address */
+
+		struct iw_point	data;		/* Other large parameters */
+	}	u;
+};
+
+/* -------------------------- IOCTL DATA -------------------------- */
+/*
+ *	For those ioctl which want to exchange mode data that what could
+ *	fit in the above structure...
+ */
+
+/*
+ *	Range of parameters
+ */
+
+struct	iw_range
+{
+	/* Informative stuff (to choose between different interface) */
+	__u32		throughput;	/* To give an idea... */
+	/* In theory this value should be the maximum benchmarked
+	 * TCP/IP throughput, because with most of these devices the
+	 * bit rate is meaningless (overhead an co) to estimate how
+	 * fast the connection will go and pick the fastest one.
+	 * I suggest people to play with Netperf or any benchmark...
+	 */
+
+	/* NWID (or domain id) */
+	__u32		min_nwid;	/* Minimal NWID we are able to set */
+	__u32		max_nwid;	/* Maximal NWID we are able to set */
+
+	/* Frequency */
+	__u16		num_channels;	/* Number of channels [0; num - 1] */
+	__u8		num_frequency;	/* Number of entry in the list */
+	struct iw_freq	freq[IW_MAX_FREQUENCIES];	/* list */
+	/* Note : this frequency list doesn't need to fit channel numbers */
+
+	/* signal level threshold range */
+	__s32	sensitivity;
+
+	/* Quality of link & SNR stuff */
+	struct iw_quality	max_qual;	/* Quality of the link */
+
+	/* Rates */
+	__u8		num_bitrates;	/* Number of entries in the list */
+	__s32		bitrate[IW_MAX_BITRATES];	/* list, in bps */
+
+	/* RTS threshold */
+	__s32		min_rts;	/* Minimal RTS threshold */
+	__s32		max_rts;	/* Maximal RTS threshold */
+
+	/* Frag threshold */
+	__s32		min_frag;	/* Minimal frag threshold */
+	__s32		max_frag;	/* Maximal frag threshold */
+
+	/* Power Management duration & timeout */
+	__s32		min_pmp;	/* Minimal PM period */
+	__s32		max_pmp;	/* Maximal PM period */
+	__s32		min_pmt;	/* Minimal PM timeout */
+	__s32		max_pmt;	/* Maximal PM timeout */
+	__u16		pmp_flags;	/* How to decode max/min PM period */
+	__u16		pmt_flags;	/* How to decode max/min PM timeout */
+	__u16		pm_capa;	/* What PM options are supported */
+
+	/* Encoder stuff */
+	__u16	encoding_size[IW_MAX_ENCODING_SIZES];	/* Different token sizes */
+	__u8	num_encoding_sizes;	/* Number of entry in the list */
+	__u8	max_encoding_tokens;	/* Max number of tokens */
+
+	/* Transmit power */
+	__u16		txpower_capa;	/* What options are supported */
+	__u8		num_txpower;	/* Number of entries in the list */
+	__s32		txpower[IW_MAX_TXPOWER];	/* list, in bps */
+};
+
+/*
+ * Private ioctl interface information
+ */
+ 
+struct	iw_priv_args
+{
+	__u32		cmd;		/* Number of the ioctl to issue */
+	__u16		set_args;	/* Type and number of args */
+	__u16		get_args;	/* Type and number of args */
+	char		name[IFNAMSIZ];	/* Name of the extension */
+};
+
+#endif	/* _LINUX_WIRELESS_H */
diff --git a/wireless.11.h b/wireless.11.h
new file mode 100644
index 0000000..fe42409
--- /dev/null
+++ b/wireless.11.h
@@ -0,0 +1,510 @@
+/*
+ * This file define a set of standard wireless extensions
+ *
+ * Version :	11	28.3.01
+ *
+ * Authors :	Jean Tourrilhes - HPL - <jt@hpl.hp.com>
+ */
+
+#ifndef _LINUX_WIRELESS_H
+#define _LINUX_WIRELESS_H
+
+/************************** DOCUMENTATION **************************/
+/*
+ * Basically, the wireless extensions are for now a set of standard ioctl
+ * call + /proc/net/wireless
+ *
+ * The entry /proc/net/wireless give statistics and information on the
+ * driver.
+ * This is better than having each driver having its entry because
+ * its centralised and we may remove the driver module safely.
+ *
+ * Ioctl are used to configure the driver and issue commands.  This is
+ * better than command line options of insmod because we may want to
+ * change dynamically (while the driver is running) some parameters.
+ *
+ * The ioctl mechanimsm are copied from standard devices ioctl.
+ * We have the list of command plus a structure descibing the
+ * data exchanged...
+ * Note that to add these ioctl, I was obliged to modify :
+ *	net/core/dev.c (two place + add include)
+ *	net/ipv4/af_inet.c (one place + add include)
+ *
+ * /proc/net/wireless is a copy of /proc/net/dev.
+ * We have a structure for data passed from the driver to /proc/net/wireless
+ * Too add this, I've modified :
+ *	net/core/dev.c (two other places)
+ *	include/linux/netdevice.h (one place)
+ *	include/linux/proc_fs.h (one place)
+ *
+ * Do not add here things that are redundant with other mechanisms
+ * (drivers init, ifconfig, /proc/net/dev, ...) and with are not
+ * wireless specific.
+ *
+ * These wireless extensions are not magic : each driver has to provide
+ * support for them...
+ *
+ * IMPORTANT NOTE : As everything in the kernel, this is very much a
+ * work in progress. Contact me if you have ideas of improvements...
+ */
+
+/***************************** INCLUDES *****************************/
+
+#include <linux/types.h>		/* for "caddr_t" et al		*/
+#include <linux/socket.h>		/* for "struct sockaddr" et al	*/
+#include <linux/if.h>			/* for IFNAMSIZ and co... */
+
+/**************************** CONSTANTS ****************************/
+
+/* --------------------------- VERSION --------------------------- */
+/*
+ * This constant is used to know the availability of the wireless
+ * extensions and to know which version of wireless extensions it is
+ * (there is some stuff that will be added in the future...)
+ * I just plan to increment with each new version.
+ */
+#define WIRELESS_EXT	11
+
+/*
+ * Changes :
+ *
+ * V2 to V3
+ * --------
+ *	Alan Cox start some incompatibles changes. I've integrated a bit more.
+ *	- Encryption renamed to Encode to avoid US regulation problems
+ *	- Frequency changed from float to struct to avoid problems on old 386
+ *
+ * V3 to V4
+ * --------
+ *	- Add sensitivity
+ *
+ * V4 to V5
+ * --------
+ *	- Missing encoding definitions in range
+ *	- Access points stuff
+ *
+ * V5 to V6
+ * --------
+ *	- 802.11 support (ESSID ioctls)
+ *
+ * V6 to V7
+ * --------
+ *	- define IW_ESSID_MAX_SIZE and IW_MAX_AP
+ *
+ * V7 to V8
+ * --------
+ *	- Changed my e-mail address
+ *	- More 802.11 support (nickname, rate, rts, frag)
+ *	- List index in frequencies
+ *
+ * V8 to V9
+ * --------
+ *	- Support for 'mode of operation' (ad-hoc, managed...)
+ *	- Support for unicast and multicast power saving
+ *	- Change encoding to support larger tokens (>64 bits)
+ *	- Updated iw_params (disable, flags) and use it for NWID
+ *	- Extracted iw_point from iwreq for clarity
+ *
+ * V9 to V10
+ * ---------
+ *	- Add PM capability to range structure
+ *	- Add PM modifier : MAX/MIN/RELATIVE
+ *	- Add encoding option : IW_ENCODE_NOKEY
+ *	- Add TxPower ioctls (work like TxRate)
+ *
+ * V10 to V11
+ * ----------
+ *	- Add WE version in range (help backward/forward compatibility)
+ *	- Add retry ioctls (work like PM)
+ */
+
+/* -------------------------- IOCTL LIST -------------------------- */
+
+/* Basic operations */
+#define SIOCSIWNAME	0x8B00		/* Unused */
+#define SIOCGIWNAME	0x8B01		/* get name == wireless protocol */
+#define SIOCSIWNWID	0x8B02		/* set network id (the cell) */
+#define SIOCGIWNWID	0x8B03		/* get network id */
+#define SIOCSIWFREQ	0x8B04		/* set channel/frequency (Hz) */
+#define SIOCGIWFREQ	0x8B05		/* get channel/frequency (Hz) */
+#define SIOCSIWMODE	0x8B06		/* set operation mode */
+#define SIOCGIWMODE	0x8B07		/* get operation mode */
+#define SIOCSIWSENS	0x8B08		/* set sensitivity (dBm) */
+#define SIOCGIWSENS	0x8B09		/* get sensitivity (dBm) */
+
+/* Informative stuff */
+#define SIOCSIWRANGE	0x8B0A		/* Unused */
+#define SIOCGIWRANGE	0x8B0B		/* Get range of parameters */
+#define SIOCSIWPRIV	0x8B0C		/* Unused */
+#define SIOCGIWPRIV	0x8B0D		/* get private ioctl interface info */
+
+/* Mobile IP support */
+#define SIOCSIWSPY	0x8B10		/* set spy addresses */
+#define SIOCGIWSPY	0x8B11		/* get spy info (quality of link) */
+
+/* Access Point manipulation */
+#define SIOCSIWAP	0x8B14		/* set access point MAC addresses */
+#define SIOCGIWAP	0x8B15		/* get access point MAC addresses */
+#define SIOCGIWAPLIST	0x8B17		/* get list of access point in range */
+
+/* 802.11 specific support */
+#define SIOCSIWESSID	0x8B1A		/* set ESSID (network name) */
+#define SIOCGIWESSID	0x8B1B		/* get ESSID */
+#define SIOCSIWNICKN	0x8B1C		/* set node name/nickname */
+#define SIOCGIWNICKN	0x8B1D		/* get node name/nickname */
+/* As the ESSID and NICKN are strings up to 32 bytes long, it doesn't fit
+ * within the 'iwreq' structure, so we need to use the 'data' member to
+ * point to a string in user space, like it is done for RANGE...
+ * The "flags" member indicate if the ESSID is active or not (promiscuous).
+ */
+
+/* Other parameters usefull in 802.11 and some other devices */
+#define SIOCSIWRATE	0x8B20		/* set default bit rate (bps) */
+#define SIOCGIWRATE	0x8B21		/* get default bit rate (bps) */
+#define SIOCSIWRTS	0x8B22		/* set RTS/CTS threshold (bytes) */
+#define SIOCGIWRTS	0x8B23		/* get RTS/CTS threshold (bytes) */
+#define SIOCSIWFRAG	0x8B24		/* set fragmentation thr (bytes) */
+#define SIOCGIWFRAG	0x8B25		/* get fragmentation thr (bytes) */
+#define SIOCSIWTXPOW	0x8B26		/* set transmit power (dBm) */
+#define SIOCGIWTXPOW	0x8B27		/* get transmit power (dBm) */
+#define SIOCSIWRETRY	0x8B28		/* set retry limits and lifetime */
+#define SIOCGIWRETRY	0x8B29		/* get retry limits and lifetime */
+
+/* Encoding stuff (scrambling, hardware security, WEP...) */
+#define SIOCSIWENCODE	0x8B2A		/* set encoding token & mode */
+#define SIOCGIWENCODE	0x8B2B		/* get encoding token & mode */
+/* Power saving stuff (power management, unicast and multicast) */
+#define SIOCSIWPOWER	0x8B2C		/* set Power Management settings */
+#define SIOCGIWPOWER	0x8B2D		/* get Power Management settings */
+
+/* ------------------------- IOCTL STUFF ------------------------- */
+
+/* The first and the last (range) */
+#define SIOCIWFIRST	0x8B00
+#define SIOCIWLAST	0x8B30
+
+/* Even : get (world access), odd : set (root access) */
+#define IW_IS_SET(cmd)	(!((cmd) & 0x1))
+#define IW_IS_GET(cmd)	((cmd) & 0x1)
+
+/* ------------------------- PRIVATE INFO ------------------------- */
+/*
+ * The following is used with SIOCGIWPRIV. It allow a driver to define
+ * the interface (name, type of data) for its private ioctl.
+ * Privates ioctl are SIOCDEVPRIVATE -> SIOCDEVPRIVATE + 0xF
+ */
+
+#define IW_PRIV_TYPE_MASK	0x7000	/* Type of arguments */
+#define IW_PRIV_TYPE_NONE	0x0000
+#define IW_PRIV_TYPE_BYTE	0x1000	/* Char as number */
+#define IW_PRIV_TYPE_CHAR	0x2000	/* Char as character */
+#define IW_PRIV_TYPE_INT	0x4000	/* 32 bits int */
+#define IW_PRIV_TYPE_FLOAT	0x5000
+
+#define IW_PRIV_SIZE_FIXED	0x0800	/* Variable or fixed nuber of args */
+
+#define IW_PRIV_SIZE_MASK	0x07FF	/* Max number of those args */
+
+/*
+ * Note : if the number of args is fixed and the size < 16 octets,
+ * instead of passing a pointer we will put args in the iwreq struct...
+ */
+
+/* ----------------------- OTHER CONSTANTS ----------------------- */
+
+/* Maximum frequencies in the range struct */
+#define IW_MAX_FREQUENCIES	16
+/* Note : if you have something like 80 frequencies,
+ * don't increase this constant and don't fill the frequency list.
+ * The user will be able to set by channel anyway... */
+
+/* Maximum bit rates in the range struct */
+#define IW_MAX_BITRATES		8
+
+/* Maximum tx powers in the range struct */
+#define IW_MAX_TXPOWER		8
+
+/* Maximum of address that you may set with SPY */
+#define IW_MAX_SPY		8
+
+/* Maximum of address that you may get in the
+   list of access points in range */
+#define IW_MAX_AP		8
+
+/* Maximum size of the ESSID and NICKN strings */
+#define IW_ESSID_MAX_SIZE	32
+
+/* Modes of operation */
+#define IW_MODE_AUTO	0	/* Let the driver decides */
+#define IW_MODE_ADHOC	1	/* Single cell network */
+#define IW_MODE_INFRA	2	/* Multi cell network, roaming, ... */
+#define IW_MODE_MASTER	3	/* Synchronisation master or Access Point */
+#define IW_MODE_REPEAT	4	/* Wireless Repeater (forwarder) */
+#define IW_MODE_SECOND	5	/* Secondary master/repeater (backup) */
+
+/* Maximum number of size of encoding token available
+ * they are listed in the range structure */
+#define IW_MAX_ENCODING_SIZES	8
+
+/* Maximum size of the encoding token in bytes */
+#define IW_ENCODING_TOKEN_MAX	32	/* 256 bits (for now) */
+
+/* Flags for encoding (along with the token) */
+#define IW_ENCODE_INDEX		0x00FF	/* Token index (if needed) */
+#define IW_ENCODE_FLAGS		0xFF00	/* Flags defined below */
+#define IW_ENCODE_MODE		0xF000	/* Modes defined below */
+#define IW_ENCODE_DISABLED	0x8000	/* Encoding disabled */
+#define IW_ENCODE_ENABLED	0x0000	/* Encoding enabled */
+#define IW_ENCODE_RESTRICTED	0x4000	/* Refuse non-encoded packets */
+#define IW_ENCODE_OPEN		0x2000	/* Accept non-encoded packets */
+#define IW_ENCODE_NOKEY         0x0800  /* Key is write only, so not present */
+
+/* Power management flags available (along with the value, if any) */
+#define IW_POWER_ON		0x0000	/* No details... */
+#define IW_POWER_TYPE		0xF000	/* Type of parameter */
+#define IW_POWER_PERIOD		0x1000	/* Value is a period/duration of  */
+#define IW_POWER_TIMEOUT	0x2000	/* Value is a timeout (to go asleep) */
+#define IW_POWER_MODE		0x0F00	/* Power Management mode */
+#define IW_POWER_UNICAST_R	0x0100	/* Receive only unicast messages */
+#define IW_POWER_MULTICAST_R	0x0200	/* Receive only multicast messages */
+#define IW_POWER_ALL_R		0x0300	/* Receive all messages though PM */
+#define IW_POWER_FORCE_S	0x0400	/* Force PM procedure for sending unicast */
+#define IW_POWER_REPEATER	0x0800	/* Repeat broadcast messages in PM period */
+#define IW_POWER_MODIFIER	0x000F	/* Modify a parameter */
+#define IW_POWER_MIN		0x0001	/* Value is a minimum  */
+#define IW_POWER_MAX		0x0002	/* Value is a maximum */
+#define IW_POWER_RELATIVE	0x0004	/* Value is not in seconds/ms/us */
+
+/* Transmit Power flags available */
+#define IW_TXPOW_DBM		0x0000	/* Value is in dBm */
+#define IW_TXPOW_MWATT		0x0001	/* Value is in mW */
+
+/* Retry limits and lifetime flags available */
+#define IW_RETRY_ON		0x0000	/* No details... */
+#define IW_RETRY_TYPE		0xF000	/* Type of parameter */
+#define IW_RETRY_LIMIT		0x1000	/* Maximum number of retries*/
+#define IW_RETRY_LIFETIME	0x2000	/* Maximum duration of retries in us */
+#define IW_RETRY_MODIFIER	0x000F	/* Modify a parameter */
+#define IW_RETRY_MIN		0x0001	/* Value is a minimum  */
+#define IW_RETRY_MAX		0x0002	/* Value is a maximum */
+#define IW_RETRY_RELATIVE	0x0004	/* Value is not in seconds/ms/us */
+
+/****************************** TYPES ******************************/
+
+/* --------------------------- SUBTYPES --------------------------- */
+/*
+ *	Generic format for most parameters that fit in an int
+ */
+struct	iw_param
+{
+  __s32		value;		/* The value of the parameter itself */
+  __u8		fixed;		/* Hardware should not use auto select */
+  __u8		disabled;	/* Disable the feature */
+  __u16		flags;		/* Various specifc flags (if any) */
+};
+
+/*
+ *	For all data larger than 16 octets, we need to use a
+ *	pointer to memory alocated in user space.
+ */
+struct	iw_point
+{
+  caddr_t	pointer;	/* Pointer to the data  (in user space) */
+  __u16		length;		/* number of fields or size in bytes */
+  __u16		flags;		/* Optional params */
+};
+
+/*
+ *	A frequency
+ *	For numbers lower than 10^9, we encode the number in 'm' and
+ *	set 'e' to 0
+ *	For number greater than 10^9, we divide it by the lowest power
+ *	of 10 to get 'm' lower than 10^9, with 'm'= f / (10^'e')...
+ *	The power of 10 is in 'e', the result of the division is in 'm'.
+ */
+struct	iw_freq
+{
+	__u32		m;		/* Mantissa */
+	__u16		e;		/* Exponent */
+	__u8		i;		/* List index (when in range struct) */
+};
+
+/*
+ *	Quality of the link
+ */
+struct	iw_quality
+{
+	__u8		qual;		/* link quality (%retries, SNR or better...) */
+	__u8		level;		/* signal level */
+	__u8		noise;		/* noise level */
+	__u8		updated;	/* Flags to know if updated */
+};
+
+/*
+ *	Packet discarded in the wireless adapter due to
+ *	"wireless" specific problems...
+ */
+struct	iw_discarded
+{
+	__u32		nwid;		/* Wrong nwid */
+	__u32		code;		/* Unable to code/decode */
+	__u32		misc;		/* Others cases */
+};
+
+/* ------------------------ WIRELESS STATS ------------------------ */
+/*
+ * Wireless statistics (used for /proc/net/wireless)
+ */
+struct	iw_statistics
+{
+	__u16		status;		/* Status
+					 * - device dependent for now */
+
+	struct iw_quality	qual;		/* Quality of the link
+						 * (instant/mean/max) */
+	struct iw_discarded	discard;	/* Packet discarded counts */
+};
+
+/* ------------------------ IOCTL REQUEST ------------------------ */
+/*
+ * The structure to exchange data for ioctl.
+ * This structure is the same as 'struct ifreq', but (re)defined for
+ * convenience...
+ *
+ * Note that it should fit on the same memory footprint !
+ * You should check this when increasing the above structures (16 octets)
+ * 16 octets = 128 bits. Warning, pointers might be 64 bits wide...
+ */
+struct	iwreq 
+{
+	union
+	{
+		char	ifrn_name[IFNAMSIZ];	/* if name, e.g. "eth0" */
+	} ifr_ifrn;
+
+	/* Data part */
+	union
+	{
+		/* Config - generic */
+		char		name[IFNAMSIZ];
+		/* Name : used to verify the presence of  wireless extensions.
+		 * Name of the protocol/provider... */
+
+		struct iw_point	essid;	/* Extended network name */
+		struct iw_param	nwid;	/* network id (or domain - the cell) */
+		struct iw_freq	freq;	/* frequency or channel :
+					 * 0-1000 = channel
+					 * > 1000 = frequency in Hz */
+
+		struct iw_param	sens;		/* signal level threshold */
+		struct iw_param	bitrate;	/* default bit rate */
+		struct iw_param	txpower;	/* default transmit power */
+		struct iw_param	rts;		/* RTS threshold threshold */
+		struct iw_param	frag;		/* Fragmentation threshold */
+		__u32		mode;		/* Operation mode */
+		struct iw_param	retry;		/* Retry limits & lifetime */
+
+		struct iw_point	encoding;	/* Encoding stuff : tokens */
+		struct iw_param	power;		/* PM duration/timeout */
+
+		struct sockaddr	ap_addr;	/* Access point address */
+
+		struct iw_point	data;		/* Other large parameters */
+	}	u;
+};
+
+/* -------------------------- IOCTL DATA -------------------------- */
+/*
+ *	For those ioctl which want to exchange mode data that what could
+ *	fit in the above structure...
+ */
+
+/*
+ *	Range of parameters
+ */
+
+struct	iw_range
+{
+	/* Informative stuff (to choose between different interface) */
+	__u32		throughput;	/* To give an idea... */
+	/* In theory this value should be the maximum benchmarked
+	 * TCP/IP throughput, because with most of these devices the
+	 * bit rate is meaningless (overhead an co) to estimate how
+	 * fast the connection will go and pick the fastest one.
+	 * I suggest people to play with Netperf or any benchmark...
+	 */
+
+	/* NWID (or domain id) */
+	__u32		min_nwid;	/* Minimal NWID we are able to set */
+	__u32		max_nwid;	/* Maximal NWID we are able to set */
+
+	/* Frequency */
+	__u16		num_channels;	/* Number of channels [0; num - 1] */
+	__u8		num_frequency;	/* Number of entry in the list */
+	struct iw_freq	freq[IW_MAX_FREQUENCIES];	/* list */
+	/* Note : this frequency list doesn't need to fit channel numbers */
+
+	/* signal level threshold range */
+	__s32	sensitivity;
+
+	/* Quality of link & SNR stuff */
+	struct iw_quality	max_qual;	/* Quality of the link */
+
+	/* Rates */
+	__u8		num_bitrates;	/* Number of entries in the list */
+	__s32		bitrate[IW_MAX_BITRATES];	/* list, in bps */
+
+	/* RTS threshold */
+	__s32		min_rts;	/* Minimal RTS threshold */
+	__s32		max_rts;	/* Maximal RTS threshold */
+
+	/* Frag threshold */
+	__s32		min_frag;	/* Minimal frag threshold */
+	__s32		max_frag;	/* Maximal frag threshold */
+
+	/* Power Management duration & timeout */
+	__s32		min_pmp;	/* Minimal PM period */
+	__s32		max_pmp;	/* Maximal PM period */
+	__s32		min_pmt;	/* Minimal PM timeout */
+	__s32		max_pmt;	/* Maximal PM timeout */
+	__u16		pmp_flags;	/* How to decode max/min PM period */
+	__u16		pmt_flags;	/* How to decode max/min PM timeout */
+	__u16		pm_capa;	/* What PM options are supported */
+
+	/* Encoder stuff */
+	__u16	encoding_size[IW_MAX_ENCODING_SIZES];	/* Different token sizes */
+	__u8	num_encoding_sizes;	/* Number of entry in the list */
+	__u8	max_encoding_tokens;	/* Max number of tokens */
+
+	/* Transmit power */
+	__u16		txpower_capa;	/* What options are supported */
+	__u8		num_txpower;	/* Number of entries in the list */
+	__s32		txpower[IW_MAX_TXPOWER];	/* list, in bps */
+
+	/* Wireless Extension version info */
+	__u8		we_version_compiled;	/* Must be WIRELESS_EXT */
+	__u8		we_version_source;	/* Last update of source */
+
+	/* Retry limits and lifetime */
+	__u16		retry_capa;	/* What retry options are supported */
+	__u16		retry_flags;	/* How to decode max/min retry limit */
+	__u16		r_time_flags;	/* How to decode max/min retry life */
+	__s32		min_retry;	/* Minimal number of retries */
+	__s32		max_retry;	/* Maximal number of retries */
+	__s32		min_r_time;	/* Minimal retry lifetime */
+	__s32		max_r_time;	/* Maximal retry lifetime */
+};
+
+/*
+ * Private ioctl interface information
+ */
+ 
+struct	iw_priv_args
+{
+	__u32		cmd;		/* Number of the ioctl to issue */
+	__u16		set_args;	/* Type and number of args */
+	__u16		get_args;	/* Type and number of args */
+	char		name[IFNAMSIZ];	/* Name of the extension */
+};
+
+#endif	/* _LINUX_WIRELESS_H */
diff --git a/wireless.12.h b/wireless.12.h
new file mode 100644
index 0000000..4183d4a
--- /dev/null
+++ b/wireless.12.h
@@ -0,0 +1,570 @@
+/*
+ * This file define a set of standard wireless extensions
+ *
+ * Version :	12	5.10.01
+ *
+ * Authors :	Jean Tourrilhes - HPL - <jt@hpl.hp.com>
+ */
+
+#ifndef _LINUX_WIRELESS_H
+#define _LINUX_WIRELESS_H
+
+/************************** DOCUMENTATION **************************/
+/*
+ * Basically, the wireless extensions are for now a set of standard ioctl
+ * call + /proc/net/wireless
+ *
+ * The entry /proc/net/wireless give statistics and information on the
+ * driver.
+ * This is better than having each driver having its entry because
+ * its centralised and we may remove the driver module safely.
+ *
+ * Ioctl are used to configure the driver and issue commands.  This is
+ * better than command line options of insmod because we may want to
+ * change dynamically (while the driver is running) some parameters.
+ *
+ * The ioctl mechanimsm are copied from standard devices ioctl.
+ * We have the list of command plus a structure descibing the
+ * data exchanged...
+ * Note that to add these ioctl, I was obliged to modify :
+ *	net/core/dev.c (two place + add include)
+ *	net/ipv4/af_inet.c (one place + add include)
+ *
+ * /proc/net/wireless is a copy of /proc/net/dev.
+ * We have a structure for data passed from the driver to /proc/net/wireless
+ * Too add this, I've modified :
+ *	net/core/dev.c (two other places)
+ *	include/linux/netdevice.h (one place)
+ *	include/linux/proc_fs.h (one place)
+ *
+ * Do not add here things that are redundant with other mechanisms
+ * (drivers init, ifconfig, /proc/net/dev, ...) and with are not
+ * wireless specific.
+ *
+ * These wireless extensions are not magic : each driver has to provide
+ * support for them...
+ *
+ * IMPORTANT NOTE : As everything in the kernel, this is very much a
+ * work in progress. Contact me if you have ideas of improvements...
+ */
+
+/***************************** INCLUDES *****************************/
+
+#include <linux/types.h>		/* for "caddr_t" et al		*/
+#include <linux/socket.h>		/* for "struct sockaddr" et al	*/
+#include <linux/if.h>			/* for IFNAMSIZ and co... */
+
+/**************************** CONSTANTS ****************************/
+
+/* --------------------------- VERSION --------------------------- */
+/*
+ * This constant is used to know the availability of the wireless
+ * extensions and to know which version of wireless extensions it is
+ * (there is some stuff that will be added in the future...)
+ * I just plan to increment with each new version.
+ */
+#define WIRELESS_EXT	12
+
+/*
+ * Changes :
+ *
+ * V2 to V3
+ * --------
+ *	Alan Cox start some incompatibles changes. I've integrated a bit more.
+ *	- Encryption renamed to Encode to avoid US regulation problems
+ *	- Frequency changed from float to struct to avoid problems on old 386
+ *
+ * V3 to V4
+ * --------
+ *	- Add sensitivity
+ *
+ * V4 to V5
+ * --------
+ *	- Missing encoding definitions in range
+ *	- Access points stuff
+ *
+ * V5 to V6
+ * --------
+ *	- 802.11 support (ESSID ioctls)
+ *
+ * V6 to V7
+ * --------
+ *	- define IW_ESSID_MAX_SIZE and IW_MAX_AP
+ *
+ * V7 to V8
+ * --------
+ *	- Changed my e-mail address
+ *	- More 802.11 support (nickname, rate, rts, frag)
+ *	- List index in frequencies
+ *
+ * V8 to V9
+ * --------
+ *	- Support for 'mode of operation' (ad-hoc, managed...)
+ *	- Support for unicast and multicast power saving
+ *	- Change encoding to support larger tokens (>64 bits)
+ *	- Updated iw_params (disable, flags) and use it for NWID
+ *	- Extracted iw_point from iwreq for clarity
+ *
+ * V9 to V10
+ * ---------
+ *	- Add PM capability to range structure
+ *	- Add PM modifier : MAX/MIN/RELATIVE
+ *	- Add encoding option : IW_ENCODE_NOKEY
+ *	- Add TxPower ioctls (work like TxRate)
+ *
+ * V10 to V11
+ * ----------
+ *	- Add WE version in range (help backward/forward compatibility)
+ *	- Add retry ioctls (work like PM)
+ *
+ * V11 to V12
+ * ----------
+ *	- Add SIOCSIWSTATS to get /proc/net/wireless programatically
+ *	- Add DEV PRIVATE IOCTL to avoid collisions in SIOCDEVPRIVATE space
+ *	- Add new statistics (frag, retry, beacon)
+ *	- Add average quality (for user space calibration)
+ */
+
+/* -------------------------- IOCTL LIST -------------------------- */
+
+/* Basic operations */
+#define SIOCSIWNAME	0x8B00		/* Unused */
+#define SIOCGIWNAME	0x8B01		/* get name == wireless protocol */
+#define SIOCSIWNWID	0x8B02		/* set network id (the cell) */
+#define SIOCGIWNWID	0x8B03		/* get network id */
+#define SIOCSIWFREQ	0x8B04		/* set channel/frequency (Hz) */
+#define SIOCGIWFREQ	0x8B05		/* get channel/frequency (Hz) */
+#define SIOCSIWMODE	0x8B06		/* set operation mode */
+#define SIOCGIWMODE	0x8B07		/* get operation mode */
+#define SIOCSIWSENS	0x8B08		/* set sensitivity (dBm) */
+#define SIOCGIWSENS	0x8B09		/* get sensitivity (dBm) */
+
+/* Informative stuff */
+#define SIOCSIWRANGE	0x8B0A		/* Unused */
+#define SIOCGIWRANGE	0x8B0B		/* Get range of parameters */
+#define SIOCSIWPRIV	0x8B0C		/* Unused */
+#define SIOCGIWPRIV	0x8B0D		/* get private ioctl interface info */
+#define SIOCSIWSTATS	0x8B0E		/* Unused */
+#define SIOCGIWSTATS	0x8B0F		/* Get /proc/net/wireless stats */
+
+/* Mobile IP support */
+#define SIOCSIWSPY	0x8B10		/* set spy addresses */
+#define SIOCGIWSPY	0x8B11		/* get spy info (quality of link) */
+
+/* Access Point manipulation */
+#define SIOCSIWAP	0x8B14		/* set access point MAC addresses */
+#define SIOCGIWAP	0x8B15		/* get access point MAC addresses */
+#define SIOCGIWAPLIST	0x8B17		/* get list of access point in range */
+
+/* 802.11 specific support */
+#define SIOCSIWESSID	0x8B1A		/* set ESSID (network name) */
+#define SIOCGIWESSID	0x8B1B		/* get ESSID */
+#define SIOCSIWNICKN	0x8B1C		/* set node name/nickname */
+#define SIOCGIWNICKN	0x8B1D		/* get node name/nickname */
+/* As the ESSID and NICKN are strings up to 32 bytes long, it doesn't fit
+ * within the 'iwreq' structure, so we need to use the 'data' member to
+ * point to a string in user space, like it is done for RANGE...
+ * The "flags" member indicate if the ESSID is active or not (promiscuous).
+ */
+
+/* Other parameters useful in 802.11 and some other devices */
+#define SIOCSIWRATE	0x8B20		/* set default bit rate (bps) */
+#define SIOCGIWRATE	0x8B21		/* get default bit rate (bps) */
+#define SIOCSIWRTS	0x8B22		/* set RTS/CTS threshold (bytes) */
+#define SIOCGIWRTS	0x8B23		/* get RTS/CTS threshold (bytes) */
+#define SIOCSIWFRAG	0x8B24		/* set fragmentation thr (bytes) */
+#define SIOCGIWFRAG	0x8B25		/* get fragmentation thr (bytes) */
+#define SIOCSIWTXPOW	0x8B26		/* set transmit power (dBm) */
+#define SIOCGIWTXPOW	0x8B27		/* get transmit power (dBm) */
+#define SIOCSIWRETRY	0x8B28		/* set retry limits and lifetime */
+#define SIOCGIWRETRY	0x8B29		/* get retry limits and lifetime */
+
+/* Encoding stuff (scrambling, hardware security, WEP...) */
+#define SIOCSIWENCODE	0x8B2A		/* set encoding token & mode */
+#define SIOCGIWENCODE	0x8B2B		/* get encoding token & mode */
+/* Power saving stuff (power management, unicast and multicast) */
+#define SIOCSIWPOWER	0x8B2C		/* set Power Management settings */
+#define SIOCGIWPOWER	0x8B2D		/* get Power Management settings */
+
+/* -------------------- DEV PRIVATE IOCTL LIST -------------------- */
+
+/* These 16 ioctl are wireless device private.
+ * Each driver is free to use them for whatever purpose it chooses,
+ * however the driver *must* export the description of those ioctls
+ * with SIOCGIWPRIV and *must* use arguments as defined below.
+ * If you don't follow those rules, DaveM is going to hate you (reason :
+ * it make mixed 32/64bit operation impossible).
+ */
+#define SIOCIWFIRSTPRIV	0x8BE0
+#define SIOCIWLASTPRIV	0x8BFF
+/* Previously, we were using SIOCDEVPRIVATE, but we know have our
+ * separate range because of collisions with other tools such as
+ * 'mii-tool'.
+ * We now have 32 commands, so a bit more space ;-).
+ * Also, all 'odd' commands are only usable by root and don't return the
+ * content of ifr/iwr to user (but you are not obliged to use the set/get
+ * convention, just use every other two command).
+ * And I repeat : you are not obliged to use them with iwspy, but you
+ * must be compliant with it.
+ */
+
+/* ------------------------- IOCTL STUFF ------------------------- */
+
+/* The first and the last (range) */
+#define SIOCIWFIRST	0x8B00
+#define SIOCIWLAST	SIOCIWLASTPRIV		/* 0x8BFF */
+
+/* Even : get (world access), odd : set (root access) */
+#define IW_IS_SET(cmd)	(!((cmd) & 0x1))
+#define IW_IS_GET(cmd)	((cmd) & 0x1)
+
+/* ------------------------- PRIVATE INFO ------------------------- */
+/*
+ * The following is used with SIOCGIWPRIV. It allow a driver to define
+ * the interface (name, type of data) for its private ioctl.
+ * Privates ioctl are SIOCIWFIRSTPRIV -> SIOCIWLASTPRIV
+ */
+
+#define IW_PRIV_TYPE_MASK	0x7000	/* Type of arguments */
+#define IW_PRIV_TYPE_NONE	0x0000
+#define IW_PRIV_TYPE_BYTE	0x1000	/* Char as number */
+#define IW_PRIV_TYPE_CHAR	0x2000	/* Char as character */
+#define IW_PRIV_TYPE_INT	0x4000	/* 32 bits int */
+#define IW_PRIV_TYPE_FLOAT	0x5000
+
+#define IW_PRIV_SIZE_FIXED	0x0800	/* Variable or fixed nuber of args */
+
+#define IW_PRIV_SIZE_MASK	0x07FF	/* Max number of those args */
+
+/*
+ * Note : if the number of args is fixed and the size < 16 octets,
+ * instead of passing a pointer we will put args in the iwreq struct...
+ */
+
+/* ----------------------- OTHER CONSTANTS ----------------------- */
+
+/* Maximum frequencies in the range struct */
+#define IW_MAX_FREQUENCIES	16
+/* Note : if you have something like 80 frequencies,
+ * don't increase this constant and don't fill the frequency list.
+ * The user will be able to set by channel anyway... */
+
+/* Maximum bit rates in the range struct */
+#define IW_MAX_BITRATES		8
+
+/* Maximum tx powers in the range struct */
+#define IW_MAX_TXPOWER		8
+
+/* Maximum of address that you may set with SPY */
+#define IW_MAX_SPY		8
+
+/* Maximum of address that you may get in the
+   list of access points in range */
+#define IW_MAX_AP		8
+
+/* Maximum size of the ESSID and NICKN strings */
+#define IW_ESSID_MAX_SIZE	32
+
+/* Modes of operation */
+#define IW_MODE_AUTO	0	/* Let the driver decides */
+#define IW_MODE_ADHOC	1	/* Single cell network */
+#define IW_MODE_INFRA	2	/* Multi cell network, roaming, ... */
+#define IW_MODE_MASTER	3	/* Synchronisation master or Access Point */
+#define IW_MODE_REPEAT	4	/* Wireless Repeater (forwarder) */
+#define IW_MODE_SECOND	5	/* Secondary master/repeater (backup) */
+
+/* Maximum number of size of encoding token available
+ * they are listed in the range structure */
+#define IW_MAX_ENCODING_SIZES	8
+
+/* Maximum size of the encoding token in bytes */
+#define IW_ENCODING_TOKEN_MAX	32	/* 256 bits (for now) */
+
+/* Flags for encoding (along with the token) */
+#define IW_ENCODE_INDEX		0x00FF	/* Token index (if needed) */
+#define IW_ENCODE_FLAGS		0xFF00	/* Flags defined below */
+#define IW_ENCODE_MODE		0xF000	/* Modes defined below */
+#define IW_ENCODE_DISABLED	0x8000	/* Encoding disabled */
+#define IW_ENCODE_ENABLED	0x0000	/* Encoding enabled */
+#define IW_ENCODE_RESTRICTED	0x4000	/* Refuse non-encoded packets */
+#define IW_ENCODE_OPEN		0x2000	/* Accept non-encoded packets */
+#define IW_ENCODE_NOKEY         0x0800  /* Key is write only, so not present */
+
+/* Power management flags available (along with the value, if any) */
+#define IW_POWER_ON		0x0000	/* No details... */
+#define IW_POWER_TYPE		0xF000	/* Type of parameter */
+#define IW_POWER_PERIOD		0x1000	/* Value is a period/duration of  */
+#define IW_POWER_TIMEOUT	0x2000	/* Value is a timeout (to go asleep) */
+#define IW_POWER_MODE		0x0F00	/* Power Management mode */
+#define IW_POWER_UNICAST_R	0x0100	/* Receive only unicast messages */
+#define IW_POWER_MULTICAST_R	0x0200	/* Receive only multicast messages */
+#define IW_POWER_ALL_R		0x0300	/* Receive all messages though PM */
+#define IW_POWER_FORCE_S	0x0400	/* Force PM procedure for sending unicast */
+#define IW_POWER_REPEATER	0x0800	/* Repeat broadcast messages in PM period */
+#define IW_POWER_MODIFIER	0x000F	/* Modify a parameter */
+#define IW_POWER_MIN		0x0001	/* Value is a minimum  */
+#define IW_POWER_MAX		0x0002	/* Value is a maximum */
+#define IW_POWER_RELATIVE	0x0004	/* Value is not in seconds/ms/us */
+
+/* Transmit Power flags available */
+#define IW_TXPOW_DBM		0x0000	/* Value is in dBm */
+#define IW_TXPOW_MWATT		0x0001	/* Value is in mW */
+
+/* Retry limits and lifetime flags available */
+#define IW_RETRY_ON		0x0000	/* No details... */
+#define IW_RETRY_TYPE		0xF000	/* Type of parameter */
+#define IW_RETRY_LIMIT		0x1000	/* Maximum number of retries*/
+#define IW_RETRY_LIFETIME	0x2000	/* Maximum duration of retries in us */
+#define IW_RETRY_MODIFIER	0x000F	/* Modify a parameter */
+#define IW_RETRY_MIN		0x0001	/* Value is a minimum  */
+#define IW_RETRY_MAX		0x0002	/* Value is a maximum */
+#define IW_RETRY_RELATIVE	0x0004	/* Value is not in seconds/ms/us */
+
+/****************************** TYPES ******************************/
+
+/* --------------------------- SUBTYPES --------------------------- */
+/*
+ *	Generic format for most parameters that fit in an int
+ */
+struct	iw_param
+{
+  __s32		value;		/* The value of the parameter itself */
+  __u8		fixed;		/* Hardware should not use auto select */
+  __u8		disabled;	/* Disable the feature */
+  __u16		flags;		/* Various specifc flags (if any) */
+};
+
+/*
+ *	For all data larger than 16 octets, we need to use a
+ *	pointer to memory allocated in user space.
+ */
+struct	iw_point
+{
+  caddr_t	pointer;	/* Pointer to the data  (in user space) */
+  __u16		length;		/* number of fields or size in bytes */
+  __u16		flags;		/* Optional params */
+};
+
+/*
+ *	A frequency
+ *	For numbers lower than 10^9, we encode the number in 'm' and
+ *	set 'e' to 0
+ *	For number greater than 10^9, we divide it by the lowest power
+ *	of 10 to get 'm' lower than 10^9, with 'm'= f / (10^'e')...
+ *	The power of 10 is in 'e', the result of the division is in 'm'.
+ */
+struct	iw_freq
+{
+	__u32		m;		/* Mantissa */
+	__u16		e;		/* Exponent */
+	__u8		i;		/* List index (when in range struct) */
+};
+
+/*
+ *	Quality of the link
+ */
+struct	iw_quality
+{
+	__u8		qual;		/* link quality (%retries, SNR,
+					   %missed beacons or better...) */
+	__u8		level;		/* signal level (dBm) */
+	__u8		noise;		/* noise level (dBm) */
+	__u8		updated;	/* Flags to know if updated */
+};
+
+/*
+ *	Packet discarded in the wireless adapter due to
+ *	"wireless" specific problems...
+ *	Note : the list of counter and statistics in net_device_stats
+ *	is already pretty exhaustive, and you should use that first.
+ *	This is only additional stats...
+ */
+struct	iw_discarded
+{
+	__u32		nwid;		/* Rx : Wrong nwid/essid */
+	__u32		code;		/* Rx : Unable to code/decode (WEP) */
+	__u32		fragment;	/* Rx : Can't perform MAC reassembly */
+	__u32		retries;	/* Tx : Max MAC retries num reached */
+	__u32		misc;		/* Others cases */
+};
+
+/*
+ *	Packet/Time period missed in the wireless adapter due to
+ *	"wireless" specific problems...
+ */
+struct	iw_missed
+{
+	__u32		beacon;		/* Missed beacons/superframe */
+};
+
+/* ------------------------ WIRELESS STATS ------------------------ */
+/*
+ * Wireless statistics (used for /proc/net/wireless)
+ */
+struct	iw_statistics
+{
+	__u16		status;		/* Status
+					 * - device dependent for now */
+
+	struct iw_quality	qual;		/* Quality of the link
+						 * (instant/mean/max) */
+	struct iw_discarded	discard;	/* Packet discarded counts */
+	struct iw_missed	miss;		/* Packet missed counts */
+};
+
+/* ------------------------ IOCTL REQUEST ------------------------ */
+/*
+ * The structure to exchange data for ioctl.
+ * This structure is the same as 'struct ifreq', but (re)defined for
+ * convenience...
+ *
+ * Note that it should fit on the same memory footprint !
+ * You should check this when increasing the above structures (16 octets)
+ * 16 octets = 128 bits. Warning, pointers might be 64 bits wide...
+ */
+struct	iwreq 
+{
+	union
+	{
+		char	ifrn_name[IFNAMSIZ];	/* if name, e.g. "eth0" */
+	} ifr_ifrn;
+
+	/* Data part */
+	union
+	{
+		/* Config - generic */
+		char		name[IFNAMSIZ];
+		/* Name : used to verify the presence of  wireless extensions.
+		 * Name of the protocol/provider... */
+
+		struct iw_point	essid;	/* Extended network name */
+		struct iw_param	nwid;	/* network id (or domain - the cell) */
+		struct iw_freq	freq;	/* frequency or channel :
+					 * 0-1000 = channel
+					 * > 1000 = frequency in Hz */
+
+		struct iw_param	sens;		/* signal level threshold */
+		struct iw_param	bitrate;	/* default bit rate */
+		struct iw_param	txpower;	/* default transmit power */
+		struct iw_param	rts;		/* RTS threshold threshold */
+		struct iw_param	frag;		/* Fragmentation threshold */
+		__u32		mode;		/* Operation mode */
+		struct iw_param	retry;		/* Retry limits & lifetime */
+
+		struct iw_point	encoding;	/* Encoding stuff : tokens */
+		struct iw_param	power;		/* PM duration/timeout */
+
+		struct sockaddr	ap_addr;	/* Access point address */
+
+		struct iw_point	data;		/* Other large parameters */
+	}	u;
+};
+
+/* -------------------------- IOCTL DATA -------------------------- */
+/*
+ *	For those ioctl which want to exchange mode data that what could
+ *	fit in the above structure...
+ */
+
+/*
+ *	Range of parameters
+ */
+
+struct	iw_range
+{
+	/* Informative stuff (to choose between different interface) */
+	__u32		throughput;	/* To give an idea... */
+	/* In theory this value should be the maximum benchmarked
+	 * TCP/IP throughput, because with most of these devices the
+	 * bit rate is meaningless (overhead an co) to estimate how
+	 * fast the connection will go and pick the fastest one.
+	 * I suggest people to play with Netperf or any benchmark...
+	 */
+
+	/* NWID (or domain id) */
+	__u32		min_nwid;	/* Minimal NWID we are able to set */
+	__u32		max_nwid;	/* Maximal NWID we are able to set */
+
+	/* Frequency */
+	__u16		num_channels;	/* Number of channels [0; num - 1] */
+	__u8		num_frequency;	/* Number of entry in the list */
+	struct iw_freq	freq[IW_MAX_FREQUENCIES];	/* list */
+	/* Note : this frequency list doesn't need to fit channel numbers */
+
+	/* signal level threshold range */
+	__s32	sensitivity;
+
+	/* Quality of link & SNR stuff */
+	struct iw_quality	max_qual;	/* Quality of the link */
+
+	/* Rates */
+	__u8		num_bitrates;	/* Number of entries in the list */
+	__s32		bitrate[IW_MAX_BITRATES];	/* list, in bps */
+
+	/* RTS threshold */
+	__s32		min_rts;	/* Minimal RTS threshold */
+	__s32		max_rts;	/* Maximal RTS threshold */
+
+	/* Frag threshold */
+	__s32		min_frag;	/* Minimal frag threshold */
+	__s32		max_frag;	/* Maximal frag threshold */
+
+	/* Power Management duration & timeout */
+	__s32		min_pmp;	/* Minimal PM period */
+	__s32		max_pmp;	/* Maximal PM period */
+	__s32		min_pmt;	/* Minimal PM timeout */
+	__s32		max_pmt;	/* Maximal PM timeout */
+	__u16		pmp_flags;	/* How to decode max/min PM period */
+	__u16		pmt_flags;	/* How to decode max/min PM timeout */
+	__u16		pm_capa;	/* What PM options are supported */
+
+	/* Encoder stuff */
+	__u16	encoding_size[IW_MAX_ENCODING_SIZES];	/* Different token sizes */
+	__u8	num_encoding_sizes;	/* Number of entry in the list */
+	__u8	max_encoding_tokens;	/* Max number of tokens */
+
+	/* Transmit power */
+	__u16		txpower_capa;	/* What options are supported */
+	__u8		num_txpower;	/* Number of entries in the list */
+	__s32		txpower[IW_MAX_TXPOWER];	/* list, in bps */
+
+	/* Wireless Extension version info */
+	__u8		we_version_compiled;	/* Must be WIRELESS_EXT */
+	__u8		we_version_source;	/* Last update of source */
+
+	/* Retry limits and lifetime */
+	__u16		retry_capa;	/* What retry options are supported */
+	__u16		retry_flags;	/* How to decode max/min retry limit */
+	__u16		r_time_flags;	/* How to decode max/min retry life */
+	__s32		min_retry;	/* Minimal number of retries */
+	__s32		max_retry;	/* Maximal number of retries */
+	__s32		min_r_time;	/* Minimal retry lifetime */
+	__s32		max_r_time;	/* Maximal retry lifetime */
+
+	/* Average quality of link & SNR */
+	struct iw_quality	avg_qual;	/* Quality of the link */
+	/* This should contain the average/typical values of the quality
+	 * indicator. This should be the threshold between a "good" and
+	 * a "bad" link (example : monitor going from green to orange).
+	 * Currently, user space apps like quality monitors don't have any
+	 * way to calibrate the measurement. With this, they can split
+	 * the range between 0 and max_qual in different quality level
+	 * (using a geometric subdivision centered on the average).
+	 * I expect that people doing the user space apps will feedback
+	 * us on which value we need to put in each driver...
+	 */
+};
+
+/*
+ * Private ioctl interface information
+ */
+ 
+struct	iw_priv_args
+{
+	__u32		cmd;		/* Number of the ioctl to issue */
+	__u16		set_args;	/* Type and number of args */
+	__u16		get_args;	/* Type and number of args */
+	char		name[IFNAMSIZ];	/* Name of the extension */
+};
+
+#endif	/* _LINUX_WIRELESS_H */
diff --git a/wireless.13.h b/wireless.13.h
new file mode 100644
index 0000000..fa3c64f
--- /dev/null
+++ b/wireless.13.h
@@ -0,0 +1,599 @@
+/*
+ * This file define a set of standard wireless extensions
+ *
+ * Version :	13	6.12.01
+ *
+ * Authors :	Jean Tourrilhes - HPL - <jt@hpl.hp.com>
+ * Copyright (c) 1997-2001 Jean Tourrilhes, All Rights Reserved.
+ */
+
+#ifndef _LINUX_WIRELESS_H
+#define _LINUX_WIRELESS_H
+
+/************************** DOCUMENTATION **************************/
+/*
+ * Initial APIs (1996 -> onward) :
+ * -----------------------------
+ * Basically, the wireless extensions are for now a set of standard ioctl
+ * call + /proc/net/wireless
+ *
+ * The entry /proc/net/wireless give statistics and information on the
+ * driver.
+ * This is better than having each driver having its entry because
+ * its centralised and we may remove the driver module safely.
+ *
+ * Ioctl are used to configure the driver and issue commands.  This is
+ * better than command line options of insmod because we may want to
+ * change dynamically (while the driver is running) some parameters.
+ *
+ * The ioctl mechanimsm are copied from standard devices ioctl.
+ * We have the list of command plus a structure descibing the
+ * data exchanged...
+ * Note that to add these ioctl, I was obliged to modify :
+ *	# net/core/dev.c (two place + add include)
+ *	# net/ipv4/af_inet.c (one place + add include)
+ *
+ * /proc/net/wireless is a copy of /proc/net/dev.
+ * We have a structure for data passed from the driver to /proc/net/wireless
+ * Too add this, I've modified :
+ *	# net/core/dev.c (two other places)
+ *	# include/linux/netdevice.h (one place)
+ *	# include/linux/proc_fs.h (one place)
+ *
+ * New driver API (2001 -> onward) :
+ * -------------------------------
+ * This file is only concerned with the user space API and common definitions.
+ * The new driver API is defined and documented in :
+ *	# include/net/iw_handler.h
+ *
+ * Note as well that /proc/net/wireless implementation has now moved in :
+ *	# include/linux/wireless.c
+ *
+ * Other comments :
+ * --------------
+ * Do not add here things that are redundant with other mechanisms
+ * (drivers init, ifconfig, /proc/net/dev, ...) and with are not
+ * wireless specific.
+ *
+ * These wireless extensions are not magic : each driver has to provide
+ * support for them...
+ *
+ * IMPORTANT NOTE : As everything in the kernel, this is very much a
+ * work in progress. Contact me if you have ideas of improvements...
+ */
+
+/***************************** INCLUDES *****************************/
+
+#include <linux/types.h>		/* for "caddr_t" et al		*/
+#include <linux/socket.h>		/* for "struct sockaddr" et al	*/
+#include <linux/if.h>			/* for IFNAMSIZ and co... */
+
+/***************************** VERSION *****************************/
+/*
+ * This constant is used to know the availability of the wireless
+ * extensions and to know which version of wireless extensions it is
+ * (there is some stuff that will be added in the future...)
+ * I just plan to increment with each new version.
+ */
+#define WIRELESS_EXT	13
+
+/*
+ * Changes :
+ *
+ * V2 to V3
+ * --------
+ *	Alan Cox start some incompatibles changes. I've integrated a bit more.
+ *	- Encryption renamed to Encode to avoid US regulation problems
+ *	- Frequency changed from float to struct to avoid problems on old 386
+ *
+ * V3 to V4
+ * --------
+ *	- Add sensitivity
+ *
+ * V4 to V5
+ * --------
+ *	- Missing encoding definitions in range
+ *	- Access points stuff
+ *
+ * V5 to V6
+ * --------
+ *	- 802.11 support (ESSID ioctls)
+ *
+ * V6 to V7
+ * --------
+ *	- define IW_ESSID_MAX_SIZE and IW_MAX_AP
+ *
+ * V7 to V8
+ * --------
+ *	- Changed my e-mail address
+ *	- More 802.11 support (nickname, rate, rts, frag)
+ *	- List index in frequencies
+ *
+ * V8 to V9
+ * --------
+ *	- Support for 'mode of operation' (ad-hoc, managed...)
+ *	- Support for unicast and multicast power saving
+ *	- Change encoding to support larger tokens (>64 bits)
+ *	- Updated iw_params (disable, flags) and use it for NWID
+ *	- Extracted iw_point from iwreq for clarity
+ *
+ * V9 to V10
+ * ---------
+ *	- Add PM capability to range structure
+ *	- Add PM modifier : MAX/MIN/RELATIVE
+ *	- Add encoding option : IW_ENCODE_NOKEY
+ *	- Add TxPower ioctls (work like TxRate)
+ *
+ * V10 to V11
+ * ----------
+ *	- Add WE version in range (help backward/forward compatibility)
+ *	- Add retry ioctls (work like PM)
+ *
+ * V11 to V12
+ * ----------
+ *	- Add SIOCSIWSTATS to get /proc/net/wireless programatically
+ *	- Add DEV PRIVATE IOCTL to avoid collisions in SIOCDEVPRIVATE space
+ *	- Add new statistics (frag, retry, beacon)
+ *	- Add average quality (for user space calibration)
+ *
+ * V12 to V13
+ * ----------
+ *	- Document creation of new driver API.
+ *	- Extract union iwreq_data from struct iwreq (for new driver API).
+ *	- Rename SIOCSIWNAME as SIOCSIWCOMMIT
+ */
+
+/**************************** CONSTANTS ****************************/
+
+/* -------------------------- IOCTL LIST -------------------------- */
+
+/* Basic operations */
+#define SIOCSIWCOMMIT	0x8B00		/* Commit pending changes to driver */
+#define SIOCGIWNAME	0x8B01		/* get name == wireless protocol */
+#define SIOCSIWNWID	0x8B02		/* set network id (the cell) */
+#define SIOCGIWNWID	0x8B03		/* get network id */
+#define SIOCSIWFREQ	0x8B04		/* set channel/frequency (Hz) */
+#define SIOCGIWFREQ	0x8B05		/* get channel/frequency (Hz) */
+#define SIOCSIWMODE	0x8B06		/* set operation mode */
+#define SIOCGIWMODE	0x8B07		/* get operation mode */
+#define SIOCSIWSENS	0x8B08		/* set sensitivity (dBm) */
+#define SIOCGIWSENS	0x8B09		/* get sensitivity (dBm) */
+
+/* Informative stuff */
+#define SIOCSIWRANGE	0x8B0A		/* Unused */
+#define SIOCGIWRANGE	0x8B0B		/* Get range of parameters */
+#define SIOCSIWPRIV	0x8B0C		/* Unused */
+#define SIOCGIWPRIV	0x8B0D		/* get private ioctl interface info */
+#define SIOCSIWSTATS	0x8B0E		/* Unused */
+#define SIOCGIWSTATS	0x8B0F		/* Get /proc/net/wireless stats */
+
+/* Mobile IP support */
+#define SIOCSIWSPY	0x8B10		/* set spy addresses */
+#define SIOCGIWSPY	0x8B11		/* get spy info (quality of link) */
+
+/* Access Point manipulation */
+#define SIOCSIWAP	0x8B14		/* set access point MAC addresses */
+#define SIOCGIWAP	0x8B15		/* get access point MAC addresses */
+#define SIOCGIWAPLIST	0x8B17		/* get list of access point in range */
+
+/* 802.11 specific support */
+#define SIOCSIWESSID	0x8B1A		/* set ESSID (network name) */
+#define SIOCGIWESSID	0x8B1B		/* get ESSID */
+#define SIOCSIWNICKN	0x8B1C		/* set node name/nickname */
+#define SIOCGIWNICKN	0x8B1D		/* get node name/nickname */
+/* As the ESSID and NICKN are strings up to 32 bytes long, it doesn't fit
+ * within the 'iwreq' structure, so we need to use the 'data' member to
+ * point to a string in user space, like it is done for RANGE...
+ * The "flags" member indicate if the ESSID is active or not (promiscuous).
+ */
+
+/* Other parameters useful in 802.11 and some other devices */
+#define SIOCSIWRATE	0x8B20		/* set default bit rate (bps) */
+#define SIOCGIWRATE	0x8B21		/* get default bit rate (bps) */
+#define SIOCSIWRTS	0x8B22		/* set RTS/CTS threshold (bytes) */
+#define SIOCGIWRTS	0x8B23		/* get RTS/CTS threshold (bytes) */
+#define SIOCSIWFRAG	0x8B24		/* set fragmentation thr (bytes) */
+#define SIOCGIWFRAG	0x8B25		/* get fragmentation thr (bytes) */
+#define SIOCSIWTXPOW	0x8B26		/* set transmit power (dBm) */
+#define SIOCGIWTXPOW	0x8B27		/* get transmit power (dBm) */
+#define SIOCSIWRETRY	0x8B28		/* set retry limits and lifetime */
+#define SIOCGIWRETRY	0x8B29		/* get retry limits and lifetime */
+
+/* Encoding stuff (scrambling, hardware security, WEP...) */
+#define SIOCSIWENCODE	0x8B2A		/* set encoding token & mode */
+#define SIOCGIWENCODE	0x8B2B		/* get encoding token & mode */
+/* Power saving stuff (power management, unicast and multicast) */
+#define SIOCSIWPOWER	0x8B2C		/* set Power Management settings */
+#define SIOCGIWPOWER	0x8B2D		/* get Power Management settings */
+
+/* -------------------- DEV PRIVATE IOCTL LIST -------------------- */
+
+/* These 16 ioctl are wireless device private.
+ * Each driver is free to use them for whatever purpose it chooses,
+ * however the driver *must* export the description of those ioctls
+ * with SIOCGIWPRIV and *must* use arguments as defined below.
+ * If you don't follow those rules, DaveM is going to hate you (reason :
+ * it make mixed 32/64bit operation impossible).
+ */
+#define SIOCIWFIRSTPRIV	0x8BE0
+#define SIOCIWLASTPRIV	0x8BFF
+/* Previously, we were using SIOCDEVPRIVATE, but we now have our
+ * separate range because of collisions with other tools such as
+ * 'mii-tool'.
+ * We now have 32 commands, so a bit more space ;-).
+ * Also, all 'odd' commands are only usable by root and don't return the
+ * content of ifr/iwr to user (but you are not obliged to use the set/get
+ * convention, just use every other two command).
+ * And I repeat : you are not obliged to use them with iwspy, but you
+ * must be compliant with it.
+ */
+
+/* ------------------------- IOCTL STUFF ------------------------- */
+
+/* The first and the last (range) */
+#define SIOCIWFIRST	0x8B00
+#define SIOCIWLAST	SIOCIWLASTPRIV		/* 0x8BFF */
+
+/* Even : get (world access), odd : set (root access) */
+#define IW_IS_SET(cmd)	(!((cmd) & 0x1))
+#define IW_IS_GET(cmd)	((cmd) & 0x1)
+
+/* ------------------------- PRIVATE INFO ------------------------- */
+/*
+ * The following is used with SIOCGIWPRIV. It allow a driver to define
+ * the interface (name, type of data) for its private ioctl.
+ * Privates ioctl are SIOCIWFIRSTPRIV -> SIOCIWLASTPRIV
+ */
+
+#define IW_PRIV_TYPE_MASK	0x7000	/* Type of arguments */
+#define IW_PRIV_TYPE_NONE	0x0000
+#define IW_PRIV_TYPE_BYTE	0x1000	/* Char as number */
+#define IW_PRIV_TYPE_CHAR	0x2000	/* Char as character */
+#define IW_PRIV_TYPE_INT	0x4000	/* 32 bits int */
+#define IW_PRIV_TYPE_FLOAT	0x5000
+
+#define IW_PRIV_SIZE_FIXED	0x0800	/* Variable or fixed nuber of args */
+
+#define IW_PRIV_SIZE_MASK	0x07FF	/* Max number of those args */
+
+/*
+ * Note : if the number of args is fixed and the size < 16 octets,
+ * instead of passing a pointer we will put args in the iwreq struct...
+ */
+
+/* ----------------------- OTHER CONSTANTS ----------------------- */
+
+/* Maximum frequencies in the range struct */
+#define IW_MAX_FREQUENCIES	16
+/* Note : if you have something like 80 frequencies,
+ * don't increase this constant and don't fill the frequency list.
+ * The user will be able to set by channel anyway... */
+
+/* Maximum bit rates in the range struct */
+#define IW_MAX_BITRATES		8
+
+/* Maximum tx powers in the range struct */
+#define IW_MAX_TXPOWER		8
+
+/* Maximum of address that you may set with SPY */
+#define IW_MAX_SPY		8
+
+/* Maximum of address that you may get in the
+   list of access points in range */
+#define IW_MAX_AP		8
+
+/* Maximum size of the ESSID and NICKN strings */
+#define IW_ESSID_MAX_SIZE	32
+
+/* Modes of operation */
+#define IW_MODE_AUTO	0	/* Let the driver decides */
+#define IW_MODE_ADHOC	1	/* Single cell network */
+#define IW_MODE_INFRA	2	/* Multi cell network, roaming, ... */
+#define IW_MODE_MASTER	3	/* Synchronisation master or Access Point */
+#define IW_MODE_REPEAT	4	/* Wireless Repeater (forwarder) */
+#define IW_MODE_SECOND	5	/* Secondary master/repeater (backup) */
+
+/* Maximum number of size of encoding token available
+ * they are listed in the range structure */
+#define IW_MAX_ENCODING_SIZES	8
+
+/* Maximum size of the encoding token in bytes */
+#define IW_ENCODING_TOKEN_MAX	32	/* 256 bits (for now) */
+
+/* Flags for encoding (along with the token) */
+#define IW_ENCODE_INDEX		0x00FF	/* Token index (if needed) */
+#define IW_ENCODE_FLAGS		0xFF00	/* Flags defined below */
+#define IW_ENCODE_MODE		0xF000	/* Modes defined below */
+#define IW_ENCODE_DISABLED	0x8000	/* Encoding disabled */
+#define IW_ENCODE_ENABLED	0x0000	/* Encoding enabled */
+#define IW_ENCODE_RESTRICTED	0x4000	/* Refuse non-encoded packets */
+#define IW_ENCODE_OPEN		0x2000	/* Accept non-encoded packets */
+#define IW_ENCODE_NOKEY         0x0800  /* Key is write only, so not present */
+
+/* Power management flags available (along with the value, if any) */
+#define IW_POWER_ON		0x0000	/* No details... */
+#define IW_POWER_TYPE		0xF000	/* Type of parameter */
+#define IW_POWER_PERIOD		0x1000	/* Value is a period/duration of  */
+#define IW_POWER_TIMEOUT	0x2000	/* Value is a timeout (to go asleep) */
+#define IW_POWER_MODE		0x0F00	/* Power Management mode */
+#define IW_POWER_UNICAST_R	0x0100	/* Receive only unicast messages */
+#define IW_POWER_MULTICAST_R	0x0200	/* Receive only multicast messages */
+#define IW_POWER_ALL_R		0x0300	/* Receive all messages though PM */
+#define IW_POWER_FORCE_S	0x0400	/* Force PM procedure for sending unicast */
+#define IW_POWER_REPEATER	0x0800	/* Repeat broadcast messages in PM period */
+#define IW_POWER_MODIFIER	0x000F	/* Modify a parameter */
+#define IW_POWER_MIN		0x0001	/* Value is a minimum  */
+#define IW_POWER_MAX		0x0002	/* Value is a maximum */
+#define IW_POWER_RELATIVE	0x0004	/* Value is not in seconds/ms/us */
+
+/* Transmit Power flags available */
+#define IW_TXPOW_DBM		0x0000	/* Value is in dBm */
+#define IW_TXPOW_MWATT		0x0001	/* Value is in mW */
+
+/* Retry limits and lifetime flags available */
+#define IW_RETRY_ON		0x0000	/* No details... */
+#define IW_RETRY_TYPE		0xF000	/* Type of parameter */
+#define IW_RETRY_LIMIT		0x1000	/* Maximum number of retries*/
+#define IW_RETRY_LIFETIME	0x2000	/* Maximum duration of retries in us */
+#define IW_RETRY_MODIFIER	0x000F	/* Modify a parameter */
+#define IW_RETRY_MIN		0x0001	/* Value is a minimum  */
+#define IW_RETRY_MAX		0x0002	/* Value is a maximum */
+#define IW_RETRY_RELATIVE	0x0004	/* Value is not in seconds/ms/us */
+
+/****************************** TYPES ******************************/
+
+/* --------------------------- SUBTYPES --------------------------- */
+/*
+ *	Generic format for most parameters that fit in an int
+ */
+struct	iw_param
+{
+  __s32		value;		/* The value of the parameter itself */
+  __u8		fixed;		/* Hardware should not use auto select */
+  __u8		disabled;	/* Disable the feature */
+  __u16		flags;		/* Various specifc flags (if any) */
+};
+
+/*
+ *	For all data larger than 16 octets, we need to use a
+ *	pointer to memory allocated in user space.
+ */
+struct	iw_point
+{
+  caddr_t	pointer;	/* Pointer to the data  (in user space) */
+  __u16		length;		/* number of fields or size in bytes */
+  __u16		flags;		/* Optional params */
+};
+
+/*
+ *	A frequency
+ *	For numbers lower than 10^9, we encode the number in 'm' and
+ *	set 'e' to 0
+ *	For number greater than 10^9, we divide it by the lowest power
+ *	of 10 to get 'm' lower than 10^9, with 'm'= f / (10^'e')...
+ *	The power of 10 is in 'e', the result of the division is in 'm'.
+ */
+struct	iw_freq
+{
+	__u32		m;		/* Mantissa */
+	__u16		e;		/* Exponent */
+	__u8		i;		/* List index (when in range struct) */
+};
+
+/*
+ *	Quality of the link
+ */
+struct	iw_quality
+{
+	__u8		qual;		/* link quality (%retries, SNR,
+					   %missed beacons or better...) */
+	__u8		level;		/* signal level (dBm) */
+	__u8		noise;		/* noise level (dBm) */
+	__u8		updated;	/* Flags to know if updated */
+};
+
+/*
+ *	Packet discarded in the wireless adapter due to
+ *	"wireless" specific problems...
+ *	Note : the list of counter and statistics in net_device_stats
+ *	is already pretty exhaustive, and you should use that first.
+ *	This is only additional stats...
+ */
+struct	iw_discarded
+{
+	__u32		nwid;		/* Rx : Wrong nwid/essid */
+	__u32		code;		/* Rx : Unable to code/decode (WEP) */
+	__u32		fragment;	/* Rx : Can't perform MAC reassembly */
+	__u32		retries;	/* Tx : Max MAC retries num reached */
+	__u32		misc;		/* Others cases */
+};
+
+/*
+ *	Packet/Time period missed in the wireless adapter due to
+ *	"wireless" specific problems...
+ */
+struct	iw_missed
+{
+	__u32		beacon;		/* Missed beacons/superframe */
+};
+
+/* ------------------------ WIRELESS STATS ------------------------ */
+/*
+ * Wireless statistics (used for /proc/net/wireless)
+ */
+struct	iw_statistics
+{
+	__u16		status;		/* Status
+					 * - device dependent for now */
+
+	struct iw_quality	qual;		/* Quality of the link
+						 * (instant/mean/max) */
+	struct iw_discarded	discard;	/* Packet discarded counts */
+	struct iw_missed	miss;		/* Packet missed counts */
+};
+
+/* ------------------------ IOCTL REQUEST ------------------------ */
+/*
+ * This structure defines the payload of an ioctl, and is used 
+ * below.
+ *
+ * Note that this structure should fit on the memory footprint
+ * of iwreq (which is the same as ifreq), which mean a max size of
+ * 16 octets = 128 bits. Warning, pointers might be 64 bits wide...
+ * You should check this when increasing the structures defined
+ * above in this file...
+ */
+union	iwreq_data
+{
+	/* Config - generic */
+	char		name[IFNAMSIZ];
+	/* Name : used to verify the presence of  wireless extensions.
+	 * Name of the protocol/provider... */
+
+	struct iw_point	essid;		/* Extended network name */
+	struct iw_param	nwid;		/* network id (or domain - the cell) */
+	struct iw_freq	freq;		/* frequency or channel :
+					 * 0-1000 = channel
+					 * > 1000 = frequency in Hz */
+
+	struct iw_param	sens;		/* signal level threshold */
+	struct iw_param	bitrate;	/* default bit rate */
+	struct iw_param	txpower;	/* default transmit power */
+	struct iw_param	rts;		/* RTS threshold threshold */
+	struct iw_param	frag;		/* Fragmentation threshold */
+	__u32		mode;		/* Operation mode */
+	struct iw_param	retry;		/* Retry limits & lifetime */
+
+	struct iw_point	encoding;	/* Encoding stuff : tokens */
+	struct iw_param	power;		/* PM duration/timeout */
+
+	struct sockaddr	ap_addr;	/* Access point address */
+
+	struct iw_point	data;		/* Other large parameters */
+};
+
+/*
+ * The structure to exchange data for ioctl.
+ * This structure is the same as 'struct ifreq', but (re)defined for
+ * convenience...
+ * Do I need to remind you about structure size (32 octets) ?
+ */
+struct	iwreq 
+{
+	union
+	{
+		char	ifrn_name[IFNAMSIZ];	/* if name, e.g. "eth0" */
+	} ifr_ifrn;
+
+	/* Data part (defined just above) */
+	union	iwreq_data	u;
+};
+
+/* -------------------------- IOCTL DATA -------------------------- */
+/*
+ *	For those ioctl which want to exchange mode data that what could
+ *	fit in the above structure...
+ */
+
+/*
+ *	Range of parameters
+ */
+
+struct	iw_range
+{
+	/* Informative stuff (to choose between different interface) */
+	__u32		throughput;	/* To give an idea... */
+	/* In theory this value should be the maximum benchmarked
+	 * TCP/IP throughput, because with most of these devices the
+	 * bit rate is meaningless (overhead an co) to estimate how
+	 * fast the connection will go and pick the fastest one.
+	 * I suggest people to play with Netperf or any benchmark...
+	 */
+
+	/* NWID (or domain id) */
+	__u32		min_nwid;	/* Minimal NWID we are able to set */
+	__u32		max_nwid;	/* Maximal NWID we are able to set */
+
+	/* Frequency */
+	__u16		num_channels;	/* Number of channels [0; num - 1] */
+	__u8		num_frequency;	/* Number of entry in the list */
+	struct iw_freq	freq[IW_MAX_FREQUENCIES];	/* list */
+	/* Note : this frequency list doesn't need to fit channel numbers */
+
+	/* signal level threshold range */
+	__s32	sensitivity;
+
+	/* Quality of link & SNR stuff */
+	struct iw_quality	max_qual;	/* Quality of the link */
+
+	/* Rates */
+	__u8		num_bitrates;	/* Number of entries in the list */
+	__s32		bitrate[IW_MAX_BITRATES];	/* list, in bps */
+
+	/* RTS threshold */
+	__s32		min_rts;	/* Minimal RTS threshold */
+	__s32		max_rts;	/* Maximal RTS threshold */
+
+	/* Frag threshold */
+	__s32		min_frag;	/* Minimal frag threshold */
+	__s32		max_frag;	/* Maximal frag threshold */
+
+	/* Power Management duration & timeout */
+	__s32		min_pmp;	/* Minimal PM period */
+	__s32		max_pmp;	/* Maximal PM period */
+	__s32		min_pmt;	/* Minimal PM timeout */
+	__s32		max_pmt;	/* Maximal PM timeout */
+	__u16		pmp_flags;	/* How to decode max/min PM period */
+	__u16		pmt_flags;	/* How to decode max/min PM timeout */
+	__u16		pm_capa;	/* What PM options are supported */
+
+	/* Encoder stuff */
+	__u16	encoding_size[IW_MAX_ENCODING_SIZES];	/* Different token sizes */
+	__u8	num_encoding_sizes;	/* Number of entry in the list */
+	__u8	max_encoding_tokens;	/* Max number of tokens */
+
+	/* Transmit power */
+	__u16		txpower_capa;	/* What options are supported */
+	__u8		num_txpower;	/* Number of entries in the list */
+	__s32		txpower[IW_MAX_TXPOWER];	/* list, in bps */
+
+	/* Wireless Extension version info */
+	__u8		we_version_compiled;	/* Must be WIRELESS_EXT */
+	__u8		we_version_source;	/* Last update of source */
+
+	/* Retry limits and lifetime */
+	__u16		retry_capa;	/* What retry options are supported */
+	__u16		retry_flags;	/* How to decode max/min retry limit */
+	__u16		r_time_flags;	/* How to decode max/min retry life */
+	__s32		min_retry;	/* Minimal number of retries */
+	__s32		max_retry;	/* Maximal number of retries */
+	__s32		min_r_time;	/* Minimal retry lifetime */
+	__s32		max_r_time;	/* Maximal retry lifetime */
+
+	/* Average quality of link & SNR */
+	struct iw_quality	avg_qual;	/* Quality of the link */
+	/* This should contain the average/typical values of the quality
+	 * indicator. This should be the threshold between a "good" and
+	 * a "bad" link (example : monitor going from green to orange).
+	 * Currently, user space apps like quality monitors don't have any
+	 * way to calibrate the measurement. With this, they can split
+	 * the range between 0 and max_qual in different quality level
+	 * (using a geometric subdivision centered on the average).
+	 * I expect that people doing the user space apps will feedback
+	 * us on which value we need to put in each driver...
+	 */
+};
+
+/*
+ * Private ioctl interface information
+ */
+ 
+struct	iw_priv_args
+{
+	__u32		cmd;		/* Number of the ioctl to issue */
+	__u16		set_args;	/* Type and number of args */
+	__u16		get_args;	/* Type and number of args */
+	char		name[IFNAMSIZ];	/* Name of the extension */
+};
+
+#endif	/* _LINUX_WIRELESS_H */
diff --git a/wireless.14.h b/wireless.14.h
new file mode 100644
index 0000000..226f540
--- /dev/null
+++ b/wireless.14.h
@@ -0,0 +1,669 @@
+/*
+ * This file define a set of standard wireless extensions
+ *
+ * Version :	14	25.1.02
+ *
+ * Authors :	Jean Tourrilhes - HPL - <jt@hpl.hp.com>
+ * Copyright (c) 1997-2002 Jean Tourrilhes, All Rights Reserved.
+ */
+
+#ifndef _LINUX_WIRELESS_H
+#define _LINUX_WIRELESS_H
+
+/************************** DOCUMENTATION **************************/
+/*
+ * Initial APIs (1996 -> onward) :
+ * -----------------------------
+ * Basically, the wireless extensions are for now a set of standard ioctl
+ * call + /proc/net/wireless
+ *
+ * The entry /proc/net/wireless give statistics and information on the
+ * driver.
+ * This is better than having each driver having its entry because
+ * its centralised and we may remove the driver module safely.
+ *
+ * Ioctl are used to configure the driver and issue commands.  This is
+ * better than command line options of insmod because we may want to
+ * change dynamically (while the driver is running) some parameters.
+ *
+ * The ioctl mechanimsm are copied from standard devices ioctl.
+ * We have the list of command plus a structure descibing the
+ * data exchanged...
+ * Note that to add these ioctl, I was obliged to modify :
+ *	# net/core/dev.c (two place + add include)
+ *	# net/ipv4/af_inet.c (one place + add include)
+ *
+ * /proc/net/wireless is a copy of /proc/net/dev.
+ * We have a structure for data passed from the driver to /proc/net/wireless
+ * Too add this, I've modified :
+ *	# net/core/dev.c (two other places)
+ *	# include/linux/netdevice.h (one place)
+ *	# include/linux/proc_fs.h (one place)
+ *
+ * New driver API (2002 -> onward) :
+ * -------------------------------
+ * This file is only concerned with the user space API and common definitions.
+ * The new driver API is defined and documented in :
+ *	# include/net/iw_handler.h
+ *
+ * Note as well that /proc/net/wireless implementation has now moved in :
+ *	# include/linux/wireless.c
+ *
+ * Wireless Events (2002 -> onward) :
+ * --------------------------------
+ * Events are defined at the end of this file, and implemented in :
+ *	# include/linux/wireless.c
+ *
+ * Other comments :
+ * --------------
+ * Do not add here things that are redundant with other mechanisms
+ * (drivers init, ifconfig, /proc/net/dev, ...) and with are not
+ * wireless specific.
+ *
+ * These wireless extensions are not magic : each driver has to provide
+ * support for them...
+ *
+ * IMPORTANT NOTE : As everything in the kernel, this is very much a
+ * work in progress. Contact me if you have ideas of improvements...
+ */
+
+/***************************** INCLUDES *****************************/
+
+#include <linux/types.h>		/* for "caddr_t" et al		*/
+#include <linux/socket.h>		/* for "struct sockaddr" et al	*/
+#include <linux/if.h>			/* for IFNAMSIZ and co... */
+
+/***************************** VERSION *****************************/
+/*
+ * This constant is used to know the availability of the wireless
+ * extensions and to know which version of wireless extensions it is
+ * (there is some stuff that will be added in the future...)
+ * I just plan to increment with each new version.
+ */
+#define WIRELESS_EXT	14
+
+/*
+ * Changes :
+ *
+ * V2 to V3
+ * --------
+ *	Alan Cox start some incompatibles changes. I've integrated a bit more.
+ *	- Encryption renamed to Encode to avoid US regulation problems
+ *	- Frequency changed from float to struct to avoid problems on old 386
+ *
+ * V3 to V4
+ * --------
+ *	- Add sensitivity
+ *
+ * V4 to V5
+ * --------
+ *	- Missing encoding definitions in range
+ *	- Access points stuff
+ *
+ * V5 to V6
+ * --------
+ *	- 802.11 support (ESSID ioctls)
+ *
+ * V6 to V7
+ * --------
+ *	- define IW_ESSID_MAX_SIZE and IW_MAX_AP
+ *
+ * V7 to V8
+ * --------
+ *	- Changed my e-mail address
+ *	- More 802.11 support (nickname, rate, rts, frag)
+ *	- List index in frequencies
+ *
+ * V8 to V9
+ * --------
+ *	- Support for 'mode of operation' (ad-hoc, managed...)
+ *	- Support for unicast and multicast power saving
+ *	- Change encoding to support larger tokens (>64 bits)
+ *	- Updated iw_params (disable, flags) and use it for NWID
+ *	- Extracted iw_point from iwreq for clarity
+ *
+ * V9 to V10
+ * ---------
+ *	- Add PM capability to range structure
+ *	- Add PM modifier : MAX/MIN/RELATIVE
+ *	- Add encoding option : IW_ENCODE_NOKEY
+ *	- Add TxPower ioctls (work like TxRate)
+ *
+ * V10 to V11
+ * ----------
+ *	- Add WE version in range (help backward/forward compatibility)
+ *	- Add retry ioctls (work like PM)
+ *
+ * V11 to V12
+ * ----------
+ *	- Add SIOCSIWSTATS to get /proc/net/wireless programatically
+ *	- Add DEV PRIVATE IOCTL to avoid collisions in SIOCDEVPRIVATE space
+ *	- Add new statistics (frag, retry, beacon)
+ *	- Add average quality (for user space calibration)
+ *
+ * V12 to V13
+ * ----------
+ *	- Document creation of new driver API.
+ *	- Extract union iwreq_data from struct iwreq (for new driver API).
+ *	- Rename SIOCSIWNAME as SIOCSIWCOMMIT
+ *
+ * V13 to V14
+ * ----------
+ *	- Wireless Events support : define struct iw_event
+ *	- Define additional specific event numbers
+ *	- Add "addr" and "param" fields in union iwreq_data
+ *	- AP scanning stuff (SIOCSIWSCAN and friends)
+ */
+
+/**************************** CONSTANTS ****************************/
+
+/* -------------------------- IOCTL LIST -------------------------- */
+
+/* Basic operations */
+#define SIOCSIWCOMMIT	0x8B00		/* Commit pending changes to driver */
+#define SIOCGIWNAME	0x8B01		/* get name == wireless protocol */
+#define SIOCSIWNWID	0x8B02		/* set network id (the cell) */
+#define SIOCGIWNWID	0x8B03		/* get network id */
+#define SIOCSIWFREQ	0x8B04		/* set channel/frequency (Hz) */
+#define SIOCGIWFREQ	0x8B05		/* get channel/frequency (Hz) */
+#define SIOCSIWMODE	0x8B06		/* set operation mode */
+#define SIOCGIWMODE	0x8B07		/* get operation mode */
+#define SIOCSIWSENS	0x8B08		/* set sensitivity (dBm) */
+#define SIOCGIWSENS	0x8B09		/* get sensitivity (dBm) */
+
+/* Informative stuff */
+#define SIOCSIWRANGE	0x8B0A		/* Unused */
+#define SIOCGIWRANGE	0x8B0B		/* Get range of parameters */
+#define SIOCSIWPRIV	0x8B0C		/* Unused */
+#define SIOCGIWPRIV	0x8B0D		/* get private ioctl interface info */
+#define SIOCSIWSTATS	0x8B0E		/* Unused */
+#define SIOCGIWSTATS	0x8B0F		/* Get /proc/net/wireless stats */
+
+/* Mobile IP support */
+#define SIOCSIWSPY	0x8B10		/* set spy addresses */
+#define SIOCGIWSPY	0x8B11		/* get spy info (quality of link) */
+
+/* Access Point manipulation */
+#define SIOCSIWAP	0x8B14		/* set access point MAC addresses */
+#define SIOCGIWAP	0x8B15		/* get access point MAC addresses */
+#define SIOCGIWAPLIST	0x8B17		/* get list of access point in range */
+#define SIOCSIWSCAN	0x8B18		/* trigger scanning */
+#define SIOCGIWSCAN	0x8B19		/* get scanning results */
+
+/* 802.11 specific support */
+#define SIOCSIWESSID	0x8B1A		/* set ESSID (network name) */
+#define SIOCGIWESSID	0x8B1B		/* get ESSID */
+#define SIOCSIWNICKN	0x8B1C		/* set node name/nickname */
+#define SIOCGIWNICKN	0x8B1D		/* get node name/nickname */
+/* As the ESSID and NICKN are strings up to 32 bytes long, it doesn't fit
+ * within the 'iwreq' structure, so we need to use the 'data' member to
+ * point to a string in user space, like it is done for RANGE...
+ * The "flags" member indicate if the ESSID is active or not (promiscuous).
+ */
+
+/* Other parameters useful in 802.11 and some other devices */
+#define SIOCSIWRATE	0x8B20		/* set default bit rate (bps) */
+#define SIOCGIWRATE	0x8B21		/* get default bit rate (bps) */
+#define SIOCSIWRTS	0x8B22		/* set RTS/CTS threshold (bytes) */
+#define SIOCGIWRTS	0x8B23		/* get RTS/CTS threshold (bytes) */
+#define SIOCSIWFRAG	0x8B24		/* set fragmentation thr (bytes) */
+#define SIOCGIWFRAG	0x8B25		/* get fragmentation thr (bytes) */
+#define SIOCSIWTXPOW	0x8B26		/* set transmit power (dBm) */
+#define SIOCGIWTXPOW	0x8B27		/* get transmit power (dBm) */
+#define SIOCSIWRETRY	0x8B28		/* set retry limits and lifetime */
+#define SIOCGIWRETRY	0x8B29		/* get retry limits and lifetime */
+
+/* Encoding stuff (scrambling, hardware security, WEP...) */
+#define SIOCSIWENCODE	0x8B2A		/* set encoding token & mode */
+#define SIOCGIWENCODE	0x8B2B		/* get encoding token & mode */
+/* Power saving stuff (power management, unicast and multicast) */
+#define SIOCSIWPOWER	0x8B2C		/* set Power Management settings */
+#define SIOCGIWPOWER	0x8B2D		/* get Power Management settings */
+
+/* -------------------- DEV PRIVATE IOCTL LIST -------------------- */
+
+/* These 16 ioctl are wireless device private.
+ * Each driver is free to use them for whatever purpose it chooses,
+ * however the driver *must* export the description of those ioctls
+ * with SIOCGIWPRIV and *must* use arguments as defined below.
+ * If you don't follow those rules, DaveM is going to hate you (reason :
+ * it make mixed 32/64bit operation impossible).
+ */
+#define SIOCIWFIRSTPRIV	0x8BE0
+#define SIOCIWLASTPRIV	0x8BFF
+/* Previously, we were using SIOCDEVPRIVATE, but we now have our
+ * separate range because of collisions with other tools such as
+ * 'mii-tool'.
+ * We now have 32 commands, so a bit more space ;-).
+ * Also, all 'odd' commands are only usable by root and don't return the
+ * content of ifr/iwr to user (but you are not obliged to use the set/get
+ * convention, just use every other two command).
+ * And I repeat : you are not obliged to use them with iwspy, but you
+ * must be compliant with it.
+ */
+
+/* ------------------------- IOCTL STUFF ------------------------- */
+
+/* The first and the last (range) */
+#define SIOCIWFIRST	0x8B00
+#define SIOCIWLAST	SIOCIWLASTPRIV		/* 0x8BFF */
+
+/* Even : get (world access), odd : set (root access) */
+#define IW_IS_SET(cmd)	(!((cmd) & 0x1))
+#define IW_IS_GET(cmd)	((cmd) & 0x1)
+
+/* ----------------------- WIRELESS EVENTS ----------------------- */
+/* Those are *NOT* ioctls, do not issue request on them !!! */
+/* Most events use the same identifier as ioctl requests */
+
+#define IWEVTXDROP	0x8C00		/* Packet dropped to excessive retry */
+#define IWEVQUAL	0x8C01		/* Quality part of statistics */
+
+#define IWEVFIRST	0x8C00
+
+/* ------------------------- PRIVATE INFO ------------------------- */
+/*
+ * The following is used with SIOCGIWPRIV. It allow a driver to define
+ * the interface (name, type of data) for its private ioctl.
+ * Privates ioctl are SIOCIWFIRSTPRIV -> SIOCIWLASTPRIV
+ */
+
+#define IW_PRIV_TYPE_MASK	0x7000	/* Type of arguments */
+#define IW_PRIV_TYPE_NONE	0x0000
+#define IW_PRIV_TYPE_BYTE	0x1000	/* Char as number */
+#define IW_PRIV_TYPE_CHAR	0x2000	/* Char as character */
+#define IW_PRIV_TYPE_INT	0x4000	/* 32 bits int */
+#define IW_PRIV_TYPE_FLOAT	0x5000
+
+#define IW_PRIV_SIZE_FIXED	0x0800	/* Variable or fixed nuber of args */
+
+#define IW_PRIV_SIZE_MASK	0x07FF	/* Max number of those args */
+
+/*
+ * Note : if the number of args is fixed and the size < 16 octets,
+ * instead of passing a pointer we will put args in the iwreq struct...
+ */
+
+/* ----------------------- OTHER CONSTANTS ----------------------- */
+
+/* Maximum frequencies in the range struct */
+#define IW_MAX_FREQUENCIES	16
+/* Note : if you have something like 80 frequencies,
+ * don't increase this constant and don't fill the frequency list.
+ * The user will be able to set by channel anyway... */
+
+/* Maximum bit rates in the range struct */
+#define IW_MAX_BITRATES		8
+
+/* Maximum tx powers in the range struct */
+#define IW_MAX_TXPOWER		8
+
+/* Maximum of address that you may set with SPY */
+#define IW_MAX_SPY		8
+
+/* Maximum of address that you may get in the
+   list of access points in range */
+#define IW_MAX_AP		8
+
+/* Maximum size of the ESSID and NICKN strings */
+#define IW_ESSID_MAX_SIZE	32
+
+/* Modes of operation */
+#define IW_MODE_AUTO	0	/* Let the driver decides */
+#define IW_MODE_ADHOC	1	/* Single cell network */
+#define IW_MODE_INFRA	2	/* Multi cell network, roaming, ... */
+#define IW_MODE_MASTER	3	/* Synchronisation master or Access Point */
+#define IW_MODE_REPEAT	4	/* Wireless Repeater (forwarder) */
+#define IW_MODE_SECOND	5	/* Secondary master/repeater (backup) */
+
+/* Maximum number of size of encoding token available
+ * they are listed in the range structure */
+#define IW_MAX_ENCODING_SIZES	8
+
+/* Maximum size of the encoding token in bytes */
+#define IW_ENCODING_TOKEN_MAX	32	/* 256 bits (for now) */
+
+/* Flags for encoding (along with the token) */
+#define IW_ENCODE_INDEX		0x00FF	/* Token index (if needed) */
+#define IW_ENCODE_FLAGS		0xFF00	/* Flags defined below */
+#define IW_ENCODE_MODE		0xF000	/* Modes defined below */
+#define IW_ENCODE_DISABLED	0x8000	/* Encoding disabled */
+#define IW_ENCODE_ENABLED	0x0000	/* Encoding enabled */
+#define IW_ENCODE_RESTRICTED	0x4000	/* Refuse non-encoded packets */
+#define IW_ENCODE_OPEN		0x2000	/* Accept non-encoded packets */
+#define IW_ENCODE_NOKEY         0x0800  /* Key is write only, so not present */
+
+/* Power management flags available (along with the value, if any) */
+#define IW_POWER_ON		0x0000	/* No details... */
+#define IW_POWER_TYPE		0xF000	/* Type of parameter */
+#define IW_POWER_PERIOD		0x1000	/* Value is a period/duration of  */
+#define IW_POWER_TIMEOUT	0x2000	/* Value is a timeout (to go asleep) */
+#define IW_POWER_MODE		0x0F00	/* Power Management mode */
+#define IW_POWER_UNICAST_R	0x0100	/* Receive only unicast messages */
+#define IW_POWER_MULTICAST_R	0x0200	/* Receive only multicast messages */
+#define IW_POWER_ALL_R		0x0300	/* Receive all messages though PM */
+#define IW_POWER_FORCE_S	0x0400	/* Force PM procedure for sending unicast */
+#define IW_POWER_REPEATER	0x0800	/* Repeat broadcast messages in PM period */
+#define IW_POWER_MODIFIER	0x000F	/* Modify a parameter */
+#define IW_POWER_MIN		0x0001	/* Value is a minimum  */
+#define IW_POWER_MAX		0x0002	/* Value is a maximum */
+#define IW_POWER_RELATIVE	0x0004	/* Value is not in seconds/ms/us */
+
+/* Transmit Power flags available */
+#define IW_TXPOW_DBM		0x0000	/* Value is in dBm */
+#define IW_TXPOW_MWATT		0x0001	/* Value is in mW */
+
+/* Retry limits and lifetime flags available */
+#define IW_RETRY_ON		0x0000	/* No details... */
+#define IW_RETRY_TYPE		0xF000	/* Type of parameter */
+#define IW_RETRY_LIMIT		0x1000	/* Maximum number of retries*/
+#define IW_RETRY_LIFETIME	0x2000	/* Maximum duration of retries in us */
+#define IW_RETRY_MODIFIER	0x000F	/* Modify a parameter */
+#define IW_RETRY_MIN		0x0001	/* Value is a minimum  */
+#define IW_RETRY_MAX		0x0002	/* Value is a maximum */
+#define IW_RETRY_RELATIVE	0x0004	/* Value is not in seconds/ms/us */
+
+/* Scanning request flags */
+#define IW_SCAN_DEFAULT		0x0000	/* Default scan of the driver */
+#define IW_SCAN_ALL_ESSID	0x0001	/* Scan all ESSIDs */
+#define IW_SCAN_THIS_ESSID	0x0002	/* Scan only this ESSID */
+#define IW_SCAN_ALL_FREQ	0x0004	/* Scan all Frequencies */
+#define IW_SCAN_THIS_FREQ	0x0008	/* Scan only this Frequency */
+#define IW_SCAN_ALL_MODE	0x0010	/* Scan all Modes */
+#define IW_SCAN_THIS_MODE	0x0020	/* Scan only this Mode */
+#define IW_SCAN_ALL_RATE	0x0040	/* Scan all Bit-Rates */
+#define IW_SCAN_THIS_RATE	0x0080	/* Scan only this Bit-Rate */
+/* Maximum size of returned data */
+#define IW_SCAN_MAX_DATA	4096	/* In bytes */
+
+/****************************** TYPES ******************************/
+
+/* --------------------------- SUBTYPES --------------------------- */
+/*
+ *	Generic format for most parameters that fit in an int
+ */
+struct	iw_param
+{
+  __s32		value;		/* The value of the parameter itself */
+  __u8		fixed;		/* Hardware should not use auto select */
+  __u8		disabled;	/* Disable the feature */
+  __u16		flags;		/* Various specifc flags (if any) */
+};
+
+/*
+ *	For all data larger than 16 octets, we need to use a
+ *	pointer to memory allocated in user space.
+ */
+struct	iw_point
+{
+  caddr_t	pointer;	/* Pointer to the data  (in user space) */
+  __u16		length;		/* number of fields or size in bytes */
+  __u16		flags;		/* Optional params */
+};
+
+/*
+ *	A frequency
+ *	For numbers lower than 10^9, we encode the number in 'm' and
+ *	set 'e' to 0
+ *	For number greater than 10^9, we divide it by the lowest power
+ *	of 10 to get 'm' lower than 10^9, with 'm'= f / (10^'e')...
+ *	The power of 10 is in 'e', the result of the division is in 'm'.
+ */
+struct	iw_freq
+{
+	__u32		m;		/* Mantissa */
+	__u16		e;		/* Exponent */
+	__u8		i;		/* List index (when in range struct) */
+};
+
+/*
+ *	Quality of the link
+ */
+struct	iw_quality
+{
+	__u8		qual;		/* link quality (%retries, SNR,
+					   %missed beacons or better...) */
+	__u8		level;		/* signal level (dBm) */
+	__u8		noise;		/* noise level (dBm) */
+	__u8		updated;	/* Flags to know if updated */
+};
+
+/*
+ *	Packet discarded in the wireless adapter due to
+ *	"wireless" specific problems...
+ *	Note : the list of counter and statistics in net_device_stats
+ *	is already pretty exhaustive, and you should use that first.
+ *	This is only additional stats...
+ */
+struct	iw_discarded
+{
+	__u32		nwid;		/* Rx : Wrong nwid/essid */
+	__u32		code;		/* Rx : Unable to code/decode (WEP) */
+	__u32		fragment;	/* Rx : Can't perform MAC reassembly */
+	__u32		retries;	/* Tx : Max MAC retries num reached */
+	__u32		misc;		/* Others cases */
+};
+
+/*
+ *	Packet/Time period missed in the wireless adapter due to
+ *	"wireless" specific problems...
+ */
+struct	iw_missed
+{
+	__u32		beacon;		/* Missed beacons/superframe */
+};
+
+/* ------------------------ WIRELESS STATS ------------------------ */
+/*
+ * Wireless statistics (used for /proc/net/wireless)
+ */
+struct	iw_statistics
+{
+	__u16		status;		/* Status
+					 * - device dependent for now */
+
+	struct iw_quality	qual;		/* Quality of the link
+						 * (instant/mean/max) */
+	struct iw_discarded	discard;	/* Packet discarded counts */
+	struct iw_missed	miss;		/* Packet missed counts */
+};
+
+/* ------------------------ IOCTL REQUEST ------------------------ */
+/*
+ * This structure defines the payload of an ioctl, and is used 
+ * below.
+ *
+ * Note that this structure should fit on the memory footprint
+ * of iwreq (which is the same as ifreq), which mean a max size of
+ * 16 octets = 128 bits. Warning, pointers might be 64 bits wide...
+ * You should check this when increasing the structures defined
+ * above in this file...
+ */
+union	iwreq_data
+{
+	/* Config - generic */
+	char		name[IFNAMSIZ];
+	/* Name : used to verify the presence of  wireless extensions.
+	 * Name of the protocol/provider... */
+
+	struct iw_point	essid;		/* Extended network name */
+	struct iw_param	nwid;		/* network id (or domain - the cell) */
+	struct iw_freq	freq;		/* frequency or channel :
+					 * 0-1000 = channel
+					 * > 1000 = frequency in Hz */
+
+	struct iw_param	sens;		/* signal level threshold */
+	struct iw_param	bitrate;	/* default bit rate */
+	struct iw_param	txpower;	/* default transmit power */
+	struct iw_param	rts;		/* RTS threshold threshold */
+	struct iw_param	frag;		/* Fragmentation threshold */
+	__u32		mode;		/* Operation mode */
+	struct iw_param	retry;		/* Retry limits & lifetime */
+
+	struct iw_point	encoding;	/* Encoding stuff : tokens */
+	struct iw_param	power;		/* PM duration/timeout */
+	struct iw_quality qual;		/* Quality part of statistics */
+
+	struct sockaddr	ap_addr;	/* Access point address */
+	struct sockaddr	addr;		/* Destination address (hw) */
+
+	struct iw_param	param;		/* Other small parameters */
+	struct iw_point	data;		/* Other large parameters */
+};
+
+/*
+ * The structure to exchange data for ioctl.
+ * This structure is the same as 'struct ifreq', but (re)defined for
+ * convenience...
+ * Do I need to remind you about structure size (32 octets) ?
+ */
+struct	iwreq 
+{
+	union
+	{
+		char	ifrn_name[IFNAMSIZ];	/* if name, e.g. "eth0" */
+	} ifr_ifrn;
+
+	/* Data part (defined just above) */
+	union	iwreq_data	u;
+};
+
+/* -------------------------- IOCTL DATA -------------------------- */
+/*
+ *	For those ioctl which want to exchange mode data that what could
+ *	fit in the above structure...
+ */
+
+/*
+ *	Range of parameters
+ */
+
+struct	iw_range
+{
+	/* Informative stuff (to choose between different interface) */
+	__u32		throughput;	/* To give an idea... */
+	/* In theory this value should be the maximum benchmarked
+	 * TCP/IP throughput, because with most of these devices the
+	 * bit rate is meaningless (overhead an co) to estimate how
+	 * fast the connection will go and pick the fastest one.
+	 * I suggest people to play with Netperf or any benchmark...
+	 */
+
+	/* NWID (or domain id) */
+	__u32		min_nwid;	/* Minimal NWID we are able to set */
+	__u32		max_nwid;	/* Maximal NWID we are able to set */
+
+	/* Frequency */
+	__u16		num_channels;	/* Number of channels [0; num - 1] */
+	__u8		num_frequency;	/* Number of entry in the list */
+	struct iw_freq	freq[IW_MAX_FREQUENCIES];	/* list */
+	/* Note : this frequency list doesn't need to fit channel numbers */
+
+	/* signal level threshold range */
+	__s32	sensitivity;
+
+	/* Quality of link & SNR stuff */
+	struct iw_quality	max_qual;	/* Quality of the link */
+
+	/* Rates */
+	__u8		num_bitrates;	/* Number of entries in the list */
+	__s32		bitrate[IW_MAX_BITRATES];	/* list, in bps */
+
+	/* RTS threshold */
+	__s32		min_rts;	/* Minimal RTS threshold */
+	__s32		max_rts;	/* Maximal RTS threshold */
+
+	/* Frag threshold */
+	__s32		min_frag;	/* Minimal frag threshold */
+	__s32		max_frag;	/* Maximal frag threshold */
+
+	/* Power Management duration & timeout */
+	__s32		min_pmp;	/* Minimal PM period */
+	__s32		max_pmp;	/* Maximal PM period */
+	__s32		min_pmt;	/* Minimal PM timeout */
+	__s32		max_pmt;	/* Maximal PM timeout */
+	__u16		pmp_flags;	/* How to decode max/min PM period */
+	__u16		pmt_flags;	/* How to decode max/min PM timeout */
+	__u16		pm_capa;	/* What PM options are supported */
+
+	/* Encoder stuff */
+	__u16	encoding_size[IW_MAX_ENCODING_SIZES];	/* Different token sizes */
+	__u8	num_encoding_sizes;	/* Number of entry in the list */
+	__u8	max_encoding_tokens;	/* Max number of tokens */
+
+	/* Transmit power */
+	__u16		txpower_capa;	/* What options are supported */
+	__u8		num_txpower;	/* Number of entries in the list */
+	__s32		txpower[IW_MAX_TXPOWER];	/* list, in bps */
+
+	/* Wireless Extension version info */
+	__u8		we_version_compiled;	/* Must be WIRELESS_EXT */
+	__u8		we_version_source;	/* Last update of source */
+
+	/* Retry limits and lifetime */
+	__u16		retry_capa;	/* What retry options are supported */
+	__u16		retry_flags;	/* How to decode max/min retry limit */
+	__u16		r_time_flags;	/* How to decode max/min retry life */
+	__s32		min_retry;	/* Minimal number of retries */
+	__s32		max_retry;	/* Maximal number of retries */
+	__s32		min_r_time;	/* Minimal retry lifetime */
+	__s32		max_r_time;	/* Maximal retry lifetime */
+
+	/* Average quality of link & SNR */
+	struct iw_quality	avg_qual;	/* Quality of the link */
+	/* This should contain the average/typical values of the quality
+	 * indicator. This should be the threshold between a "good" and
+	 * a "bad" link (example : monitor going from green to orange).
+	 * Currently, user space apps like quality monitors don't have any
+	 * way to calibrate the measurement. With this, they can split
+	 * the range between 0 and max_qual in different quality level
+	 * (using a geometric subdivision centered on the average).
+	 * I expect that people doing the user space apps will feedback
+	 * us on which value we need to put in each driver...
+	 */
+};
+
+/*
+ * Private ioctl interface information
+ */
+ 
+struct	iw_priv_args
+{
+	__u32		cmd;		/* Number of the ioctl to issue */
+	__u16		set_args;	/* Type and number of args */
+	__u16		get_args;	/* Type and number of args */
+	char		name[IFNAMSIZ];	/* Name of the extension */
+};
+
+/* ----------------------- WIRELESS EVENTS ----------------------- */
+/*
+ * Wireless events are carried through the rtnetlink socket to user
+ * space. They are encapsulated in the IFLA_WIRELESS field of
+ * a RTM_NEWLINK message.
+ */
+
+/*
+ * A Wireless Event. Contains basically the same data as the ioctl...
+ */
+struct iw_event
+{
+	__u16		len;			/* Real lenght of this stuff */
+	__u16		cmd;			/* Wireless IOCTL */
+	union iwreq_data	u;		/* IOCTL fixed payload */
+};
+
+/* Size of the Event prefix (including padding and alignement junk) */
+#define IW_EV_LCP_LEN	(sizeof(struct iw_event) - sizeof(union iwreq_data))
+/* Size of the various events */
+#define IW_EV_CHAR_LEN	(IW_EV_LCP_LEN + IFNAMSIZ)
+#define IW_EV_UINT_LEN	(IW_EV_LCP_LEN + sizeof(__u32))
+#define IW_EV_FREQ_LEN	(IW_EV_LCP_LEN + sizeof(struct iw_freq))
+#define IW_EV_POINT_LEN	(IW_EV_LCP_LEN + sizeof(struct iw_point))
+#define IW_EV_PARAM_LEN	(IW_EV_LCP_LEN + sizeof(struct iw_param))
+#define IW_EV_ADDR_LEN	(IW_EV_LCP_LEN + sizeof(struct sockaddr))
+#define IW_EV_QUAL_LEN	(IW_EV_LCP_LEN + sizeof(struct iw_quality))
+
+/* Note : in the case of iw_point, the extra data will come at the
+ * end of the event */
+
+#endif	/* _LINUX_WIRELESS_H */
diff --git a/wireless.15.h b/wireless.15.h
new file mode 100644
index 0000000..bacf44b
--- /dev/null
+++ b/wireless.15.h
@@ -0,0 +1,698 @@
+/*
+ * This file define a set of standard wireless extensions
+ *
+ * Version :	15	12.7.02
+ *
+ * Authors :	Jean Tourrilhes - HPL - <jt@hpl.hp.com>
+ * Copyright (c) 1997-2002 Jean Tourrilhes, All Rights Reserved.
+ */
+
+#ifndef _LINUX_WIRELESS_H
+#define _LINUX_WIRELESS_H
+
+/************************** DOCUMENTATION **************************/
+/*
+ * Initial APIs (1996 -> onward) :
+ * -----------------------------
+ * Basically, the wireless extensions are for now a set of standard ioctl
+ * call + /proc/net/wireless
+ *
+ * The entry /proc/net/wireless give statistics and information on the
+ * driver.
+ * This is better than having each driver having its entry because
+ * its centralised and we may remove the driver module safely.
+ *
+ * Ioctl are used to configure the driver and issue commands.  This is
+ * better than command line options of insmod because we may want to
+ * change dynamically (while the driver is running) some parameters.
+ *
+ * The ioctl mechanimsm are copied from standard devices ioctl.
+ * We have the list of command plus a structure descibing the
+ * data exchanged...
+ * Note that to add these ioctl, I was obliged to modify :
+ *	# net/core/dev.c (two place + add include)
+ *	# net/ipv4/af_inet.c (one place + add include)
+ *
+ * /proc/net/wireless is a copy of /proc/net/dev.
+ * We have a structure for data passed from the driver to /proc/net/wireless
+ * Too add this, I've modified :
+ *	# net/core/dev.c (two other places)
+ *	# include/linux/netdevice.h (one place)
+ *	# include/linux/proc_fs.h (one place)
+ *
+ * New driver API (2002 -> onward) :
+ * -------------------------------
+ * This file is only concerned with the user space API and common definitions.
+ * The new driver API is defined and documented in :
+ *	# include/net/iw_handler.h
+ *
+ * Note as well that /proc/net/wireless implementation has now moved in :
+ *	# include/linux/wireless.c
+ *
+ * Wireless Events (2002 -> onward) :
+ * --------------------------------
+ * Events are defined at the end of this file, and implemented in :
+ *	# include/linux/wireless.c
+ *
+ * Other comments :
+ * --------------
+ * Do not add here things that are redundant with other mechanisms
+ * (drivers init, ifconfig, /proc/net/dev, ...) and with are not
+ * wireless specific.
+ *
+ * These wireless extensions are not magic : each driver has to provide
+ * support for them...
+ *
+ * IMPORTANT NOTE : As everything in the kernel, this is very much a
+ * work in progress. Contact me if you have ideas of improvements...
+ */
+
+/***************************** INCLUDES *****************************/
+
+#include <linux/types.h>		/* for "caddr_t" et al		*/
+#include <linux/socket.h>		/* for "struct sockaddr" et al	*/
+#include <linux/if.h>			/* for IFNAMSIZ and co... */
+
+/***************************** VERSION *****************************/
+/*
+ * This constant is used to know the availability of the wireless
+ * extensions and to know which version of wireless extensions it is
+ * (there is some stuff that will be added in the future...)
+ * I just plan to increment with each new version.
+ */
+#define WIRELESS_EXT	15
+
+/*
+ * Changes :
+ *
+ * V2 to V3
+ * --------
+ *	Alan Cox start some incompatibles changes. I've integrated a bit more.
+ *	- Encryption renamed to Encode to avoid US regulation problems
+ *	- Frequency changed from float to struct to avoid problems on old 386
+ *
+ * V3 to V4
+ * --------
+ *	- Add sensitivity
+ *
+ * V4 to V5
+ * --------
+ *	- Missing encoding definitions in range
+ *	- Access points stuff
+ *
+ * V5 to V6
+ * --------
+ *	- 802.11 support (ESSID ioctls)
+ *
+ * V6 to V7
+ * --------
+ *	- define IW_ESSID_MAX_SIZE and IW_MAX_AP
+ *
+ * V7 to V8
+ * --------
+ *	- Changed my e-mail address
+ *	- More 802.11 support (nickname, rate, rts, frag)
+ *	- List index in frequencies
+ *
+ * V8 to V9
+ * --------
+ *	- Support for 'mode of operation' (ad-hoc, managed...)
+ *	- Support for unicast and multicast power saving
+ *	- Change encoding to support larger tokens (>64 bits)
+ *	- Updated iw_params (disable, flags) and use it for NWID
+ *	- Extracted iw_point from iwreq for clarity
+ *
+ * V9 to V10
+ * ---------
+ *	- Add PM capability to range structure
+ *	- Add PM modifier : MAX/MIN/RELATIVE
+ *	- Add encoding option : IW_ENCODE_NOKEY
+ *	- Add TxPower ioctls (work like TxRate)
+ *
+ * V10 to V11
+ * ----------
+ *	- Add WE version in range (help backward/forward compatibility)
+ *	- Add retry ioctls (work like PM)
+ *
+ * V11 to V12
+ * ----------
+ *	- Add SIOCSIWSTATS to get /proc/net/wireless programatically
+ *	- Add DEV PRIVATE IOCTL to avoid collisions in SIOCDEVPRIVATE space
+ *	- Add new statistics (frag, retry, beacon)
+ *	- Add average quality (for user space calibration)
+ *
+ * V12 to V13
+ * ----------
+ *	- Document creation of new driver API.
+ *	- Extract union iwreq_data from struct iwreq (for new driver API).
+ *	- Rename SIOCSIWNAME as SIOCSIWCOMMIT
+ *
+ * V13 to V14
+ * ----------
+ *	- Wireless Events support : define struct iw_event
+ *	- Define additional specific event numbers
+ *	- Add "addr" and "param" fields in union iwreq_data
+ *	- AP scanning stuff (SIOCSIWSCAN and friends)
+ *
+ * V14 to V15
+ * ----------
+ *	- Add IW_PRIV_TYPE_ADDR for struct sockaddr private arg
+ *	- Make struct iw_freq signed (both m & e), add explicit padding
+ *	- Add IWEVCUSTOM for driver specific event/scanning token
+ *	- Add IW_MAX_GET_SPY for driver returning a lot of addresses
+ *	- Add IW_TXPOW_RANGE for range of Tx Powers
+ *	- Add IWEVREGISTERED & IWEVEXPIRED events for Access Points
+ *	- Add IW_MODE_MONITOR for passive monitor
+ */
+
+/**************************** CONSTANTS ****************************/
+
+/* -------------------------- IOCTL LIST -------------------------- */
+
+/* Wireless Identification */
+#define SIOCSIWCOMMIT	0x8B00		/* Commit pending changes to driver */
+#define SIOCGIWNAME	0x8B01		/* get name == wireless protocol */
+/* SIOCGIWNAME is used to verify the presence of Wireless Extensions.
+ * Common values : "IEEE 802.11-DS", "IEEE 802.11-FH", "IEEE 802.11b"...
+ * Don't put the name of your driver there, it's useless. */
+
+/* Basic operations */
+#define SIOCSIWNWID	0x8B02		/* set network id (pre-802.11) */
+#define SIOCGIWNWID	0x8B03		/* get network id (the cell) */
+#define SIOCSIWFREQ	0x8B04		/* set channel/frequency (Hz) */
+#define SIOCGIWFREQ	0x8B05		/* get channel/frequency (Hz) */
+#define SIOCSIWMODE	0x8B06		/* set operation mode */
+#define SIOCGIWMODE	0x8B07		/* get operation mode */
+#define SIOCSIWSENS	0x8B08		/* set sensitivity (dBm) */
+#define SIOCGIWSENS	0x8B09		/* get sensitivity (dBm) */
+
+/* Informative stuff */
+#define SIOCSIWRANGE	0x8B0A		/* Unused */
+#define SIOCGIWRANGE	0x8B0B		/* Get range of parameters */
+#define SIOCSIWPRIV	0x8B0C		/* Unused */
+#define SIOCGIWPRIV	0x8B0D		/* get private ioctl interface info */
+#define SIOCSIWSTATS	0x8B0E		/* Unused */
+#define SIOCGIWSTATS	0x8B0F		/* Get /proc/net/wireless stats */
+/* SIOCGIWSTATS is strictly used between user space and the kernel, and
+ * is never passed to the driver (i.e. the driver will never see it). */
+
+/* Mobile IP support (statistics per MAC address) */
+#define SIOCSIWSPY	0x8B10		/* set spy addresses */
+#define SIOCGIWSPY	0x8B11		/* get spy info (quality of link) */
+
+/* Access Point manipulation */
+#define SIOCSIWAP	0x8B14		/* set access point MAC addresses */
+#define SIOCGIWAP	0x8B15		/* get access point MAC addresses */
+#define SIOCGIWAPLIST	0x8B17		/* Deprecated in favor of scanning */
+#define SIOCSIWSCAN	0x8B18		/* trigger scanning (list cells) */
+#define SIOCGIWSCAN	0x8B19		/* get scanning results */
+
+/* 802.11 specific support */
+#define SIOCSIWESSID	0x8B1A		/* set ESSID (network name) */
+#define SIOCGIWESSID	0x8B1B		/* get ESSID */
+#define SIOCSIWNICKN	0x8B1C		/* set node name/nickname */
+#define SIOCGIWNICKN	0x8B1D		/* get node name/nickname */
+/* As the ESSID and NICKN are strings up to 32 bytes long, it doesn't fit
+ * within the 'iwreq' structure, so we need to use the 'data' member to
+ * point to a string in user space, like it is done for RANGE... */
+
+/* Other parameters useful in 802.11 and some other devices */
+#define SIOCSIWRATE	0x8B20		/* set default bit rate (bps) */
+#define SIOCGIWRATE	0x8B21		/* get default bit rate (bps) */
+#define SIOCSIWRTS	0x8B22		/* set RTS/CTS threshold (bytes) */
+#define SIOCGIWRTS	0x8B23		/* get RTS/CTS threshold (bytes) */
+#define SIOCSIWFRAG	0x8B24		/* set fragmentation thr (bytes) */
+#define SIOCGIWFRAG	0x8B25		/* get fragmentation thr (bytes) */
+#define SIOCSIWTXPOW	0x8B26		/* set transmit power (dBm) */
+#define SIOCGIWTXPOW	0x8B27		/* get transmit power (dBm) */
+#define SIOCSIWRETRY	0x8B28		/* set retry limits and lifetime */
+#define SIOCGIWRETRY	0x8B29		/* get retry limits and lifetime */
+
+/* Encoding stuff (scrambling, hardware security, WEP...) */
+#define SIOCSIWENCODE	0x8B2A		/* set encoding token & mode */
+#define SIOCGIWENCODE	0x8B2B		/* get encoding token & mode */
+/* Power saving stuff (power management, unicast and multicast) */
+#define SIOCSIWPOWER	0x8B2C		/* set Power Management settings */
+#define SIOCGIWPOWER	0x8B2D		/* get Power Management settings */
+
+/* -------------------- DEV PRIVATE IOCTL LIST -------------------- */
+
+/* These 16 ioctl are wireless device private.
+ * Each driver is free to use them for whatever purpose it chooses,
+ * however the driver *must* export the description of those ioctls
+ * with SIOCGIWPRIV and *must* use arguments as defined below.
+ * If you don't follow those rules, DaveM is going to hate you (reason :
+ * it make mixed 32/64bit operation impossible).
+ */
+#define SIOCIWFIRSTPRIV	0x8BE0
+#define SIOCIWLASTPRIV	0x8BFF
+/* Previously, we were using SIOCDEVPRIVATE, but we now have our
+ * separate range because of collisions with other tools such as
+ * 'mii-tool'.
+ * We now have 32 commands, so a bit more space ;-).
+ * Also, all 'odd' commands are only usable by root and don't return the
+ * content of ifr/iwr to user (but you are not obliged to use the set/get
+ * convention, just use every other two command).
+ * And I repeat : you are not obliged to use them with iwspy, but you
+ * must be compliant with it.
+ */
+
+/* ------------------------- IOCTL STUFF ------------------------- */
+
+/* The first and the last (range) */
+#define SIOCIWFIRST	0x8B00
+#define SIOCIWLAST	SIOCIWLASTPRIV		/* 0x8BFF */
+
+/* Even : get (world access), odd : set (root access) */
+#define IW_IS_SET(cmd)	(!((cmd) & 0x1))
+#define IW_IS_GET(cmd)	((cmd) & 0x1)
+
+/* ----------------------- WIRELESS EVENTS ----------------------- */
+/* Those are *NOT* ioctls, do not issue request on them !!! */
+/* Most events use the same identifier as ioctl requests */
+
+#define IWEVTXDROP	0x8C00		/* Packet dropped to excessive retry */
+#define IWEVQUAL	0x8C01		/* Quality part of statistics (scan) */
+#define IWEVCUSTOM	0x8C02		/* Driver specific ascii string */
+#define IWEVREGISTERED	0x8C03		/* Discovered a new node (AP mode) */
+#define IWEVEXPIRED	0x8C04		/* Expired a node (AP mode) */
+
+#define IWEVFIRST	0x8C00
+
+/* ------------------------- PRIVATE INFO ------------------------- */
+/*
+ * The following is used with SIOCGIWPRIV. It allow a driver to define
+ * the interface (name, type of data) for its private ioctl.
+ * Privates ioctl are SIOCIWFIRSTPRIV -> SIOCIWLASTPRIV
+ */
+
+#define IW_PRIV_TYPE_MASK	0x7000	/* Type of arguments */
+#define IW_PRIV_TYPE_NONE	0x0000
+#define IW_PRIV_TYPE_BYTE	0x1000	/* Char as number */
+#define IW_PRIV_TYPE_CHAR	0x2000	/* Char as character */
+#define IW_PRIV_TYPE_INT	0x4000	/* 32 bits int */
+#define IW_PRIV_TYPE_FLOAT	0x5000	/* struct iw_freq */
+#define IW_PRIV_TYPE_ADDR	0x6000	/* struct sockaddr */
+
+#define IW_PRIV_SIZE_FIXED	0x0800	/* Variable or fixed nuber of args */
+
+#define IW_PRIV_SIZE_MASK	0x07FF	/* Max number of those args */
+
+/*
+ * Note : if the number of args is fixed and the size < 16 octets,
+ * instead of passing a pointer we will put args in the iwreq struct...
+ */
+
+/* ----------------------- OTHER CONSTANTS ----------------------- */
+
+/* Maximum frequencies in the range struct */
+#define IW_MAX_FREQUENCIES	16
+/* Note : if you have something like 80 frequencies,
+ * don't increase this constant and don't fill the frequency list.
+ * The user will be able to set by channel anyway... */
+
+/* Maximum bit rates in the range struct */
+#define IW_MAX_BITRATES		8
+
+/* Maximum tx powers in the range struct */
+#define IW_MAX_TXPOWER		8
+/* Note : if you more than 8 TXPowers, just set the max and min or
+ * a few of them in the struct iw_range. */
+
+/* Maximum of address that you may set with SPY */
+#define IW_MAX_SPY		8	/* set */
+#define IW_MAX_GET_SPY		64	/* get */
+
+/* Maximum of address that you may get in the
+   list of access points in range */
+#define IW_MAX_AP		8
+
+/* Maximum size of the ESSID and NICKN strings */
+#define IW_ESSID_MAX_SIZE	32
+
+/* Modes of operation */
+#define IW_MODE_AUTO	0	/* Let the driver decides */
+#define IW_MODE_ADHOC	1	/* Single cell network */
+#define IW_MODE_INFRA	2	/* Multi cell network, roaming, ... */
+#define IW_MODE_MASTER	3	/* Synchronisation master or Access Point */
+#define IW_MODE_REPEAT	4	/* Wireless Repeater (forwarder) */
+#define IW_MODE_SECOND	5	/* Secondary master/repeater (backup) */
+#define IW_MODE_MONITOR	6	/* Passive monitor (listen only) */
+
+/* Maximum number of size of encoding token available
+ * they are listed in the range structure */
+#define IW_MAX_ENCODING_SIZES	8
+
+/* Maximum size of the encoding token in bytes */
+#define IW_ENCODING_TOKEN_MAX	32	/* 256 bits (for now) */
+
+/* Flags for encoding (along with the token) */
+#define IW_ENCODE_INDEX		0x00FF	/* Token index (if needed) */
+#define IW_ENCODE_FLAGS		0xFF00	/* Flags defined below */
+#define IW_ENCODE_MODE		0xF000	/* Modes defined below */
+#define IW_ENCODE_DISABLED	0x8000	/* Encoding disabled */
+#define IW_ENCODE_ENABLED	0x0000	/* Encoding enabled */
+#define IW_ENCODE_RESTRICTED	0x4000	/* Refuse non-encoded packets */
+#define IW_ENCODE_OPEN		0x2000	/* Accept non-encoded packets */
+#define IW_ENCODE_NOKEY         0x0800  /* Key is write only, so not present */
+
+/* Power management flags available (along with the value, if any) */
+#define IW_POWER_ON		0x0000	/* No details... */
+#define IW_POWER_TYPE		0xF000	/* Type of parameter */
+#define IW_POWER_PERIOD		0x1000	/* Value is a period/duration of  */
+#define IW_POWER_TIMEOUT	0x2000	/* Value is a timeout (to go asleep) */
+#define IW_POWER_MODE		0x0F00	/* Power Management mode */
+#define IW_POWER_UNICAST_R	0x0100	/* Receive only unicast messages */
+#define IW_POWER_MULTICAST_R	0x0200	/* Receive only multicast messages */
+#define IW_POWER_ALL_R		0x0300	/* Receive all messages though PM */
+#define IW_POWER_FORCE_S	0x0400	/* Force PM procedure for sending unicast */
+#define IW_POWER_REPEATER	0x0800	/* Repeat broadcast messages in PM period */
+#define IW_POWER_MODIFIER	0x000F	/* Modify a parameter */
+#define IW_POWER_MIN		0x0001	/* Value is a minimum  */
+#define IW_POWER_MAX		0x0002	/* Value is a maximum */
+#define IW_POWER_RELATIVE	0x0004	/* Value is not in seconds/ms/us */
+
+/* Transmit Power flags available */
+#define IW_TXPOW_TYPE		0x00FF	/* Type of value */
+#define IW_TXPOW_DBM		0x0000	/* Value is in dBm */
+#define IW_TXPOW_MWATT		0x0001	/* Value is in mW */
+#define IW_TXPOW_RANGE		0x1000	/* Range of value between min/max */
+
+/* Retry limits and lifetime flags available */
+#define IW_RETRY_ON		0x0000	/* No details... */
+#define IW_RETRY_TYPE		0xF000	/* Type of parameter */
+#define IW_RETRY_LIMIT		0x1000	/* Maximum number of retries*/
+#define IW_RETRY_LIFETIME	0x2000	/* Maximum duration of retries in us */
+#define IW_RETRY_MODIFIER	0x000F	/* Modify a parameter */
+#define IW_RETRY_MIN		0x0001	/* Value is a minimum  */
+#define IW_RETRY_MAX		0x0002	/* Value is a maximum */
+#define IW_RETRY_RELATIVE	0x0004	/* Value is not in seconds/ms/us */
+
+/* Scanning request flags */
+#define IW_SCAN_DEFAULT		0x0000	/* Default scan of the driver */
+#define IW_SCAN_ALL_ESSID	0x0001	/* Scan all ESSIDs */
+#define IW_SCAN_THIS_ESSID	0x0002	/* Scan only this ESSID */
+#define IW_SCAN_ALL_FREQ	0x0004	/* Scan all Frequencies */
+#define IW_SCAN_THIS_FREQ	0x0008	/* Scan only this Frequency */
+#define IW_SCAN_ALL_MODE	0x0010	/* Scan all Modes */
+#define IW_SCAN_THIS_MODE	0x0020	/* Scan only this Mode */
+#define IW_SCAN_ALL_RATE	0x0040	/* Scan all Bit-Rates */
+#define IW_SCAN_THIS_RATE	0x0080	/* Scan only this Bit-Rate */
+/* Maximum size of returned data */
+#define IW_SCAN_MAX_DATA	4096	/* In bytes */
+
+/* Max number of char in custom event - use multiple of them if needed */
+#define IW_CUSTOM_MAX		256	/* In bytes */
+
+/****************************** TYPES ******************************/
+
+/* --------------------------- SUBTYPES --------------------------- */
+/*
+ *	Generic format for most parameters that fit in an int
+ */
+struct	iw_param
+{
+  __s32		value;		/* The value of the parameter itself */
+  __u8		fixed;		/* Hardware should not use auto select */
+  __u8		disabled;	/* Disable the feature */
+  __u16		flags;		/* Various specifc flags (if any) */
+};
+
+/*
+ *	For all data larger than 16 octets, we need to use a
+ *	pointer to memory allocated in user space.
+ */
+struct	iw_point
+{
+  caddr_t	pointer;	/* Pointer to the data  (in user space) */
+  __u16		length;		/* number of fields or size in bytes */
+  __u16		flags;		/* Optional params */
+};
+
+/*
+ *	A frequency
+ *	For numbers lower than 10^9, we encode the number in 'm' and
+ *	set 'e' to 0
+ *	For number greater than 10^9, we divide it by the lowest power
+ *	of 10 to get 'm' lower than 10^9, with 'm'= f / (10^'e')...
+ *	The power of 10 is in 'e', the result of the division is in 'm'.
+ */
+struct	iw_freq
+{
+	__s32		m;		/* Mantissa */
+	__s16		e;		/* Exponent */
+	__u8		i;		/* List index (when in range struct) */
+	__u8		pad;		/* Unused - just for alignement */
+};
+
+/*
+ *	Quality of the link
+ */
+struct	iw_quality
+{
+	__u8		qual;		/* link quality (%retries, SNR,
+					   %missed beacons or better...) */
+	__u8		level;		/* signal level (dBm) */
+	__u8		noise;		/* noise level (dBm) */
+	__u8		updated;	/* Flags to know if updated */
+};
+
+/*
+ *	Packet discarded in the wireless adapter due to
+ *	"wireless" specific problems...
+ *	Note : the list of counter and statistics in net_device_stats
+ *	is already pretty exhaustive, and you should use that first.
+ *	This is only additional stats...
+ */
+struct	iw_discarded
+{
+	__u32		nwid;		/* Rx : Wrong nwid/essid */
+	__u32		code;		/* Rx : Unable to code/decode (WEP) */
+	__u32		fragment;	/* Rx : Can't perform MAC reassembly */
+	__u32		retries;	/* Tx : Max MAC retries num reached */
+	__u32		misc;		/* Others cases */
+};
+
+/*
+ *	Packet/Time period missed in the wireless adapter due to
+ *	"wireless" specific problems...
+ */
+struct	iw_missed
+{
+	__u32		beacon;		/* Missed beacons/superframe */
+};
+
+/* ------------------------ WIRELESS STATS ------------------------ */
+/*
+ * Wireless statistics (used for /proc/net/wireless)
+ */
+struct	iw_statistics
+{
+	__u16		status;		/* Status
+					 * - device dependent for now */
+
+	struct iw_quality	qual;		/* Quality of the link
+						 * (instant/mean/max) */
+	struct iw_discarded	discard;	/* Packet discarded counts */
+	struct iw_missed	miss;		/* Packet missed counts */
+};
+
+/* ------------------------ IOCTL REQUEST ------------------------ */
+/*
+ * This structure defines the payload of an ioctl, and is used 
+ * below.
+ *
+ * Note that this structure should fit on the memory footprint
+ * of iwreq (which is the same as ifreq), which mean a max size of
+ * 16 octets = 128 bits. Warning, pointers might be 64 bits wide...
+ * You should check this when increasing the structures defined
+ * above in this file...
+ */
+union	iwreq_data
+{
+	/* Config - generic */
+	char		name[IFNAMSIZ];
+	/* Name : used to verify the presence of  wireless extensions.
+	 * Name of the protocol/provider... */
+
+	struct iw_point	essid;		/* Extended network name */
+	struct iw_param	nwid;		/* network id (or domain - the cell) */
+	struct iw_freq	freq;		/* frequency or channel :
+					 * 0-1000 = channel
+					 * > 1000 = frequency in Hz */
+
+	struct iw_param	sens;		/* signal level threshold */
+	struct iw_param	bitrate;	/* default bit rate */
+	struct iw_param	txpower;	/* default transmit power */
+	struct iw_param	rts;		/* RTS threshold threshold */
+	struct iw_param	frag;		/* Fragmentation threshold */
+	__u32		mode;		/* Operation mode */
+	struct iw_param	retry;		/* Retry limits & lifetime */
+
+	struct iw_point	encoding;	/* Encoding stuff : tokens */
+	struct iw_param	power;		/* PM duration/timeout */
+	struct iw_quality qual;		/* Quality part of statistics */
+
+	struct sockaddr	ap_addr;	/* Access point address */
+	struct sockaddr	addr;		/* Destination address (hw) */
+
+	struct iw_param	param;		/* Other small parameters */
+	struct iw_point	data;		/* Other large parameters */
+};
+
+/*
+ * The structure to exchange data for ioctl.
+ * This structure is the same as 'struct ifreq', but (re)defined for
+ * convenience...
+ * Do I need to remind you about structure size (32 octets) ?
+ */
+struct	iwreq 
+{
+	union
+	{
+		char	ifrn_name[IFNAMSIZ];	/* if name, e.g. "eth0" */
+	} ifr_ifrn;
+
+	/* Data part (defined just above) */
+	union	iwreq_data	u;
+};
+
+/* -------------------------- IOCTL DATA -------------------------- */
+/*
+ *	For those ioctl which want to exchange mode data that what could
+ *	fit in the above structure...
+ */
+
+/*
+ *	Range of parameters
+ */
+
+struct	iw_range
+{
+	/* Informative stuff (to choose between different interface) */
+	__u32		throughput;	/* To give an idea... */
+	/* In theory this value should be the maximum benchmarked
+	 * TCP/IP throughput, because with most of these devices the
+	 * bit rate is meaningless (overhead an co) to estimate how
+	 * fast the connection will go and pick the fastest one.
+	 * I suggest people to play with Netperf or any benchmark...
+	 */
+
+	/* NWID (or domain id) */
+	__u32		min_nwid;	/* Minimal NWID we are able to set */
+	__u32		max_nwid;	/* Maximal NWID we are able to set */
+
+	/* Frequency */
+	__u16		num_channels;	/* Number of channels [0; num - 1] */
+	__u8		num_frequency;	/* Number of entry in the list */
+	struct iw_freq	freq[IW_MAX_FREQUENCIES];	/* list */
+	/* Note : this frequency list doesn't need to fit channel numbers */
+
+	/* signal level threshold range */
+	__s32	sensitivity;
+
+	/* Quality of link & SNR stuff */
+	struct iw_quality	max_qual;	/* Quality of the link */
+
+	/* Rates */
+	__u8		num_bitrates;	/* Number of entries in the list */
+	__s32		bitrate[IW_MAX_BITRATES];	/* list, in bps */
+
+	/* RTS threshold */
+	__s32		min_rts;	/* Minimal RTS threshold */
+	__s32		max_rts;	/* Maximal RTS threshold */
+
+	/* Frag threshold */
+	__s32		min_frag;	/* Minimal frag threshold */
+	__s32		max_frag;	/* Maximal frag threshold */
+
+	/* Power Management duration & timeout */
+	__s32		min_pmp;	/* Minimal PM period */
+	__s32		max_pmp;	/* Maximal PM period */
+	__s32		min_pmt;	/* Minimal PM timeout */
+	__s32		max_pmt;	/* Maximal PM timeout */
+	__u16		pmp_flags;	/* How to decode max/min PM period */
+	__u16		pmt_flags;	/* How to decode max/min PM timeout */
+	__u16		pm_capa;	/* What PM options are supported */
+
+	/* Encoder stuff */
+	__u16	encoding_size[IW_MAX_ENCODING_SIZES];	/* Different token sizes */
+	__u8	num_encoding_sizes;	/* Number of entry in the list */
+	__u8	max_encoding_tokens;	/* Max number of tokens */
+
+	/* Transmit power */
+	__u16		txpower_capa;	/* What options are supported */
+	__u8		num_txpower;	/* Number of entries in the list */
+	__s32		txpower[IW_MAX_TXPOWER];	/* list, in bps */
+
+	/* Wireless Extension version info */
+	__u8		we_version_compiled;	/* Must be WIRELESS_EXT */
+	__u8		we_version_source;	/* Last update of source */
+
+	/* Retry limits and lifetime */
+	__u16		retry_capa;	/* What retry options are supported */
+	__u16		retry_flags;	/* How to decode max/min retry limit */
+	__u16		r_time_flags;	/* How to decode max/min retry life */
+	__s32		min_retry;	/* Minimal number of retries */
+	__s32		max_retry;	/* Maximal number of retries */
+	__s32		min_r_time;	/* Minimal retry lifetime */
+	__s32		max_r_time;	/* Maximal retry lifetime */
+
+	/* Average quality of link & SNR */
+	struct iw_quality	avg_qual;	/* Quality of the link */
+	/* This should contain the average/typical values of the quality
+	 * indicator. This should be the threshold between a "good" and
+	 * a "bad" link (example : monitor going from green to orange).
+	 * Currently, user space apps like quality monitors don't have any
+	 * way to calibrate the measurement. With this, they can split
+	 * the range between 0 and max_qual in different quality level
+	 * (using a geometric subdivision centered on the average).
+	 * I expect that people doing the user space apps will feedback
+	 * us on which value we need to put in each driver...
+	 */
+};
+
+/*
+ * Private ioctl interface information
+ */
+ 
+struct	iw_priv_args
+{
+	__u32		cmd;		/* Number of the ioctl to issue */
+	__u16		set_args;	/* Type and number of args */
+	__u16		get_args;	/* Type and number of args */
+	char		name[IFNAMSIZ];	/* Name of the extension */
+};
+
+/* ----------------------- WIRELESS EVENTS ----------------------- */
+/*
+ * Wireless events are carried through the rtnetlink socket to user
+ * space. They are encapsulated in the IFLA_WIRELESS field of
+ * a RTM_NEWLINK message.
+ */
+
+/*
+ * A Wireless Event. Contains basically the same data as the ioctl...
+ */
+struct iw_event
+{
+	__u16		len;			/* Real lenght of this stuff */
+	__u16		cmd;			/* Wireless IOCTL */
+	union iwreq_data	u;		/* IOCTL fixed payload */
+};
+
+/* Size of the Event prefix (including padding and alignement junk) */
+#define IW_EV_LCP_LEN	(sizeof(struct iw_event) - sizeof(union iwreq_data))
+/* Size of the various events */
+#define IW_EV_CHAR_LEN	(IW_EV_LCP_LEN + IFNAMSIZ)
+#define IW_EV_UINT_LEN	(IW_EV_LCP_LEN + sizeof(__u32))
+#define IW_EV_FREQ_LEN	(IW_EV_LCP_LEN + sizeof(struct iw_freq))
+#define IW_EV_POINT_LEN	(IW_EV_LCP_LEN + sizeof(struct iw_point))
+#define IW_EV_PARAM_LEN	(IW_EV_LCP_LEN + sizeof(struct iw_param))
+#define IW_EV_ADDR_LEN	(IW_EV_LCP_LEN + sizeof(struct sockaddr))
+#define IW_EV_QUAL_LEN	(IW_EV_LCP_LEN + sizeof(struct iw_quality))
+
+/* Note : in the case of iw_point, the extra data will come at the
+ * end of the event */
+
+#endif	/* _LINUX_WIRELESS_H */
diff --git a/wireless.16.h b/wireless.16.h
new file mode 100644
index 0000000..965a83b
--- /dev/null
+++ b/wireless.16.h
@@ -0,0 +1,733 @@
+/*
+ * This file define a set of standard wireless extensions
+ *
+ * Version :	16	2.4.03
+ *
+ * Authors :	Jean Tourrilhes - HPL - <jt@hpl.hp.com>
+ * Copyright (c) 1997-2002 Jean Tourrilhes, All Rights Reserved.
+ */
+
+#ifndef _LINUX_WIRELESS_H
+#define _LINUX_WIRELESS_H
+
+/************************** DOCUMENTATION **************************/
+/*
+ * Initial APIs (1996 -> onward) :
+ * -----------------------------
+ * Basically, the wireless extensions are for now a set of standard ioctl
+ * call + /proc/net/wireless
+ *
+ * The entry /proc/net/wireless give statistics and information on the
+ * driver.
+ * This is better than having each driver having its entry because
+ * its centralised and we may remove the driver module safely.
+ *
+ * Ioctl are used to configure the driver and issue commands.  This is
+ * better than command line options of insmod because we may want to
+ * change dynamically (while the driver is running) some parameters.
+ *
+ * The ioctl mechanimsm are copied from standard devices ioctl.
+ * We have the list of command plus a structure descibing the
+ * data exchanged...
+ * Note that to add these ioctl, I was obliged to modify :
+ *	# net/core/dev.c (two place + add include)
+ *	# net/ipv4/af_inet.c (one place + add include)
+ *
+ * /proc/net/wireless is a copy of /proc/net/dev.
+ * We have a structure for data passed from the driver to /proc/net/wireless
+ * Too add this, I've modified :
+ *	# net/core/dev.c (two other places)
+ *	# include/linux/netdevice.h (one place)
+ *	# include/linux/proc_fs.h (one place)
+ *
+ * New driver API (2002 -> onward) :
+ * -------------------------------
+ * This file is only concerned with the user space API and common definitions.
+ * The new driver API is defined and documented in :
+ *	# include/net/iw_handler.h
+ *
+ * Note as well that /proc/net/wireless implementation has now moved in :
+ *	# include/linux/wireless.c
+ *
+ * Wireless Events (2002 -> onward) :
+ * --------------------------------
+ * Events are defined at the end of this file, and implemented in :
+ *	# include/linux/wireless.c
+ *
+ * Other comments :
+ * --------------
+ * Do not add here things that are redundant with other mechanisms
+ * (drivers init, ifconfig, /proc/net/dev, ...) and with are not
+ * wireless specific.
+ *
+ * These wireless extensions are not magic : each driver has to provide
+ * support for them...
+ *
+ * IMPORTANT NOTE : As everything in the kernel, this is very much a
+ * work in progress. Contact me if you have ideas of improvements...
+ */
+
+/***************************** INCLUDES *****************************/
+
+/* To minimise problems in user space, I might remove those headers
+ * at some point. Jean II */
+#include <linux/types.h>		/* for "caddr_t" et al		*/
+#include <linux/socket.h>		/* for "struct sockaddr" et al	*/
+#include <linux/if.h>			/* for IFNAMSIZ and co... */
+
+/***************************** VERSION *****************************/
+/*
+ * This constant is used to know the availability of the wireless
+ * extensions and to know which version of wireless extensions it is
+ * (there is some stuff that will be added in the future...)
+ * I just plan to increment with each new version.
+ */
+#define WIRELESS_EXT	16
+
+/*
+ * Changes :
+ *
+ * V2 to V3
+ * --------
+ *	Alan Cox start some incompatibles changes. I've integrated a bit more.
+ *	- Encryption renamed to Encode to avoid US regulation problems
+ *	- Frequency changed from float to struct to avoid problems on old 386
+ *
+ * V3 to V4
+ * --------
+ *	- Add sensitivity
+ *
+ * V4 to V5
+ * --------
+ *	- Missing encoding definitions in range
+ *	- Access points stuff
+ *
+ * V5 to V6
+ * --------
+ *	- 802.11 support (ESSID ioctls)
+ *
+ * V6 to V7
+ * --------
+ *	- define IW_ESSID_MAX_SIZE and IW_MAX_AP
+ *
+ * V7 to V8
+ * --------
+ *	- Changed my e-mail address
+ *	- More 802.11 support (nickname, rate, rts, frag)
+ *	- List index in frequencies
+ *
+ * V8 to V9
+ * --------
+ *	- Support for 'mode of operation' (ad-hoc, managed...)
+ *	- Support for unicast and multicast power saving
+ *	- Change encoding to support larger tokens (>64 bits)
+ *	- Updated iw_params (disable, flags) and use it for NWID
+ *	- Extracted iw_point from iwreq for clarity
+ *
+ * V9 to V10
+ * ---------
+ *	- Add PM capability to range structure
+ *	- Add PM modifier : MAX/MIN/RELATIVE
+ *	- Add encoding option : IW_ENCODE_NOKEY
+ *	- Add TxPower ioctls (work like TxRate)
+ *
+ * V10 to V11
+ * ----------
+ *	- Add WE version in range (help backward/forward compatibility)
+ *	- Add retry ioctls (work like PM)
+ *
+ * V11 to V12
+ * ----------
+ *	- Add SIOCSIWSTATS to get /proc/net/wireless programatically
+ *	- Add DEV PRIVATE IOCTL to avoid collisions in SIOCDEVPRIVATE space
+ *	- Add new statistics (frag, retry, beacon)
+ *	- Add average quality (for user space calibration)
+ *
+ * V12 to V13
+ * ----------
+ *	- Document creation of new driver API.
+ *	- Extract union iwreq_data from struct iwreq (for new driver API).
+ *	- Rename SIOCSIWNAME as SIOCSIWCOMMIT
+ *
+ * V13 to V14
+ * ----------
+ *	- Wireless Events support : define struct iw_event
+ *	- Define additional specific event numbers
+ *	- Add "addr" and "param" fields in union iwreq_data
+ *	- AP scanning stuff (SIOCSIWSCAN and friends)
+ *
+ * V14 to V15
+ * ----------
+ *	- Add IW_PRIV_TYPE_ADDR for struct sockaddr private arg
+ *	- Make struct iw_freq signed (both m & e), add explicit padding
+ *	- Add IWEVCUSTOM for driver specific event/scanning token
+ *	- Add IW_MAX_GET_SPY for driver returning a lot of addresses
+ *	- Add IW_TXPOW_RANGE for range of Tx Powers
+ *	- Add IWEVREGISTERED & IWEVEXPIRED events for Access Points
+ *	- Add IW_MODE_MONITOR for passive monitor
+ *
+ * V15 to V16
+ * ----------
+ *	- Increase the number of bitrates in iw_range to 32 (for 802.11g)
+ *	- Increase the number of frequencies in iw_range to 32 (for 802.11b+a)
+ *	- Reshuffle struct iw_range for increases, add filler
+ *	- Increase IW_MAX_AP to 64 for driver returning a lot of addresses
+ *	- Remove IW_MAX_GET_SPY because conflict with enhanced spy support
+ *	- Add SIOCSIWTHRSPY/SIOCGIWTHRSPY and "struct iw_thrspy"
+ *	- Add IW_ENCODE_TEMP and iw_range->encoding_login_index
+ */
+
+/**************************** CONSTANTS ****************************/
+
+/* -------------------------- IOCTL LIST -------------------------- */
+
+/* Wireless Identification */
+#define SIOCSIWCOMMIT	0x8B00		/* Commit pending changes to driver */
+#define SIOCGIWNAME	0x8B01		/* get name == wireless protocol */
+/* SIOCGIWNAME is used to verify the presence of Wireless Extensions.
+ * Common values : "IEEE 802.11-DS", "IEEE 802.11-FH", "IEEE 802.11b"...
+ * Don't put the name of your driver there, it's useless. */
+
+/* Basic operations */
+#define SIOCSIWNWID	0x8B02		/* set network id (pre-802.11) */
+#define SIOCGIWNWID	0x8B03		/* get network id (the cell) */
+#define SIOCSIWFREQ	0x8B04		/* set channel/frequency (Hz) */
+#define SIOCGIWFREQ	0x8B05		/* get channel/frequency (Hz) */
+#define SIOCSIWMODE	0x8B06		/* set operation mode */
+#define SIOCGIWMODE	0x8B07		/* get operation mode */
+#define SIOCSIWSENS	0x8B08		/* set sensitivity (dBm) */
+#define SIOCGIWSENS	0x8B09		/* get sensitivity (dBm) */
+
+/* Informative stuff */
+#define SIOCSIWRANGE	0x8B0A		/* Unused */
+#define SIOCGIWRANGE	0x8B0B		/* Get range of parameters */
+#define SIOCSIWPRIV	0x8B0C		/* Unused */
+#define SIOCGIWPRIV	0x8B0D		/* get private ioctl interface info */
+#define SIOCSIWSTATS	0x8B0E		/* Unused */
+#define SIOCGIWSTATS	0x8B0F		/* Get /proc/net/wireless stats */
+/* SIOCGIWSTATS is strictly used between user space and the kernel, and
+ * is never passed to the driver (i.e. the driver will never see it). */
+
+/* Spy support (statistics per MAC address - used for Mobile IP support) */
+#define SIOCSIWSPY	0x8B10		/* set spy addresses */
+#define SIOCGIWSPY	0x8B11		/* get spy info (quality of link) */
+#define SIOCSIWTHRSPY	0x8B12		/* set spy threshold (spy event) */
+#define SIOCGIWTHRSPY	0x8B13		/* get spy threshold */
+
+/* Access Point manipulation */
+#define SIOCSIWAP	0x8B14		/* set access point MAC addresses */
+#define SIOCGIWAP	0x8B15		/* get access point MAC addresses */
+#define SIOCGIWAPLIST	0x8B17		/* Deprecated in favor of scanning */
+#define SIOCSIWSCAN	0x8B18		/* trigger scanning (list cells) */
+#define SIOCGIWSCAN	0x8B19		/* get scanning results */
+
+/* 802.11 specific support */
+#define SIOCSIWESSID	0x8B1A		/* set ESSID (network name) */
+#define SIOCGIWESSID	0x8B1B		/* get ESSID */
+#define SIOCSIWNICKN	0x8B1C		/* set node name/nickname */
+#define SIOCGIWNICKN	0x8B1D		/* get node name/nickname */
+/* As the ESSID and NICKN are strings up to 32 bytes long, it doesn't fit
+ * within the 'iwreq' structure, so we need to use the 'data' member to
+ * point to a string in user space, like it is done for RANGE... */
+
+/* Other parameters useful in 802.11 and some other devices */
+#define SIOCSIWRATE	0x8B20		/* set default bit rate (bps) */
+#define SIOCGIWRATE	0x8B21		/* get default bit rate (bps) */
+#define SIOCSIWRTS	0x8B22		/* set RTS/CTS threshold (bytes) */
+#define SIOCGIWRTS	0x8B23		/* get RTS/CTS threshold (bytes) */
+#define SIOCSIWFRAG	0x8B24		/* set fragmentation thr (bytes) */
+#define SIOCGIWFRAG	0x8B25		/* get fragmentation thr (bytes) */
+#define SIOCSIWTXPOW	0x8B26		/* set transmit power (dBm) */
+#define SIOCGIWTXPOW	0x8B27		/* get transmit power (dBm) */
+#define SIOCSIWRETRY	0x8B28		/* set retry limits and lifetime */
+#define SIOCGIWRETRY	0x8B29		/* get retry limits and lifetime */
+
+/* Encoding stuff (scrambling, hardware security, WEP...) */
+#define SIOCSIWENCODE	0x8B2A		/* set encoding token & mode */
+#define SIOCGIWENCODE	0x8B2B		/* get encoding token & mode */
+/* Power saving stuff (power management, unicast and multicast) */
+#define SIOCSIWPOWER	0x8B2C		/* set Power Management settings */
+#define SIOCGIWPOWER	0x8B2D		/* get Power Management settings */
+
+/* -------------------- DEV PRIVATE IOCTL LIST -------------------- */
+
+/* These 16 ioctl are wireless device private.
+ * Each driver is free to use them for whatever purpose it chooses,
+ * however the driver *must* export the description of those ioctls
+ * with SIOCGIWPRIV and *must* use arguments as defined below.
+ * If you don't follow those rules, DaveM is going to hate you (reason :
+ * it make mixed 32/64bit operation impossible).
+ */
+#define SIOCIWFIRSTPRIV	0x8BE0
+#define SIOCIWLASTPRIV	0x8BFF
+/* Previously, we were using SIOCDEVPRIVATE, but we now have our
+ * separate range because of collisions with other tools such as
+ * 'mii-tool'.
+ * We now have 32 commands, so a bit more space ;-).
+ * Also, all 'odd' commands are only usable by root and don't return the
+ * content of ifr/iwr to user (but you are not obliged to use the set/get
+ * convention, just use every other two command).
+ * And I repeat : you are not obliged to use them with iwspy, but you
+ * must be compliant with it.
+ */
+
+/* ------------------------- IOCTL STUFF ------------------------- */
+
+/* The first and the last (range) */
+#define SIOCIWFIRST	0x8B00
+#define SIOCIWLAST	SIOCIWLASTPRIV		/* 0x8BFF */
+
+/* Even : get (world access), odd : set (root access) */
+#define IW_IS_SET(cmd)	(!((cmd) & 0x1))
+#define IW_IS_GET(cmd)	((cmd) & 0x1)
+
+/* ----------------------- WIRELESS EVENTS ----------------------- */
+/* Those are *NOT* ioctls, do not issue request on them !!! */
+/* Most events use the same identifier as ioctl requests */
+
+#define IWEVTXDROP	0x8C00		/* Packet dropped to excessive retry */
+#define IWEVQUAL	0x8C01		/* Quality part of statistics (scan) */
+#define IWEVCUSTOM	0x8C02		/* Driver specific ascii string */
+#define IWEVREGISTERED	0x8C03		/* Discovered a new node (AP mode) */
+#define IWEVEXPIRED	0x8C04		/* Expired a node (AP mode) */
+
+#define IWEVFIRST	0x8C00
+
+/* ------------------------- PRIVATE INFO ------------------------- */
+/*
+ * The following is used with SIOCGIWPRIV. It allow a driver to define
+ * the interface (name, type of data) for its private ioctl.
+ * Privates ioctl are SIOCIWFIRSTPRIV -> SIOCIWLASTPRIV
+ */
+
+#define IW_PRIV_TYPE_MASK	0x7000	/* Type of arguments */
+#define IW_PRIV_TYPE_NONE	0x0000
+#define IW_PRIV_TYPE_BYTE	0x1000	/* Char as number */
+#define IW_PRIV_TYPE_CHAR	0x2000	/* Char as character */
+#define IW_PRIV_TYPE_INT	0x4000	/* 32 bits int */
+#define IW_PRIV_TYPE_FLOAT	0x5000	/* struct iw_freq */
+#define IW_PRIV_TYPE_ADDR	0x6000	/* struct sockaddr */
+
+#define IW_PRIV_SIZE_FIXED	0x0800	/* Variable or fixed number of args */
+
+#define IW_PRIV_SIZE_MASK	0x07FF	/* Max number of those args */
+
+/*
+ * Note : if the number of args is fixed and the size < 16 octets,
+ * instead of passing a pointer we will put args in the iwreq struct...
+ */
+
+/* ----------------------- OTHER CONSTANTS ----------------------- */
+
+/* Maximum frequencies in the range struct */
+#define IW_MAX_FREQUENCIES	32
+/* Note : if you have something like 80 frequencies,
+ * don't increase this constant and don't fill the frequency list.
+ * The user will be able to set by channel anyway... */
+
+/* Maximum bit rates in the range struct */
+#define IW_MAX_BITRATES		32
+
+/* Maximum tx powers in the range struct */
+#define IW_MAX_TXPOWER		8
+/* Note : if you more than 8 TXPowers, just set the max and min or
+ * a few of them in the struct iw_range. */
+
+/* Maximum of address that you may set with SPY */
+#define IW_MAX_SPY		8
+
+/* Maximum of address that you may get in the
+   list of access points in range */
+#define IW_MAX_AP		64
+
+/* Maximum size of the ESSID and NICKN strings */
+#define IW_ESSID_MAX_SIZE	32
+
+/* Modes of operation */
+#define IW_MODE_AUTO	0	/* Let the driver decides */
+#define IW_MODE_ADHOC	1	/* Single cell network */
+#define IW_MODE_INFRA	2	/* Multi cell network, roaming, ... */
+#define IW_MODE_MASTER	3	/* Synchronisation master or Access Point */
+#define IW_MODE_REPEAT	4	/* Wireless Repeater (forwarder) */
+#define IW_MODE_SECOND	5	/* Secondary master/repeater (backup) */
+#define IW_MODE_MONITOR	6	/* Passive monitor (listen only) */
+
+/* Maximum number of size of encoding token available
+ * they are listed in the range structure */
+#define IW_MAX_ENCODING_SIZES	8
+
+/* Maximum size of the encoding token in bytes */
+#define IW_ENCODING_TOKEN_MAX	32	/* 256 bits (for now) */
+
+/* Flags for encoding (along with the token) */
+#define IW_ENCODE_INDEX		0x00FF	/* Token index (if needed) */
+#define IW_ENCODE_FLAGS		0xFF00	/* Flags defined below */
+#define IW_ENCODE_MODE		0xF000	/* Modes defined below */
+#define IW_ENCODE_DISABLED	0x8000	/* Encoding disabled */
+#define IW_ENCODE_ENABLED	0x0000	/* Encoding enabled */
+#define IW_ENCODE_RESTRICTED	0x4000	/* Refuse non-encoded packets */
+#define IW_ENCODE_OPEN		0x2000	/* Accept non-encoded packets */
+#define IW_ENCODE_NOKEY		0x0800  /* Key is write only, so not present */
+#define IW_ENCODE_TEMP		0x0400  /* Temporary key */
+
+/* Power management flags available (along with the value, if any) */
+#define IW_POWER_ON		0x0000	/* No details... */
+#define IW_POWER_TYPE		0xF000	/* Type of parameter */
+#define IW_POWER_PERIOD		0x1000	/* Value is a period/duration of  */
+#define IW_POWER_TIMEOUT	0x2000	/* Value is a timeout (to go asleep) */
+#define IW_POWER_MODE		0x0F00	/* Power Management mode */
+#define IW_POWER_UNICAST_R	0x0100	/* Receive only unicast messages */
+#define IW_POWER_MULTICAST_R	0x0200	/* Receive only multicast messages */
+#define IW_POWER_ALL_R		0x0300	/* Receive all messages though PM */
+#define IW_POWER_FORCE_S	0x0400	/* Force PM procedure for sending unicast */
+#define IW_POWER_REPEATER	0x0800	/* Repeat broadcast messages in PM period */
+#define IW_POWER_MODIFIER	0x000F	/* Modify a parameter */
+#define IW_POWER_MIN		0x0001	/* Value is a minimum  */
+#define IW_POWER_MAX		0x0002	/* Value is a maximum */
+#define IW_POWER_RELATIVE	0x0004	/* Value is not in seconds/ms/us */
+
+/* Transmit Power flags available */
+#define IW_TXPOW_TYPE		0x00FF	/* Type of value */
+#define IW_TXPOW_DBM		0x0000	/* Value is in dBm */
+#define IW_TXPOW_MWATT		0x0001	/* Value is in mW */
+#define IW_TXPOW_RANGE		0x1000	/* Range of value between min/max */
+
+/* Retry limits and lifetime flags available */
+#define IW_RETRY_ON		0x0000	/* No details... */
+#define IW_RETRY_TYPE		0xF000	/* Type of parameter */
+#define IW_RETRY_LIMIT		0x1000	/* Maximum number of retries*/
+#define IW_RETRY_LIFETIME	0x2000	/* Maximum duration of retries in us */
+#define IW_RETRY_MODIFIER	0x000F	/* Modify a parameter */
+#define IW_RETRY_MIN		0x0001	/* Value is a minimum  */
+#define IW_RETRY_MAX		0x0002	/* Value is a maximum */
+#define IW_RETRY_RELATIVE	0x0004	/* Value is not in seconds/ms/us */
+
+/* Scanning request flags */
+#define IW_SCAN_DEFAULT		0x0000	/* Default scan of the driver */
+#define IW_SCAN_ALL_ESSID	0x0001	/* Scan all ESSIDs */
+#define IW_SCAN_THIS_ESSID	0x0002	/* Scan only this ESSID */
+#define IW_SCAN_ALL_FREQ	0x0004	/* Scan all Frequencies */
+#define IW_SCAN_THIS_FREQ	0x0008	/* Scan only this Frequency */
+#define IW_SCAN_ALL_MODE	0x0010	/* Scan all Modes */
+#define IW_SCAN_THIS_MODE	0x0020	/* Scan only this Mode */
+#define IW_SCAN_ALL_RATE	0x0040	/* Scan all Bit-Rates */
+#define IW_SCAN_THIS_RATE	0x0080	/* Scan only this Bit-Rate */
+/* Maximum size of returned data */
+#define IW_SCAN_MAX_DATA	4096	/* In bytes */
+
+/* Max number of char in custom event - use multiple of them if needed */
+#define IW_CUSTOM_MAX		256	/* In bytes */
+
+/****************************** TYPES ******************************/
+
+/* --------------------------- SUBTYPES --------------------------- */
+/*
+ *	Generic format for most parameters that fit in an int
+ */
+struct	iw_param
+{
+  __s32		value;		/* The value of the parameter itself */
+  __u8		fixed;		/* Hardware should not use auto select */
+  __u8		disabled;	/* Disable the feature */
+  __u16		flags;		/* Various specifc flags (if any) */
+};
+
+/*
+ *	For all data larger than 16 octets, we need to use a
+ *	pointer to memory allocated in user space.
+ */
+struct	iw_point
+{
+  caddr_t	pointer;	/* Pointer to the data  (in user space) */
+  __u16		length;		/* number of fields or size in bytes */
+  __u16		flags;		/* Optional params */
+};
+
+/*
+ *	A frequency
+ *	For numbers lower than 10^9, we encode the number in 'm' and
+ *	set 'e' to 0
+ *	For number greater than 10^9, we divide it by the lowest power
+ *	of 10 to get 'm' lower than 10^9, with 'm'= f / (10^'e')...
+ *	The power of 10 is in 'e', the result of the division is in 'm'.
+ */
+struct	iw_freq
+{
+	__s32		m;		/* Mantissa */
+	__s16		e;		/* Exponent */
+	__u8		i;		/* List index (when in range struct) */
+	__u8		pad;		/* Unused - just for alignement */
+};
+
+/*
+ *	Quality of the link
+ */
+struct	iw_quality
+{
+	__u8		qual;		/* link quality (%retries, SNR,
+					   %missed beacons or better...) */
+	__u8		level;		/* signal level (dBm) */
+	__u8		noise;		/* noise level (dBm) */
+	__u8		updated;	/* Flags to know if updated */
+};
+
+/*
+ *	Packet discarded in the wireless adapter due to
+ *	"wireless" specific problems...
+ *	Note : the list of counter and statistics in net_device_stats
+ *	is already pretty exhaustive, and you should use that first.
+ *	This is only additional stats...
+ */
+struct	iw_discarded
+{
+	__u32		nwid;		/* Rx : Wrong nwid/essid */
+	__u32		code;		/* Rx : Unable to code/decode (WEP) */
+	__u32		fragment;	/* Rx : Can't perform MAC reassembly */
+	__u32		retries;	/* Tx : Max MAC retries num reached */
+	__u32		misc;		/* Others cases */
+};
+
+/*
+ *	Packet/Time period missed in the wireless adapter due to
+ *	"wireless" specific problems...
+ */
+struct	iw_missed
+{
+	__u32		beacon;		/* Missed beacons/superframe */
+};
+
+/*
+ *	Quality range (for spy threshold)
+ */
+struct	iw_thrspy
+{
+	struct sockaddr		addr;		/* Source address (hw/mac) */
+	struct iw_quality	qual;		/* Quality of the link */
+	struct iw_quality	low;		/* Low threshold */
+	struct iw_quality	high;		/* High threshold */
+};
+
+/* ------------------------ WIRELESS STATS ------------------------ */
+/*
+ * Wireless statistics (used for /proc/net/wireless)
+ */
+struct	iw_statistics
+{
+	__u16		status;		/* Status
+					 * - device dependent for now */
+
+	struct iw_quality	qual;		/* Quality of the link
+						 * (instant/mean/max) */
+	struct iw_discarded	discard;	/* Packet discarded counts */
+	struct iw_missed	miss;		/* Packet missed counts */
+};
+
+/* ------------------------ IOCTL REQUEST ------------------------ */
+/*
+ * This structure defines the payload of an ioctl, and is used 
+ * below.
+ *
+ * Note that this structure should fit on the memory footprint
+ * of iwreq (which is the same as ifreq), which mean a max size of
+ * 16 octets = 128 bits. Warning, pointers might be 64 bits wide...
+ * You should check this when increasing the structures defined
+ * above in this file...
+ */
+union	iwreq_data
+{
+	/* Config - generic */
+	char		name[IFNAMSIZ];
+	/* Name : used to verify the presence of  wireless extensions.
+	 * Name of the protocol/provider... */
+
+	struct iw_point	essid;		/* Extended network name */
+	struct iw_param	nwid;		/* network id (or domain - the cell) */
+	struct iw_freq	freq;		/* frequency or channel :
+					 * 0-1000 = channel
+					 * > 1000 = frequency in Hz */
+
+	struct iw_param	sens;		/* signal level threshold */
+	struct iw_param	bitrate;	/* default bit rate */
+	struct iw_param	txpower;	/* default transmit power */
+	struct iw_param	rts;		/* RTS threshold threshold */
+	struct iw_param	frag;		/* Fragmentation threshold */
+	__u32		mode;		/* Operation mode */
+	struct iw_param	retry;		/* Retry limits & lifetime */
+
+	struct iw_point	encoding;	/* Encoding stuff : tokens */
+	struct iw_param	power;		/* PM duration/timeout */
+	struct iw_quality qual;		/* Quality part of statistics */
+
+	struct sockaddr	ap_addr;	/* Access point address */
+	struct sockaddr	addr;		/* Destination address (hw/mac) */
+
+	struct iw_param	param;		/* Other small parameters */
+	struct iw_point	data;		/* Other large parameters */
+};
+
+/*
+ * The structure to exchange data for ioctl.
+ * This structure is the same as 'struct ifreq', but (re)defined for
+ * convenience...
+ * Do I need to remind you about structure size (32 octets) ?
+ */
+struct	iwreq 
+{
+	union
+	{
+		char	ifrn_name[IFNAMSIZ];	/* if name, e.g. "eth0" */
+	} ifr_ifrn;
+
+	/* Data part (defined just above) */
+	union	iwreq_data	u;
+};
+
+/* -------------------------- IOCTL DATA -------------------------- */
+/*
+ *	For those ioctl which want to exchange mode data that what could
+ *	fit in the above structure...
+ */
+
+/*
+ *	Range of parameters
+ */
+
+struct	iw_range
+{
+	/* Informative stuff (to choose between different interface) */
+	__u32		throughput;	/* To give an idea... */
+	/* In theory this value should be the maximum benchmarked
+	 * TCP/IP throughput, because with most of these devices the
+	 * bit rate is meaningless (overhead an co) to estimate how
+	 * fast the connection will go and pick the fastest one.
+	 * I suggest people to play with Netperf or any benchmark...
+	 */
+
+	/* NWID (or domain id) */
+	__u32		min_nwid;	/* Minimal NWID we are able to set */
+	__u32		max_nwid;	/* Maximal NWID we are able to set */
+
+	/* Old Frequency (backward compat - moved lower ) */
+	__u16		old_num_channels;
+	__u8		old_num_frequency;
+	/* Filler to keep "version" at the same offset */
+	__s32		old_freq[6];
+
+	/* signal level threshold range */
+	__s32	sensitivity;
+
+	/* Quality of link & SNR stuff */
+	/* Quality range (link, level, noise)
+	 * If the quality is absolute, it will be in the range [0 ; max_qual],
+	 * if the quality is dBm, it will be in the range [max_qual ; 0].
+	 * Don't forget that we use 8 bit arithmetics... */
+	struct iw_quality	max_qual;	/* Quality of the link */
+	/* This should contain the average/typical values of the quality
+	 * indicator. This should be the threshold between a "good" and
+	 * a "bad" link (example : monitor going from green to orange).
+	 * Currently, user space apps like quality monitors don't have any
+	 * way to calibrate the measurement. With this, they can split
+	 * the range between 0 and max_qual in different quality level
+	 * (using a geometric subdivision centered on the average).
+	 * I expect that people doing the user space apps will feedback
+	 * us on which value we need to put in each driver... */
+	struct iw_quality	avg_qual;	/* Quality of the link */
+
+	/* Rates */
+	__u8		num_bitrates;	/* Number of entries in the list */
+	__s32		bitrate[IW_MAX_BITRATES];	/* list, in bps */
+
+	/* RTS threshold */
+	__s32		min_rts;	/* Minimal RTS threshold */
+	__s32		max_rts;	/* Maximal RTS threshold */
+
+	/* Frag threshold */
+	__s32		min_frag;	/* Minimal frag threshold */
+	__s32		max_frag;	/* Maximal frag threshold */
+
+	/* Power Management duration & timeout */
+	__s32		min_pmp;	/* Minimal PM period */
+	__s32		max_pmp;	/* Maximal PM period */
+	__s32		min_pmt;	/* Minimal PM timeout */
+	__s32		max_pmt;	/* Maximal PM timeout */
+	__u16		pmp_flags;	/* How to decode max/min PM period */
+	__u16		pmt_flags;	/* How to decode max/min PM timeout */
+	__u16		pm_capa;	/* What PM options are supported */
+
+	/* Encoder stuff */
+	__u16	encoding_size[IW_MAX_ENCODING_SIZES];	/* Different token sizes */
+	__u8	num_encoding_sizes;	/* Number of entry in the list */
+	__u8	max_encoding_tokens;	/* Max number of tokens */
+	/* For drivers that need a "login/passwd" form */
+	__u8	encoding_login_index;	/* token index for login token */
+
+	/* Transmit power */
+	__u16		txpower_capa;	/* What options are supported */
+	__u8		num_txpower;	/* Number of entries in the list */
+	__s32		txpower[IW_MAX_TXPOWER];	/* list, in bps */
+
+	/* Wireless Extension version info */
+	__u8		we_version_compiled;	/* Must be WIRELESS_EXT */
+	__u8		we_version_source;	/* Last update of source */
+
+	/* Retry limits and lifetime */
+	__u16		retry_capa;	/* What retry options are supported */
+	__u16		retry_flags;	/* How to decode max/min retry limit */
+	__u16		r_time_flags;	/* How to decode max/min retry life */
+	__s32		min_retry;	/* Minimal number of retries */
+	__s32		max_retry;	/* Maximal number of retries */
+	__s32		min_r_time;	/* Minimal retry lifetime */
+	__s32		max_r_time;	/* Maximal retry lifetime */
+
+	/* Frequency */
+	__u16		num_channels;	/* Number of channels [0; num - 1] */
+	__u8		num_frequency;	/* Number of entry in the list */
+	struct iw_freq	freq[IW_MAX_FREQUENCIES];	/* list */
+	/* Note : this frequency list doesn't need to fit channel numbers,
+	 * because each entry contain its channel index */
+};
+
+/*
+ * Private ioctl interface information
+ */
+ 
+struct	iw_priv_args
+{
+	__u32		cmd;		/* Number of the ioctl to issue */
+	__u16		set_args;	/* Type and number of args */
+	__u16		get_args;	/* Type and number of args */
+	char		name[IFNAMSIZ];	/* Name of the extension */
+};
+
+/* ----------------------- WIRELESS EVENTS ----------------------- */
+/*
+ * Wireless events are carried through the rtnetlink socket to user
+ * space. They are encapsulated in the IFLA_WIRELESS field of
+ * a RTM_NEWLINK message.
+ */
+
+/*
+ * A Wireless Event. Contains basically the same data as the ioctl...
+ */
+struct iw_event
+{
+	__u16		len;			/* Real lenght of this stuff */
+	__u16		cmd;			/* Wireless IOCTL */
+	union iwreq_data	u;		/* IOCTL fixed payload */
+};
+
+/* Size of the Event prefix (including padding and alignement junk) */
+#define IW_EV_LCP_LEN	(sizeof(struct iw_event) - sizeof(union iwreq_data))
+/* Size of the various events */
+#define IW_EV_CHAR_LEN	(IW_EV_LCP_LEN + IFNAMSIZ)
+#define IW_EV_UINT_LEN	(IW_EV_LCP_LEN + sizeof(__u32))
+#define IW_EV_FREQ_LEN	(IW_EV_LCP_LEN + sizeof(struct iw_freq))
+#define IW_EV_POINT_LEN	(IW_EV_LCP_LEN + sizeof(struct iw_point))
+#define IW_EV_PARAM_LEN	(IW_EV_LCP_LEN + sizeof(struct iw_param))
+#define IW_EV_ADDR_LEN	(IW_EV_LCP_LEN + sizeof(struct sockaddr))
+#define IW_EV_QUAL_LEN	(IW_EV_LCP_LEN + sizeof(struct iw_quality))
+
+/* Note : in the case of iw_point, the extra data will come at the
+ * end of the event */
+
+#endif	/* _LINUX_WIRELESS_H */
diff --git a/wireless.17.h b/wireless.17.h
new file mode 100644
index 0000000..794b94a
--- /dev/null
+++ b/wireless.17.h
@@ -0,0 +1,773 @@
+/*
+ * This file define a set of standard wireless extensions
+ *
+ * Version :	17	21.6.04
+ *
+ * Authors :	Jean Tourrilhes - HPL - <jt@hpl.hp.com>
+ * Copyright (c) 1997-2004 Jean Tourrilhes, All Rights Reserved.
+ */
+
+#ifndef _LINUX_WIRELESS_H
+#define _LINUX_WIRELESS_H
+
+/************************** DOCUMENTATION **************************/
+/*
+ * Initial APIs (1996 -> onward) :
+ * -----------------------------
+ * Basically, the wireless extensions are for now a set of standard ioctl
+ * call + /proc/net/wireless
+ *
+ * The entry /proc/net/wireless give statistics and information on the
+ * driver.
+ * This is better than having each driver having its entry because
+ * its centralised and we may remove the driver module safely.
+ *
+ * Ioctl are used to configure the driver and issue commands.  This is
+ * better than command line options of insmod because we may want to
+ * change dynamically (while the driver is running) some parameters.
+ *
+ * The ioctl mechanimsm are copied from standard devices ioctl.
+ * We have the list of command plus a structure descibing the
+ * data exchanged...
+ * Note that to add these ioctl, I was obliged to modify :
+ *	# net/core/dev.c (two place + add include)
+ *	# net/ipv4/af_inet.c (one place + add include)
+ *
+ * /proc/net/wireless is a copy of /proc/net/dev.
+ * We have a structure for data passed from the driver to /proc/net/wireless
+ * Too add this, I've modified :
+ *	# net/core/dev.c (two other places)
+ *	# include/linux/netdevice.h (one place)
+ *	# include/linux/proc_fs.h (one place)
+ *
+ * New driver API (2002 -> onward) :
+ * -------------------------------
+ * This file is only concerned with the user space API and common definitions.
+ * The new driver API is defined and documented in :
+ *	# include/net/iw_handler.h
+ *
+ * Note as well that /proc/net/wireless implementation has now moved in :
+ *	# net/core/wireless.c
+ *
+ * Wireless Events (2002 -> onward) :
+ * --------------------------------
+ * Events are defined at the end of this file, and implemented in :
+ *	# net/core/wireless.c
+ *
+ * Other comments :
+ * --------------
+ * Do not add here things that are redundant with other mechanisms
+ * (drivers init, ifconfig, /proc/net/dev, ...) and with are not
+ * wireless specific.
+ *
+ * These wireless extensions are not magic : each driver has to provide
+ * support for them...
+ *
+ * IMPORTANT NOTE : As everything in the kernel, this is very much a
+ * work in progress. Contact me if you have ideas of improvements...
+ */
+
+/***************************** INCLUDES *****************************/
+
+/* To minimise problems in user space, I might remove those headers
+ * at some point. Jean II */
+#include <linux/types.h>		/* for "caddr_t" et al		*/
+#include <linux/socket.h>		/* for "struct sockaddr" et al	*/
+#include <linux/if.h>			/* for IFNAMSIZ and co... */
+
+/***************************** VERSION *****************************/
+/*
+ * This constant is used to know the availability of the wireless
+ * extensions and to know which version of wireless extensions it is
+ * (there is some stuff that will be added in the future...)
+ * I just plan to increment with each new version.
+ */
+#define WIRELESS_EXT	17
+
+/*
+ * Changes :
+ *
+ * V2 to V3
+ * --------
+ *	Alan Cox start some incompatibles changes. I've integrated a bit more.
+ *	- Encryption renamed to Encode to avoid US regulation problems
+ *	- Frequency changed from float to struct to avoid problems on old 386
+ *
+ * V3 to V4
+ * --------
+ *	- Add sensitivity
+ *
+ * V4 to V5
+ * --------
+ *	- Missing encoding definitions in range
+ *	- Access points stuff
+ *
+ * V5 to V6
+ * --------
+ *	- 802.11 support (ESSID ioctls)
+ *
+ * V6 to V7
+ * --------
+ *	- define IW_ESSID_MAX_SIZE and IW_MAX_AP
+ *
+ * V7 to V8
+ * --------
+ *	- Changed my e-mail address
+ *	- More 802.11 support (nickname, rate, rts, frag)
+ *	- List index in frequencies
+ *
+ * V8 to V9
+ * --------
+ *	- Support for 'mode of operation' (ad-hoc, managed...)
+ *	- Support for unicast and multicast power saving
+ *	- Change encoding to support larger tokens (>64 bits)
+ *	- Updated iw_params (disable, flags) and use it for NWID
+ *	- Extracted iw_point from iwreq for clarity
+ *
+ * V9 to V10
+ * ---------
+ *	- Add PM capability to range structure
+ *	- Add PM modifier : MAX/MIN/RELATIVE
+ *	- Add encoding option : IW_ENCODE_NOKEY
+ *	- Add TxPower ioctls (work like TxRate)
+ *
+ * V10 to V11
+ * ----------
+ *	- Add WE version in range (help backward/forward compatibility)
+ *	- Add retry ioctls (work like PM)
+ *
+ * V11 to V12
+ * ----------
+ *	- Add SIOCSIWSTATS to get /proc/net/wireless programatically
+ *	- Add DEV PRIVATE IOCTL to avoid collisions in SIOCDEVPRIVATE space
+ *	- Add new statistics (frag, retry, beacon)
+ *	- Add average quality (for user space calibration)
+ *
+ * V12 to V13
+ * ----------
+ *	- Document creation of new driver API.
+ *	- Extract union iwreq_data from struct iwreq (for new driver API).
+ *	- Rename SIOCSIWNAME as SIOCSIWCOMMIT
+ *
+ * V13 to V14
+ * ----------
+ *	- Wireless Events support : define struct iw_event
+ *	- Define additional specific event numbers
+ *	- Add "addr" and "param" fields in union iwreq_data
+ *	- AP scanning stuff (SIOCSIWSCAN and friends)
+ *
+ * V14 to V15
+ * ----------
+ *	- Add IW_PRIV_TYPE_ADDR for struct sockaddr private arg
+ *	- Make struct iw_freq signed (both m & e), add explicit padding
+ *	- Add IWEVCUSTOM for driver specific event/scanning token
+ *	- Add IW_MAX_GET_SPY for driver returning a lot of addresses
+ *	- Add IW_TXPOW_RANGE for range of Tx Powers
+ *	- Add IWEVREGISTERED & IWEVEXPIRED events for Access Points
+ *	- Add IW_MODE_MONITOR for passive monitor
+ *
+ * V15 to V16
+ * ----------
+ *	- Increase the number of bitrates in iw_range to 32 (for 802.11g)
+ *	- Increase the number of frequencies in iw_range to 32 (for 802.11b+a)
+ *	- Reshuffle struct iw_range for increases, add filler
+ *	- Increase IW_MAX_AP to 64 for driver returning a lot of addresses
+ *	- Remove IW_MAX_GET_SPY because conflict with enhanced spy support
+ *	- Add SIOCSIWTHRSPY/SIOCGIWTHRSPY and "struct iw_thrspy"
+ *	- Add IW_ENCODE_TEMP and iw_range->encoding_login_index
+ *
+ * V16 to V17
+ * ----------
+ *	- Add flags to frequency -> auto/fixed
+ *	- Document (struct iw_quality *)->updated, add new flags (INVALID)
+ *	- Wireless Event capability in struct iw_range
+ *	- Add support for relative TxPower (yick !)
+ */
+
+/**************************** CONSTANTS ****************************/
+
+/* -------------------------- IOCTL LIST -------------------------- */
+
+/* Wireless Identification */
+#define SIOCSIWCOMMIT	0x8B00		/* Commit pending changes to driver */
+#define SIOCGIWNAME	0x8B01		/* get name == wireless protocol */
+/* SIOCGIWNAME is used to verify the presence of Wireless Extensions.
+ * Common values : "IEEE 802.11-DS", "IEEE 802.11-FH", "IEEE 802.11b"...
+ * Don't put the name of your driver there, it's useless. */
+
+/* Basic operations */
+#define SIOCSIWNWID	0x8B02		/* set network id (pre-802.11) */
+#define SIOCGIWNWID	0x8B03		/* get network id (the cell) */
+#define SIOCSIWFREQ	0x8B04		/* set channel/frequency (Hz) */
+#define SIOCGIWFREQ	0x8B05		/* get channel/frequency (Hz) */
+#define SIOCSIWMODE	0x8B06		/* set operation mode */
+#define SIOCGIWMODE	0x8B07		/* get operation mode */
+#define SIOCSIWSENS	0x8B08		/* set sensitivity (dBm) */
+#define SIOCGIWSENS	0x8B09		/* get sensitivity (dBm) */
+
+/* Informative stuff */
+#define SIOCSIWRANGE	0x8B0A		/* Unused */
+#define SIOCGIWRANGE	0x8B0B		/* Get range of parameters */
+#define SIOCSIWPRIV	0x8B0C		/* Unused */
+#define SIOCGIWPRIV	0x8B0D		/* get private ioctl interface info */
+#define SIOCSIWSTATS	0x8B0E		/* Unused */
+#define SIOCGIWSTATS	0x8B0F		/* Get /proc/net/wireless stats */
+/* SIOCGIWSTATS is strictly used between user space and the kernel, and
+ * is never passed to the driver (i.e. the driver will never see it). */
+
+/* Spy support (statistics per MAC address - used for Mobile IP support) */
+#define SIOCSIWSPY	0x8B10		/* set spy addresses */
+#define SIOCGIWSPY	0x8B11		/* get spy info (quality of link) */
+#define SIOCSIWTHRSPY	0x8B12		/* set spy threshold (spy event) */
+#define SIOCGIWTHRSPY	0x8B13		/* get spy threshold */
+
+/* Access Point manipulation */
+#define SIOCSIWAP	0x8B14		/* set access point MAC addresses */
+#define SIOCGIWAP	0x8B15		/* get access point MAC addresses */
+#define SIOCGIWAPLIST	0x8B17		/* Deprecated in favor of scanning */
+#define SIOCSIWSCAN	0x8B18		/* trigger scanning (list cells) */
+#define SIOCGIWSCAN	0x8B19		/* get scanning results */
+
+/* 802.11 specific support */
+#define SIOCSIWESSID	0x8B1A		/* set ESSID (network name) */
+#define SIOCGIWESSID	0x8B1B		/* get ESSID */
+#define SIOCSIWNICKN	0x8B1C		/* set node name/nickname */
+#define SIOCGIWNICKN	0x8B1D		/* get node name/nickname */
+/* As the ESSID and NICKN are strings up to 32 bytes long, it doesn't fit
+ * within the 'iwreq' structure, so we need to use the 'data' member to
+ * point to a string in user space, like it is done for RANGE... */
+
+/* Other parameters useful in 802.11 and some other devices */
+#define SIOCSIWRATE	0x8B20		/* set default bit rate (bps) */
+#define SIOCGIWRATE	0x8B21		/* get default bit rate (bps) */
+#define SIOCSIWRTS	0x8B22		/* set RTS/CTS threshold (bytes) */
+#define SIOCGIWRTS	0x8B23		/* get RTS/CTS threshold (bytes) */
+#define SIOCSIWFRAG	0x8B24		/* set fragmentation thr (bytes) */
+#define SIOCGIWFRAG	0x8B25		/* get fragmentation thr (bytes) */
+#define SIOCSIWTXPOW	0x8B26		/* set transmit power (dBm) */
+#define SIOCGIWTXPOW	0x8B27		/* get transmit power (dBm) */
+#define SIOCSIWRETRY	0x8B28		/* set retry limits and lifetime */
+#define SIOCGIWRETRY	0x8B29		/* get retry limits and lifetime */
+
+/* Encoding stuff (scrambling, hardware security, WEP...) */
+#define SIOCSIWENCODE	0x8B2A		/* set encoding token & mode */
+#define SIOCGIWENCODE	0x8B2B		/* get encoding token & mode */
+/* Power saving stuff (power management, unicast and multicast) */
+#define SIOCSIWPOWER	0x8B2C		/* set Power Management settings */
+#define SIOCGIWPOWER	0x8B2D		/* get Power Management settings */
+
+/* -------------------- DEV PRIVATE IOCTL LIST -------------------- */
+
+/* These 32 ioctl are wireless device private, for 16 commands.
+ * Each driver is free to use them for whatever purpose it chooses,
+ * however the driver *must* export the description of those ioctls
+ * with SIOCGIWPRIV and *must* use arguments as defined below.
+ * If you don't follow those rules, DaveM is going to hate you (reason :
+ * it make mixed 32/64bit operation impossible).
+ */
+#define SIOCIWFIRSTPRIV	0x8BE0
+#define SIOCIWLASTPRIV	0x8BFF
+/* Previously, we were using SIOCDEVPRIVATE, but we now have our
+ * separate range because of collisions with other tools such as
+ * 'mii-tool'.
+ * We now have 32 commands, so a bit more space ;-).
+ * Also, all 'odd' commands are only usable by root and don't return the
+ * content of ifr/iwr to user (but you are not obliged to use the set/get
+ * convention, just use every other two command). More details in iwpriv.c.
+ * And I repeat : you are not forced to use them with iwpriv, but you
+ * must be compliant with it.
+ */
+
+/* ------------------------- IOCTL STUFF ------------------------- */
+
+/* The first and the last (range) */
+#define SIOCIWFIRST	0x8B00
+#define SIOCIWLAST	SIOCIWLASTPRIV		/* 0x8BFF */
+
+/* Even : get (world access), odd : set (root access) */
+#define IW_IS_SET(cmd)	(!((cmd) & 0x1))
+#define IW_IS_GET(cmd)	((cmd) & 0x1)
+
+/* ----------------------- WIRELESS EVENTS ----------------------- */
+/* Those are *NOT* ioctls, do not issue request on them !!! */
+/* Most events use the same identifier as ioctl requests */
+
+#define IWEVTXDROP	0x8C00		/* Packet dropped to excessive retry */
+#define IWEVQUAL	0x8C01		/* Quality part of statistics (scan) */
+#define IWEVCUSTOM	0x8C02		/* Driver specific ascii string */
+#define IWEVREGISTERED	0x8C03		/* Discovered a new node (AP mode) */
+#define IWEVEXPIRED	0x8C04		/* Expired a node (AP mode) */
+
+#define IWEVFIRST	0x8C00
+
+/* ------------------------- PRIVATE INFO ------------------------- */
+/*
+ * The following is used with SIOCGIWPRIV. It allow a driver to define
+ * the interface (name, type of data) for its private ioctl.
+ * Privates ioctl are SIOCIWFIRSTPRIV -> SIOCIWLASTPRIV
+ */
+
+#define IW_PRIV_TYPE_MASK	0x7000	/* Type of arguments */
+#define IW_PRIV_TYPE_NONE	0x0000
+#define IW_PRIV_TYPE_BYTE	0x1000	/* Char as number */
+#define IW_PRIV_TYPE_CHAR	0x2000	/* Char as character */
+#define IW_PRIV_TYPE_INT	0x4000	/* 32 bits int */
+#define IW_PRIV_TYPE_FLOAT	0x5000	/* struct iw_freq */
+#define IW_PRIV_TYPE_ADDR	0x6000	/* struct sockaddr */
+
+#define IW_PRIV_SIZE_FIXED	0x0800	/* Variable or fixed number of args */
+
+#define IW_PRIV_SIZE_MASK	0x07FF	/* Max number of those args */
+
+/*
+ * Note : if the number of args is fixed and the size < 16 octets,
+ * instead of passing a pointer we will put args in the iwreq struct...
+ */
+
+/* ----------------------- OTHER CONSTANTS ----------------------- */
+
+/* Maximum frequencies in the range struct */
+#define IW_MAX_FREQUENCIES	32
+/* Note : if you have something like 80 frequencies,
+ * don't increase this constant and don't fill the frequency list.
+ * The user will be able to set by channel anyway... */
+
+/* Maximum bit rates in the range struct */
+#define IW_MAX_BITRATES		32
+
+/* Maximum tx powers in the range struct */
+#define IW_MAX_TXPOWER		8
+/* Note : if you more than 8 TXPowers, just set the max and min or
+ * a few of them in the struct iw_range. */
+
+/* Maximum of address that you may set with SPY */
+#define IW_MAX_SPY		8
+
+/* Maximum of address that you may get in the
+   list of access points in range */
+#define IW_MAX_AP		64
+
+/* Maximum size of the ESSID and NICKN strings */
+#define IW_ESSID_MAX_SIZE	32
+
+/* Modes of operation */
+#define IW_MODE_AUTO	0	/* Let the driver decides */
+#define IW_MODE_ADHOC	1	/* Single cell network */
+#define IW_MODE_INFRA	2	/* Multi cell network, roaming, ... */
+#define IW_MODE_MASTER	3	/* Synchronisation master or Access Point */
+#define IW_MODE_REPEAT	4	/* Wireless Repeater (forwarder) */
+#define IW_MODE_SECOND	5	/* Secondary master/repeater (backup) */
+#define IW_MODE_MONITOR	6	/* Passive monitor (listen only) */
+
+/* Statistics flags (bitmask in updated) */
+#define IW_QUAL_QUAL_UPDATED	0x1	/* Value was updated since last read */
+#define IW_QUAL_LEVEL_UPDATED	0x2
+#define IW_QUAL_NOISE_UPDATED	0x4
+#define IW_QUAL_QUAL_INVALID	0x10	/* Driver doesn't provide value */
+#define IW_QUAL_LEVEL_INVALID	0x20
+#define IW_QUAL_NOISE_INVALID	0x40
+
+/* Frequency flags */
+#define IW_FREQ_AUTO		0x00	/* Let the driver decides */
+#define IW_FREQ_FIXED		0x01	/* Force a specific value */
+
+/* Maximum number of size of encoding token available
+ * they are listed in the range structure */
+#define IW_MAX_ENCODING_SIZES	8
+
+/* Maximum size of the encoding token in bytes */
+#define IW_ENCODING_TOKEN_MAX	32	/* 256 bits (for now) */
+
+/* Flags for encoding (along with the token) */
+#define IW_ENCODE_INDEX		0x00FF	/* Token index (if needed) */
+#define IW_ENCODE_FLAGS		0xFF00	/* Flags defined below */
+#define IW_ENCODE_MODE		0xF000	/* Modes defined below */
+#define IW_ENCODE_DISABLED	0x8000	/* Encoding disabled */
+#define IW_ENCODE_ENABLED	0x0000	/* Encoding enabled */
+#define IW_ENCODE_RESTRICTED	0x4000	/* Refuse non-encoded packets */
+#define IW_ENCODE_OPEN		0x2000	/* Accept non-encoded packets */
+#define IW_ENCODE_NOKEY		0x0800  /* Key is write only, so not present */
+#define IW_ENCODE_TEMP		0x0400  /* Temporary key */
+
+/* Power management flags available (along with the value, if any) */
+#define IW_POWER_ON		0x0000	/* No details... */
+#define IW_POWER_TYPE		0xF000	/* Type of parameter */
+#define IW_POWER_PERIOD		0x1000	/* Value is a period/duration of  */
+#define IW_POWER_TIMEOUT	0x2000	/* Value is a timeout (to go asleep) */
+#define IW_POWER_MODE		0x0F00	/* Power Management mode */
+#define IW_POWER_UNICAST_R	0x0100	/* Receive only unicast messages */
+#define IW_POWER_MULTICAST_R	0x0200	/* Receive only multicast messages */
+#define IW_POWER_ALL_R		0x0300	/* Receive all messages though PM */
+#define IW_POWER_FORCE_S	0x0400	/* Force PM procedure for sending unicast */
+#define IW_POWER_REPEATER	0x0800	/* Repeat broadcast messages in PM period */
+#define IW_POWER_MODIFIER	0x000F	/* Modify a parameter */
+#define IW_POWER_MIN		0x0001	/* Value is a minimum  */
+#define IW_POWER_MAX		0x0002	/* Value is a maximum */
+#define IW_POWER_RELATIVE	0x0004	/* Value is not in seconds/ms/us */
+
+/* Transmit Power flags available */
+#define IW_TXPOW_TYPE		0x00FF	/* Type of value */
+#define IW_TXPOW_DBM		0x0000	/* Value is in dBm */
+#define IW_TXPOW_MWATT		0x0001	/* Value is in mW */
+#define IW_TXPOW_RELATIVE	0x0002	/* Value is in arbitrary units */
+#define IW_TXPOW_RANGE		0x1000	/* Range of value between min/max */
+
+/* Retry limits and lifetime flags available */
+#define IW_RETRY_ON		0x0000	/* No details... */
+#define IW_RETRY_TYPE		0xF000	/* Type of parameter */
+#define IW_RETRY_LIMIT		0x1000	/* Maximum number of retries*/
+#define IW_RETRY_LIFETIME	0x2000	/* Maximum duration of retries in us */
+#define IW_RETRY_MODIFIER	0x000F	/* Modify a parameter */
+#define IW_RETRY_MIN		0x0001	/* Value is a minimum  */
+#define IW_RETRY_MAX		0x0002	/* Value is a maximum */
+#define IW_RETRY_RELATIVE	0x0004	/* Value is not in seconds/ms/us */
+
+/* Scanning request flags */
+#define IW_SCAN_DEFAULT		0x0000	/* Default scan of the driver */
+#define IW_SCAN_ALL_ESSID	0x0001	/* Scan all ESSIDs */
+#define IW_SCAN_THIS_ESSID	0x0002	/* Scan only this ESSID */
+#define IW_SCAN_ALL_FREQ	0x0004	/* Scan all Frequencies */
+#define IW_SCAN_THIS_FREQ	0x0008	/* Scan only this Frequency */
+#define IW_SCAN_ALL_MODE	0x0010	/* Scan all Modes */
+#define IW_SCAN_THIS_MODE	0x0020	/* Scan only this Mode */
+#define IW_SCAN_ALL_RATE	0x0040	/* Scan all Bit-Rates */
+#define IW_SCAN_THIS_RATE	0x0080	/* Scan only this Bit-Rate */
+/* Maximum size of returned data */
+#define IW_SCAN_MAX_DATA	4096	/* In bytes */
+
+/* Max number of char in custom event - use multiple of them if needed */
+#define IW_CUSTOM_MAX		256	/* In bytes */
+
+/* Event capability macros - in (struct iw_range *)->event_capa
+ * Because we have more than 32 possible events, we use an array of
+ * 32 bit bitmasks. Note : 32 bits = 0x20 = 2^5. */
+#define IW_EVENT_CAPA_BASE(cmd)		((cmd >= SIOCIWFIRSTPRIV) ? \
+					 (cmd - SIOCIWFIRSTPRIV + 0x60) : \
+					 (cmd - SIOCSIWCOMMIT))
+#define IW_EVENT_CAPA_INDEX(cmd)	(IW_EVENT_CAPA_BASE(cmd) >> 5)
+#define IW_EVENT_CAPA_MASK(cmd)		(1 << (IW_EVENT_CAPA_BASE(cmd) & 0x1F))
+/* Event capability constants - event autogenerated by the kernel
+ * This list is valid for most 802.11 devices, customise as needed... */
+#define IW_EVENT_CAPA_K_0	(IW_EVENT_CAPA_MASK(0x8B04) | \
+				 IW_EVENT_CAPA_MASK(0x8B06) | \
+				 IW_EVENT_CAPA_MASK(0x8B1A))
+#define IW_EVENT_CAPA_K_1	(IW_EVENT_CAPA_MASK(0x8B2A))
+/* "Easy" macro to set events in iw_range (less efficient) */
+#define IW_EVENT_CAPA_SET(event_capa, cmd) (event_capa[IW_EVENT_CAPA_INDEX(cmd)] |= IW_EVENT_CAPA_MASK(cmd))
+#define IW_EVENT_CAPA_SET_KERNEL(event_capa) {event_capa[0] |= IW_EVENT_CAPA_K_0; event_capa[1] |= IW_EVENT_CAPA_K_1; }
+
+
+/****************************** TYPES ******************************/
+
+/* --------------------------- SUBTYPES --------------------------- */
+/*
+ *	Generic format for most parameters that fit in an int
+ */
+struct	iw_param
+{
+  __s32		value;		/* The value of the parameter itself */
+  __u8		fixed;		/* Hardware should not use auto select */
+  __u8		disabled;	/* Disable the feature */
+  __u16		flags;		/* Various specifc flags (if any) */
+};
+
+/*
+ *	For all data larger than 16 octets, we need to use a
+ *	pointer to memory allocated in user space.
+ */
+struct	iw_point
+{
+  caddr_t	pointer;	/* Pointer to the data  (in user space) */
+  __u16		length;		/* number of fields or size in bytes */
+  __u16		flags;		/* Optional params */
+};
+
+/*
+ *	A frequency
+ *	For numbers lower than 10^9, we encode the number in 'm' and
+ *	set 'e' to 0
+ *	For number greater than 10^9, we divide it by the lowest power
+ *	of 10 to get 'm' lower than 10^9, with 'm'= f / (10^'e')...
+ *	The power of 10 is in 'e', the result of the division is in 'm'.
+ */
+struct	iw_freq
+{
+	__s32		m;		/* Mantissa */
+	__s16		e;		/* Exponent */
+	__u8		i;		/* List index (when in range struct) */
+	__u8		flags;		/* Flags (fixed/auto) */
+};
+
+/*
+ *	Quality of the link
+ */
+struct	iw_quality
+{
+	__u8		qual;		/* link quality (%retries, SNR,
+					   %missed beacons or better...) */
+	__u8		level;		/* signal level (dBm) */
+	__u8		noise;		/* noise level (dBm) */
+	__u8		updated;	/* Flags to know if updated */
+};
+
+/*
+ *	Packet discarded in the wireless adapter due to
+ *	"wireless" specific problems...
+ *	Note : the list of counter and statistics in net_device_stats
+ *	is already pretty exhaustive, and you should use that first.
+ *	This is only additional stats...
+ */
+struct	iw_discarded
+{
+	__u32		nwid;		/* Rx : Wrong nwid/essid */
+	__u32		code;		/* Rx : Unable to code/decode (WEP) */
+	__u32		fragment;	/* Rx : Can't perform MAC reassembly */
+	__u32		retries;	/* Tx : Max MAC retries num reached */
+	__u32		misc;		/* Others cases */
+};
+
+/*
+ *	Packet/Time period missed in the wireless adapter due to
+ *	"wireless" specific problems...
+ */
+struct	iw_missed
+{
+	__u32		beacon;		/* Missed beacons/superframe */
+};
+
+/*
+ *	Quality range (for spy threshold)
+ */
+struct	iw_thrspy
+{
+	struct sockaddr		addr;		/* Source address (hw/mac) */
+	struct iw_quality	qual;		/* Quality of the link */
+	struct iw_quality	low;		/* Low threshold */
+	struct iw_quality	high;		/* High threshold */
+};
+
+/* ------------------------ WIRELESS STATS ------------------------ */
+/*
+ * Wireless statistics (used for /proc/net/wireless)
+ */
+struct	iw_statistics
+{
+	__u16		status;		/* Status
+					 * - device dependent for now */
+
+	struct iw_quality	qual;		/* Quality of the link
+						 * (instant/mean/max) */
+	struct iw_discarded	discard;	/* Packet discarded counts */
+	struct iw_missed	miss;		/* Packet missed counts */
+};
+
+/* ------------------------ IOCTL REQUEST ------------------------ */
+/*
+ * This structure defines the payload of an ioctl, and is used 
+ * below.
+ *
+ * Note that this structure should fit on the memory footprint
+ * of iwreq (which is the same as ifreq), which mean a max size of
+ * 16 octets = 128 bits. Warning, pointers might be 64 bits wide...
+ * You should check this when increasing the structures defined
+ * above in this file...
+ */
+union	iwreq_data
+{
+	/* Config - generic */
+	char		name[IFNAMSIZ];
+	/* Name : used to verify the presence of  wireless extensions.
+	 * Name of the protocol/provider... */
+
+	struct iw_point	essid;		/* Extended network name */
+	struct iw_param	nwid;		/* network id (or domain - the cell) */
+	struct iw_freq	freq;		/* frequency or channel :
+					 * 0-1000 = channel
+					 * > 1000 = frequency in Hz */
+
+	struct iw_param	sens;		/* signal level threshold */
+	struct iw_param	bitrate;	/* default bit rate */
+	struct iw_param	txpower;	/* default transmit power */
+	struct iw_param	rts;		/* RTS threshold threshold */
+	struct iw_param	frag;		/* Fragmentation threshold */
+	__u32		mode;		/* Operation mode */
+	struct iw_param	retry;		/* Retry limits & lifetime */
+
+	struct iw_point	encoding;	/* Encoding stuff : tokens */
+	struct iw_param	power;		/* PM duration/timeout */
+	struct iw_quality qual;		/* Quality part of statistics */
+
+	struct sockaddr	ap_addr;	/* Access point address */
+	struct sockaddr	addr;		/* Destination address (hw/mac) */
+
+	struct iw_param	param;		/* Other small parameters */
+	struct iw_point	data;		/* Other large parameters */
+};
+
+/*
+ * The structure to exchange data for ioctl.
+ * This structure is the same as 'struct ifreq', but (re)defined for
+ * convenience...
+ * Do I need to remind you about structure size (32 octets) ?
+ */
+struct	iwreq 
+{
+	union
+	{
+		char	ifrn_name[IFNAMSIZ];	/* if name, e.g. "eth0" */
+	} ifr_ifrn;
+
+	/* Data part (defined just above) */
+	union	iwreq_data	u;
+};
+
+/* -------------------------- IOCTL DATA -------------------------- */
+/*
+ *	For those ioctl which want to exchange mode data that what could
+ *	fit in the above structure...
+ */
+
+/*
+ *	Range of parameters
+ */
+
+struct	iw_range
+{
+	/* Informative stuff (to choose between different interface) */
+	__u32		throughput;	/* To give an idea... */
+	/* In theory this value should be the maximum benchmarked
+	 * TCP/IP throughput, because with most of these devices the
+	 * bit rate is meaningless (overhead an co) to estimate how
+	 * fast the connection will go and pick the fastest one.
+	 * I suggest people to play with Netperf or any benchmark...
+	 */
+
+	/* NWID (or domain id) */
+	__u32		min_nwid;	/* Minimal NWID we are able to set */
+	__u32		max_nwid;	/* Maximal NWID we are able to set */
+
+	/* Old Frequency (backward compat - moved lower ) */
+	__u16		old_num_channels;
+	__u8		old_num_frequency;
+
+	/* Wireless event capability bitmasks */
+	__u32		event_capa[6];
+
+	/* signal level threshold range */
+	__s32		sensitivity;
+
+	/* Quality of link & SNR stuff */
+	/* Quality range (link, level, noise)
+	 * If the quality is absolute, it will be in the range [0 ; max_qual],
+	 * if the quality is dBm, it will be in the range [max_qual ; 0].
+	 * Don't forget that we use 8 bit arithmetics... */
+	struct iw_quality	max_qual;	/* Quality of the link */
+	/* This should contain the average/typical values of the quality
+	 * indicator. This should be the threshold between a "good" and
+	 * a "bad" link (example : monitor going from green to orange).
+	 * Currently, user space apps like quality monitors don't have any
+	 * way to calibrate the measurement. With this, they can split
+	 * the range between 0 and max_qual in different quality level
+	 * (using a geometric subdivision centered on the average).
+	 * I expect that people doing the user space apps will feedback
+	 * us on which value we need to put in each driver... */
+	struct iw_quality	avg_qual;	/* Quality of the link */
+
+	/* Rates */
+	__u8		num_bitrates;	/* Number of entries in the list */
+	__s32		bitrate[IW_MAX_BITRATES];	/* list, in bps */
+
+	/* RTS threshold */
+	__s32		min_rts;	/* Minimal RTS threshold */
+	__s32		max_rts;	/* Maximal RTS threshold */
+
+	/* Frag threshold */
+	__s32		min_frag;	/* Minimal frag threshold */
+	__s32		max_frag;	/* Maximal frag threshold */
+
+	/* Power Management duration & timeout */
+	__s32		min_pmp;	/* Minimal PM period */
+	__s32		max_pmp;	/* Maximal PM period */
+	__s32		min_pmt;	/* Minimal PM timeout */
+	__s32		max_pmt;	/* Maximal PM timeout */
+	__u16		pmp_flags;	/* How to decode max/min PM period */
+	__u16		pmt_flags;	/* How to decode max/min PM timeout */
+	__u16		pm_capa;	/* What PM options are supported */
+
+	/* Encoder stuff */
+	__u16	encoding_size[IW_MAX_ENCODING_SIZES];	/* Different token sizes */
+	__u8	num_encoding_sizes;	/* Number of entry in the list */
+	__u8	max_encoding_tokens;	/* Max number of tokens */
+	/* For drivers that need a "login/passwd" form */
+	__u8	encoding_login_index;	/* token index for login token */
+
+	/* Transmit power */
+	__u16		txpower_capa;	/* What options are supported */
+	__u8		num_txpower;	/* Number of entries in the list */
+	__s32		txpower[IW_MAX_TXPOWER];	/* list, in bps */
+
+	/* Wireless Extension version info */
+	__u8		we_version_compiled;	/* Must be WIRELESS_EXT */
+	__u8		we_version_source;	/* Last update of source */
+
+	/* Retry limits and lifetime */
+	__u16		retry_capa;	/* What retry options are supported */
+	__u16		retry_flags;	/* How to decode max/min retry limit */
+	__u16		r_time_flags;	/* How to decode max/min retry life */
+	__s32		min_retry;	/* Minimal number of retries */
+	__s32		max_retry;	/* Maximal number of retries */
+	__s32		min_r_time;	/* Minimal retry lifetime */
+	__s32		max_r_time;	/* Maximal retry lifetime */
+
+	/* Frequency */
+	__u16		num_channels;	/* Number of channels [0; num - 1] */
+	__u8		num_frequency;	/* Number of entry in the list */
+	struct iw_freq	freq[IW_MAX_FREQUENCIES];	/* list */
+	/* Note : this frequency list doesn't need to fit channel numbers,
+	 * because each entry contain its channel index */
+};
+
+/*
+ * Private ioctl interface information
+ */
+ 
+struct	iw_priv_args
+{
+	__u32		cmd;		/* Number of the ioctl to issue */
+	__u16		set_args;	/* Type and number of args */
+	__u16		get_args;	/* Type and number of args */
+	char		name[IFNAMSIZ];	/* Name of the extension */
+};
+
+/* ----------------------- WIRELESS EVENTS ----------------------- */
+/*
+ * Wireless events are carried through the rtnetlink socket to user
+ * space. They are encapsulated in the IFLA_WIRELESS field of
+ * a RTM_NEWLINK message.
+ */
+
+/*
+ * A Wireless Event. Contains basically the same data as the ioctl...
+ */
+struct iw_event
+{
+	__u16		len;			/* Real lenght of this stuff */
+	__u16		cmd;			/* Wireless IOCTL */
+	union iwreq_data	u;		/* IOCTL fixed payload */
+};
+
+/* Size of the Event prefix (including padding and alignement junk) */
+#define IW_EV_LCP_LEN	(sizeof(struct iw_event) - sizeof(union iwreq_data))
+/* Size of the various events */
+#define IW_EV_CHAR_LEN	(IW_EV_LCP_LEN + IFNAMSIZ)
+#define IW_EV_UINT_LEN	(IW_EV_LCP_LEN + sizeof(__u32))
+#define IW_EV_FREQ_LEN	(IW_EV_LCP_LEN + sizeof(struct iw_freq))
+#define IW_EV_POINT_LEN	(IW_EV_LCP_LEN + sizeof(struct iw_point))
+#define IW_EV_PARAM_LEN	(IW_EV_LCP_LEN + sizeof(struct iw_param))
+#define IW_EV_ADDR_LEN	(IW_EV_LCP_LEN + sizeof(struct sockaddr))
+#define IW_EV_QUAL_LEN	(IW_EV_LCP_LEN + sizeof(struct iw_quality))
+
+/* Note : in the case of iw_point, the extra data will come at the
+ * end of the event */
+
+#endif	/* _LINUX_WIRELESS_H */
diff --git a/wireless.18.h b/wireless.18.h
new file mode 100644
index 0000000..ae485f9
--- /dev/null
+++ b/wireless.18.h
@@ -0,0 +1,1050 @@
+/*
+ * This file define a set of standard wireless extensions
+ *
+ * Version :	18	12.3.05
+ *
+ * Authors :	Jean Tourrilhes - HPL - <jt@hpl.hp.com>
+ * Copyright (c) 1997-2005 Jean Tourrilhes, All Rights Reserved.
+ */
+
+#ifndef _LINUX_WIRELESS_H
+#define _LINUX_WIRELESS_H
+
+/************************** DOCUMENTATION **************************/
+/*
+ * Initial APIs (1996 -> onward) :
+ * -----------------------------
+ * Basically, the wireless extensions are for now a set of standard ioctl
+ * call + /proc/net/wireless
+ *
+ * The entry /proc/net/wireless give statistics and information on the
+ * driver.
+ * This is better than having each driver having its entry because
+ * its centralised and we may remove the driver module safely.
+ *
+ * Ioctl are used to configure the driver and issue commands.  This is
+ * better than command line options of insmod because we may want to
+ * change dynamically (while the driver is running) some parameters.
+ *
+ * The ioctl mechanimsm are copied from standard devices ioctl.
+ * We have the list of command plus a structure descibing the
+ * data exchanged...
+ * Note that to add these ioctl, I was obliged to modify :
+ *	# net/core/dev.c (two place + add include)
+ *	# net/ipv4/af_inet.c (one place + add include)
+ *
+ * /proc/net/wireless is a copy of /proc/net/dev.
+ * We have a structure for data passed from the driver to /proc/net/wireless
+ * Too add this, I've modified :
+ *	# net/core/dev.c (two other places)
+ *	# include/linux/netdevice.h (one place)
+ *	# include/linux/proc_fs.h (one place)
+ *
+ * New driver API (2002 -> onward) :
+ * -------------------------------
+ * This file is only concerned with the user space API and common definitions.
+ * The new driver API is defined and documented in :
+ *	# include/net/iw_handler.h
+ *
+ * Note as well that /proc/net/wireless implementation has now moved in :
+ *	# net/core/wireless.c
+ *
+ * Wireless Events (2002 -> onward) :
+ * --------------------------------
+ * Events are defined at the end of this file, and implemented in :
+ *	# net/core/wireless.c
+ *
+ * Other comments :
+ * --------------
+ * Do not add here things that are redundant with other mechanisms
+ * (drivers init, ifconfig, /proc/net/dev, ...) and with are not
+ * wireless specific.
+ *
+ * These wireless extensions are not magic : each driver has to provide
+ * support for them...
+ *
+ * IMPORTANT NOTE : As everything in the kernel, this is very much a
+ * work in progress. Contact me if you have ideas of improvements...
+ */
+
+/***************************** INCLUDES *****************************/
+
+/* To minimise problems in user space, I might remove those headers
+ * at some point. Jean II */
+#include <linux/types.h>		/* for "caddr_t" et al		*/
+#include <linux/socket.h>		/* for "struct sockaddr" et al	*/
+#include <linux/if.h>			/* for IFNAMSIZ and co... */
+
+/***************************** VERSION *****************************/
+/*
+ * This constant is used to know the availability of the wireless
+ * extensions and to know which version of wireless extensions it is
+ * (there is some stuff that will be added in the future...)
+ * I just plan to increment with each new version.
+ */
+#define WIRELESS_EXT	18
+
+/*
+ * Changes :
+ *
+ * V2 to V3
+ * --------
+ *	Alan Cox start some incompatibles changes. I've integrated a bit more.
+ *	- Encryption renamed to Encode to avoid US regulation problems
+ *	- Frequency changed from float to struct to avoid problems on old 386
+ *
+ * V3 to V4
+ * --------
+ *	- Add sensitivity
+ *
+ * V4 to V5
+ * --------
+ *	- Missing encoding definitions in range
+ *	- Access points stuff
+ *
+ * V5 to V6
+ * --------
+ *	- 802.11 support (ESSID ioctls)
+ *
+ * V6 to V7
+ * --------
+ *	- define IW_ESSID_MAX_SIZE and IW_MAX_AP
+ *
+ * V7 to V8
+ * --------
+ *	- Changed my e-mail address
+ *	- More 802.11 support (nickname, rate, rts, frag)
+ *	- List index in frequencies
+ *
+ * V8 to V9
+ * --------
+ *	- Support for 'mode of operation' (ad-hoc, managed...)
+ *	- Support for unicast and multicast power saving
+ *	- Change encoding to support larger tokens (>64 bits)
+ *	- Updated iw_params (disable, flags) and use it for NWID
+ *	- Extracted iw_point from iwreq for clarity
+ *
+ * V9 to V10
+ * ---------
+ *	- Add PM capability to range structure
+ *	- Add PM modifier : MAX/MIN/RELATIVE
+ *	- Add encoding option : IW_ENCODE_NOKEY
+ *	- Add TxPower ioctls (work like TxRate)
+ *
+ * V10 to V11
+ * ----------
+ *	- Add WE version in range (help backward/forward compatibility)
+ *	- Add retry ioctls (work like PM)
+ *
+ * V11 to V12
+ * ----------
+ *	- Add SIOCSIWSTATS to get /proc/net/wireless programatically
+ *	- Add DEV PRIVATE IOCTL to avoid collisions in SIOCDEVPRIVATE space
+ *	- Add new statistics (frag, retry, beacon)
+ *	- Add average quality (for user space calibration)
+ *
+ * V12 to V13
+ * ----------
+ *	- Document creation of new driver API.
+ *	- Extract union iwreq_data from struct iwreq (for new driver API).
+ *	- Rename SIOCSIWNAME as SIOCSIWCOMMIT
+ *
+ * V13 to V14
+ * ----------
+ *	- Wireless Events support : define struct iw_event
+ *	- Define additional specific event numbers
+ *	- Add "addr" and "param" fields in union iwreq_data
+ *	- AP scanning stuff (SIOCSIWSCAN and friends)
+ *
+ * V14 to V15
+ * ----------
+ *	- Add IW_PRIV_TYPE_ADDR for struct sockaddr private arg
+ *	- Make struct iw_freq signed (both m & e), add explicit padding
+ *	- Add IWEVCUSTOM for driver specific event/scanning token
+ *	- Add IW_MAX_GET_SPY for driver returning a lot of addresses
+ *	- Add IW_TXPOW_RANGE for range of Tx Powers
+ *	- Add IWEVREGISTERED & IWEVEXPIRED events for Access Points
+ *	- Add IW_MODE_MONITOR for passive monitor
+ *
+ * V15 to V16
+ * ----------
+ *	- Increase the number of bitrates in iw_range to 32 (for 802.11g)
+ *	- Increase the number of frequencies in iw_range to 32 (for 802.11b+a)
+ *	- Reshuffle struct iw_range for increases, add filler
+ *	- Increase IW_MAX_AP to 64 for driver returning a lot of addresses
+ *	- Remove IW_MAX_GET_SPY because conflict with enhanced spy support
+ *	- Add SIOCSIWTHRSPY/SIOCGIWTHRSPY and "struct iw_thrspy"
+ *	- Add IW_ENCODE_TEMP and iw_range->encoding_login_index
+ *
+ * V16 to V17
+ * ----------
+ *	- Add flags to frequency -> auto/fixed
+ *	- Document (struct iw_quality *)->updated, add new flags (INVALID)
+ *	- Wireless Event capability in struct iw_range
+ *	- Add support for relative TxPower (yick !)
+ *
+ * V17 to V18 (From Jouni Malinen <jkmaline@cc.hut.fi>)
+ * ----------
+ *	- Add support for WPA/WPA2
+ *	- Add extended encoding configuration (SIOCSIWENCODEEXT and
+ *	  SIOCGIWENCODEEXT)
+ *	- Add SIOCSIWGENIE/SIOCGIWGENIE
+ *	- Add SIOCSIWMLME
+ *	- Add SIOCSIWPMKSA
+ *	- Add struct iw_range bit field for supported encoding capabilities
+ *	- Add optional scan request parameters for SIOCSIWSCAN
+ *	- Add SIOCSIWAUTH/SIOCGIWAUTH for setting authentication and WPA
+ *	  related parameters (extensible up to 4096 parameter values)
+ *	- Add wireless events: IWEVGENIE, IWEVMICHAELMICFAILURE,
+ *	  IWEVASSOCREQIE, IWEVASSOCRESPIE, IWEVPMKIDCAND
+ */
+
+/**************************** CONSTANTS ****************************/
+
+/* -------------------------- IOCTL LIST -------------------------- */
+
+/* Wireless Identification */
+#define SIOCSIWCOMMIT	0x8B00		/* Commit pending changes to driver */
+#define SIOCGIWNAME	0x8B01		/* get name == wireless protocol */
+/* SIOCGIWNAME is used to verify the presence of Wireless Extensions.
+ * Common values : "IEEE 802.11-DS", "IEEE 802.11-FH", "IEEE 802.11b"...
+ * Don't put the name of your driver there, it's useless. */
+
+/* Basic operations */
+#define SIOCSIWNWID	0x8B02		/* set network id (pre-802.11) */
+#define SIOCGIWNWID	0x8B03		/* get network id (the cell) */
+#define SIOCSIWFREQ	0x8B04		/* set channel/frequency (Hz) */
+#define SIOCGIWFREQ	0x8B05		/* get channel/frequency (Hz) */
+#define SIOCSIWMODE	0x8B06		/* set operation mode */
+#define SIOCGIWMODE	0x8B07		/* get operation mode */
+#define SIOCSIWSENS	0x8B08		/* set sensitivity (dBm) */
+#define SIOCGIWSENS	0x8B09		/* get sensitivity (dBm) */
+
+/* Informative stuff */
+#define SIOCSIWRANGE	0x8B0A		/* Unused */
+#define SIOCGIWRANGE	0x8B0B		/* Get range of parameters */
+#define SIOCSIWPRIV	0x8B0C		/* Unused */
+#define SIOCGIWPRIV	0x8B0D		/* get private ioctl interface info */
+#define SIOCSIWSTATS	0x8B0E		/* Unused */
+#define SIOCGIWSTATS	0x8B0F		/* Get /proc/net/wireless stats */
+/* SIOCGIWSTATS is strictly used between user space and the kernel, and
+ * is never passed to the driver (i.e. the driver will never see it). */
+
+/* Spy support (statistics per MAC address - used for Mobile IP support) */
+#define SIOCSIWSPY	0x8B10		/* set spy addresses */
+#define SIOCGIWSPY	0x8B11		/* get spy info (quality of link) */
+#define SIOCSIWTHRSPY	0x8B12		/* set spy threshold (spy event) */
+#define SIOCGIWTHRSPY	0x8B13		/* get spy threshold */
+
+/* Access Point manipulation */
+#define SIOCSIWAP	0x8B14		/* set access point MAC addresses */
+#define SIOCGIWAP	0x8B15		/* get access point MAC addresses */
+#define SIOCGIWAPLIST	0x8B17		/* Deprecated in favor of scanning */
+#define SIOCSIWSCAN	0x8B18		/* trigger scanning (list cells) */
+#define SIOCGIWSCAN	0x8B19		/* get scanning results */
+
+/* 802.11 specific support */
+#define SIOCSIWESSID	0x8B1A		/* set ESSID (network name) */
+#define SIOCGIWESSID	0x8B1B		/* get ESSID */
+#define SIOCSIWNICKN	0x8B1C		/* set node name/nickname */
+#define SIOCGIWNICKN	0x8B1D		/* get node name/nickname */
+/* As the ESSID and NICKN are strings up to 32 bytes long, it doesn't fit
+ * within the 'iwreq' structure, so we need to use the 'data' member to
+ * point to a string in user space, like it is done for RANGE... */
+
+/* Other parameters useful in 802.11 and some other devices */
+#define SIOCSIWRATE	0x8B20		/* set default bit rate (bps) */
+#define SIOCGIWRATE	0x8B21		/* get default bit rate (bps) */
+#define SIOCSIWRTS	0x8B22		/* set RTS/CTS threshold (bytes) */
+#define SIOCGIWRTS	0x8B23		/* get RTS/CTS threshold (bytes) */
+#define SIOCSIWFRAG	0x8B24		/* set fragmentation thr (bytes) */
+#define SIOCGIWFRAG	0x8B25		/* get fragmentation thr (bytes) */
+#define SIOCSIWTXPOW	0x8B26		/* set transmit power (dBm) */
+#define SIOCGIWTXPOW	0x8B27		/* get transmit power (dBm) */
+#define SIOCSIWRETRY	0x8B28		/* set retry limits and lifetime */
+#define SIOCGIWRETRY	0x8B29		/* get retry limits and lifetime */
+
+/* Encoding stuff (scrambling, hardware security, WEP...) */
+#define SIOCSIWENCODE	0x8B2A		/* set encoding token & mode */
+#define SIOCGIWENCODE	0x8B2B		/* get encoding token & mode */
+/* Power saving stuff (power management, unicast and multicast) */
+#define SIOCSIWPOWER	0x8B2C		/* set Power Management settings */
+#define SIOCGIWPOWER	0x8B2D		/* get Power Management settings */
+
+/* WPA : Generic IEEE 802.11 informatiom element (e.g., for WPA/RSN/WMM).
+ * This ioctl uses struct iw_point and data buffer that includes IE id and len
+ * fields. More than one IE may be included in the request. Setting the generic
+ * IE to empty buffer (len=0) removes the generic IE from the driver. Drivers
+ * are allowed to generate their own WPA/RSN IEs, but in these cases, drivers
+ * are required to report the used IE as a wireless event, e.g., when
+ * associating with an AP. */
+#define SIOCSIWGENIE	0x8B30		/* set generic IE */
+#define SIOCGIWGENIE	0x8B31		/* get generic IE */
+
+/* WPA : IEEE 802.11 MLME requests */
+#define SIOCSIWMLME	0x8B16		/* request MLME operation; uses
+					 * struct iw_mlme */
+/* WPA : Authentication mode parameters */
+#define SIOCSIWAUTH	0x8B32		/* set authentication mode params */
+#define SIOCGIWAUTH	0x8B33		/* get authentication mode params */
+
+/* WPA : Extended version of encoding configuration */
+#define SIOCSIWENCODEEXT 0x8B34		/* set encoding token & mode */
+#define SIOCGIWENCODEEXT 0x8B35		/* get encoding token & mode */
+
+/* WPA2 : PMKSA cache management */
+#define SIOCSIWPMKSA	0x8B36		/* PMKSA cache operation */
+
+/* -------------------- DEV PRIVATE IOCTL LIST -------------------- */
+
+/* These 32 ioctl are wireless device private, for 16 commands.
+ * Each driver is free to use them for whatever purpose it chooses,
+ * however the driver *must* export the description of those ioctls
+ * with SIOCGIWPRIV and *must* use arguments as defined below.
+ * If you don't follow those rules, DaveM is going to hate you (reason :
+ * it make mixed 32/64bit operation impossible).
+ */
+#define SIOCIWFIRSTPRIV	0x8BE0
+#define SIOCIWLASTPRIV	0x8BFF
+/* Previously, we were using SIOCDEVPRIVATE, but we now have our
+ * separate range because of collisions with other tools such as
+ * 'mii-tool'.
+ * We now have 32 commands, so a bit more space ;-).
+ * Also, all 'odd' commands are only usable by root and don't return the
+ * content of ifr/iwr to user (but you are not obliged to use the set/get
+ * convention, just use every other two command). More details in iwpriv.c.
+ * And I repeat : you are not forced to use them with iwpriv, but you
+ * must be compliant with it.
+ */
+
+/* ------------------------- IOCTL STUFF ------------------------- */
+
+/* The first and the last (range) */
+#define SIOCIWFIRST	0x8B00
+#define SIOCIWLAST	SIOCIWLASTPRIV		/* 0x8BFF */
+
+/* Even : get (world access), odd : set (root access) */
+#define IW_IS_SET(cmd)	(!((cmd) & 0x1))
+#define IW_IS_GET(cmd)	((cmd) & 0x1)
+
+/* ----------------------- WIRELESS EVENTS ----------------------- */
+/* Those are *NOT* ioctls, do not issue request on them !!! */
+/* Most events use the same identifier as ioctl requests */
+
+#define IWEVTXDROP	0x8C00		/* Packet dropped to excessive retry */
+#define IWEVQUAL	0x8C01		/* Quality part of statistics (scan) */
+#define IWEVCUSTOM	0x8C02		/* Driver specific ascii string */
+#define IWEVREGISTERED	0x8C03		/* Discovered a new node (AP mode) */
+#define IWEVEXPIRED	0x8C04		/* Expired a node (AP mode) */
+#define IWEVGENIE	0x8C05		/* Generic IE (WPA, RSN, WMM, ..)
+					 * (scan results); This includes id and
+					 * length fields. One IWEVGENIE may
+					 * contain more than one IE. Scan
+					 * results may contain one or more
+					 * IWEVGENIE events. */
+#define IWEVMICHAELMICFAILURE 0x8C06	/* Michael MIC failure
+					 * (struct iw_michaelmicfailure)
+					 */
+#define IWEVASSOCREQIE	0x8C07		/* IEs used in (Re)Association Request.
+					 * The data includes id and length
+					 * fields and may contain more than one
+					 * IE. This event is required in
+					 * Managed mode if the driver
+					 * generates its own WPA/RSN IE. This
+					 * should be sent just before
+					 * IWEVREGISTERED event for the
+					 * association. */
+#define IWEVASSOCRESPIE	0x8C08		/* IEs used in (Re)Association
+					 * Response. The data includes id and
+					 * length fields and may contain more
+					 * than one IE. This may be sent
+					 * between IWEVASSOCREQIE and
+					 * IWEVREGISTERED events for the
+					 * association. */
+#define IWEVPMKIDCAND	0x8C09		/* PMKID candidate for RSN
+					 * pre-authentication
+					 * (struct iw_pmkid_cand) */
+
+#define IWEVFIRST	0x8C00
+
+/* ------------------------- PRIVATE INFO ------------------------- */
+/*
+ * The following is used with SIOCGIWPRIV. It allow a driver to define
+ * the interface (name, type of data) for its private ioctl.
+ * Privates ioctl are SIOCIWFIRSTPRIV -> SIOCIWLASTPRIV
+ */
+
+#define IW_PRIV_TYPE_MASK	0x7000	/* Type of arguments */
+#define IW_PRIV_TYPE_NONE	0x0000
+#define IW_PRIV_TYPE_BYTE	0x1000	/* Char as number */
+#define IW_PRIV_TYPE_CHAR	0x2000	/* Char as character */
+#define IW_PRIV_TYPE_INT	0x4000	/* 32 bits int */
+#define IW_PRIV_TYPE_FLOAT	0x5000	/* struct iw_freq */
+#define IW_PRIV_TYPE_ADDR	0x6000	/* struct sockaddr */
+
+#define IW_PRIV_SIZE_FIXED	0x0800	/* Variable or fixed number of args */
+
+#define IW_PRIV_SIZE_MASK	0x07FF	/* Max number of those args */
+
+/*
+ * Note : if the number of args is fixed and the size < 16 octets,
+ * instead of passing a pointer we will put args in the iwreq struct...
+ */
+
+/* ----------------------- OTHER CONSTANTS ----------------------- */
+
+/* Maximum frequencies in the range struct */
+#define IW_MAX_FREQUENCIES	32
+/* Note : if you have something like 80 frequencies,
+ * don't increase this constant and don't fill the frequency list.
+ * The user will be able to set by channel anyway... */
+
+/* Maximum bit rates in the range struct */
+#define IW_MAX_BITRATES		32
+
+/* Maximum tx powers in the range struct */
+#define IW_MAX_TXPOWER		8
+/* Note : if you more than 8 TXPowers, just set the max and min or
+ * a few of them in the struct iw_range. */
+
+/* Maximum of address that you may set with SPY */
+#define IW_MAX_SPY		8
+
+/* Maximum of address that you may get in the
+   list of access points in range */
+#define IW_MAX_AP		64
+
+/* Maximum size of the ESSID and NICKN strings */
+#define IW_ESSID_MAX_SIZE	32
+
+/* Modes of operation */
+#define IW_MODE_AUTO	0	/* Let the driver decides */
+#define IW_MODE_ADHOC	1	/* Single cell network */
+#define IW_MODE_INFRA	2	/* Multi cell network, roaming, ... */
+#define IW_MODE_MASTER	3	/* Synchronisation master or Access Point */
+#define IW_MODE_REPEAT	4	/* Wireless Repeater (forwarder) */
+#define IW_MODE_SECOND	5	/* Secondary master/repeater (backup) */
+#define IW_MODE_MONITOR	6	/* Passive monitor (listen only) */
+
+/* Statistics flags (bitmask in updated) */
+#define IW_QUAL_QUAL_UPDATED	0x1	/* Value was updated since last read */
+#define IW_QUAL_LEVEL_UPDATED	0x2
+#define IW_QUAL_NOISE_UPDATED	0x4
+#define IW_QUAL_QUAL_INVALID	0x10	/* Driver doesn't provide value */
+#define IW_QUAL_LEVEL_INVALID	0x20
+#define IW_QUAL_NOISE_INVALID	0x40
+
+/* Frequency flags */
+#define IW_FREQ_AUTO		0x00	/* Let the driver decides */
+#define IW_FREQ_FIXED		0x01	/* Force a specific value */
+
+/* Maximum number of size of encoding token available
+ * they are listed in the range structure */
+#define IW_MAX_ENCODING_SIZES	8
+
+/* Maximum size of the encoding token in bytes */
+#define IW_ENCODING_TOKEN_MAX	32	/* 256 bits (for now) */
+
+/* Flags for encoding (along with the token) */
+#define IW_ENCODE_INDEX		0x00FF	/* Token index (if needed) */
+#define IW_ENCODE_FLAGS		0xFF00	/* Flags defined below */
+#define IW_ENCODE_MODE		0xF000	/* Modes defined below */
+#define IW_ENCODE_DISABLED	0x8000	/* Encoding disabled */
+#define IW_ENCODE_ENABLED	0x0000	/* Encoding enabled */
+#define IW_ENCODE_RESTRICTED	0x4000	/* Refuse non-encoded packets */
+#define IW_ENCODE_OPEN		0x2000	/* Accept non-encoded packets */
+#define IW_ENCODE_NOKEY		0x0800  /* Key is write only, so not present */
+#define IW_ENCODE_TEMP		0x0400  /* Temporary key */
+
+/* Power management flags available (along with the value, if any) */
+#define IW_POWER_ON		0x0000	/* No details... */
+#define IW_POWER_TYPE		0xF000	/* Type of parameter */
+#define IW_POWER_PERIOD		0x1000	/* Value is a period/duration of  */
+#define IW_POWER_TIMEOUT	0x2000	/* Value is a timeout (to go asleep) */
+#define IW_POWER_MODE		0x0F00	/* Power Management mode */
+#define IW_POWER_UNICAST_R	0x0100	/* Receive only unicast messages */
+#define IW_POWER_MULTICAST_R	0x0200	/* Receive only multicast messages */
+#define IW_POWER_ALL_R		0x0300	/* Receive all messages though PM */
+#define IW_POWER_FORCE_S	0x0400	/* Force PM procedure for sending unicast */
+#define IW_POWER_REPEATER	0x0800	/* Repeat broadcast messages in PM period */
+#define IW_POWER_MODIFIER	0x000F	/* Modify a parameter */
+#define IW_POWER_MIN		0x0001	/* Value is a minimum  */
+#define IW_POWER_MAX		0x0002	/* Value is a maximum */
+#define IW_POWER_RELATIVE	0x0004	/* Value is not in seconds/ms/us */
+
+/* Transmit Power flags available */
+#define IW_TXPOW_TYPE		0x00FF	/* Type of value */
+#define IW_TXPOW_DBM		0x0000	/* Value is in dBm */
+#define IW_TXPOW_MWATT		0x0001	/* Value is in mW */
+#define IW_TXPOW_RELATIVE	0x0002	/* Value is in arbitrary units */
+#define IW_TXPOW_RANGE		0x1000	/* Range of value between min/max */
+
+/* Retry limits and lifetime flags available */
+#define IW_RETRY_ON		0x0000	/* No details... */
+#define IW_RETRY_TYPE		0xF000	/* Type of parameter */
+#define IW_RETRY_LIMIT		0x1000	/* Maximum number of retries*/
+#define IW_RETRY_LIFETIME	0x2000	/* Maximum duration of retries in us */
+#define IW_RETRY_MODIFIER	0x000F	/* Modify a parameter */
+#define IW_RETRY_MIN		0x0001	/* Value is a minimum  */
+#define IW_RETRY_MAX		0x0002	/* Value is a maximum */
+#define IW_RETRY_RELATIVE	0x0004	/* Value is not in seconds/ms/us */
+
+/* Scanning request flags */
+#define IW_SCAN_DEFAULT		0x0000	/* Default scan of the driver */
+#define IW_SCAN_ALL_ESSID	0x0001	/* Scan all ESSIDs */
+#define IW_SCAN_THIS_ESSID	0x0002	/* Scan only this ESSID */
+#define IW_SCAN_ALL_FREQ	0x0004	/* Scan all Frequencies */
+#define IW_SCAN_THIS_FREQ	0x0008	/* Scan only this Frequency */
+#define IW_SCAN_ALL_MODE	0x0010	/* Scan all Modes */
+#define IW_SCAN_THIS_MODE	0x0020	/* Scan only this Mode */
+#define IW_SCAN_ALL_RATE	0x0040	/* Scan all Bit-Rates */
+#define IW_SCAN_THIS_RATE	0x0080	/* Scan only this Bit-Rate */
+/* struct iw_scan_req scan_type */
+#define IW_SCAN_TYPE_ACTIVE 0
+#define IW_SCAN_TYPE_PASSIVE 1
+/* Maximum size of returned data */
+#define IW_SCAN_MAX_DATA	4096	/* In bytes */
+
+/* Max number of char in custom event - use multiple of them if needed */
+#define IW_CUSTOM_MAX		256	/* In bytes */
+
+/* Generic information element */
+#define IW_GENERIC_IE_MAX	1024
+
+/* MLME requests (SIOCSIWMLME / struct iw_mlme) */
+#define IW_MLME_DEAUTH		0
+#define IW_MLME_DISASSOC	1
+
+/* SIOCSIWAUTH/SIOCGIWAUTH struct iw_param flags */
+#define IW_AUTH_INDEX		0x0FFF
+#define IW_AUTH_FLAGS		0xF000
+/* SIOCSIWAUTH/SIOCGIWAUTH parameters (0 .. 4095)
+ * (IW_AUTH_INDEX mask in struct iw_param flags; this is the index of the
+ * parameter that is being set/get to; value will be read/written to
+ * struct iw_param value field) */
+#define IW_AUTH_WPA_VERSION		0
+#define IW_AUTH_CIPHER_PAIRWISE		1
+#define IW_AUTH_CIPHER_GROUP		2
+#define IW_AUTH_KEY_MGMT		3
+#define IW_AUTH_TKIP_COUNTERMEASURES	4
+#define IW_AUTH_DROP_UNENCRYPTED	5
+#define IW_AUTH_80211_AUTH_ALG		6
+#define IW_AUTH_WPA_ENABLED		7
+#define IW_AUTH_RX_UNENCRYPTED_EAPOL	8
+#define IW_AUTH_ROAMING_CONTROL		9
+#define IW_AUTH_PRIVACY_INVOKED		10
+
+/* IW_AUTH_WPA_VERSION values (bit field) */
+#define IW_AUTH_WPA_VERSION_DISABLED	0x00000001
+#define IW_AUTH_WPA_VERSION_WPA		0x00000002
+#define IW_AUTH_WPA_VERSION_WPA2	0x00000004
+
+/* IW_AUTH_PAIRWISE_CIPHER and IW_AUTH_GROUP_CIPHER values (bit field) */
+#define IW_AUTH_CIPHER_NONE	0x00000001
+#define IW_AUTH_CIPHER_WEP40	0x00000002
+#define IW_AUTH_CIPHER_TKIP	0x00000004
+#define IW_AUTH_CIPHER_CCMP	0x00000008
+#define IW_AUTH_CIPHER_WEP104	0x00000010
+
+/* IW_AUTH_KEY_MGMT values (bit field) */
+#define IW_AUTH_KEY_MGMT_802_1X	1
+#define IW_AUTH_KEY_MGMT_PSK	2
+
+/* IW_AUTH_80211_AUTH_ALG values (bit field) */
+#define IW_AUTH_ALG_OPEN_SYSTEM	0x00000001
+#define IW_AUTH_ALG_SHARED_KEY	0x00000002
+#define IW_AUTH_ALG_LEAP	0x00000004
+
+/* IW_AUTH_ROAMING_CONTROL values */
+#define IW_AUTH_ROAMING_ENABLE	0	/* driver/firmware based roaming */
+#define IW_AUTH_ROAMING_DISABLE	1	/* user space program used for roaming
+					 * control */
+
+/* SIOCSIWENCODEEXT definitions */
+#define IW_ENCODE_SEQ_MAX_SIZE	8
+/* struct iw_encode_ext ->alg */
+#define IW_ENCODE_ALG_NONE	0
+#define IW_ENCODE_ALG_WEP	1
+#define IW_ENCODE_ALG_TKIP	2
+#define IW_ENCODE_ALG_CCMP	3
+/* struct iw_encode_ext ->ext_flags */
+#define IW_ENCODE_EXT_TX_SEQ_VALID	0x00000001
+#define IW_ENCODE_EXT_RX_SEQ_VALID	0x00000002
+#define IW_ENCODE_EXT_GROUP_KEY		0x00000004
+#define IW_ENCODE_EXT_SET_TX_KEY	0x00000008
+
+/* IWEVMICHAELMICFAILURE : struct iw_michaelmicfailure ->flags */
+#define IW_MICFAILURE_KEY_ID	0x00000003 /* Key ID 0..3 */
+#define IW_MICFAILURE_GROUP	0x00000004
+#define IW_MICFAILURE_PAIRWISE	0x00000008
+#define IW_MICFAILURE_STAKEY	0x00000010
+#define IW_MICFAILURE_COUNT	0x00000060 /* 1 or 2 (0 = count not supported)
+					    */
+
+/* Bit field values for enc_capa in struct iw_range */
+#define IW_ENC_CAPA_WPA		0x00000001
+#define IW_ENC_CAPA_WPA2	0x00000002
+#define IW_ENC_CAPA_CIPHER_TKIP	0x00000004
+#define IW_ENC_CAPA_CIPHER_CCMP	0x00000008
+
+/* Event capability macros - in (struct iw_range *)->event_capa
+ * Because we have more than 32 possible events, we use an array of
+ * 32 bit bitmasks. Note : 32 bits = 0x20 = 2^5. */
+#define IW_EVENT_CAPA_BASE(cmd)		((cmd >= SIOCIWFIRSTPRIV) ? \
+					 (cmd - SIOCIWFIRSTPRIV + 0x60) : \
+					 (cmd - SIOCSIWCOMMIT))
+#define IW_EVENT_CAPA_INDEX(cmd)	(IW_EVENT_CAPA_BASE(cmd) >> 5)
+#define IW_EVENT_CAPA_MASK(cmd)		(1 << (IW_EVENT_CAPA_BASE(cmd) & 0x1F))
+/* Event capability constants - event autogenerated by the kernel
+ * This list is valid for most 802.11 devices, customise as needed... */
+#define IW_EVENT_CAPA_K_0	(IW_EVENT_CAPA_MASK(0x8B04) | \
+				 IW_EVENT_CAPA_MASK(0x8B06) | \
+				 IW_EVENT_CAPA_MASK(0x8B1A))
+#define IW_EVENT_CAPA_K_1	(IW_EVENT_CAPA_MASK(0x8B2A))
+/* "Easy" macro to set events in iw_range (less efficient) */
+#define IW_EVENT_CAPA_SET(event_capa, cmd) (event_capa[IW_EVENT_CAPA_INDEX(cmd)] |= IW_EVENT_CAPA_MASK(cmd))
+#define IW_EVENT_CAPA_SET_KERNEL(event_capa) {event_capa[0] |= IW_EVENT_CAPA_K_0; event_capa[1] |= IW_EVENT_CAPA_K_1; }
+
+
+/****************************** TYPES ******************************/
+
+/* --------------------------- SUBTYPES --------------------------- */
+/*
+ *	Generic format for most parameters that fit in an int
+ */
+struct	iw_param
+{
+  __s32		value;		/* The value of the parameter itself */
+  __u8		fixed;		/* Hardware should not use auto select */
+  __u8		disabled;	/* Disable the feature */
+  __u16		flags;		/* Various specifc flags (if any) */
+};
+
+/*
+ *	For all data larger than 16 octets, we need to use a
+ *	pointer to memory allocated in user space.
+ */
+struct	iw_point
+{
+  void __user	*pointer;	/* Pointer to the data  (in user space) */
+  __u16		length;		/* number of fields or size in bytes */
+  __u16		flags;		/* Optional params */
+};
+
+/*
+ *	A frequency
+ *	For numbers lower than 10^9, we encode the number in 'm' and
+ *	set 'e' to 0
+ *	For number greater than 10^9, we divide it by the lowest power
+ *	of 10 to get 'm' lower than 10^9, with 'm'= f / (10^'e')...
+ *	The power of 10 is in 'e', the result of the division is in 'm'.
+ */
+struct	iw_freq
+{
+	__s32		m;		/* Mantissa */
+	__s16		e;		/* Exponent */
+	__u8		i;		/* List index (when in range struct) */
+	__u8		flags;		/* Flags (fixed/auto) */
+};
+
+/*
+ *	Quality of the link
+ */
+struct	iw_quality
+{
+	__u8		qual;		/* link quality (%retries, SNR,
+					   %missed beacons or better...) */
+	__u8		level;		/* signal level (dBm) */
+	__u8		noise;		/* noise level (dBm) */
+	__u8		updated;	/* Flags to know if updated */
+};
+
+/*
+ *	Packet discarded in the wireless adapter due to
+ *	"wireless" specific problems...
+ *	Note : the list of counter and statistics in net_device_stats
+ *	is already pretty exhaustive, and you should use that first.
+ *	This is only additional stats...
+ */
+struct	iw_discarded
+{
+	__u32		nwid;		/* Rx : Wrong nwid/essid */
+	__u32		code;		/* Rx : Unable to code/decode (WEP) */
+	__u32		fragment;	/* Rx : Can't perform MAC reassembly */
+	__u32		retries;	/* Tx : Max MAC retries num reached */
+	__u32		misc;		/* Others cases */
+};
+
+/*
+ *	Packet/Time period missed in the wireless adapter due to
+ *	"wireless" specific problems...
+ */
+struct	iw_missed
+{
+	__u32		beacon;		/* Missed beacons/superframe */
+};
+
+/*
+ *	Quality range (for spy threshold)
+ */
+struct	iw_thrspy
+{
+	struct sockaddr		addr;		/* Source address (hw/mac) */
+	struct iw_quality	qual;		/* Quality of the link */
+	struct iw_quality	low;		/* Low threshold */
+	struct iw_quality	high;		/* High threshold */
+};
+
+/*
+ *	Optional data for scan request
+ *
+ *	Note: these optional parameters are controlling parameters for the
+ *	scanning behavior, these do not apply to getting scan results
+ *	(SIOCGIWSCAN). Drivers are expected to keep a local BSS table and
+ *	provide a merged results with all BSSes even if the previous scan
+ *	request limited scanning to a subset, e.g., by specifying an SSID.
+ *	Especially, scan results are required to include an entry for the
+ *	current BSS if the driver is in Managed mode and associated with an AP.
+ */
+struct	iw_scan_req
+{
+	__u8		scan_type; /* IW_SCAN_TYPE_{ACTIVE,PASSIVE} */
+	__u8		essid_len;
+	__u8		num_channels; /* num entries in channel_list;
+				       * 0 = scan all allowed channels */
+	__u8		flags; /* reserved as padding; use zero, this may
+				* be used in the future for adding flags
+				* to request different scan behavior */
+	struct sockaddr	bssid; /* ff:ff:ff:ff:ff:ff for broadcast BSSID or
+				* individual address of a specific BSS */
+
+	/*
+	 * Use this ESSID if IW_SCAN_THIS_ESSID flag is used instead of using
+	 * the current ESSID. This allows scan requests for specific ESSID
+	 * without having to change the current ESSID and potentially breaking
+	 * the current association.
+	 */
+	__u8		essid[IW_ESSID_MAX_SIZE];
+
+	/*
+	 * Optional parameters for changing the default scanning behavior.
+	 * These are based on the MLME-SCAN.request from IEEE Std 802.11.
+	 * TU is 1.024 ms. If these are set to 0, driver is expected to use
+	 * reasonable default values. min_channel_time defines the time that
+	 * will be used to wait for the first reply on each channel. If no
+	 * replies are received, next channel will be scanned after this. If
+	 * replies are received, total time waited on the channel is defined by
+	 * max_channel_time.
+	 */
+	__u32		min_channel_time; /* in TU */
+	__u32		max_channel_time; /* in TU */
+
+	struct iw_freq	channel_list[IW_MAX_FREQUENCIES];
+};
+
+/* ------------------------- WPA SUPPORT ------------------------- */
+
+/*
+ *	Extended data structure for get/set encoding (this is used with
+ *	SIOCSIWENCODEEXT/SIOCGIWENCODEEXT. struct iw_point and IW_ENCODE_*
+ *	flags are used in the same way as with SIOCSIWENCODE/SIOCGIWENCODE and
+ *	only the data contents changes (key data -> this structure, including
+ *	key data).
+ *
+ *	If the new key is the first group key, it will be set as the default
+ *	TX key. Otherwise, default TX key index is only changed if
+ *	IW_ENCODE_EXT_SET_TX_KEY flag is set.
+ *
+ *	Key will be changed with SIOCSIWENCODEEXT in all cases except for
+ *	special "change TX key index" operation which is indicated by setting
+ *	key_len = 0 and ext_flags |= IW_ENCODE_EXT_SET_TX_KEY.
+ *
+ *	tx_seq/rx_seq are only used when respective
+ *	IW_ENCODE_EXT_{TX,RX}_SEQ_VALID flag is set in ext_flags. Normal
+ *	TKIP/CCMP operation is to set RX seq with SIOCSIWENCODEEXT and start
+ *	TX seq from zero whenever key is changed. SIOCGIWENCODEEXT is normally
+ *	used only by an Authenticator (AP or an IBSS station) to get the
+ *	current TX sequence number. Using TX_SEQ_VALID for SIOCSIWENCODEEXT and
+ *	RX_SEQ_VALID for SIOCGIWENCODEEXT are optional, but can be useful for
+ *	debugging/testing.
+ */
+struct	iw_encode_ext
+{
+	__u32		ext_flags; /* IW_ENCODE_EXT_* */
+	__u8		tx_seq[IW_ENCODE_SEQ_MAX_SIZE]; /* LSB first */
+	__u8		rx_seq[IW_ENCODE_SEQ_MAX_SIZE]; /* LSB first */
+	struct sockaddr	addr; /* ff:ff:ff:ff:ff:ff for broadcast/multicast
+			       * (group) keys or unicast address for
+			       * individual keys */
+	__u16		alg; /* IW_ENCODE_ALG_* */
+	__u16		key_len;
+	__u8		key[0];
+};
+
+/* SIOCSIWMLME data */
+struct	iw_mlme
+{
+	__u16		cmd; /* IW_MLME_* */
+	__u16		reason_code;
+	struct sockaddr	addr;
+};
+
+/* SIOCSIWPMKSA data */
+#define IW_PMKSA_ADD		1
+#define IW_PMKSA_REMOVE		2
+#define IW_PMKSA_FLUSH		3
+
+#define IW_PMKID_LEN	16
+
+struct	iw_pmksa
+{
+	__u32		cmd; /* IW_PMKSA_* */
+	struct sockaddr	bssid;
+	__u8		pmkid[IW_PMKID_LEN];
+};
+
+/* IWEVMICHAELMICFAILURE data */
+struct	iw_michaelmicfailure
+{
+	__u32		flags;
+	struct sockaddr	src_addr;
+	__u8		tsc[IW_ENCODE_SEQ_MAX_SIZE]; /* LSB first */
+};
+
+/* IWEVPMKIDCAND data */
+#define IW_PMKID_CAND_PREAUTH	0x00000001 /* RNS pre-authentication enabled */
+struct	iw_pmkid_cand
+{
+	__u32		flags; /* IW_PMKID_CAND_* */
+	__u32		index; /* the smaller the index, the higher the
+				* priority */
+	struct sockaddr	bssid;
+};
+
+/* ------------------------ WIRELESS STATS ------------------------ */
+/*
+ * Wireless statistics (used for /proc/net/wireless)
+ */
+struct	iw_statistics
+{
+	__u16		status;		/* Status
+					 * - device dependent for now */
+
+	struct iw_quality	qual;		/* Quality of the link
+						 * (instant/mean/max) */
+	struct iw_discarded	discard;	/* Packet discarded counts */
+	struct iw_missed	miss;		/* Packet missed counts */
+};
+
+/* ------------------------ IOCTL REQUEST ------------------------ */
+/*
+ * This structure defines the payload of an ioctl, and is used 
+ * below.
+ *
+ * Note that this structure should fit on the memory footprint
+ * of iwreq (which is the same as ifreq), which mean a max size of
+ * 16 octets = 128 bits. Warning, pointers might be 64 bits wide...
+ * You should check this when increasing the structures defined
+ * above in this file...
+ */
+union	iwreq_data
+{
+	/* Config - generic */
+	char		name[IFNAMSIZ];
+	/* Name : used to verify the presence of  wireless extensions.
+	 * Name of the protocol/provider... */
+
+	struct iw_point	essid;		/* Extended network name */
+	struct iw_param	nwid;		/* network id (or domain - the cell) */
+	struct iw_freq	freq;		/* frequency or channel :
+					 * 0-1000 = channel
+					 * > 1000 = frequency in Hz */
+
+	struct iw_param	sens;		/* signal level threshold */
+	struct iw_param	bitrate;	/* default bit rate */
+	struct iw_param	txpower;	/* default transmit power */
+	struct iw_param	rts;		/* RTS threshold threshold */
+	struct iw_param	frag;		/* Fragmentation threshold */
+	__u32		mode;		/* Operation mode */
+	struct iw_param	retry;		/* Retry limits & lifetime */
+
+	struct iw_point	encoding;	/* Encoding stuff : tokens */
+	struct iw_param	power;		/* PM duration/timeout */
+	struct iw_quality qual;		/* Quality part of statistics */
+
+	struct sockaddr	ap_addr;	/* Access point address */
+	struct sockaddr	addr;		/* Destination address (hw/mac) */
+
+	struct iw_param	param;		/* Other small parameters */
+	struct iw_point	data;		/* Other large parameters */
+};
+
+/*
+ * The structure to exchange data for ioctl.
+ * This structure is the same as 'struct ifreq', but (re)defined for
+ * convenience...
+ * Do I need to remind you about structure size (32 octets) ?
+ */
+struct	iwreq 
+{
+	union
+	{
+		char	ifrn_name[IFNAMSIZ];	/* if name, e.g. "eth0" */
+	} ifr_ifrn;
+
+	/* Data part (defined just above) */
+	union	iwreq_data	u;
+};
+
+/* -------------------------- IOCTL DATA -------------------------- */
+/*
+ *	For those ioctl which want to exchange mode data that what could
+ *	fit in the above structure...
+ */
+
+/*
+ *	Range of parameters
+ */
+
+struct	iw_range
+{
+	/* Informative stuff (to choose between different interface) */
+	__u32		throughput;	/* To give an idea... */
+	/* In theory this value should be the maximum benchmarked
+	 * TCP/IP throughput, because with most of these devices the
+	 * bit rate is meaningless (overhead an co) to estimate how
+	 * fast the connection will go and pick the fastest one.
+	 * I suggest people to play with Netperf or any benchmark...
+	 */
+
+	/* NWID (or domain id) */
+	__u32		min_nwid;	/* Minimal NWID we are able to set */
+	__u32		max_nwid;	/* Maximal NWID we are able to set */
+
+	/* Old Frequency (backward compat - moved lower ) */
+	__u16		old_num_channels;
+	__u8		old_num_frequency;
+
+	/* Wireless event capability bitmasks */
+	__u32		event_capa[6];
+
+	/* signal level threshold range */
+	__s32		sensitivity;
+
+	/* Quality of link & SNR stuff */
+	/* Quality range (link, level, noise)
+	 * If the quality is absolute, it will be in the range [0 ; max_qual],
+	 * if the quality is dBm, it will be in the range [max_qual ; 0].
+	 * Don't forget that we use 8 bit arithmetics... */
+	struct iw_quality	max_qual;	/* Quality of the link */
+	/* This should contain the average/typical values of the quality
+	 * indicator. This should be the threshold between a "good" and
+	 * a "bad" link (example : monitor going from green to orange).
+	 * Currently, user space apps like quality monitors don't have any
+	 * way to calibrate the measurement. With this, they can split
+	 * the range between 0 and max_qual in different quality level
+	 * (using a geometric subdivision centered on the average).
+	 * I expect that people doing the user space apps will feedback
+	 * us on which value we need to put in each driver... */
+	struct iw_quality	avg_qual;	/* Quality of the link */
+
+	/* Rates */
+	__u8		num_bitrates;	/* Number of entries in the list */
+	__s32		bitrate[IW_MAX_BITRATES];	/* list, in bps */
+
+	/* RTS threshold */
+	__s32		min_rts;	/* Minimal RTS threshold */
+	__s32		max_rts;	/* Maximal RTS threshold */
+
+	/* Frag threshold */
+	__s32		min_frag;	/* Minimal frag threshold */
+	__s32		max_frag;	/* Maximal frag threshold */
+
+	/* Power Management duration & timeout */
+	__s32		min_pmp;	/* Minimal PM period */
+	__s32		max_pmp;	/* Maximal PM period */
+	__s32		min_pmt;	/* Minimal PM timeout */
+	__s32		max_pmt;	/* Maximal PM timeout */
+	__u16		pmp_flags;	/* How to decode max/min PM period */
+	__u16		pmt_flags;	/* How to decode max/min PM timeout */
+	__u16		pm_capa;	/* What PM options are supported */
+
+	/* Encoder stuff */
+	__u16	encoding_size[IW_MAX_ENCODING_SIZES];	/* Different token sizes */
+	__u8	num_encoding_sizes;	/* Number of entry in the list */
+	__u8	max_encoding_tokens;	/* Max number of tokens */
+	/* For drivers that need a "login/passwd" form */
+	__u8	encoding_login_index;	/* token index for login token */
+
+	/* Transmit power */
+	__u16		txpower_capa;	/* What options are supported */
+	__u8		num_txpower;	/* Number of entries in the list */
+	__s32		txpower[IW_MAX_TXPOWER];	/* list, in bps */
+
+	/* Wireless Extension version info */
+	__u8		we_version_compiled;	/* Must be WIRELESS_EXT */
+	__u8		we_version_source;	/* Last update of source */
+
+	/* Retry limits and lifetime */
+	__u16		retry_capa;	/* What retry options are supported */
+	__u16		retry_flags;	/* How to decode max/min retry limit */
+	__u16		r_time_flags;	/* How to decode max/min retry life */
+	__s32		min_retry;	/* Minimal number of retries */
+	__s32		max_retry;	/* Maximal number of retries */
+	__s32		min_r_time;	/* Minimal retry lifetime */
+	__s32		max_r_time;	/* Maximal retry lifetime */
+
+	/* Frequency */
+	__u16		num_channels;	/* Number of channels [0; num - 1] */
+	__u8		num_frequency;	/* Number of entry in the list */
+	struct iw_freq	freq[IW_MAX_FREQUENCIES];	/* list */
+	/* Note : this frequency list doesn't need to fit channel numbers,
+	 * because each entry contain its channel index */
+
+	__u32		enc_capa; /* IW_ENC_CAPA_* bit field */
+};
+
+/*
+ * Private ioctl interface information
+ */
+ 
+struct	iw_priv_args
+{
+	__u32		cmd;		/* Number of the ioctl to issue */
+	__u16		set_args;	/* Type and number of args */
+	__u16		get_args;	/* Type and number of args */
+	char		name[IFNAMSIZ];	/* Name of the extension */
+};
+
+/* ----------------------- WIRELESS EVENTS ----------------------- */
+/*
+ * Wireless events are carried through the rtnetlink socket to user
+ * space. They are encapsulated in the IFLA_WIRELESS field of
+ * a RTM_NEWLINK message.
+ */
+
+/*
+ * A Wireless Event. Contains basically the same data as the ioctl...
+ */
+struct iw_event
+{
+	__u16		len;			/* Real lenght of this stuff */
+	__u16		cmd;			/* Wireless IOCTL */
+	union iwreq_data	u;		/* IOCTL fixed payload */
+};
+
+/* Size of the Event prefix (including padding and alignement junk) */
+#define IW_EV_LCP_LEN	(sizeof(struct iw_event) - sizeof(union iwreq_data))
+/* Size of the various events */
+#define IW_EV_CHAR_LEN	(IW_EV_LCP_LEN + IFNAMSIZ)
+#define IW_EV_UINT_LEN	(IW_EV_LCP_LEN + sizeof(__u32))
+#define IW_EV_FREQ_LEN	(IW_EV_LCP_LEN + sizeof(struct iw_freq))
+#define IW_EV_POINT_LEN	(IW_EV_LCP_LEN + sizeof(struct iw_point))
+#define IW_EV_PARAM_LEN	(IW_EV_LCP_LEN + sizeof(struct iw_param))
+#define IW_EV_ADDR_LEN	(IW_EV_LCP_LEN + sizeof(struct sockaddr))
+#define IW_EV_QUAL_LEN	(IW_EV_LCP_LEN + sizeof(struct iw_quality))
+
+/* Note : in the case of iw_point, the extra data will come at the
+ * end of the event */
+
+#endif	/* _LINUX_WIRELESS_H */
diff --git a/wireless.19.h b/wireless.19.h
new file mode 100644
index 0000000..dab5afd
--- /dev/null
+++ b/wireless.19.h
@@ -0,0 +1,1069 @@
+/*
+ * This file define a set of standard wireless extensions
+ *
+ * Version :	19	18.3.05
+ *
+ * Authors :	Jean Tourrilhes - HPL - <jt@hpl.hp.com>
+ * Copyright (c) 1997-2005 Jean Tourrilhes, All Rights Reserved.
+ */
+
+#ifndef _LINUX_WIRELESS_H
+#define _LINUX_WIRELESS_H
+
+/************************** DOCUMENTATION **************************/
+/*
+ * Initial APIs (1996 -> onward) :
+ * -----------------------------
+ * Basically, the wireless extensions are for now a set of standard ioctl
+ * call + /proc/net/wireless
+ *
+ * The entry /proc/net/wireless give statistics and information on the
+ * driver.
+ * This is better than having each driver having its entry because
+ * its centralised and we may remove the driver module safely.
+ *
+ * Ioctl are used to configure the driver and issue commands.  This is
+ * better than command line options of insmod because we may want to
+ * change dynamically (while the driver is running) some parameters.
+ *
+ * The ioctl mechanimsm are copied from standard devices ioctl.
+ * We have the list of command plus a structure descibing the
+ * data exchanged...
+ * Note that to add these ioctl, I was obliged to modify :
+ *	# net/core/dev.c (two place + add include)
+ *	# net/ipv4/af_inet.c (one place + add include)
+ *
+ * /proc/net/wireless is a copy of /proc/net/dev.
+ * We have a structure for data passed from the driver to /proc/net/wireless
+ * Too add this, I've modified :
+ *	# net/core/dev.c (two other places)
+ *	# include/linux/netdevice.h (one place)
+ *	# include/linux/proc_fs.h (one place)
+ *
+ * New driver API (2002 -> onward) :
+ * -------------------------------
+ * This file is only concerned with the user space API and common definitions.
+ * The new driver API is defined and documented in :
+ *	# include/net/iw_handler.h
+ *
+ * Note as well that /proc/net/wireless implementation has now moved in :
+ *	# net/core/wireless.c
+ *
+ * Wireless Events (2002 -> onward) :
+ * --------------------------------
+ * Events are defined at the end of this file, and implemented in :
+ *	# net/core/wireless.c
+ *
+ * Other comments :
+ * --------------
+ * Do not add here things that are redundant with other mechanisms
+ * (drivers init, ifconfig, /proc/net/dev, ...) and with are not
+ * wireless specific.
+ *
+ * These wireless extensions are not magic : each driver has to provide
+ * support for them...
+ *
+ * IMPORTANT NOTE : As everything in the kernel, this is very much a
+ * work in progress. Contact me if you have ideas of improvements...
+ */
+
+/***************************** INCLUDES *****************************/
+
+/* Do not put any header in this file, this creates a mess when
+ * exported to user space. Most users have included all the
+ * relevant headers anyway... Jean II */
+/*#include <linux/types.h>*/		/* for "caddr_t" et al		*/
+/*#include <linux/socket.h>*/		/* for "struct sockaddr" et al	*/
+/*#include <linux/if.h>*/		/* for IFNAMSIZ and co... */
+
+/***************************** VERSION *****************************/
+/*
+ * This constant is used to know the availability of the wireless
+ * extensions and to know which version of wireless extensions it is
+ * (there is some stuff that will be added in the future...)
+ * I just plan to increment with each new version.
+ */
+#define WIRELESS_EXT	19
+
+/*
+ * Changes :
+ *
+ * V2 to V3
+ * --------
+ *	Alan Cox start some incompatibles changes. I've integrated a bit more.
+ *	- Encryption renamed to Encode to avoid US regulation problems
+ *	- Frequency changed from float to struct to avoid problems on old 386
+ *
+ * V3 to V4
+ * --------
+ *	- Add sensitivity
+ *
+ * V4 to V5
+ * --------
+ *	- Missing encoding definitions in range
+ *	- Access points stuff
+ *
+ * V5 to V6
+ * --------
+ *	- 802.11 support (ESSID ioctls)
+ *
+ * V6 to V7
+ * --------
+ *	- define IW_ESSID_MAX_SIZE and IW_MAX_AP
+ *
+ * V7 to V8
+ * --------
+ *	- Changed my e-mail address
+ *	- More 802.11 support (nickname, rate, rts, frag)
+ *	- List index in frequencies
+ *
+ * V8 to V9
+ * --------
+ *	- Support for 'mode of operation' (ad-hoc, managed...)
+ *	- Support for unicast and multicast power saving
+ *	- Change encoding to support larger tokens (>64 bits)
+ *	- Updated iw_params (disable, flags) and use it for NWID
+ *	- Extracted iw_point from iwreq for clarity
+ *
+ * V9 to V10
+ * ---------
+ *	- Add PM capability to range structure
+ *	- Add PM modifier : MAX/MIN/RELATIVE
+ *	- Add encoding option : IW_ENCODE_NOKEY
+ *	- Add TxPower ioctls (work like TxRate)
+ *
+ * V10 to V11
+ * ----------
+ *	- Add WE version in range (help backward/forward compatibility)
+ *	- Add retry ioctls (work like PM)
+ *
+ * V11 to V12
+ * ----------
+ *	- Add SIOCSIWSTATS to get /proc/net/wireless programatically
+ *	- Add DEV PRIVATE IOCTL to avoid collisions in SIOCDEVPRIVATE space
+ *	- Add new statistics (frag, retry, beacon)
+ *	- Add average quality (for user space calibration)
+ *
+ * V12 to V13
+ * ----------
+ *	- Document creation of new driver API.
+ *	- Extract union iwreq_data from struct iwreq (for new driver API).
+ *	- Rename SIOCSIWNAME as SIOCSIWCOMMIT
+ *
+ * V13 to V14
+ * ----------
+ *	- Wireless Events support : define struct iw_event
+ *	- Define additional specific event numbers
+ *	- Add "addr" and "param" fields in union iwreq_data
+ *	- AP scanning stuff (SIOCSIWSCAN and friends)
+ *
+ * V14 to V15
+ * ----------
+ *	- Add IW_PRIV_TYPE_ADDR for struct sockaddr private arg
+ *	- Make struct iw_freq signed (both m & e), add explicit padding
+ *	- Add IWEVCUSTOM for driver specific event/scanning token
+ *	- Add IW_MAX_GET_SPY for driver returning a lot of addresses
+ *	- Add IW_TXPOW_RANGE for range of Tx Powers
+ *	- Add IWEVREGISTERED & IWEVEXPIRED events for Access Points
+ *	- Add IW_MODE_MONITOR for passive monitor
+ *
+ * V15 to V16
+ * ----------
+ *	- Increase the number of bitrates in iw_range to 32 (for 802.11g)
+ *	- Increase the number of frequencies in iw_range to 32 (for 802.11b+a)
+ *	- Reshuffle struct iw_range for increases, add filler
+ *	- Increase IW_MAX_AP to 64 for driver returning a lot of addresses
+ *	- Remove IW_MAX_GET_SPY because conflict with enhanced spy support
+ *	- Add SIOCSIWTHRSPY/SIOCGIWTHRSPY and "struct iw_thrspy"
+ *	- Add IW_ENCODE_TEMP and iw_range->encoding_login_index
+ *
+ * V16 to V17
+ * ----------
+ *	- Add flags to frequency -> auto/fixed
+ *	- Document (struct iw_quality *)->updated, add new flags (INVALID)
+ *	- Wireless Event capability in struct iw_range
+ *	- Add support for relative TxPower (yick !)
+ *
+ * V17 to V18 (From Jouni Malinen <jkmaline@cc.hut.fi>)
+ * ----------
+ *	- Add support for WPA/WPA2
+ *	- Add extended encoding configuration (SIOCSIWENCODEEXT and
+ *	  SIOCGIWENCODEEXT)
+ *	- Add SIOCSIWGENIE/SIOCGIWGENIE
+ *	- Add SIOCSIWMLME
+ *	- Add SIOCSIWPMKSA
+ *	- Add struct iw_range bit field for supported encoding capabilities
+ *	- Add optional scan request parameters for SIOCSIWSCAN
+ *	- Add SIOCSIWAUTH/SIOCGIWAUTH for setting authentication and WPA
+ *	  related parameters (extensible up to 4096 parameter values)
+ *	- Add wireless events: IWEVGENIE, IWEVMICHAELMICFAILURE,
+ *	  IWEVASSOCREQIE, IWEVASSOCRESPIE, IWEVPMKIDCAND
+ *
+ * V18 to V19
+ * ----------
+ *	- Remove (struct iw_point *)->pointer from events and streams
+ *	- Remove header includes to help user space
+ *	- Increase IW_ENCODING_TOKEN_MAX from 32 to 64
+ *	- Add IW_QUAL_ALL_UPDATED and IW_QUAL_ALL_INVALID macros
+ *	- Add explicit flag to tell stats are in dBm : IW_QUAL_DBM
+ *	- Add IW_IOCTL_IDX() and IW_EVENT_IDX() macros
+ */
+
+/**************************** CONSTANTS ****************************/
+
+/* -------------------------- IOCTL LIST -------------------------- */
+
+/* Wireless Identification */
+#define SIOCSIWCOMMIT	0x8B00		/* Commit pending changes to driver */
+#define SIOCGIWNAME	0x8B01		/* get name == wireless protocol */
+/* SIOCGIWNAME is used to verify the presence of Wireless Extensions.
+ * Common values : "IEEE 802.11-DS", "IEEE 802.11-FH", "IEEE 802.11b"...
+ * Don't put the name of your driver there, it's useless. */
+
+/* Basic operations */
+#define SIOCSIWNWID	0x8B02		/* set network id (pre-802.11) */
+#define SIOCGIWNWID	0x8B03		/* get network id (the cell) */
+#define SIOCSIWFREQ	0x8B04		/* set channel/frequency (Hz) */
+#define SIOCGIWFREQ	0x8B05		/* get channel/frequency (Hz) */
+#define SIOCSIWMODE	0x8B06		/* set operation mode */
+#define SIOCGIWMODE	0x8B07		/* get operation mode */
+#define SIOCSIWSENS	0x8B08		/* set sensitivity (dBm) */
+#define SIOCGIWSENS	0x8B09		/* get sensitivity (dBm) */
+
+/* Informative stuff */
+#define SIOCSIWRANGE	0x8B0A		/* Unused */
+#define SIOCGIWRANGE	0x8B0B		/* Get range of parameters */
+#define SIOCSIWPRIV	0x8B0C		/* Unused */
+#define SIOCGIWPRIV	0x8B0D		/* get private ioctl interface info */
+#define SIOCSIWSTATS	0x8B0E		/* Unused */
+#define SIOCGIWSTATS	0x8B0F		/* Get /proc/net/wireless stats */
+/* SIOCGIWSTATS is strictly used between user space and the kernel, and
+ * is never passed to the driver (i.e. the driver will never see it). */
+
+/* Spy support (statistics per MAC address - used for Mobile IP support) */
+#define SIOCSIWSPY	0x8B10		/* set spy addresses */
+#define SIOCGIWSPY	0x8B11		/* get spy info (quality of link) */
+#define SIOCSIWTHRSPY	0x8B12		/* set spy threshold (spy event) */
+#define SIOCGIWTHRSPY	0x8B13		/* get spy threshold */
+
+/* Access Point manipulation */
+#define SIOCSIWAP	0x8B14		/* set access point MAC addresses */
+#define SIOCGIWAP	0x8B15		/* get access point MAC addresses */
+#define SIOCGIWAPLIST	0x8B17		/* Deprecated in favor of scanning */
+#define SIOCSIWSCAN	0x8B18		/* trigger scanning (list cells) */
+#define SIOCGIWSCAN	0x8B19		/* get scanning results */
+
+/* 802.11 specific support */
+#define SIOCSIWESSID	0x8B1A		/* set ESSID (network name) */
+#define SIOCGIWESSID	0x8B1B		/* get ESSID */
+#define SIOCSIWNICKN	0x8B1C		/* set node name/nickname */
+#define SIOCGIWNICKN	0x8B1D		/* get node name/nickname */
+/* As the ESSID and NICKN are strings up to 32 bytes long, it doesn't fit
+ * within the 'iwreq' structure, so we need to use the 'data' member to
+ * point to a string in user space, like it is done for RANGE... */
+
+/* Other parameters useful in 802.11 and some other devices */
+#define SIOCSIWRATE	0x8B20		/* set default bit rate (bps) */
+#define SIOCGIWRATE	0x8B21		/* get default bit rate (bps) */
+#define SIOCSIWRTS	0x8B22		/* set RTS/CTS threshold (bytes) */
+#define SIOCGIWRTS	0x8B23		/* get RTS/CTS threshold (bytes) */
+#define SIOCSIWFRAG	0x8B24		/* set fragmentation thr (bytes) */
+#define SIOCGIWFRAG	0x8B25		/* get fragmentation thr (bytes) */
+#define SIOCSIWTXPOW	0x8B26		/* set transmit power (dBm) */
+#define SIOCGIWTXPOW	0x8B27		/* get transmit power (dBm) */
+#define SIOCSIWRETRY	0x8B28		/* set retry limits and lifetime */
+#define SIOCGIWRETRY	0x8B29		/* get retry limits and lifetime */
+
+/* Encoding stuff (scrambling, hardware security, WEP...) */
+#define SIOCSIWENCODE	0x8B2A		/* set encoding token & mode */
+#define SIOCGIWENCODE	0x8B2B		/* get encoding token & mode */
+/* Power saving stuff (power management, unicast and multicast) */
+#define SIOCSIWPOWER	0x8B2C		/* set Power Management settings */
+#define SIOCGIWPOWER	0x8B2D		/* get Power Management settings */
+
+/* WPA : Generic IEEE 802.11 informatiom element (e.g., for WPA/RSN/WMM).
+ * This ioctl uses struct iw_point and data buffer that includes IE id and len
+ * fields. More than one IE may be included in the request. Setting the generic
+ * IE to empty buffer (len=0) removes the generic IE from the driver. Drivers
+ * are allowed to generate their own WPA/RSN IEs, but in these cases, drivers
+ * are required to report the used IE as a wireless event, e.g., when
+ * associating with an AP. */
+#define SIOCSIWGENIE	0x8B30		/* set generic IE */
+#define SIOCGIWGENIE	0x8B31		/* get generic IE */
+
+/* WPA : IEEE 802.11 MLME requests */
+#define SIOCSIWMLME	0x8B16		/* request MLME operation; uses
+					 * struct iw_mlme */
+/* WPA : Authentication mode parameters */
+#define SIOCSIWAUTH	0x8B32		/* set authentication mode params */
+#define SIOCGIWAUTH	0x8B33		/* get authentication mode params */
+
+/* WPA : Extended version of encoding configuration */
+#define SIOCSIWENCODEEXT 0x8B34		/* set encoding token & mode */
+#define SIOCGIWENCODEEXT 0x8B35		/* get encoding token & mode */
+
+/* WPA2 : PMKSA cache management */
+#define SIOCSIWPMKSA	0x8B36		/* PMKSA cache operation */
+
+/* -------------------- DEV PRIVATE IOCTL LIST -------------------- */
+
+/* These 32 ioctl are wireless device private, for 16 commands.
+ * Each driver is free to use them for whatever purpose it chooses,
+ * however the driver *must* export the description of those ioctls
+ * with SIOCGIWPRIV and *must* use arguments as defined below.
+ * If you don't follow those rules, DaveM is going to hate you (reason :
+ * it make mixed 32/64bit operation impossible).
+ */
+#define SIOCIWFIRSTPRIV	0x8BE0
+#define SIOCIWLASTPRIV	0x8BFF
+/* Previously, we were using SIOCDEVPRIVATE, but we now have our
+ * separate range because of collisions with other tools such as
+ * 'mii-tool'.
+ * We now have 32 commands, so a bit more space ;-).
+ * Also, all 'odd' commands are only usable by root and don't return the
+ * content of ifr/iwr to user (but you are not obliged to use the set/get
+ * convention, just use every other two command). More details in iwpriv.c.
+ * And I repeat : you are not forced to use them with iwpriv, but you
+ * must be compliant with it.
+ */
+
+/* ------------------------- IOCTL STUFF ------------------------- */
+
+/* The first and the last (range) */
+#define SIOCIWFIRST	0x8B00
+#define SIOCIWLAST	SIOCIWLASTPRIV		/* 0x8BFF */
+#define IW_IOCTL_IDX(cmd)	((cmd) - SIOCIWFIRST)
+
+/* Even : get (world access), odd : set (root access) */
+#define IW_IS_SET(cmd)	(!((cmd) & 0x1))
+#define IW_IS_GET(cmd)	((cmd) & 0x1)
+
+/* ----------------------- WIRELESS EVENTS ----------------------- */
+/* Those are *NOT* ioctls, do not issue request on them !!! */
+/* Most events use the same identifier as ioctl requests */
+
+#define IWEVTXDROP	0x8C00		/* Packet dropped to excessive retry */
+#define IWEVQUAL	0x8C01		/* Quality part of statistics (scan) */
+#define IWEVCUSTOM	0x8C02		/* Driver specific ascii string */
+#define IWEVREGISTERED	0x8C03		/* Discovered a new node (AP mode) */
+#define IWEVEXPIRED	0x8C04		/* Expired a node (AP mode) */
+#define IWEVGENIE	0x8C05		/* Generic IE (WPA, RSN, WMM, ..)
+					 * (scan results); This includes id and
+					 * length fields. One IWEVGENIE may
+					 * contain more than one IE. Scan
+					 * results may contain one or more
+					 * IWEVGENIE events. */
+#define IWEVMICHAELMICFAILURE 0x8C06	/* Michael MIC failure
+					 * (struct iw_michaelmicfailure)
+					 */
+#define IWEVASSOCREQIE	0x8C07		/* IEs used in (Re)Association Request.
+					 * The data includes id and length
+					 * fields and may contain more than one
+					 * IE. This event is required in
+					 * Managed mode if the driver
+					 * generates its own WPA/RSN IE. This
+					 * should be sent just before
+					 * IWEVREGISTERED event for the
+					 * association. */
+#define IWEVASSOCRESPIE	0x8C08		/* IEs used in (Re)Association
+					 * Response. The data includes id and
+					 * length fields and may contain more
+					 * than one IE. This may be sent
+					 * between IWEVASSOCREQIE and
+					 * IWEVREGISTERED events for the
+					 * association. */
+#define IWEVPMKIDCAND	0x8C09		/* PMKID candidate for RSN
+					 * pre-authentication
+					 * (struct iw_pmkid_cand) */
+
+#define IWEVFIRST	0x8C00
+#define IW_EVENT_IDX(cmd)	((cmd) - IWEVFIRST)
+
+/* ------------------------- PRIVATE INFO ------------------------- */
+/*
+ * The following is used with SIOCGIWPRIV. It allow a driver to define
+ * the interface (name, type of data) for its private ioctl.
+ * Privates ioctl are SIOCIWFIRSTPRIV -> SIOCIWLASTPRIV
+ */
+
+#define IW_PRIV_TYPE_MASK	0x7000	/* Type of arguments */
+#define IW_PRIV_TYPE_NONE	0x0000
+#define IW_PRIV_TYPE_BYTE	0x1000	/* Char as number */
+#define IW_PRIV_TYPE_CHAR	0x2000	/* Char as character */
+#define IW_PRIV_TYPE_INT	0x4000	/* 32 bits int */
+#define IW_PRIV_TYPE_FLOAT	0x5000	/* struct iw_freq */
+#define IW_PRIV_TYPE_ADDR	0x6000	/* struct sockaddr */
+
+#define IW_PRIV_SIZE_FIXED	0x0800	/* Variable or fixed number of args */
+
+#define IW_PRIV_SIZE_MASK	0x07FF	/* Max number of those args */
+
+/*
+ * Note : if the number of args is fixed and the size < 16 octets,
+ * instead of passing a pointer we will put args in the iwreq struct...
+ */
+
+/* ----------------------- OTHER CONSTANTS ----------------------- */
+
+/* Maximum frequencies in the range struct */
+#define IW_MAX_FREQUENCIES	32
+/* Note : if you have something like 80 frequencies,
+ * don't increase this constant and don't fill the frequency list.
+ * The user will be able to set by channel anyway... */
+
+/* Maximum bit rates in the range struct */
+#define IW_MAX_BITRATES		32
+
+/* Maximum tx powers in the range struct */
+#define IW_MAX_TXPOWER		8
+/* Note : if you more than 8 TXPowers, just set the max and min or
+ * a few of them in the struct iw_range. */
+
+/* Maximum of address that you may set with SPY */
+#define IW_MAX_SPY		8
+
+/* Maximum of address that you may get in the
+   list of access points in range */
+#define IW_MAX_AP		64
+
+/* Maximum size of the ESSID and NICKN strings */
+#define IW_ESSID_MAX_SIZE	32
+
+/* Modes of operation */
+#define IW_MODE_AUTO	0	/* Let the driver decides */
+#define IW_MODE_ADHOC	1	/* Single cell network */
+#define IW_MODE_INFRA	2	/* Multi cell network, roaming, ... */
+#define IW_MODE_MASTER	3	/* Synchronisation master or Access Point */
+#define IW_MODE_REPEAT	4	/* Wireless Repeater (forwarder) */
+#define IW_MODE_SECOND	5	/* Secondary master/repeater (backup) */
+#define IW_MODE_MONITOR	6	/* Passive monitor (listen only) */
+
+/* Statistics flags (bitmask in updated) */
+#define IW_QUAL_QUAL_UPDATED	0x01	/* Value was updated since last read */
+#define IW_QUAL_LEVEL_UPDATED	0x02
+#define IW_QUAL_NOISE_UPDATED	0x04
+#define IW_QUAL_ALL_UPDATED	0x07
+#define IW_QUAL_DBM		0x08	/* Level + Noise are dBm */
+#define IW_QUAL_QUAL_INVALID	0x10	/* Driver doesn't provide value */
+#define IW_QUAL_LEVEL_INVALID	0x20
+#define IW_QUAL_NOISE_INVALID	0x40
+#define IW_QUAL_ALL_INVALID	0x70
+
+/* Frequency flags */
+#define IW_FREQ_AUTO		0x00	/* Let the driver decides */
+#define IW_FREQ_FIXED		0x01	/* Force a specific value */
+
+/* Maximum number of size of encoding token available
+ * they are listed in the range structure */
+#define IW_MAX_ENCODING_SIZES	8
+
+/* Maximum size of the encoding token in bytes */
+#define IW_ENCODING_TOKEN_MAX	64	/* 512 bits (for now) */
+
+/* Flags for encoding (along with the token) */
+#define IW_ENCODE_INDEX		0x00FF	/* Token index (if needed) */
+#define IW_ENCODE_FLAGS		0xFF00	/* Flags defined below */
+#define IW_ENCODE_MODE		0xF000	/* Modes defined below */
+#define IW_ENCODE_DISABLED	0x8000	/* Encoding disabled */
+#define IW_ENCODE_ENABLED	0x0000	/* Encoding enabled */
+#define IW_ENCODE_RESTRICTED	0x4000	/* Refuse non-encoded packets */
+#define IW_ENCODE_OPEN		0x2000	/* Accept non-encoded packets */
+#define IW_ENCODE_NOKEY		0x0800  /* Key is write only, so not present */
+#define IW_ENCODE_TEMP		0x0400  /* Temporary key */
+
+/* Power management flags available (along with the value, if any) */
+#define IW_POWER_ON		0x0000	/* No details... */
+#define IW_POWER_TYPE		0xF000	/* Type of parameter */
+#define IW_POWER_PERIOD		0x1000	/* Value is a period/duration of  */
+#define IW_POWER_TIMEOUT	0x2000	/* Value is a timeout (to go asleep) */
+#define IW_POWER_MODE		0x0F00	/* Power Management mode */
+#define IW_POWER_UNICAST_R	0x0100	/* Receive only unicast messages */
+#define IW_POWER_MULTICAST_R	0x0200	/* Receive only multicast messages */
+#define IW_POWER_ALL_R		0x0300	/* Receive all messages though PM */
+#define IW_POWER_FORCE_S	0x0400	/* Force PM procedure for sending unicast */
+#define IW_POWER_REPEATER	0x0800	/* Repeat broadcast messages in PM period */
+#define IW_POWER_MODIFIER	0x000F	/* Modify a parameter */
+#define IW_POWER_MIN		0x0001	/* Value is a minimum  */
+#define IW_POWER_MAX		0x0002	/* Value is a maximum */
+#define IW_POWER_RELATIVE	0x0004	/* Value is not in seconds/ms/us */
+
+/* Transmit Power flags available */
+#define IW_TXPOW_TYPE		0x00FF	/* Type of value */
+#define IW_TXPOW_DBM		0x0000	/* Value is in dBm */
+#define IW_TXPOW_MWATT		0x0001	/* Value is in mW */
+#define IW_TXPOW_RELATIVE	0x0002	/* Value is in arbitrary units */
+#define IW_TXPOW_RANGE		0x1000	/* Range of value between min/max */
+
+/* Retry limits and lifetime flags available */
+#define IW_RETRY_ON		0x0000	/* No details... */
+#define IW_RETRY_TYPE		0xF000	/* Type of parameter */
+#define IW_RETRY_LIMIT		0x1000	/* Maximum number of retries*/
+#define IW_RETRY_LIFETIME	0x2000	/* Maximum duration of retries in us */
+#define IW_RETRY_MODIFIER	0x000F	/* Modify a parameter */
+#define IW_RETRY_MIN		0x0001	/* Value is a minimum  */
+#define IW_RETRY_MAX		0x0002	/* Value is a maximum */
+#define IW_RETRY_RELATIVE	0x0004	/* Value is not in seconds/ms/us */
+
+/* Scanning request flags */
+#define IW_SCAN_DEFAULT		0x0000	/* Default scan of the driver */
+#define IW_SCAN_ALL_ESSID	0x0001	/* Scan all ESSIDs */
+#define IW_SCAN_THIS_ESSID	0x0002	/* Scan only this ESSID */
+#define IW_SCAN_ALL_FREQ	0x0004	/* Scan all Frequencies */
+#define IW_SCAN_THIS_FREQ	0x0008	/* Scan only this Frequency */
+#define IW_SCAN_ALL_MODE	0x0010	/* Scan all Modes */
+#define IW_SCAN_THIS_MODE	0x0020	/* Scan only this Mode */
+#define IW_SCAN_ALL_RATE	0x0040	/* Scan all Bit-Rates */
+#define IW_SCAN_THIS_RATE	0x0080	/* Scan only this Bit-Rate */
+/* struct iw_scan_req scan_type */
+#define IW_SCAN_TYPE_ACTIVE 0
+#define IW_SCAN_TYPE_PASSIVE 1
+/* Maximum size of returned data */
+#define IW_SCAN_MAX_DATA	4096	/* In bytes */
+
+/* Max number of char in custom event - use multiple of them if needed */
+#define IW_CUSTOM_MAX		256	/* In bytes */
+
+/* Generic information element */
+#define IW_GENERIC_IE_MAX	1024
+
+/* MLME requests (SIOCSIWMLME / struct iw_mlme) */
+#define IW_MLME_DEAUTH		0
+#define IW_MLME_DISASSOC	1
+
+/* SIOCSIWAUTH/SIOCGIWAUTH struct iw_param flags */
+#define IW_AUTH_INDEX		0x0FFF
+#define IW_AUTH_FLAGS		0xF000
+/* SIOCSIWAUTH/SIOCGIWAUTH parameters (0 .. 4095)
+ * (IW_AUTH_INDEX mask in struct iw_param flags; this is the index of the
+ * parameter that is being set/get to; value will be read/written to
+ * struct iw_param value field) */
+#define IW_AUTH_WPA_VERSION		0
+#define IW_AUTH_CIPHER_PAIRWISE		1
+#define IW_AUTH_CIPHER_GROUP		2
+#define IW_AUTH_KEY_MGMT		3
+#define IW_AUTH_TKIP_COUNTERMEASURES	4
+#define IW_AUTH_DROP_UNENCRYPTED	5
+#define IW_AUTH_80211_AUTH_ALG		6
+#define IW_AUTH_WPA_ENABLED		7
+#define IW_AUTH_RX_UNENCRYPTED_EAPOL	8
+#define IW_AUTH_ROAMING_CONTROL		9
+#define IW_AUTH_PRIVACY_INVOKED		10
+
+/* IW_AUTH_WPA_VERSION values (bit field) */
+#define IW_AUTH_WPA_VERSION_DISABLED	0x00000001
+#define IW_AUTH_WPA_VERSION_WPA		0x00000002
+#define IW_AUTH_WPA_VERSION_WPA2	0x00000004
+
+/* IW_AUTH_PAIRWISE_CIPHER and IW_AUTH_GROUP_CIPHER values (bit field) */
+#define IW_AUTH_CIPHER_NONE	0x00000001
+#define IW_AUTH_CIPHER_WEP40	0x00000002
+#define IW_AUTH_CIPHER_TKIP	0x00000004
+#define IW_AUTH_CIPHER_CCMP	0x00000008
+#define IW_AUTH_CIPHER_WEP104	0x00000010
+
+/* IW_AUTH_KEY_MGMT values (bit field) */
+#define IW_AUTH_KEY_MGMT_802_1X	1
+#define IW_AUTH_KEY_MGMT_PSK	2
+
+/* IW_AUTH_80211_AUTH_ALG values (bit field) */
+#define IW_AUTH_ALG_OPEN_SYSTEM	0x00000001
+#define IW_AUTH_ALG_SHARED_KEY	0x00000002
+#define IW_AUTH_ALG_LEAP	0x00000004
+
+/* IW_AUTH_ROAMING_CONTROL values */
+#define IW_AUTH_ROAMING_ENABLE	0	/* driver/firmware based roaming */
+#define IW_AUTH_ROAMING_DISABLE	1	/* user space program used for roaming
+					 * control */
+
+/* SIOCSIWENCODEEXT definitions */
+#define IW_ENCODE_SEQ_MAX_SIZE	8
+/* struct iw_encode_ext ->alg */
+#define IW_ENCODE_ALG_NONE	0
+#define IW_ENCODE_ALG_WEP	1
+#define IW_ENCODE_ALG_TKIP	2
+#define IW_ENCODE_ALG_CCMP	3
+/* struct iw_encode_ext ->ext_flags */
+#define IW_ENCODE_EXT_TX_SEQ_VALID	0x00000001
+#define IW_ENCODE_EXT_RX_SEQ_VALID	0x00000002
+#define IW_ENCODE_EXT_GROUP_KEY		0x00000004
+#define IW_ENCODE_EXT_SET_TX_KEY	0x00000008
+
+/* IWEVMICHAELMICFAILURE : struct iw_michaelmicfailure ->flags */
+#define IW_MICFAILURE_KEY_ID	0x00000003 /* Key ID 0..3 */
+#define IW_MICFAILURE_GROUP	0x00000004
+#define IW_MICFAILURE_PAIRWISE	0x00000008
+#define IW_MICFAILURE_STAKEY	0x00000010
+#define IW_MICFAILURE_COUNT	0x00000060 /* 1 or 2 (0 = count not supported)
+					    */
+
+/* Bit field values for enc_capa in struct iw_range */
+#define IW_ENC_CAPA_WPA		0x00000001
+#define IW_ENC_CAPA_WPA2	0x00000002
+#define IW_ENC_CAPA_CIPHER_TKIP	0x00000004
+#define IW_ENC_CAPA_CIPHER_CCMP	0x00000008
+
+/* Event capability macros - in (struct iw_range *)->event_capa
+ * Because we have more than 32 possible events, we use an array of
+ * 32 bit bitmasks. Note : 32 bits = 0x20 = 2^5. */
+#define IW_EVENT_CAPA_BASE(cmd)		((cmd >= SIOCIWFIRSTPRIV) ? \
+					 (cmd - SIOCIWFIRSTPRIV + 0x60) : \
+					 (cmd - SIOCSIWCOMMIT))
+#define IW_EVENT_CAPA_INDEX(cmd)	(IW_EVENT_CAPA_BASE(cmd) >> 5)
+#define IW_EVENT_CAPA_MASK(cmd)		(1 << (IW_EVENT_CAPA_BASE(cmd) & 0x1F))
+/* Event capability constants - event autogenerated by the kernel
+ * This list is valid for most 802.11 devices, customise as needed... */
+#define IW_EVENT_CAPA_K_0	(IW_EVENT_CAPA_MASK(0x8B04) | \
+				 IW_EVENT_CAPA_MASK(0x8B06) | \
+				 IW_EVENT_CAPA_MASK(0x8B1A))
+#define IW_EVENT_CAPA_K_1	(IW_EVENT_CAPA_MASK(0x8B2A))
+/* "Easy" macro to set events in iw_range (less efficient) */
+#define IW_EVENT_CAPA_SET(event_capa, cmd) (event_capa[IW_EVENT_CAPA_INDEX(cmd)] |= IW_EVENT_CAPA_MASK(cmd))
+#define IW_EVENT_CAPA_SET_KERNEL(event_capa) {event_capa[0] |= IW_EVENT_CAPA_K_0; event_capa[1] |= IW_EVENT_CAPA_K_1; }
+
+
+/****************************** TYPES ******************************/
+
+/* --------------------------- SUBTYPES --------------------------- */
+/*
+ *	Generic format for most parameters that fit in an int
+ */
+struct	iw_param
+{
+  __s32		value;		/* The value of the parameter itself */
+  __u8		fixed;		/* Hardware should not use auto select */
+  __u8		disabled;	/* Disable the feature */
+  __u16		flags;		/* Various specifc flags (if any) */
+};
+
+/*
+ *	For all data larger than 16 octets, we need to use a
+ *	pointer to memory allocated in user space.
+ */
+struct	iw_point
+{
+  void __user	*pointer;	/* Pointer to the data  (in user space) */
+  __u16		length;		/* number of fields or size in bytes */
+  __u16		flags;		/* Optional params */
+};
+
+/*
+ *	A frequency
+ *	For numbers lower than 10^9, we encode the number in 'm' and
+ *	set 'e' to 0
+ *	For number greater than 10^9, we divide it by the lowest power
+ *	of 10 to get 'm' lower than 10^9, with 'm'= f / (10^'e')...
+ *	The power of 10 is in 'e', the result of the division is in 'm'.
+ */
+struct	iw_freq
+{
+	__s32		m;		/* Mantissa */
+	__s16		e;		/* Exponent */
+	__u8		i;		/* List index (when in range struct) */
+	__u8		flags;		/* Flags (fixed/auto) */
+};
+
+/*
+ *	Quality of the link
+ */
+struct	iw_quality
+{
+	__u8		qual;		/* link quality (%retries, SNR,
+					   %missed beacons or better...) */
+	__u8		level;		/* signal level (dBm) */
+	__u8		noise;		/* noise level (dBm) */
+	__u8		updated;	/* Flags to know if updated */
+};
+
+/*
+ *	Packet discarded in the wireless adapter due to
+ *	"wireless" specific problems...
+ *	Note : the list of counter and statistics in net_device_stats
+ *	is already pretty exhaustive, and you should use that first.
+ *	This is only additional stats...
+ */
+struct	iw_discarded
+{
+	__u32		nwid;		/* Rx : Wrong nwid/essid */
+	__u32		code;		/* Rx : Unable to code/decode (WEP) */
+	__u32		fragment;	/* Rx : Can't perform MAC reassembly */
+	__u32		retries;	/* Tx : Max MAC retries num reached */
+	__u32		misc;		/* Others cases */
+};
+
+/*
+ *	Packet/Time period missed in the wireless adapter due to
+ *	"wireless" specific problems...
+ */
+struct	iw_missed
+{
+	__u32		beacon;		/* Missed beacons/superframe */
+};
+
+/*
+ *	Quality range (for spy threshold)
+ */
+struct	iw_thrspy
+{
+	struct sockaddr		addr;		/* Source address (hw/mac) */
+	struct iw_quality	qual;		/* Quality of the link */
+	struct iw_quality	low;		/* Low threshold */
+	struct iw_quality	high;		/* High threshold */
+};
+
+/*
+ *	Optional data for scan request
+ *
+ *	Note: these optional parameters are controlling parameters for the
+ *	scanning behavior, these do not apply to getting scan results
+ *	(SIOCGIWSCAN). Drivers are expected to keep a local BSS table and
+ *	provide a merged results with all BSSes even if the previous scan
+ *	request limited scanning to a subset, e.g., by specifying an SSID.
+ *	Especially, scan results are required to include an entry for the
+ *	current BSS if the driver is in Managed mode and associated with an AP.
+ */
+struct	iw_scan_req
+{
+	__u8		scan_type; /* IW_SCAN_TYPE_{ACTIVE,PASSIVE} */
+	__u8		essid_len;
+	__u8		num_channels; /* num entries in channel_list;
+				       * 0 = scan all allowed channels */
+	__u8		flags; /* reserved as padding; use zero, this may
+				* be used in the future for adding flags
+				* to request different scan behavior */
+	struct sockaddr	bssid; /* ff:ff:ff:ff:ff:ff for broadcast BSSID or
+				* individual address of a specific BSS */
+
+	/*
+	 * Use this ESSID if IW_SCAN_THIS_ESSID flag is used instead of using
+	 * the current ESSID. This allows scan requests for specific ESSID
+	 * without having to change the current ESSID and potentially breaking
+	 * the current association.
+	 */
+	__u8		essid[IW_ESSID_MAX_SIZE];
+
+	/*
+	 * Optional parameters for changing the default scanning behavior.
+	 * These are based on the MLME-SCAN.request from IEEE Std 802.11.
+	 * TU is 1.024 ms. If these are set to 0, driver is expected to use
+	 * reasonable default values. min_channel_time defines the time that
+	 * will be used to wait for the first reply on each channel. If no
+	 * replies are received, next channel will be scanned after this. If
+	 * replies are received, total time waited on the channel is defined by
+	 * max_channel_time.
+	 */
+	__u32		min_channel_time; /* in TU */
+	__u32		max_channel_time; /* in TU */
+
+	struct iw_freq	channel_list[IW_MAX_FREQUENCIES];
+};
+
+/* ------------------------- WPA SUPPORT ------------------------- */
+
+/*
+ *	Extended data structure for get/set encoding (this is used with
+ *	SIOCSIWENCODEEXT/SIOCGIWENCODEEXT. struct iw_point and IW_ENCODE_*
+ *	flags are used in the same way as with SIOCSIWENCODE/SIOCGIWENCODE and
+ *	only the data contents changes (key data -> this structure, including
+ *	key data).
+ *
+ *	If the new key is the first group key, it will be set as the default
+ *	TX key. Otherwise, default TX key index is only changed if
+ *	IW_ENCODE_EXT_SET_TX_KEY flag is set.
+ *
+ *	Key will be changed with SIOCSIWENCODEEXT in all cases except for
+ *	special "change TX key index" operation which is indicated by setting
+ *	key_len = 0 and ext_flags |= IW_ENCODE_EXT_SET_TX_KEY.
+ *
+ *	tx_seq/rx_seq are only used when respective
+ *	IW_ENCODE_EXT_{TX,RX}_SEQ_VALID flag is set in ext_flags. Normal
+ *	TKIP/CCMP operation is to set RX seq with SIOCSIWENCODEEXT and start
+ *	TX seq from zero whenever key is changed. SIOCGIWENCODEEXT is normally
+ *	used only by an Authenticator (AP or an IBSS station) to get the
+ *	current TX sequence number. Using TX_SEQ_VALID for SIOCSIWENCODEEXT and
+ *	RX_SEQ_VALID for SIOCGIWENCODEEXT are optional, but can be useful for
+ *	debugging/testing.
+ */
+struct	iw_encode_ext
+{
+	__u32		ext_flags; /* IW_ENCODE_EXT_* */
+	__u8		tx_seq[IW_ENCODE_SEQ_MAX_SIZE]; /* LSB first */
+	__u8		rx_seq[IW_ENCODE_SEQ_MAX_SIZE]; /* LSB first */
+	struct sockaddr	addr; /* ff:ff:ff:ff:ff:ff for broadcast/multicast
+			       * (group) keys or unicast address for
+			       * individual keys */
+	__u16		alg; /* IW_ENCODE_ALG_* */
+	__u16		key_len;
+	__u8		key[0];
+};
+
+/* SIOCSIWMLME data */
+struct	iw_mlme
+{
+	__u16		cmd; /* IW_MLME_* */
+	__u16		reason_code;
+	struct sockaddr	addr;
+};
+
+/* SIOCSIWPMKSA data */
+#define IW_PMKSA_ADD		1
+#define IW_PMKSA_REMOVE		2
+#define IW_PMKSA_FLUSH		3
+
+#define IW_PMKID_LEN	16
+
+struct	iw_pmksa
+{
+	__u32		cmd; /* IW_PMKSA_* */
+	struct sockaddr	bssid;
+	__u8		pmkid[IW_PMKID_LEN];
+};
+
+/* IWEVMICHAELMICFAILURE data */
+struct	iw_michaelmicfailure
+{
+	__u32		flags;
+	struct sockaddr	src_addr;
+	__u8		tsc[IW_ENCODE_SEQ_MAX_SIZE]; /* LSB first */
+};
+
+/* IWEVPMKIDCAND data */
+#define IW_PMKID_CAND_PREAUTH	0x00000001 /* RNS pre-authentication enabled */
+struct	iw_pmkid_cand
+{
+	__u32		flags; /* IW_PMKID_CAND_* */
+	__u32		index; /* the smaller the index, the higher the
+				* priority */
+	struct sockaddr	bssid;
+};
+
+/* ------------------------ WIRELESS STATS ------------------------ */
+/*
+ * Wireless statistics (used for /proc/net/wireless)
+ */
+struct	iw_statistics
+{
+	__u16		status;		/* Status
+					 * - device dependent for now */
+
+	struct iw_quality	qual;		/* Quality of the link
+						 * (instant/mean/max) */
+	struct iw_discarded	discard;	/* Packet discarded counts */
+	struct iw_missed	miss;		/* Packet missed counts */
+};
+
+/* ------------------------ IOCTL REQUEST ------------------------ */
+/*
+ * This structure defines the payload of an ioctl, and is used 
+ * below.
+ *
+ * Note that this structure should fit on the memory footprint
+ * of iwreq (which is the same as ifreq), which mean a max size of
+ * 16 octets = 128 bits. Warning, pointers might be 64 bits wide...
+ * You should check this when increasing the structures defined
+ * above in this file...
+ */
+union	iwreq_data
+{
+	/* Config - generic */
+	char		name[IFNAMSIZ];
+	/* Name : used to verify the presence of  wireless extensions.
+	 * Name of the protocol/provider... */
+
+	struct iw_point	essid;		/* Extended network name */
+	struct iw_param	nwid;		/* network id (or domain - the cell) */
+	struct iw_freq	freq;		/* frequency or channel :
+					 * 0-1000 = channel
+					 * > 1000 = frequency in Hz */
+
+	struct iw_param	sens;		/* signal level threshold */
+	struct iw_param	bitrate;	/* default bit rate */
+	struct iw_param	txpower;	/* default transmit power */
+	struct iw_param	rts;		/* RTS threshold threshold */
+	struct iw_param	frag;		/* Fragmentation threshold */
+	__u32		mode;		/* Operation mode */
+	struct iw_param	retry;		/* Retry limits & lifetime */
+
+	struct iw_point	encoding;	/* Encoding stuff : tokens */
+	struct iw_param	power;		/* PM duration/timeout */
+	struct iw_quality qual;		/* Quality part of statistics */
+
+	struct sockaddr	ap_addr;	/* Access point address */
+	struct sockaddr	addr;		/* Destination address (hw/mac) */
+
+	struct iw_param	param;		/* Other small parameters */
+	struct iw_point	data;		/* Other large parameters */
+};
+
+/*
+ * The structure to exchange data for ioctl.
+ * This structure is the same as 'struct ifreq', but (re)defined for
+ * convenience...
+ * Do I need to remind you about structure size (32 octets) ?
+ */
+struct	iwreq 
+{
+	union
+	{
+		char	ifrn_name[IFNAMSIZ];	/* if name, e.g. "eth0" */
+	} ifr_ifrn;
+
+	/* Data part (defined just above) */
+	union	iwreq_data	u;
+};
+
+/* -------------------------- IOCTL DATA -------------------------- */
+/*
+ *	For those ioctl which want to exchange mode data that what could
+ *	fit in the above structure...
+ */
+
+/*
+ *	Range of parameters
+ */
+
+struct	iw_range
+{
+	/* Informative stuff (to choose between different interface) */
+	__u32		throughput;	/* To give an idea... */
+	/* In theory this value should be the maximum benchmarked
+	 * TCP/IP throughput, because with most of these devices the
+	 * bit rate is meaningless (overhead an co) to estimate how
+	 * fast the connection will go and pick the fastest one.
+	 * I suggest people to play with Netperf or any benchmark...
+	 */
+
+	/* NWID (or domain id) */
+	__u32		min_nwid;	/* Minimal NWID we are able to set */
+	__u32		max_nwid;	/* Maximal NWID we are able to set */
+
+	/* Old Frequency (backward compat - moved lower ) */
+	__u16		old_num_channels;
+	__u8		old_num_frequency;
+
+	/* Wireless event capability bitmasks */
+	__u32		event_capa[6];
+
+	/* signal level threshold range */
+	__s32		sensitivity;
+
+	/* Quality of link & SNR stuff */
+	/* Quality range (link, level, noise)
+	 * If the quality is absolute, it will be in the range [0 ; max_qual],
+	 * if the quality is dBm, it will be in the range [max_qual ; 0].
+	 * Don't forget that we use 8 bit arithmetics... */
+	struct iw_quality	max_qual;	/* Quality of the link */
+	/* This should contain the average/typical values of the quality
+	 * indicator. This should be the threshold between a "good" and
+	 * a "bad" link (example : monitor going from green to orange).
+	 * Currently, user space apps like quality monitors don't have any
+	 * way to calibrate the measurement. With this, they can split
+	 * the range between 0 and max_qual in different quality level
+	 * (using a geometric subdivision centered on the average).
+	 * I expect that people doing the user space apps will feedback
+	 * us on which value we need to put in each driver... */
+	struct iw_quality	avg_qual;	/* Quality of the link */
+
+	/* Rates */
+	__u8		num_bitrates;	/* Number of entries in the list */
+	__s32		bitrate[IW_MAX_BITRATES];	/* list, in bps */
+
+	/* RTS threshold */
+	__s32		min_rts;	/* Minimal RTS threshold */
+	__s32		max_rts;	/* Maximal RTS threshold */
+
+	/* Frag threshold */
+	__s32		min_frag;	/* Minimal frag threshold */
+	__s32		max_frag;	/* Maximal frag threshold */
+
+	/* Power Management duration & timeout */
+	__s32		min_pmp;	/* Minimal PM period */
+	__s32		max_pmp;	/* Maximal PM period */
+	__s32		min_pmt;	/* Minimal PM timeout */
+	__s32		max_pmt;	/* Maximal PM timeout */
+	__u16		pmp_flags;	/* How to decode max/min PM period */
+	__u16		pmt_flags;	/* How to decode max/min PM timeout */
+	__u16		pm_capa;	/* What PM options are supported */
+
+	/* Encoder stuff */
+	__u16	encoding_size[IW_MAX_ENCODING_SIZES];	/* Different token sizes */
+	__u8	num_encoding_sizes;	/* Number of entry in the list */
+	__u8	max_encoding_tokens;	/* Max number of tokens */
+	/* For drivers that need a "login/passwd" form */
+	__u8	encoding_login_index;	/* token index for login token */
+
+	/* Transmit power */
+	__u16		txpower_capa;	/* What options are supported */
+	__u8		num_txpower;	/* Number of entries in the list */
+	__s32		txpower[IW_MAX_TXPOWER];	/* list, in bps */
+
+	/* Wireless Extension version info */
+	__u8		we_version_compiled;	/* Must be WIRELESS_EXT */
+	__u8		we_version_source;	/* Last update of source */
+
+	/* Retry limits and lifetime */
+	__u16		retry_capa;	/* What retry options are supported */
+	__u16		retry_flags;	/* How to decode max/min retry limit */
+	__u16		r_time_flags;	/* How to decode max/min retry life */
+	__s32		min_retry;	/* Minimal number of retries */
+	__s32		max_retry;	/* Maximal number of retries */
+	__s32		min_r_time;	/* Minimal retry lifetime */
+	__s32		max_r_time;	/* Maximal retry lifetime */
+
+	/* Frequency */
+	__u16		num_channels;	/* Number of channels [0; num - 1] */
+	__u8		num_frequency;	/* Number of entry in the list */
+	struct iw_freq	freq[IW_MAX_FREQUENCIES];	/* list */
+	/* Note : this frequency list doesn't need to fit channel numbers,
+	 * because each entry contain its channel index */
+
+	__u32		enc_capa; /* IW_ENC_CAPA_* bit field */
+};
+
+/*
+ * Private ioctl interface information
+ */
+ 
+struct	iw_priv_args
+{
+	__u32		cmd;		/* Number of the ioctl to issue */
+	__u16		set_args;	/* Type and number of args */
+	__u16		get_args;	/* Type and number of args */
+	char		name[IFNAMSIZ];	/* Name of the extension */
+};
+
+/* ----------------------- WIRELESS EVENTS ----------------------- */
+/*
+ * Wireless events are carried through the rtnetlink socket to user
+ * space. They are encapsulated in the IFLA_WIRELESS field of
+ * a RTM_NEWLINK message.
+ */
+
+/*
+ * A Wireless Event. Contains basically the same data as the ioctl...
+ */
+struct iw_event
+{
+	__u16		len;			/* Real lenght of this stuff */
+	__u16		cmd;			/* Wireless IOCTL */
+	union iwreq_data	u;		/* IOCTL fixed payload */
+};
+
+/* Size of the Event prefix (including padding and alignement junk) */
+#define IW_EV_LCP_LEN	(sizeof(struct iw_event) - sizeof(union iwreq_data))
+/* Size of the various events */
+#define IW_EV_CHAR_LEN	(IW_EV_LCP_LEN + IFNAMSIZ)
+#define IW_EV_UINT_LEN	(IW_EV_LCP_LEN + sizeof(__u32))
+#define IW_EV_FREQ_LEN	(IW_EV_LCP_LEN + sizeof(struct iw_freq))
+#define IW_EV_PARAM_LEN	(IW_EV_LCP_LEN + sizeof(struct iw_param))
+#define IW_EV_ADDR_LEN	(IW_EV_LCP_LEN + sizeof(struct sockaddr))
+#define IW_EV_QUAL_LEN	(IW_EV_LCP_LEN + sizeof(struct iw_quality))
+
+/* iw_point events are special. First, the payload (extra data) come at
+ * the end of the event, so they are bigger than IW_EV_POINT_LEN. Second,
+ * we omit the pointer, so start at an offset. */
+#define IW_EV_POINT_OFF (((char *) &(((struct iw_point *) NULL)->length)) - \
+			  (char *) NULL)
+#define IW_EV_POINT_LEN	(IW_EV_LCP_LEN + sizeof(struct iw_point) - \
+			 IW_EV_POINT_OFF)
+
+#endif	/* _LINUX_WIRELESS_H */
diff --git a/wireless.20.h b/wireless.20.h
new file mode 100644
index 0000000..e566157
--- /dev/null
+++ b/wireless.20.h
@@ -0,0 +1,1073 @@
+/*
+ * This file define a set of standard wireless extensions
+ *
+ * Version :	20	17.2.06
+ *
+ * Authors :	Jean Tourrilhes - HPL - <jt@hpl.hp.com>
+ * Copyright (c) 1997-2006 Jean Tourrilhes, All Rights Reserved.
+ */
+
+#ifndef _LINUX_WIRELESS_H
+#define _LINUX_WIRELESS_H
+
+/************************** DOCUMENTATION **************************/
+/*
+ * Initial APIs (1996 -> onward) :
+ * -----------------------------
+ * Basically, the wireless extensions are for now a set of standard ioctl
+ * call + /proc/net/wireless
+ *
+ * The entry /proc/net/wireless give statistics and information on the
+ * driver.
+ * This is better than having each driver having its entry because
+ * its centralised and we may remove the driver module safely.
+ *
+ * Ioctl are used to configure the driver and issue commands.  This is
+ * better than command line options of insmod because we may want to
+ * change dynamically (while the driver is running) some parameters.
+ *
+ * The ioctl mechanimsm are copied from standard devices ioctl.
+ * We have the list of command plus a structure descibing the
+ * data exchanged...
+ * Note that to add these ioctl, I was obliged to modify :
+ *	# net/core/dev.c (two place + add include)
+ *	# net/ipv4/af_inet.c (one place + add include)
+ *
+ * /proc/net/wireless is a copy of /proc/net/dev.
+ * We have a structure for data passed from the driver to /proc/net/wireless
+ * Too add this, I've modified :
+ *	# net/core/dev.c (two other places)
+ *	# include/linux/netdevice.h (one place)
+ *	# include/linux/proc_fs.h (one place)
+ *
+ * New driver API (2002 -> onward) :
+ * -------------------------------
+ * This file is only concerned with the user space API and common definitions.
+ * The new driver API is defined and documented in :
+ *	# include/net/iw_handler.h
+ *
+ * Note as well that /proc/net/wireless implementation has now moved in :
+ *	# net/core/wireless.c
+ *
+ * Wireless Events (2002 -> onward) :
+ * --------------------------------
+ * Events are defined at the end of this file, and implemented in :
+ *	# net/core/wireless.c
+ *
+ * Other comments :
+ * --------------
+ * Do not add here things that are redundant with other mechanisms
+ * (drivers init, ifconfig, /proc/net/dev, ...) and with are not
+ * wireless specific.
+ *
+ * These wireless extensions are not magic : each driver has to provide
+ * support for them...
+ *
+ * IMPORTANT NOTE : As everything in the kernel, this is very much a
+ * work in progress. Contact me if you have ideas of improvements...
+ */
+
+/***************************** INCLUDES *****************************/
+
+/* Do not put any header in this file, this creates a mess when
+ * exported to user space. Most users have included all the
+ * relevant headers anyway... Jean II */
+/*#include <linux/types.h>*/		/* for "caddr_t" et al		*/
+/*#include <linux/socket.h>*/		/* for "struct sockaddr" et al	*/
+/*#include <linux/if.h>*/		/* for IFNAMSIZ and co... */
+
+/***************************** VERSION *****************************/
+/*
+ * This constant is used to know the availability of the wireless
+ * extensions and to know which version of wireless extensions it is
+ * (there is some stuff that will be added in the future...)
+ * I just plan to increment with each new version.
+ */
+#define WIRELESS_EXT	20
+
+/*
+ * Changes :
+ *
+ * V2 to V3
+ * --------
+ *	Alan Cox start some incompatibles changes. I've integrated a bit more.
+ *	- Encryption renamed to Encode to avoid US regulation problems
+ *	- Frequency changed from float to struct to avoid problems on old 386
+ *
+ * V3 to V4
+ * --------
+ *	- Add sensitivity
+ *
+ * V4 to V5
+ * --------
+ *	- Missing encoding definitions in range
+ *	- Access points stuff
+ *
+ * V5 to V6
+ * --------
+ *	- 802.11 support (ESSID ioctls)
+ *
+ * V6 to V7
+ * --------
+ *	- define IW_ESSID_MAX_SIZE and IW_MAX_AP
+ *
+ * V7 to V8
+ * --------
+ *	- Changed my e-mail address
+ *	- More 802.11 support (nickname, rate, rts, frag)
+ *	- List index in frequencies
+ *
+ * V8 to V9
+ * --------
+ *	- Support for 'mode of operation' (ad-hoc, managed...)
+ *	- Support for unicast and multicast power saving
+ *	- Change encoding to support larger tokens (>64 bits)
+ *	- Updated iw_params (disable, flags) and use it for NWID
+ *	- Extracted iw_point from iwreq for clarity
+ *
+ * V9 to V10
+ * ---------
+ *	- Add PM capability to range structure
+ *	- Add PM modifier : MAX/MIN/RELATIVE
+ *	- Add encoding option : IW_ENCODE_NOKEY
+ *	- Add TxPower ioctls (work like TxRate)
+ *
+ * V10 to V11
+ * ----------
+ *	- Add WE version in range (help backward/forward compatibility)
+ *	- Add retry ioctls (work like PM)
+ *
+ * V11 to V12
+ * ----------
+ *	- Add SIOCSIWSTATS to get /proc/net/wireless programatically
+ *	- Add DEV PRIVATE IOCTL to avoid collisions in SIOCDEVPRIVATE space
+ *	- Add new statistics (frag, retry, beacon)
+ *	- Add average quality (for user space calibration)
+ *
+ * V12 to V13
+ * ----------
+ *	- Document creation of new driver API.
+ *	- Extract union iwreq_data from struct iwreq (for new driver API).
+ *	- Rename SIOCSIWNAME as SIOCSIWCOMMIT
+ *
+ * V13 to V14
+ * ----------
+ *	- Wireless Events support : define struct iw_event
+ *	- Define additional specific event numbers
+ *	- Add "addr" and "param" fields in union iwreq_data
+ *	- AP scanning stuff (SIOCSIWSCAN and friends)
+ *
+ * V14 to V15
+ * ----------
+ *	- Add IW_PRIV_TYPE_ADDR for struct sockaddr private arg
+ *	- Make struct iw_freq signed (both m & e), add explicit padding
+ *	- Add IWEVCUSTOM for driver specific event/scanning token
+ *	- Add IW_MAX_GET_SPY for driver returning a lot of addresses
+ *	- Add IW_TXPOW_RANGE for range of Tx Powers
+ *	- Add IWEVREGISTERED & IWEVEXPIRED events for Access Points
+ *	- Add IW_MODE_MONITOR for passive monitor
+ *
+ * V15 to V16
+ * ----------
+ *	- Increase the number of bitrates in iw_range to 32 (for 802.11g)
+ *	- Increase the number of frequencies in iw_range to 32 (for 802.11b+a)
+ *	- Reshuffle struct iw_range for increases, add filler
+ *	- Increase IW_MAX_AP to 64 for driver returning a lot of addresses
+ *	- Remove IW_MAX_GET_SPY because conflict with enhanced spy support
+ *	- Add SIOCSIWTHRSPY/SIOCGIWTHRSPY and "struct iw_thrspy"
+ *	- Add IW_ENCODE_TEMP and iw_range->encoding_login_index
+ *
+ * V16 to V17
+ * ----------
+ *	- Add flags to frequency -> auto/fixed
+ *	- Document (struct iw_quality *)->updated, add new flags (INVALID)
+ *	- Wireless Event capability in struct iw_range
+ *	- Add support for relative TxPower (yick !)
+ *
+ * V17 to V18 (From Jouni Malinen <jkmaline@cc.hut.fi>)
+ * ----------
+ *	- Add support for WPA/WPA2
+ *	- Add extended encoding configuration (SIOCSIWENCODEEXT and
+ *	  SIOCGIWENCODEEXT)
+ *	- Add SIOCSIWGENIE/SIOCGIWGENIE
+ *	- Add SIOCSIWMLME
+ *	- Add SIOCSIWPMKSA
+ *	- Add struct iw_range bit field for supported encoding capabilities
+ *	- Add optional scan request parameters for SIOCSIWSCAN
+ *	- Add SIOCSIWAUTH/SIOCGIWAUTH for setting authentication and WPA
+ *	  related parameters (extensible up to 4096 parameter values)
+ *	- Add wireless events: IWEVGENIE, IWEVMICHAELMICFAILURE,
+ *	  IWEVASSOCREQIE, IWEVASSOCRESPIE, IWEVPMKIDCAND
+ *
+ * V18 to V19
+ * ----------
+ *	- Remove (struct iw_point *)->pointer from events and streams
+ *	- Remove header includes to help user space
+ *	- Increase IW_ENCODING_TOKEN_MAX from 32 to 64
+ *	- Add IW_QUAL_ALL_UPDATED and IW_QUAL_ALL_INVALID macros
+ *	- Add explicit flag to tell stats are in dBm : IW_QUAL_DBM
+ *	- Add IW_IOCTL_IDX() and IW_EVENT_IDX() macros
+ *
+ * V19 to V20
+ * ----------
+ *	- RtNetlink requests support (SET/GET)
+ */
+
+/**************************** CONSTANTS ****************************/
+
+/* -------------------------- IOCTL LIST -------------------------- */
+
+/* Wireless Identification */
+#define SIOCSIWCOMMIT	0x8B00		/* Commit pending changes to driver */
+#define SIOCGIWNAME	0x8B01		/* get name == wireless protocol */
+/* SIOCGIWNAME is used to verify the presence of Wireless Extensions.
+ * Common values : "IEEE 802.11-DS", "IEEE 802.11-FH", "IEEE 802.11b"...
+ * Don't put the name of your driver there, it's useless. */
+
+/* Basic operations */
+#define SIOCSIWNWID	0x8B02		/* set network id (pre-802.11) */
+#define SIOCGIWNWID	0x8B03		/* get network id (the cell) */
+#define SIOCSIWFREQ	0x8B04		/* set channel/frequency (Hz) */
+#define SIOCGIWFREQ	0x8B05		/* get channel/frequency (Hz) */
+#define SIOCSIWMODE	0x8B06		/* set operation mode */
+#define SIOCGIWMODE	0x8B07		/* get operation mode */
+#define SIOCSIWSENS	0x8B08		/* set sensitivity (dBm) */
+#define SIOCGIWSENS	0x8B09		/* get sensitivity (dBm) */
+
+/* Informative stuff */
+#define SIOCSIWRANGE	0x8B0A		/* Unused */
+#define SIOCGIWRANGE	0x8B0B		/* Get range of parameters */
+#define SIOCSIWPRIV	0x8B0C		/* Unused */
+#define SIOCGIWPRIV	0x8B0D		/* get private ioctl interface info */
+#define SIOCSIWSTATS	0x8B0E		/* Unused */
+#define SIOCGIWSTATS	0x8B0F		/* Get /proc/net/wireless stats */
+/* SIOCGIWSTATS is strictly used between user space and the kernel, and
+ * is never passed to the driver (i.e. the driver will never see it). */
+
+/* Spy support (statistics per MAC address - used for Mobile IP support) */
+#define SIOCSIWSPY	0x8B10		/* set spy addresses */
+#define SIOCGIWSPY	0x8B11		/* get spy info (quality of link) */
+#define SIOCSIWTHRSPY	0x8B12		/* set spy threshold (spy event) */
+#define SIOCGIWTHRSPY	0x8B13		/* get spy threshold */
+
+/* Access Point manipulation */
+#define SIOCSIWAP	0x8B14		/* set access point MAC addresses */
+#define SIOCGIWAP	0x8B15		/* get access point MAC addresses */
+#define SIOCGIWAPLIST	0x8B17		/* Deprecated in favor of scanning */
+#define SIOCSIWSCAN	0x8B18		/* trigger scanning (list cells) */
+#define SIOCGIWSCAN	0x8B19		/* get scanning results */
+
+/* 802.11 specific support */
+#define SIOCSIWESSID	0x8B1A		/* set ESSID (network name) */
+#define SIOCGIWESSID	0x8B1B		/* get ESSID */
+#define SIOCSIWNICKN	0x8B1C		/* set node name/nickname */
+#define SIOCGIWNICKN	0x8B1D		/* get node name/nickname */
+/* As the ESSID and NICKN are strings up to 32 bytes long, it doesn't fit
+ * within the 'iwreq' structure, so we need to use the 'data' member to
+ * point to a string in user space, like it is done for RANGE... */
+
+/* Other parameters useful in 802.11 and some other devices */
+#define SIOCSIWRATE	0x8B20		/* set default bit rate (bps) */
+#define SIOCGIWRATE	0x8B21		/* get default bit rate (bps) */
+#define SIOCSIWRTS	0x8B22		/* set RTS/CTS threshold (bytes) */
+#define SIOCGIWRTS	0x8B23		/* get RTS/CTS threshold (bytes) */
+#define SIOCSIWFRAG	0x8B24		/* set fragmentation thr (bytes) */
+#define SIOCGIWFRAG	0x8B25		/* get fragmentation thr (bytes) */
+#define SIOCSIWTXPOW	0x8B26		/* set transmit power (dBm) */
+#define SIOCGIWTXPOW	0x8B27		/* get transmit power (dBm) */
+#define SIOCSIWRETRY	0x8B28		/* set retry limits and lifetime */
+#define SIOCGIWRETRY	0x8B29		/* get retry limits and lifetime */
+
+/* Encoding stuff (scrambling, hardware security, WEP...) */
+#define SIOCSIWENCODE	0x8B2A		/* set encoding token & mode */
+#define SIOCGIWENCODE	0x8B2B		/* get encoding token & mode */
+/* Power saving stuff (power management, unicast and multicast) */
+#define SIOCSIWPOWER	0x8B2C		/* set Power Management settings */
+#define SIOCGIWPOWER	0x8B2D		/* get Power Management settings */
+
+/* WPA : Generic IEEE 802.11 informatiom element (e.g., for WPA/RSN/WMM).
+ * This ioctl uses struct iw_point and data buffer that includes IE id and len
+ * fields. More than one IE may be included in the request. Setting the generic
+ * IE to empty buffer (len=0) removes the generic IE from the driver. Drivers
+ * are allowed to generate their own WPA/RSN IEs, but in these cases, drivers
+ * are required to report the used IE as a wireless event, e.g., when
+ * associating with an AP. */
+#define SIOCSIWGENIE	0x8B30		/* set generic IE */
+#define SIOCGIWGENIE	0x8B31		/* get generic IE */
+
+/* WPA : IEEE 802.11 MLME requests */
+#define SIOCSIWMLME	0x8B16		/* request MLME operation; uses
+					 * struct iw_mlme */
+/* WPA : Authentication mode parameters */
+#define SIOCSIWAUTH	0x8B32		/* set authentication mode params */
+#define SIOCGIWAUTH	0x8B33		/* get authentication mode params */
+
+/* WPA : Extended version of encoding configuration */
+#define SIOCSIWENCODEEXT 0x8B34		/* set encoding token & mode */
+#define SIOCGIWENCODEEXT 0x8B35		/* get encoding token & mode */
+
+/* WPA2 : PMKSA cache management */
+#define SIOCSIWPMKSA	0x8B36		/* PMKSA cache operation */
+
+/* -------------------- DEV PRIVATE IOCTL LIST -------------------- */
+
+/* These 32 ioctl are wireless device private, for 16 commands.
+ * Each driver is free to use them for whatever purpose it chooses,
+ * however the driver *must* export the description of those ioctls
+ * with SIOCGIWPRIV and *must* use arguments as defined below.
+ * If you don't follow those rules, DaveM is going to hate you (reason :
+ * it make mixed 32/64bit operation impossible).
+ */
+#define SIOCIWFIRSTPRIV	0x8BE0
+#define SIOCIWLASTPRIV	0x8BFF
+/* Previously, we were using SIOCDEVPRIVATE, but we now have our
+ * separate range because of collisions with other tools such as
+ * 'mii-tool'.
+ * We now have 32 commands, so a bit more space ;-).
+ * Also, all 'odd' commands are only usable by root and don't return the
+ * content of ifr/iwr to user (but you are not obliged to use the set/get
+ * convention, just use every other two command). More details in iwpriv.c.
+ * And I repeat : you are not forced to use them with iwpriv, but you
+ * must be compliant with it.
+ */
+
+/* ------------------------- IOCTL STUFF ------------------------- */
+
+/* The first and the last (range) */
+#define SIOCIWFIRST	0x8B00
+#define SIOCIWLAST	SIOCIWLASTPRIV		/* 0x8BFF */
+#define IW_IOCTL_IDX(cmd)	((cmd) - SIOCIWFIRST)
+
+/* Even : get (world access), odd : set (root access) */
+#define IW_IS_SET(cmd)	(!((cmd) & 0x1))
+#define IW_IS_GET(cmd)	((cmd) & 0x1)
+
+/* ----------------------- WIRELESS EVENTS ----------------------- */
+/* Those are *NOT* ioctls, do not issue request on them !!! */
+/* Most events use the same identifier as ioctl requests */
+
+#define IWEVTXDROP	0x8C00		/* Packet dropped to excessive retry */
+#define IWEVQUAL	0x8C01		/* Quality part of statistics (scan) */
+#define IWEVCUSTOM	0x8C02		/* Driver specific ascii string */
+#define IWEVREGISTERED	0x8C03		/* Discovered a new node (AP mode) */
+#define IWEVEXPIRED	0x8C04		/* Expired a node (AP mode) */
+#define IWEVGENIE	0x8C05		/* Generic IE (WPA, RSN, WMM, ..)
+					 * (scan results); This includes id and
+					 * length fields. One IWEVGENIE may
+					 * contain more than one IE. Scan
+					 * results may contain one or more
+					 * IWEVGENIE events. */
+#define IWEVMICHAELMICFAILURE 0x8C06	/* Michael MIC failure
+					 * (struct iw_michaelmicfailure)
+					 */
+#define IWEVASSOCREQIE	0x8C07		/* IEs used in (Re)Association Request.
+					 * The data includes id and length
+					 * fields and may contain more than one
+					 * IE. This event is required in
+					 * Managed mode if the driver
+					 * generates its own WPA/RSN IE. This
+					 * should be sent just before
+					 * IWEVREGISTERED event for the
+					 * association. */
+#define IWEVASSOCRESPIE	0x8C08		/* IEs used in (Re)Association
+					 * Response. The data includes id and
+					 * length fields and may contain more
+					 * than one IE. This may be sent
+					 * between IWEVASSOCREQIE and
+					 * IWEVREGISTERED events for the
+					 * association. */
+#define IWEVPMKIDCAND	0x8C09		/* PMKID candidate for RSN
+					 * pre-authentication
+					 * (struct iw_pmkid_cand) */
+
+#define IWEVFIRST	0x8C00
+#define IW_EVENT_IDX(cmd)	((cmd) - IWEVFIRST)
+
+/* ------------------------- PRIVATE INFO ------------------------- */
+/*
+ * The following is used with SIOCGIWPRIV. It allow a driver to define
+ * the interface (name, type of data) for its private ioctl.
+ * Privates ioctl are SIOCIWFIRSTPRIV -> SIOCIWLASTPRIV
+ */
+
+#define IW_PRIV_TYPE_MASK	0x7000	/* Type of arguments */
+#define IW_PRIV_TYPE_NONE	0x0000
+#define IW_PRIV_TYPE_BYTE	0x1000	/* Char as number */
+#define IW_PRIV_TYPE_CHAR	0x2000	/* Char as character */
+#define IW_PRIV_TYPE_INT	0x4000	/* 32 bits int */
+#define IW_PRIV_TYPE_FLOAT	0x5000	/* struct iw_freq */
+#define IW_PRIV_TYPE_ADDR	0x6000	/* struct sockaddr */
+
+#define IW_PRIV_SIZE_FIXED	0x0800	/* Variable or fixed number of args */
+
+#define IW_PRIV_SIZE_MASK	0x07FF	/* Max number of those args */
+
+/*
+ * Note : if the number of args is fixed and the size < 16 octets,
+ * instead of passing a pointer we will put args in the iwreq struct...
+ */
+
+/* ----------------------- OTHER CONSTANTS ----------------------- */
+
+/* Maximum frequencies in the range struct */
+#define IW_MAX_FREQUENCIES	32
+/* Note : if you have something like 80 frequencies,
+ * don't increase this constant and don't fill the frequency list.
+ * The user will be able to set by channel anyway... */
+
+/* Maximum bit rates in the range struct */
+#define IW_MAX_BITRATES		32
+
+/* Maximum tx powers in the range struct */
+#define IW_MAX_TXPOWER		8
+/* Note : if you more than 8 TXPowers, just set the max and min or
+ * a few of them in the struct iw_range. */
+
+/* Maximum of address that you may set with SPY */
+#define IW_MAX_SPY		8
+
+/* Maximum of address that you may get in the
+   list of access points in range */
+#define IW_MAX_AP		64
+
+/* Maximum size of the ESSID and NICKN strings */
+#define IW_ESSID_MAX_SIZE	32
+
+/* Modes of operation */
+#define IW_MODE_AUTO	0	/* Let the driver decides */
+#define IW_MODE_ADHOC	1	/* Single cell network */
+#define IW_MODE_INFRA	2	/* Multi cell network, roaming, ... */
+#define IW_MODE_MASTER	3	/* Synchronisation master or Access Point */
+#define IW_MODE_REPEAT	4	/* Wireless Repeater (forwarder) */
+#define IW_MODE_SECOND	5	/* Secondary master/repeater (backup) */
+#define IW_MODE_MONITOR	6	/* Passive monitor (listen only) */
+
+/* Statistics flags (bitmask in updated) */
+#define IW_QUAL_QUAL_UPDATED	0x01	/* Value was updated since last read */
+#define IW_QUAL_LEVEL_UPDATED	0x02
+#define IW_QUAL_NOISE_UPDATED	0x04
+#define IW_QUAL_ALL_UPDATED	0x07
+#define IW_QUAL_DBM		0x08	/* Level + Noise are dBm */
+#define IW_QUAL_QUAL_INVALID	0x10	/* Driver doesn't provide value */
+#define IW_QUAL_LEVEL_INVALID	0x20
+#define IW_QUAL_NOISE_INVALID	0x40
+#define IW_QUAL_ALL_INVALID	0x70
+
+/* Frequency flags */
+#define IW_FREQ_AUTO		0x00	/* Let the driver decides */
+#define IW_FREQ_FIXED		0x01	/* Force a specific value */
+
+/* Maximum number of size of encoding token available
+ * they are listed in the range structure */
+#define IW_MAX_ENCODING_SIZES	8
+
+/* Maximum size of the encoding token in bytes */
+#define IW_ENCODING_TOKEN_MAX	64	/* 512 bits (for now) */
+
+/* Flags for encoding (along with the token) */
+#define IW_ENCODE_INDEX		0x00FF	/* Token index (if needed) */
+#define IW_ENCODE_FLAGS		0xFF00	/* Flags defined below */
+#define IW_ENCODE_MODE		0xF000	/* Modes defined below */
+#define IW_ENCODE_DISABLED	0x8000	/* Encoding disabled */
+#define IW_ENCODE_ENABLED	0x0000	/* Encoding enabled */
+#define IW_ENCODE_RESTRICTED	0x4000	/* Refuse non-encoded packets */
+#define IW_ENCODE_OPEN		0x2000	/* Accept non-encoded packets */
+#define IW_ENCODE_NOKEY		0x0800  /* Key is write only, so not present */
+#define IW_ENCODE_TEMP		0x0400  /* Temporary key */
+
+/* Power management flags available (along with the value, if any) */
+#define IW_POWER_ON		0x0000	/* No details... */
+#define IW_POWER_TYPE		0xF000	/* Type of parameter */
+#define IW_POWER_PERIOD		0x1000	/* Value is a period/duration of  */
+#define IW_POWER_TIMEOUT	0x2000	/* Value is a timeout (to go asleep) */
+#define IW_POWER_MODE		0x0F00	/* Power Management mode */
+#define IW_POWER_UNICAST_R	0x0100	/* Receive only unicast messages */
+#define IW_POWER_MULTICAST_R	0x0200	/* Receive only multicast messages */
+#define IW_POWER_ALL_R		0x0300	/* Receive all messages though PM */
+#define IW_POWER_FORCE_S	0x0400	/* Force PM procedure for sending unicast */
+#define IW_POWER_REPEATER	0x0800	/* Repeat broadcast messages in PM period */
+#define IW_POWER_MODIFIER	0x000F	/* Modify a parameter */
+#define IW_POWER_MIN		0x0001	/* Value is a minimum  */
+#define IW_POWER_MAX		0x0002	/* Value is a maximum */
+#define IW_POWER_RELATIVE	0x0004	/* Value is not in seconds/ms/us */
+
+/* Transmit Power flags available */
+#define IW_TXPOW_TYPE		0x00FF	/* Type of value */
+#define IW_TXPOW_DBM		0x0000	/* Value is in dBm */
+#define IW_TXPOW_MWATT		0x0001	/* Value is in mW */
+#define IW_TXPOW_RELATIVE	0x0002	/* Value is in arbitrary units */
+#define IW_TXPOW_RANGE		0x1000	/* Range of value between min/max */
+
+/* Retry limits and lifetime flags available */
+#define IW_RETRY_ON		0x0000	/* No details... */
+#define IW_RETRY_TYPE		0xF000	/* Type of parameter */
+#define IW_RETRY_LIMIT		0x1000	/* Maximum number of retries*/
+#define IW_RETRY_LIFETIME	0x2000	/* Maximum duration of retries in us */
+#define IW_RETRY_MODIFIER	0x000F	/* Modify a parameter */
+#define IW_RETRY_MIN		0x0001	/* Value is a minimum  */
+#define IW_RETRY_MAX		0x0002	/* Value is a maximum */
+#define IW_RETRY_RELATIVE	0x0004	/* Value is not in seconds/ms/us */
+
+/* Scanning request flags */
+#define IW_SCAN_DEFAULT		0x0000	/* Default scan of the driver */
+#define IW_SCAN_ALL_ESSID	0x0001	/* Scan all ESSIDs */
+#define IW_SCAN_THIS_ESSID	0x0002	/* Scan only this ESSID */
+#define IW_SCAN_ALL_FREQ	0x0004	/* Scan all Frequencies */
+#define IW_SCAN_THIS_FREQ	0x0008	/* Scan only this Frequency */
+#define IW_SCAN_ALL_MODE	0x0010	/* Scan all Modes */
+#define IW_SCAN_THIS_MODE	0x0020	/* Scan only this Mode */
+#define IW_SCAN_ALL_RATE	0x0040	/* Scan all Bit-Rates */
+#define IW_SCAN_THIS_RATE	0x0080	/* Scan only this Bit-Rate */
+/* struct iw_scan_req scan_type */
+#define IW_SCAN_TYPE_ACTIVE 0
+#define IW_SCAN_TYPE_PASSIVE 1
+/* Maximum size of returned data */
+#define IW_SCAN_MAX_DATA	16384	/* In bytes */
+
+/* Max number of char in custom event - use multiple of them if needed */
+#define IW_CUSTOM_MAX		256	/* In bytes */
+
+/* Generic information element */
+#define IW_GENERIC_IE_MAX	1024
+
+/* MLME requests (SIOCSIWMLME / struct iw_mlme) */
+#define IW_MLME_DEAUTH		0
+#define IW_MLME_DISASSOC	1
+
+/* SIOCSIWAUTH/SIOCGIWAUTH struct iw_param flags */
+#define IW_AUTH_INDEX		0x0FFF
+#define IW_AUTH_FLAGS		0xF000
+/* SIOCSIWAUTH/SIOCGIWAUTH parameters (0 .. 4095)
+ * (IW_AUTH_INDEX mask in struct iw_param flags; this is the index of the
+ * parameter that is being set/get to; value will be read/written to
+ * struct iw_param value field) */
+#define IW_AUTH_WPA_VERSION		0
+#define IW_AUTH_CIPHER_PAIRWISE		1
+#define IW_AUTH_CIPHER_GROUP		2
+#define IW_AUTH_KEY_MGMT		3
+#define IW_AUTH_TKIP_COUNTERMEASURES	4
+#define IW_AUTH_DROP_UNENCRYPTED	5
+#define IW_AUTH_80211_AUTH_ALG		6
+#define IW_AUTH_WPA_ENABLED		7
+#define IW_AUTH_RX_UNENCRYPTED_EAPOL	8
+#define IW_AUTH_ROAMING_CONTROL		9
+#define IW_AUTH_PRIVACY_INVOKED		10
+
+/* IW_AUTH_WPA_VERSION values (bit field) */
+#define IW_AUTH_WPA_VERSION_DISABLED	0x00000001
+#define IW_AUTH_WPA_VERSION_WPA		0x00000002
+#define IW_AUTH_WPA_VERSION_WPA2	0x00000004
+
+/* IW_AUTH_PAIRWISE_CIPHER and IW_AUTH_GROUP_CIPHER values (bit field) */
+#define IW_AUTH_CIPHER_NONE	0x00000001
+#define IW_AUTH_CIPHER_WEP40	0x00000002
+#define IW_AUTH_CIPHER_TKIP	0x00000004
+#define IW_AUTH_CIPHER_CCMP	0x00000008
+#define IW_AUTH_CIPHER_WEP104	0x00000010
+
+/* IW_AUTH_KEY_MGMT values (bit field) */
+#define IW_AUTH_KEY_MGMT_802_1X	1
+#define IW_AUTH_KEY_MGMT_PSK	2
+
+/* IW_AUTH_80211_AUTH_ALG values (bit field) */
+#define IW_AUTH_ALG_OPEN_SYSTEM	0x00000001
+#define IW_AUTH_ALG_SHARED_KEY	0x00000002
+#define IW_AUTH_ALG_LEAP	0x00000004
+
+/* IW_AUTH_ROAMING_CONTROL values */
+#define IW_AUTH_ROAMING_ENABLE	0	/* driver/firmware based roaming */
+#define IW_AUTH_ROAMING_DISABLE	1	/* user space program used for roaming
+					 * control */
+
+/* SIOCSIWENCODEEXT definitions */
+#define IW_ENCODE_SEQ_MAX_SIZE	8
+/* struct iw_encode_ext ->alg */
+#define IW_ENCODE_ALG_NONE	0
+#define IW_ENCODE_ALG_WEP	1
+#define IW_ENCODE_ALG_TKIP	2
+#define IW_ENCODE_ALG_CCMP	3
+/* struct iw_encode_ext ->ext_flags */
+#define IW_ENCODE_EXT_TX_SEQ_VALID	0x00000001
+#define IW_ENCODE_EXT_RX_SEQ_VALID	0x00000002
+#define IW_ENCODE_EXT_GROUP_KEY		0x00000004
+#define IW_ENCODE_EXT_SET_TX_KEY	0x00000008
+
+/* IWEVMICHAELMICFAILURE : struct iw_michaelmicfailure ->flags */
+#define IW_MICFAILURE_KEY_ID	0x00000003 /* Key ID 0..3 */
+#define IW_MICFAILURE_GROUP	0x00000004
+#define IW_MICFAILURE_PAIRWISE	0x00000008
+#define IW_MICFAILURE_STAKEY	0x00000010
+#define IW_MICFAILURE_COUNT	0x00000060 /* 1 or 2 (0 = count not supported)
+					    */
+
+/* Bit field values for enc_capa in struct iw_range */
+#define IW_ENC_CAPA_WPA		0x00000001
+#define IW_ENC_CAPA_WPA2	0x00000002
+#define IW_ENC_CAPA_CIPHER_TKIP	0x00000004
+#define IW_ENC_CAPA_CIPHER_CCMP	0x00000008
+
+/* Event capability macros - in (struct iw_range *)->event_capa
+ * Because we have more than 32 possible events, we use an array of
+ * 32 bit bitmasks. Note : 32 bits = 0x20 = 2^5. */
+#define IW_EVENT_CAPA_BASE(cmd)		((cmd >= SIOCIWFIRSTPRIV) ? \
+					 (cmd - SIOCIWFIRSTPRIV + 0x60) : \
+					 (cmd - SIOCSIWCOMMIT))
+#define IW_EVENT_CAPA_INDEX(cmd)	(IW_EVENT_CAPA_BASE(cmd) >> 5)
+#define IW_EVENT_CAPA_MASK(cmd)		(1 << (IW_EVENT_CAPA_BASE(cmd) & 0x1F))
+/* Event capability constants - event autogenerated by the kernel
+ * This list is valid for most 802.11 devices, customise as needed... */
+#define IW_EVENT_CAPA_K_0	(IW_EVENT_CAPA_MASK(0x8B04) | \
+				 IW_EVENT_CAPA_MASK(0x8B06) | \
+				 IW_EVENT_CAPA_MASK(0x8B1A))
+#define IW_EVENT_CAPA_K_1	(IW_EVENT_CAPA_MASK(0x8B2A))
+/* "Easy" macro to set events in iw_range (less efficient) */
+#define IW_EVENT_CAPA_SET(event_capa, cmd) (event_capa[IW_EVENT_CAPA_INDEX(cmd)] |= IW_EVENT_CAPA_MASK(cmd))
+#define IW_EVENT_CAPA_SET_KERNEL(event_capa) {event_capa[0] |= IW_EVENT_CAPA_K_0; event_capa[1] |= IW_EVENT_CAPA_K_1; }
+
+
+/****************************** TYPES ******************************/
+
+/* --------------------------- SUBTYPES --------------------------- */
+/*
+ *	Generic format for most parameters that fit in an int
+ */
+struct	iw_param
+{
+  __s32		value;		/* The value of the parameter itself */
+  __u8		fixed;		/* Hardware should not use auto select */
+  __u8		disabled;	/* Disable the feature */
+  __u16		flags;		/* Various specifc flags (if any) */
+};
+
+/*
+ *	For all data larger than 16 octets, we need to use a
+ *	pointer to memory allocated in user space.
+ */
+struct	iw_point
+{
+  void __user	*pointer;	/* Pointer to the data  (in user space) */
+  __u16		length;		/* number of fields or size in bytes */
+  __u16		flags;		/* Optional params */
+};
+
+/*
+ *	A frequency
+ *	For numbers lower than 10^9, we encode the number in 'm' and
+ *	set 'e' to 0
+ *	For number greater than 10^9, we divide it by the lowest power
+ *	of 10 to get 'm' lower than 10^9, with 'm'= f / (10^'e')...
+ *	The power of 10 is in 'e', the result of the division is in 'm'.
+ */
+struct	iw_freq
+{
+	__s32		m;		/* Mantissa */
+	__s16		e;		/* Exponent */
+	__u8		i;		/* List index (when in range struct) */
+	__u8		flags;		/* Flags (fixed/auto) */
+};
+
+/*
+ *	Quality of the link
+ */
+struct	iw_quality
+{
+	__u8		qual;		/* link quality (%retries, SNR,
+					   %missed beacons or better...) */
+	__u8		level;		/* signal level (dBm) */
+	__u8		noise;		/* noise level (dBm) */
+	__u8		updated;	/* Flags to know if updated */
+};
+
+/*
+ *	Packet discarded in the wireless adapter due to
+ *	"wireless" specific problems...
+ *	Note : the list of counter and statistics in net_device_stats
+ *	is already pretty exhaustive, and you should use that first.
+ *	This is only additional stats...
+ */
+struct	iw_discarded
+{
+	__u32		nwid;		/* Rx : Wrong nwid/essid */
+	__u32		code;		/* Rx : Unable to code/decode (WEP) */
+	__u32		fragment;	/* Rx : Can't perform MAC reassembly */
+	__u32		retries;	/* Tx : Max MAC retries num reached */
+	__u32		misc;		/* Others cases */
+};
+
+/*
+ *	Packet/Time period missed in the wireless adapter due to
+ *	"wireless" specific problems...
+ */
+struct	iw_missed
+{
+	__u32		beacon;		/* Missed beacons/superframe */
+};
+
+/*
+ *	Quality range (for spy threshold)
+ */
+struct	iw_thrspy
+{
+	struct sockaddr		addr;		/* Source address (hw/mac) */
+	struct iw_quality	qual;		/* Quality of the link */
+	struct iw_quality	low;		/* Low threshold */
+	struct iw_quality	high;		/* High threshold */
+};
+
+/*
+ *	Optional data for scan request
+ *
+ *	Note: these optional parameters are controlling parameters for the
+ *	scanning behavior, these do not apply to getting scan results
+ *	(SIOCGIWSCAN). Drivers are expected to keep a local BSS table and
+ *	provide a merged results with all BSSes even if the previous scan
+ *	request limited scanning to a subset, e.g., by specifying an SSID.
+ *	Especially, scan results are required to include an entry for the
+ *	current BSS if the driver is in Managed mode and associated with an AP.
+ */
+struct	iw_scan_req
+{
+	__u8		scan_type; /* IW_SCAN_TYPE_{ACTIVE,PASSIVE} */
+	__u8		essid_len;
+	__u8		num_channels; /* num entries in channel_list;
+				       * 0 = scan all allowed channels */
+	__u8		flags; /* reserved as padding; use zero, this may
+				* be used in the future for adding flags
+				* to request different scan behavior */
+	struct sockaddr	bssid; /* ff:ff:ff:ff:ff:ff for broadcast BSSID or
+				* individual address of a specific BSS */
+
+	/*
+	 * Use this ESSID if IW_SCAN_THIS_ESSID flag is used instead of using
+	 * the current ESSID. This allows scan requests for specific ESSID
+	 * without having to change the current ESSID and potentially breaking
+	 * the current association.
+	 */
+	__u8		essid[IW_ESSID_MAX_SIZE];
+
+	/*
+	 * Optional parameters for changing the default scanning behavior.
+	 * These are based on the MLME-SCAN.request from IEEE Std 802.11.
+	 * TU is 1.024 ms. If these are set to 0, driver is expected to use
+	 * reasonable default values. min_channel_time defines the time that
+	 * will be used to wait for the first reply on each channel. If no
+	 * replies are received, next channel will be scanned after this. If
+	 * replies are received, total time waited on the channel is defined by
+	 * max_channel_time.
+	 */
+	__u32		min_channel_time; /* in TU */
+	__u32		max_channel_time; /* in TU */
+
+	struct iw_freq	channel_list[IW_MAX_FREQUENCIES];
+};
+
+/* ------------------------- WPA SUPPORT ------------------------- */
+
+/*
+ *	Extended data structure for get/set encoding (this is used with
+ *	SIOCSIWENCODEEXT/SIOCGIWENCODEEXT. struct iw_point and IW_ENCODE_*
+ *	flags are used in the same way as with SIOCSIWENCODE/SIOCGIWENCODE and
+ *	only the data contents changes (key data -> this structure, including
+ *	key data).
+ *
+ *	If the new key is the first group key, it will be set as the default
+ *	TX key. Otherwise, default TX key index is only changed if
+ *	IW_ENCODE_EXT_SET_TX_KEY flag is set.
+ *
+ *	Key will be changed with SIOCSIWENCODEEXT in all cases except for
+ *	special "change TX key index" operation which is indicated by setting
+ *	key_len = 0 and ext_flags |= IW_ENCODE_EXT_SET_TX_KEY.
+ *
+ *	tx_seq/rx_seq are only used when respective
+ *	IW_ENCODE_EXT_{TX,RX}_SEQ_VALID flag is set in ext_flags. Normal
+ *	TKIP/CCMP operation is to set RX seq with SIOCSIWENCODEEXT and start
+ *	TX seq from zero whenever key is changed. SIOCGIWENCODEEXT is normally
+ *	used only by an Authenticator (AP or an IBSS station) to get the
+ *	current TX sequence number. Using TX_SEQ_VALID for SIOCSIWENCODEEXT and
+ *	RX_SEQ_VALID for SIOCGIWENCODEEXT are optional, but can be useful for
+ *	debugging/testing.
+ */
+struct	iw_encode_ext
+{
+	__u32		ext_flags; /* IW_ENCODE_EXT_* */
+	__u8		tx_seq[IW_ENCODE_SEQ_MAX_SIZE]; /* LSB first */
+	__u8		rx_seq[IW_ENCODE_SEQ_MAX_SIZE]; /* LSB first */
+	struct sockaddr	addr; /* ff:ff:ff:ff:ff:ff for broadcast/multicast
+			       * (group) keys or unicast address for
+			       * individual keys */
+	__u16		alg; /* IW_ENCODE_ALG_* */
+	__u16		key_len;
+	__u8		key[0];
+};
+
+/* SIOCSIWMLME data */
+struct	iw_mlme
+{
+	__u16		cmd; /* IW_MLME_* */
+	__u16		reason_code;
+	struct sockaddr	addr;
+};
+
+/* SIOCSIWPMKSA data */
+#define IW_PMKSA_ADD		1
+#define IW_PMKSA_REMOVE		2
+#define IW_PMKSA_FLUSH		3
+
+#define IW_PMKID_LEN	16
+
+struct	iw_pmksa
+{
+	__u32		cmd; /* IW_PMKSA_* */
+	struct sockaddr	bssid;
+	__u8		pmkid[IW_PMKID_LEN];
+};
+
+/* IWEVMICHAELMICFAILURE data */
+struct	iw_michaelmicfailure
+{
+	__u32		flags;
+	struct sockaddr	src_addr;
+	__u8		tsc[IW_ENCODE_SEQ_MAX_SIZE]; /* LSB first */
+};
+
+/* IWEVPMKIDCAND data */
+#define IW_PMKID_CAND_PREAUTH	0x00000001 /* RNS pre-authentication enabled */
+struct	iw_pmkid_cand
+{
+	__u32		flags; /* IW_PMKID_CAND_* */
+	__u32		index; /* the smaller the index, the higher the
+				* priority */
+	struct sockaddr	bssid;
+};
+
+/* ------------------------ WIRELESS STATS ------------------------ */
+/*
+ * Wireless statistics (used for /proc/net/wireless)
+ */
+struct	iw_statistics
+{
+	__u16		status;		/* Status
+					 * - device dependent for now */
+
+	struct iw_quality	qual;		/* Quality of the link
+						 * (instant/mean/max) */
+	struct iw_discarded	discard;	/* Packet discarded counts */
+	struct iw_missed	miss;		/* Packet missed counts */
+};
+
+/* ------------------------ IOCTL REQUEST ------------------------ */
+/*
+ * This structure defines the payload of an ioctl, and is used 
+ * below.
+ *
+ * Note that this structure should fit on the memory footprint
+ * of iwreq (which is the same as ifreq), which mean a max size of
+ * 16 octets = 128 bits. Warning, pointers might be 64 bits wide...
+ * You should check this when increasing the structures defined
+ * above in this file...
+ */
+union	iwreq_data
+{
+	/* Config - generic */
+	char		name[IFNAMSIZ];
+	/* Name : used to verify the presence of  wireless extensions.
+	 * Name of the protocol/provider... */
+
+	struct iw_point	essid;		/* Extended network name */
+	struct iw_param	nwid;		/* network id (or domain - the cell) */
+	struct iw_freq	freq;		/* frequency or channel :
+					 * 0-1000 = channel
+					 * > 1000 = frequency in Hz */
+
+	struct iw_param	sens;		/* signal level threshold */
+	struct iw_param	bitrate;	/* default bit rate */
+	struct iw_param	txpower;	/* default transmit power */
+	struct iw_param	rts;		/* RTS threshold threshold */
+	struct iw_param	frag;		/* Fragmentation threshold */
+	__u32		mode;		/* Operation mode */
+	struct iw_param	retry;		/* Retry limits & lifetime */
+
+	struct iw_point	encoding;	/* Encoding stuff : tokens */
+	struct iw_param	power;		/* PM duration/timeout */
+	struct iw_quality qual;		/* Quality part of statistics */
+
+	struct sockaddr	ap_addr;	/* Access point address */
+	struct sockaddr	addr;		/* Destination address (hw/mac) */
+
+	struct iw_param	param;		/* Other small parameters */
+	struct iw_point	data;		/* Other large parameters */
+};
+
+/*
+ * The structure to exchange data for ioctl.
+ * This structure is the same as 'struct ifreq', but (re)defined for
+ * convenience...
+ * Do I need to remind you about structure size (32 octets) ?
+ */
+struct	iwreq 
+{
+	union
+	{
+		char	ifrn_name[IFNAMSIZ];	/* if name, e.g. "eth0" */
+	} ifr_ifrn;
+
+	/* Data part (defined just above) */
+	union	iwreq_data	u;
+};
+
+/* -------------------------- IOCTL DATA -------------------------- */
+/*
+ *	For those ioctl which want to exchange mode data that what could
+ *	fit in the above structure...
+ */
+
+/*
+ *	Range of parameters
+ */
+
+struct	iw_range
+{
+	/* Informative stuff (to choose between different interface) */
+	__u32		throughput;	/* To give an idea... */
+	/* In theory this value should be the maximum benchmarked
+	 * TCP/IP throughput, because with most of these devices the
+	 * bit rate is meaningless (overhead an co) to estimate how
+	 * fast the connection will go and pick the fastest one.
+	 * I suggest people to play with Netperf or any benchmark...
+	 */
+
+	/* NWID (or domain id) */
+	__u32		min_nwid;	/* Minimal NWID we are able to set */
+	__u32		max_nwid;	/* Maximal NWID we are able to set */
+
+	/* Old Frequency (backward compat - moved lower ) */
+	__u16		old_num_channels;
+	__u8		old_num_frequency;
+
+	/* Wireless event capability bitmasks */
+	__u32		event_capa[6];
+
+	/* signal level threshold range */
+	__s32		sensitivity;
+
+	/* Quality of link & SNR stuff */
+	/* Quality range (link, level, noise)
+	 * If the quality is absolute, it will be in the range [0 ; max_qual],
+	 * if the quality is dBm, it will be in the range [max_qual ; 0].
+	 * Don't forget that we use 8 bit arithmetics... */
+	struct iw_quality	max_qual;	/* Quality of the link */
+	/* This should contain the average/typical values of the quality
+	 * indicator. This should be the threshold between a "good" and
+	 * a "bad" link (example : monitor going from green to orange).
+	 * Currently, user space apps like quality monitors don't have any
+	 * way to calibrate the measurement. With this, they can split
+	 * the range between 0 and max_qual in different quality level
+	 * (using a geometric subdivision centered on the average).
+	 * I expect that people doing the user space apps will feedback
+	 * us on which value we need to put in each driver... */
+	struct iw_quality	avg_qual;	/* Quality of the link */
+
+	/* Rates */
+	__u8		num_bitrates;	/* Number of entries in the list */
+	__s32		bitrate[IW_MAX_BITRATES];	/* list, in bps */
+
+	/* RTS threshold */
+	__s32		min_rts;	/* Minimal RTS threshold */
+	__s32		max_rts;	/* Maximal RTS threshold */
+
+	/* Frag threshold */
+	__s32		min_frag;	/* Minimal frag threshold */
+	__s32		max_frag;	/* Maximal frag threshold */
+
+	/* Power Management duration & timeout */
+	__s32		min_pmp;	/* Minimal PM period */
+	__s32		max_pmp;	/* Maximal PM period */
+	__s32		min_pmt;	/* Minimal PM timeout */
+	__s32		max_pmt;	/* Maximal PM timeout */
+	__u16		pmp_flags;	/* How to decode max/min PM period */
+	__u16		pmt_flags;	/* How to decode max/min PM timeout */
+	__u16		pm_capa;	/* What PM options are supported */
+
+	/* Encoder stuff */
+	__u16	encoding_size[IW_MAX_ENCODING_SIZES];	/* Different token sizes */
+	__u8	num_encoding_sizes;	/* Number of entry in the list */
+	__u8	max_encoding_tokens;	/* Max number of tokens */
+	/* For drivers that need a "login/passwd" form */
+	__u8	encoding_login_index;	/* token index for login token */
+
+	/* Transmit power */
+	__u16		txpower_capa;	/* What options are supported */
+	__u8		num_txpower;	/* Number of entries in the list */
+	__s32		txpower[IW_MAX_TXPOWER];	/* list, in bps */
+
+	/* Wireless Extension version info */
+	__u8		we_version_compiled;	/* Must be WIRELESS_EXT */
+	__u8		we_version_source;	/* Last update of source */
+
+	/* Retry limits and lifetime */
+	__u16		retry_capa;	/* What retry options are supported */
+	__u16		retry_flags;	/* How to decode max/min retry limit */
+	__u16		r_time_flags;	/* How to decode max/min retry life */
+	__s32		min_retry;	/* Minimal number of retries */
+	__s32		max_retry;	/* Maximal number of retries */
+	__s32		min_r_time;	/* Minimal retry lifetime */
+	__s32		max_r_time;	/* Maximal retry lifetime */
+
+	/* Frequency */
+	__u16		num_channels;	/* Number of channels [0; num - 1] */
+	__u8		num_frequency;	/* Number of entry in the list */
+	struct iw_freq	freq[IW_MAX_FREQUENCIES];	/* list */
+	/* Note : this frequency list doesn't need to fit channel numbers,
+	 * because each entry contain its channel index */
+
+	__u32		enc_capa; /* IW_ENC_CAPA_* bit field */
+};
+
+/*
+ * Private ioctl interface information
+ */
+ 
+struct	iw_priv_args
+{
+	__u32		cmd;		/* Number of the ioctl to issue */
+	__u16		set_args;	/* Type and number of args */
+	__u16		get_args;	/* Type and number of args */
+	char		name[IFNAMSIZ];	/* Name of the extension */
+};
+
+/* ----------------------- WIRELESS EVENTS ----------------------- */
+/*
+ * Wireless events are carried through the rtnetlink socket to user
+ * space. They are encapsulated in the IFLA_WIRELESS field of
+ * a RTM_NEWLINK message.
+ */
+
+/*
+ * A Wireless Event. Contains basically the same data as the ioctl...
+ */
+struct iw_event
+{
+	__u16		len;			/* Real lenght of this stuff */
+	__u16		cmd;			/* Wireless IOCTL */
+	union iwreq_data	u;		/* IOCTL fixed payload */
+};
+
+/* Size of the Event prefix (including padding and alignement junk) */
+#define IW_EV_LCP_LEN	(sizeof(struct iw_event) - sizeof(union iwreq_data))
+/* Size of the various events */
+#define IW_EV_CHAR_LEN	(IW_EV_LCP_LEN + IFNAMSIZ)
+#define IW_EV_UINT_LEN	(IW_EV_LCP_LEN + sizeof(__u32))
+#define IW_EV_FREQ_LEN	(IW_EV_LCP_LEN + sizeof(struct iw_freq))
+#define IW_EV_PARAM_LEN	(IW_EV_LCP_LEN + sizeof(struct iw_param))
+#define IW_EV_ADDR_LEN	(IW_EV_LCP_LEN + sizeof(struct sockaddr))
+#define IW_EV_QUAL_LEN	(IW_EV_LCP_LEN + sizeof(struct iw_quality))
+
+/* iw_point events are special. First, the payload (extra data) come at
+ * the end of the event, so they are bigger than IW_EV_POINT_LEN. Second,
+ * we omit the pointer, so start at an offset. */
+#define IW_EV_POINT_OFF (((char *) &(((struct iw_point *) NULL)->length)) - \
+			  (char *) NULL)
+#define IW_EV_POINT_LEN	(IW_EV_LCP_LEN + sizeof(struct iw_point) - \
+			 IW_EV_POINT_OFF)
+
+#endif	/* _LINUX_WIRELESS_H */
diff --git a/wireless.21.h b/wireless.21.h
new file mode 100644
index 0000000..7f03840
--- /dev/null
+++ b/wireless.21.h
@@ -0,0 +1,1120 @@
+/*
+ * This file define a set of standard wireless extensions
+ *
+ * Version :	21	14.3.06
+ *
+ * Authors :	Jean Tourrilhes - HPL - <jt@hpl.hp.com>
+ * Copyright (c) 1997-2005 Jean Tourrilhes, All Rights Reserved.
+ */
+
+#ifndef _LINUX_WIRELESS_H
+#define _LINUX_WIRELESS_H
+
+/************************** DOCUMENTATION **************************/
+/*
+ * Initial APIs (1996 -> onward) :
+ * -----------------------------
+ * Basically, the wireless extensions are for now a set of standard ioctl
+ * call + /proc/net/wireless
+ *
+ * The entry /proc/net/wireless give statistics and information on the
+ * driver.
+ * This is better than having each driver having its entry because
+ * its centralised and we may remove the driver module safely.
+ *
+ * Ioctl are used to configure the driver and issue commands.  This is
+ * better than command line options of insmod because we may want to
+ * change dynamically (while the driver is running) some parameters.
+ *
+ * The ioctl mechanimsm are copied from standard devices ioctl.
+ * We have the list of command plus a structure descibing the
+ * data exchanged...
+ * Note that to add these ioctl, I was obliged to modify :
+ *	# net/core/dev.c (two place + add include)
+ *	# net/ipv4/af_inet.c (one place + add include)
+ *
+ * /proc/net/wireless is a copy of /proc/net/dev.
+ * We have a structure for data passed from the driver to /proc/net/wireless
+ * Too add this, I've modified :
+ *	# net/core/dev.c (two other places)
+ *	# include/linux/netdevice.h (one place)
+ *	# include/linux/proc_fs.h (one place)
+ *
+ * New driver API (2002 -> onward) :
+ * -------------------------------
+ * This file is only concerned with the user space API and common definitions.
+ * The new driver API is defined and documented in :
+ *	# include/net/iw_handler.h
+ *
+ * Note as well that /proc/net/wireless implementation has now moved in :
+ *	# net/core/wireless.c
+ *
+ * Wireless Events (2002 -> onward) :
+ * --------------------------------
+ * Events are defined at the end of this file, and implemented in :
+ *	# net/core/wireless.c
+ *
+ * Other comments :
+ * --------------
+ * Do not add here things that are redundant with other mechanisms
+ * (drivers init, ifconfig, /proc/net/dev, ...) and with are not
+ * wireless specific.
+ *
+ * These wireless extensions are not magic : each driver has to provide
+ * support for them...
+ *
+ * IMPORTANT NOTE : As everything in the kernel, this is very much a
+ * work in progress. Contact me if you have ideas of improvements...
+ */
+
+/***************************** INCLUDES *****************************/
+
+/* This header is used in user-space, therefore need to be sanitised
+ * for that purpose. Those includes are usually not compatible with glibc.
+ * To know which includes to use in user-space, check iwlib.h. */
+#ifdef __KERNEL__
+#include <linux/types.h>		/* for "caddr_t" et al		*/
+#include <linux/socket.h>		/* for "struct sockaddr" et al	*/
+#include <linux/if.h>			/* for IFNAMSIZ and co... */
+#endif	/* __KERNEL__ */
+
+/***************************** VERSION *****************************/
+/*
+ * This constant is used to know the availability of the wireless
+ * extensions and to know which version of wireless extensions it is
+ * (there is some stuff that will be added in the future...)
+ * I just plan to increment with each new version.
+ */
+#define WIRELESS_EXT	21
+
+/*
+ * Changes :
+ *
+ * V2 to V3
+ * --------
+ *	Alan Cox start some incompatibles changes. I've integrated a bit more.
+ *	- Encryption renamed to Encode to avoid US regulation problems
+ *	- Frequency changed from float to struct to avoid problems on old 386
+ *
+ * V3 to V4
+ * --------
+ *	- Add sensitivity
+ *
+ * V4 to V5
+ * --------
+ *	- Missing encoding definitions in range
+ *	- Access points stuff
+ *
+ * V5 to V6
+ * --------
+ *	- 802.11 support (ESSID ioctls)
+ *
+ * V6 to V7
+ * --------
+ *	- define IW_ESSID_MAX_SIZE and IW_MAX_AP
+ *
+ * V7 to V8
+ * --------
+ *	- Changed my e-mail address
+ *	- More 802.11 support (nickname, rate, rts, frag)
+ *	- List index in frequencies
+ *
+ * V8 to V9
+ * --------
+ *	- Support for 'mode of operation' (ad-hoc, managed...)
+ *	- Support for unicast and multicast power saving
+ *	- Change encoding to support larger tokens (>64 bits)
+ *	- Updated iw_params (disable, flags) and use it for NWID
+ *	- Extracted iw_point from iwreq for clarity
+ *
+ * V9 to V10
+ * ---------
+ *	- Add PM capability to range structure
+ *	- Add PM modifier : MAX/MIN/RELATIVE
+ *	- Add encoding option : IW_ENCODE_NOKEY
+ *	- Add TxPower ioctls (work like TxRate)
+ *
+ * V10 to V11
+ * ----------
+ *	- Add WE version in range (help backward/forward compatibility)
+ *	- Add retry ioctls (work like PM)
+ *
+ * V11 to V12
+ * ----------
+ *	- Add SIOCSIWSTATS to get /proc/net/wireless programatically
+ *	- Add DEV PRIVATE IOCTL to avoid collisions in SIOCDEVPRIVATE space
+ *	- Add new statistics (frag, retry, beacon)
+ *	- Add average quality (for user space calibration)
+ *
+ * V12 to V13
+ * ----------
+ *	- Document creation of new driver API.
+ *	- Extract union iwreq_data from struct iwreq (for new driver API).
+ *	- Rename SIOCSIWNAME as SIOCSIWCOMMIT
+ *
+ * V13 to V14
+ * ----------
+ *	- Wireless Events support : define struct iw_event
+ *	- Define additional specific event numbers
+ *	- Add "addr" and "param" fields in union iwreq_data
+ *	- AP scanning stuff (SIOCSIWSCAN and friends)
+ *
+ * V14 to V15
+ * ----------
+ *	- Add IW_PRIV_TYPE_ADDR for struct sockaddr private arg
+ *	- Make struct iw_freq signed (both m & e), add explicit padding
+ *	- Add IWEVCUSTOM for driver specific event/scanning token
+ *	- Add IW_MAX_GET_SPY for driver returning a lot of addresses
+ *	- Add IW_TXPOW_RANGE for range of Tx Powers
+ *	- Add IWEVREGISTERED & IWEVEXPIRED events for Access Points
+ *	- Add IW_MODE_MONITOR for passive monitor
+ *
+ * V15 to V16
+ * ----------
+ *	- Increase the number of bitrates in iw_range to 32 (for 802.11g)
+ *	- Increase the number of frequencies in iw_range to 32 (for 802.11b+a)
+ *	- Reshuffle struct iw_range for increases, add filler
+ *	- Increase IW_MAX_AP to 64 for driver returning a lot of addresses
+ *	- Remove IW_MAX_GET_SPY because conflict with enhanced spy support
+ *	- Add SIOCSIWTHRSPY/SIOCGIWTHRSPY and "struct iw_thrspy"
+ *	- Add IW_ENCODE_TEMP and iw_range->encoding_login_index
+ *
+ * V16 to V17
+ * ----------
+ *	- Add flags to frequency -> auto/fixed
+ *	- Document (struct iw_quality *)->updated, add new flags (INVALID)
+ *	- Wireless Event capability in struct iw_range
+ *	- Add support for relative TxPower (yick !)
+ *
+ * V17 to V18 (From Jouni Malinen <jkmaline@cc.hut.fi>)
+ * ----------
+ *	- Add support for WPA/WPA2
+ *	- Add extended encoding configuration (SIOCSIWENCODEEXT and
+ *	  SIOCGIWENCODEEXT)
+ *	- Add SIOCSIWGENIE/SIOCGIWGENIE
+ *	- Add SIOCSIWMLME
+ *	- Add SIOCSIWPMKSA
+ *	- Add struct iw_range bit field for supported encoding capabilities
+ *	- Add optional scan request parameters for SIOCSIWSCAN
+ *	- Add SIOCSIWAUTH/SIOCGIWAUTH for setting authentication and WPA
+ *	  related parameters (extensible up to 4096 parameter values)
+ *	- Add wireless events: IWEVGENIE, IWEVMICHAELMICFAILURE,
+ *	  IWEVASSOCREQIE, IWEVASSOCRESPIE, IWEVPMKIDCAND
+ *
+ * V18 to V19
+ * ----------
+ *	- Remove (struct iw_point *)->pointer from events and streams
+ *	- Remove header includes to help user space
+ *	- Increase IW_ENCODING_TOKEN_MAX from 32 to 64
+ *	- Add IW_QUAL_ALL_UPDATED and IW_QUAL_ALL_INVALID macros
+ *	- Add explicit flag to tell stats are in dBm : IW_QUAL_DBM
+ *	- Add IW_IOCTL_IDX() and IW_EVENT_IDX() macros
+ *
+ * V20 to V21
+ * ----------
+ *	- Remove (struct net_device *)->get_wireless_stats()
+ *	- Change length in ESSID and NICK to strlen() instead of strlen()+1
+ *	- Add SIOCSIWMODUL/SIOCGIWMODUL for modulation setting
+ *	- Add IW_RETRY_SHORT/IW_RETRY_LONG retry modifiers
+ *	- Add IW_POWER_SAVING power type
+ *	- Power/Retry relative values no longer * 100000
+ *	- Add bitrate flags for unicast/broadcast
+ */
+
+/**************************** CONSTANTS ****************************/
+
+/* -------------------------- IOCTL LIST -------------------------- */
+
+/* Wireless Identification */
+#define SIOCSIWCOMMIT	0x8B00		/* Commit pending changes to driver */
+#define SIOCGIWNAME	0x8B01		/* get name == wireless protocol */
+/* SIOCGIWNAME is used to verify the presence of Wireless Extensions.
+ * Common values : "IEEE 802.11-DS", "IEEE 802.11-FH", "IEEE 802.11b"...
+ * Don't put the name of your driver there, it's useless. */
+
+/* Basic operations */
+#define SIOCSIWNWID	0x8B02		/* set network id (pre-802.11) */
+#define SIOCGIWNWID	0x8B03		/* get network id (the cell) */
+#define SIOCSIWFREQ	0x8B04		/* set channel/frequency (Hz) */
+#define SIOCGIWFREQ	0x8B05		/* get channel/frequency (Hz) */
+#define SIOCSIWMODE	0x8B06		/* set operation mode */
+#define SIOCGIWMODE	0x8B07		/* get operation mode */
+#define SIOCSIWSENS	0x8B08		/* set sensitivity (dBm) */
+#define SIOCGIWSENS	0x8B09		/* get sensitivity (dBm) */
+
+/* Informative stuff */
+#define SIOCSIWRANGE	0x8B0A		/* Unused */
+#define SIOCGIWRANGE	0x8B0B		/* Get range of parameters */
+#define SIOCSIWPRIV	0x8B0C		/* Unused */
+#define SIOCGIWPRIV	0x8B0D		/* get private ioctl interface info */
+#define SIOCSIWSTATS	0x8B0E		/* Unused */
+#define SIOCGIWSTATS	0x8B0F		/* Get /proc/net/wireless stats */
+/* SIOCGIWSTATS is strictly used between user space and the kernel, and
+ * is never passed to the driver (i.e. the driver will never see it). */
+
+/* Spy support (statistics per MAC address - used for Mobile IP support) */
+#define SIOCSIWSPY	0x8B10		/* set spy addresses */
+#define SIOCGIWSPY	0x8B11		/* get spy info (quality of link) */
+#define SIOCSIWTHRSPY	0x8B12		/* set spy threshold (spy event) */
+#define SIOCGIWTHRSPY	0x8B13		/* get spy threshold */
+
+/* Access Point manipulation */
+#define SIOCSIWAP	0x8B14		/* set access point MAC addresses */
+#define SIOCGIWAP	0x8B15		/* get access point MAC addresses */
+#define SIOCGIWAPLIST	0x8B17		/* Deprecated in favor of scanning */
+#define SIOCSIWSCAN	0x8B18		/* trigger scanning (list cells) */
+#define SIOCGIWSCAN	0x8B19		/* get scanning results */
+
+/* 802.11 specific support */
+#define SIOCSIWESSID	0x8B1A		/* set ESSID (network name) */
+#define SIOCGIWESSID	0x8B1B		/* get ESSID */
+#define SIOCSIWNICKN	0x8B1C		/* set node name/nickname */
+#define SIOCGIWNICKN	0x8B1D		/* get node name/nickname */
+/* As the ESSID and NICKN are strings up to 32 bytes long, it doesn't fit
+ * within the 'iwreq' structure, so we need to use the 'data' member to
+ * point to a string in user space, like it is done for RANGE... */
+
+/* Other parameters useful in 802.11 and some other devices */
+#define SIOCSIWRATE	0x8B20		/* set default bit rate (bps) */
+#define SIOCGIWRATE	0x8B21		/* get default bit rate (bps) */
+#define SIOCSIWRTS	0x8B22		/* set RTS/CTS threshold (bytes) */
+#define SIOCGIWRTS	0x8B23		/* get RTS/CTS threshold (bytes) */
+#define SIOCSIWFRAG	0x8B24		/* set fragmentation thr (bytes) */
+#define SIOCGIWFRAG	0x8B25		/* get fragmentation thr (bytes) */
+#define SIOCSIWTXPOW	0x8B26		/* set transmit power (dBm) */
+#define SIOCGIWTXPOW	0x8B27		/* get transmit power (dBm) */
+#define SIOCSIWRETRY	0x8B28		/* set retry limits and lifetime */
+#define SIOCGIWRETRY	0x8B29		/* get retry limits and lifetime */
+
+/* Encoding stuff (scrambling, hardware security, WEP...) */
+#define SIOCSIWENCODE	0x8B2A		/* set encoding token & mode */
+#define SIOCGIWENCODE	0x8B2B		/* get encoding token & mode */
+/* Power saving stuff (power management, unicast and multicast) */
+#define SIOCSIWPOWER	0x8B2C		/* set Power Management settings */
+#define SIOCGIWPOWER	0x8B2D		/* get Power Management settings */
+/* Modulation bitmask */
+#define SIOCSIWMODUL	0x8B2E		/* set Modulations settings */
+#define SIOCGIWMODUL	0x8B2F		/* get Modulations settings */
+
+/* WPA : Generic IEEE 802.11 informatiom element (e.g., for WPA/RSN/WMM).
+ * This ioctl uses struct iw_point and data buffer that includes IE id and len
+ * fields. More than one IE may be included in the request. Setting the generic
+ * IE to empty buffer (len=0) removes the generic IE from the driver. Drivers
+ * are allowed to generate their own WPA/RSN IEs, but in these cases, drivers
+ * are required to report the used IE as a wireless event, e.g., when
+ * associating with an AP. */
+#define SIOCSIWGENIE	0x8B30		/* set generic IE */
+#define SIOCGIWGENIE	0x8B31		/* get generic IE */
+
+/* WPA : IEEE 802.11 MLME requests */
+#define SIOCSIWMLME	0x8B16		/* request MLME operation; uses
+					 * struct iw_mlme */
+/* WPA : Authentication mode parameters */
+#define SIOCSIWAUTH	0x8B32		/* set authentication mode params */
+#define SIOCGIWAUTH	0x8B33		/* get authentication mode params */
+
+/* WPA : Extended version of encoding configuration */
+#define SIOCSIWENCODEEXT 0x8B34		/* set encoding token & mode */
+#define SIOCGIWENCODEEXT 0x8B35		/* get encoding token & mode */
+
+/* WPA2 : PMKSA cache management */
+#define SIOCSIWPMKSA	0x8B36		/* PMKSA cache operation */
+
+/* -------------------- DEV PRIVATE IOCTL LIST -------------------- */
+
+/* These 32 ioctl are wireless device private, for 16 commands.
+ * Each driver is free to use them for whatever purpose it chooses,
+ * however the driver *must* export the description of those ioctls
+ * with SIOCGIWPRIV and *must* use arguments as defined below.
+ * If you don't follow those rules, DaveM is going to hate you (reason :
+ * it make mixed 32/64bit operation impossible).
+ */
+#define SIOCIWFIRSTPRIV	0x8BE0
+#define SIOCIWLASTPRIV	0x8BFF
+/* Previously, we were using SIOCDEVPRIVATE, but we now have our
+ * separate range because of collisions with other tools such as
+ * 'mii-tool'.
+ * We now have 32 commands, so a bit more space ;-).
+ * Also, all 'odd' commands are only usable by root and don't return the
+ * content of ifr/iwr to user (but you are not obliged to use the set/get
+ * convention, just use every other two command). More details in iwpriv.c.
+ * And I repeat : you are not forced to use them with iwpriv, but you
+ * must be compliant with it.
+ */
+
+/* ------------------------- IOCTL STUFF ------------------------- */
+
+/* The first and the last (range) */
+#define SIOCIWFIRST	0x8B00
+#define SIOCIWLAST	SIOCIWLASTPRIV		/* 0x8BFF */
+#define IW_IOCTL_IDX(cmd)	((cmd) - SIOCIWFIRST)
+
+/* Even : get (world access), odd : set (root access) */
+#define IW_IS_SET(cmd)	(!((cmd) & 0x1))
+#define IW_IS_GET(cmd)	((cmd) & 0x1)
+
+/* ----------------------- WIRELESS EVENTS ----------------------- */
+/* Those are *NOT* ioctls, do not issue request on them !!! */
+/* Most events use the same identifier as ioctl requests */
+
+#define IWEVTXDROP	0x8C00		/* Packet dropped to excessive retry */
+#define IWEVQUAL	0x8C01		/* Quality part of statistics (scan) */
+#define IWEVCUSTOM	0x8C02		/* Driver specific ascii string */
+#define IWEVREGISTERED	0x8C03		/* Discovered a new node (AP mode) */
+#define IWEVEXPIRED	0x8C04		/* Expired a node (AP mode) */
+#define IWEVGENIE	0x8C05		/* Generic IE (WPA, RSN, WMM, ..)
+					 * (scan results); This includes id and
+					 * length fields. One IWEVGENIE may
+					 * contain more than one IE. Scan
+					 * results may contain one or more
+					 * IWEVGENIE events. */
+#define IWEVMICHAELMICFAILURE 0x8C06	/* Michael MIC failure
+					 * (struct iw_michaelmicfailure)
+					 */
+#define IWEVASSOCREQIE	0x8C07		/* IEs used in (Re)Association Request.
+					 * The data includes id and length
+					 * fields and may contain more than one
+					 * IE. This event is required in
+					 * Managed mode if the driver
+					 * generates its own WPA/RSN IE. This
+					 * should be sent just before
+					 * IWEVREGISTERED event for the
+					 * association. */
+#define IWEVASSOCRESPIE	0x8C08		/* IEs used in (Re)Association
+					 * Response. The data includes id and
+					 * length fields and may contain more
+					 * than one IE. This may be sent
+					 * between IWEVASSOCREQIE and
+					 * IWEVREGISTERED events for the
+					 * association. */
+#define IWEVPMKIDCAND	0x8C09		/* PMKID candidate for RSN
+					 * pre-authentication
+					 * (struct iw_pmkid_cand) */
+
+#define IWEVFIRST	0x8C00
+#define IW_EVENT_IDX(cmd)	((cmd) - IWEVFIRST)
+
+/* ------------------------- PRIVATE INFO ------------------------- */
+/*
+ * The following is used with SIOCGIWPRIV. It allow a driver to define
+ * the interface (name, type of data) for its private ioctl.
+ * Privates ioctl are SIOCIWFIRSTPRIV -> SIOCIWLASTPRIV
+ */
+
+#define IW_PRIV_TYPE_MASK	0x7000	/* Type of arguments */
+#define IW_PRIV_TYPE_NONE	0x0000
+#define IW_PRIV_TYPE_BYTE	0x1000	/* Char as number */
+#define IW_PRIV_TYPE_CHAR	0x2000	/* Char as character */
+#define IW_PRIV_TYPE_INT	0x4000	/* 32 bits int */
+#define IW_PRIV_TYPE_FLOAT	0x5000	/* struct iw_freq */
+#define IW_PRIV_TYPE_ADDR	0x6000	/* struct sockaddr */
+
+#define IW_PRIV_SIZE_FIXED	0x0800	/* Variable or fixed number of args */
+
+#define IW_PRIV_SIZE_MASK	0x07FF	/* Max number of those args */
+
+/*
+ * Note : if the number of args is fixed and the size < 16 octets,
+ * instead of passing a pointer we will put args in the iwreq struct...
+ */
+
+/* ----------------------- OTHER CONSTANTS ----------------------- */
+
+/* Maximum frequencies in the range struct */
+#define IW_MAX_FREQUENCIES	32
+/* Note : if you have something like 80 frequencies,
+ * don't increase this constant and don't fill the frequency list.
+ * The user will be able to set by channel anyway... */
+
+/* Maximum bit rates in the range struct */
+#define IW_MAX_BITRATES		32
+
+/* Maximum tx powers in the range struct */
+#define IW_MAX_TXPOWER		8
+/* Note : if you more than 8 TXPowers, just set the max and min or
+ * a few of them in the struct iw_range. */
+
+/* Maximum of address that you may set with SPY */
+#define IW_MAX_SPY		8
+
+/* Maximum of address that you may get in the
+   list of access points in range */
+#define IW_MAX_AP		64
+
+/* Maximum size of the ESSID and NICKN strings */
+#define IW_ESSID_MAX_SIZE	32
+
+/* Modes of operation */
+#define IW_MODE_AUTO	0	/* Let the driver decides */
+#define IW_MODE_ADHOC	1	/* Single cell network */
+#define IW_MODE_INFRA	2	/* Multi cell network, roaming, ... */
+#define IW_MODE_MASTER	3	/* Synchronisation master or Access Point */
+#define IW_MODE_REPEAT	4	/* Wireless Repeater (forwarder) */
+#define IW_MODE_SECOND	5	/* Secondary master/repeater (backup) */
+#define IW_MODE_MONITOR	6	/* Passive monitor (listen only) */
+
+/* Statistics flags (bitmask in updated) */
+#define IW_QUAL_QUAL_UPDATED	0x01	/* Value was updated since last read */
+#define IW_QUAL_LEVEL_UPDATED	0x02
+#define IW_QUAL_NOISE_UPDATED	0x04
+#define IW_QUAL_ALL_UPDATED	0x07
+#define IW_QUAL_DBM		0x08	/* Level + Noise are dBm */
+#define IW_QUAL_QUAL_INVALID	0x10	/* Driver doesn't provide value */
+#define IW_QUAL_LEVEL_INVALID	0x20
+#define IW_QUAL_NOISE_INVALID	0x40
+#define IW_QUAL_RCPI		0x80	/* Level + Noise are 802.11k RCPI */
+#define IW_QUAL_ALL_INVALID	0x70
+
+/* Frequency flags */
+#define IW_FREQ_AUTO		0x00	/* Let the driver decides */
+#define IW_FREQ_FIXED		0x01	/* Force a specific value */
+
+/* Maximum number of size of encoding token available
+ * they are listed in the range structure */
+#define IW_MAX_ENCODING_SIZES	8
+
+/* Maximum size of the encoding token in bytes */
+#define IW_ENCODING_TOKEN_MAX	64	/* 512 bits (for now) */
+
+/* Flags for encoding (along with the token) */
+#define IW_ENCODE_INDEX		0x00FF	/* Token index (if needed) */
+#define IW_ENCODE_FLAGS		0xFF00	/* Flags defined below */
+#define IW_ENCODE_MODE		0xF000	/* Modes defined below */
+#define IW_ENCODE_DISABLED	0x8000	/* Encoding disabled */
+#define IW_ENCODE_ENABLED	0x0000	/* Encoding enabled */
+#define IW_ENCODE_RESTRICTED	0x4000	/* Refuse non-encoded packets */
+#define IW_ENCODE_OPEN		0x2000	/* Accept non-encoded packets */
+#define IW_ENCODE_NOKEY		0x0800  /* Key is write only, so not present */
+#define IW_ENCODE_TEMP		0x0400  /* Temporary key */
+
+/* Power management flags available (along with the value, if any) */
+#define IW_POWER_ON		0x0000	/* No details... */
+#define IW_POWER_TYPE		0xF000	/* Type of parameter */
+#define IW_POWER_PERIOD		0x1000	/* Value is a period/duration of  */
+#define IW_POWER_TIMEOUT	0x2000	/* Value is a timeout (to go asleep) */
+#define IW_POWER_SAVING		0x4000	/* Value is relative (how aggressive)*/
+#define IW_POWER_MODE		0x0F00	/* Power Management mode */
+#define IW_POWER_UNICAST_R	0x0100	/* Receive only unicast messages */
+#define IW_POWER_MULTICAST_R	0x0200	/* Receive only multicast messages */
+#define IW_POWER_ALL_R		0x0300	/* Receive all messages though PM */
+#define IW_POWER_FORCE_S	0x0400	/* Force PM procedure for sending unicast */
+#define IW_POWER_REPEATER	0x0800	/* Repeat broadcast messages in PM period */
+#define IW_POWER_MODIFIER	0x000F	/* Modify a parameter */
+#define IW_POWER_MIN		0x0001	/* Value is a minimum  */
+#define IW_POWER_MAX		0x0002	/* Value is a maximum */
+#define IW_POWER_RELATIVE	0x0004	/* Value is not in seconds/ms/us */
+
+/* Transmit Power flags available */
+#define IW_TXPOW_TYPE		0x00FF	/* Type of value */
+#define IW_TXPOW_DBM		0x0000	/* Value is in dBm */
+#define IW_TXPOW_MWATT		0x0001	/* Value is in mW */
+#define IW_TXPOW_RELATIVE	0x0002	/* Value is in arbitrary units */
+#define IW_TXPOW_RANGE		0x1000	/* Range of value between min/max */
+
+/* Retry limits and lifetime flags available */
+#define IW_RETRY_ON		0x0000	/* No details... */
+#define IW_RETRY_TYPE		0xF000	/* Type of parameter */
+#define IW_RETRY_LIMIT		0x1000	/* Maximum number of retries*/
+#define IW_RETRY_LIFETIME	0x2000	/* Maximum duration of retries in us */
+#define IW_RETRY_MODIFIER	0x00FF	/* Modify a parameter */
+#define IW_RETRY_MIN		0x0001	/* Value is a minimum  */
+#define IW_RETRY_MAX		0x0002	/* Value is a maximum */
+#define IW_RETRY_RELATIVE	0x0004	/* Value is not in seconds/ms/us */
+#define IW_RETRY_SHORT		0x0010	/* Value is for short packets  */
+#define IW_RETRY_LONG		0x0020	/* Value is for long packets */
+
+/* Scanning request flags */
+#define IW_SCAN_DEFAULT		0x0000	/* Default scan of the driver */
+#define IW_SCAN_ALL_ESSID	0x0001	/* Scan all ESSIDs */
+#define IW_SCAN_THIS_ESSID	0x0002	/* Scan only this ESSID */
+#define IW_SCAN_ALL_FREQ	0x0004	/* Scan all Frequencies */
+#define IW_SCAN_THIS_FREQ	0x0008	/* Scan only this Frequency */
+#define IW_SCAN_ALL_MODE	0x0010	/* Scan all Modes */
+#define IW_SCAN_THIS_MODE	0x0020	/* Scan only this Mode */
+#define IW_SCAN_ALL_RATE	0x0040	/* Scan all Bit-Rates */
+#define IW_SCAN_THIS_RATE	0x0080	/* Scan only this Bit-Rate */
+/* struct iw_scan_req scan_type */
+#define IW_SCAN_TYPE_ACTIVE 0
+#define IW_SCAN_TYPE_PASSIVE 1
+/* Maximum size of returned data */
+#define IW_SCAN_MAX_DATA	16384	/* In bytes */
+
+/* Max number of char in custom event - use multiple of them if needed */
+#define IW_CUSTOM_MAX		256	/* In bytes */
+
+/* Generic information element */
+#define IW_GENERIC_IE_MAX	1024
+
+/* MLME requests (SIOCSIWMLME / struct iw_mlme) */
+#define IW_MLME_DEAUTH		0
+#define IW_MLME_DISASSOC	1
+
+/* SIOCSIWAUTH/SIOCGIWAUTH struct iw_param flags */
+#define IW_AUTH_INDEX		0x0FFF
+#define IW_AUTH_FLAGS		0xF000
+/* SIOCSIWAUTH/SIOCGIWAUTH parameters (0 .. 4095)
+ * (IW_AUTH_INDEX mask in struct iw_param flags; this is the index of the
+ * parameter that is being set/get to; value will be read/written to
+ * struct iw_param value field) */
+#define IW_AUTH_WPA_VERSION		0
+#define IW_AUTH_CIPHER_PAIRWISE		1
+#define IW_AUTH_CIPHER_GROUP		2
+#define IW_AUTH_KEY_MGMT		3
+#define IW_AUTH_TKIP_COUNTERMEASURES	4
+#define IW_AUTH_DROP_UNENCRYPTED	5
+#define IW_AUTH_80211_AUTH_ALG		6
+#define IW_AUTH_WPA_ENABLED		7
+#define IW_AUTH_RX_UNENCRYPTED_EAPOL	8
+#define IW_AUTH_ROAMING_CONTROL		9
+#define IW_AUTH_PRIVACY_INVOKED		10
+
+/* IW_AUTH_WPA_VERSION values (bit field) */
+#define IW_AUTH_WPA_VERSION_DISABLED	0x00000001
+#define IW_AUTH_WPA_VERSION_WPA		0x00000002
+#define IW_AUTH_WPA_VERSION_WPA2	0x00000004
+
+/* IW_AUTH_PAIRWISE_CIPHER and IW_AUTH_GROUP_CIPHER values (bit field) */
+#define IW_AUTH_CIPHER_NONE	0x00000001
+#define IW_AUTH_CIPHER_WEP40	0x00000002
+#define IW_AUTH_CIPHER_TKIP	0x00000004
+#define IW_AUTH_CIPHER_CCMP	0x00000008
+#define IW_AUTH_CIPHER_WEP104	0x00000010
+
+/* IW_AUTH_KEY_MGMT values (bit field) */
+#define IW_AUTH_KEY_MGMT_802_1X	1
+#define IW_AUTH_KEY_MGMT_PSK	2
+
+/* IW_AUTH_80211_AUTH_ALG values (bit field) */
+#define IW_AUTH_ALG_OPEN_SYSTEM	0x00000001
+#define IW_AUTH_ALG_SHARED_KEY	0x00000002
+#define IW_AUTH_ALG_LEAP	0x00000004
+
+/* IW_AUTH_ROAMING_CONTROL values */
+#define IW_AUTH_ROAMING_ENABLE	0	/* driver/firmware based roaming */
+#define IW_AUTH_ROAMING_DISABLE	1	/* user space program used for roaming
+					 * control */
+
+/* SIOCSIWENCODEEXT definitions */
+#define IW_ENCODE_SEQ_MAX_SIZE	8
+/* struct iw_encode_ext ->alg */
+#define IW_ENCODE_ALG_NONE	0
+#define IW_ENCODE_ALG_WEP	1
+#define IW_ENCODE_ALG_TKIP	2
+#define IW_ENCODE_ALG_CCMP	3
+/* struct iw_encode_ext ->ext_flags */
+#define IW_ENCODE_EXT_TX_SEQ_VALID	0x00000001
+#define IW_ENCODE_EXT_RX_SEQ_VALID	0x00000002
+#define IW_ENCODE_EXT_GROUP_KEY		0x00000004
+#define IW_ENCODE_EXT_SET_TX_KEY	0x00000008
+
+/* IWEVMICHAELMICFAILURE : struct iw_michaelmicfailure ->flags */
+#define IW_MICFAILURE_KEY_ID	0x00000003 /* Key ID 0..3 */
+#define IW_MICFAILURE_GROUP	0x00000004
+#define IW_MICFAILURE_PAIRWISE	0x00000008
+#define IW_MICFAILURE_STAKEY	0x00000010
+#define IW_MICFAILURE_COUNT	0x00000060 /* 1 or 2 (0 = count not supported)
+					    */
+
+/* Bit field values for enc_capa in struct iw_range */
+#define IW_ENC_CAPA_WPA		0x00000001
+#define IW_ENC_CAPA_WPA2	0x00000002
+#define IW_ENC_CAPA_CIPHER_TKIP	0x00000004
+#define IW_ENC_CAPA_CIPHER_CCMP	0x00000008
+
+/* Event capability macros - in (struct iw_range *)->event_capa
+ * Because we have more than 32 possible events, we use an array of
+ * 32 bit bitmasks. Note : 32 bits = 0x20 = 2^5. */
+#define IW_EVENT_CAPA_BASE(cmd)		((cmd >= SIOCIWFIRSTPRIV) ? \
+					 (cmd - SIOCIWFIRSTPRIV + 0x60) : \
+					 (cmd - SIOCSIWCOMMIT))
+#define IW_EVENT_CAPA_INDEX(cmd)	(IW_EVENT_CAPA_BASE(cmd) >> 5)
+#define IW_EVENT_CAPA_MASK(cmd)		(1 << (IW_EVENT_CAPA_BASE(cmd) & 0x1F))
+/* Event capability constants - event autogenerated by the kernel
+ * This list is valid for most 802.11 devices, customise as needed... */
+#define IW_EVENT_CAPA_K_0	(IW_EVENT_CAPA_MASK(0x8B04) | \
+				 IW_EVENT_CAPA_MASK(0x8B06) | \
+				 IW_EVENT_CAPA_MASK(0x8B1A))
+#define IW_EVENT_CAPA_K_1	(IW_EVENT_CAPA_MASK(0x8B2A))
+/* "Easy" macro to set events in iw_range (less efficient) */
+#define IW_EVENT_CAPA_SET(event_capa, cmd) (event_capa[IW_EVENT_CAPA_INDEX(cmd)] |= IW_EVENT_CAPA_MASK(cmd))
+#define IW_EVENT_CAPA_SET_KERNEL(event_capa) {event_capa[0] |= IW_EVENT_CAPA_K_0; event_capa[1] |= IW_EVENT_CAPA_K_1; }
+
+/* Modulations bitmasks */
+#define IW_MODUL_ALL		0x00000000	/* Everything supported */
+#define IW_MODUL_FH		0x00000001	/* Frequency Hopping */
+#define IW_MODUL_DS		0x00000002	/* Original Direct Sequence */
+#define IW_MODUL_CCK		0x00000004	/* 802.11b : 5.5 + 11 Mb/s */
+#define IW_MODUL_11B		(IW_MODUL_DS | IW_MODUL_CCK)
+#define IW_MODUL_PBCC		0x00000008	/* TI : 5.5 + 11 + 22 Mb/s */
+#define IW_MODUL_OFDM_A		0x00000010	/* 802.11a : 54 Mb/s */
+#define IW_MODUL_11A		(IW_MODUL_OFDM_A)
+#define IW_MODUL_11AB		(IW_MODUL_11B | IW_MODUL_11A)
+#define IW_MODUL_OFDM_G		0x00000020	/* 802.11g : 54 Mb/s */
+#define IW_MODUL_11G		(IW_MODUL_11B | IW_MODUL_OFDM_G)
+#define IW_MODUL_11AG		(IW_MODUL_11G | IW_MODUL_11A)
+#define IW_MODUL_TURBO		0x00000040	/* ATH : bonding, 108 Mb/s */
+/* In here we should define MIMO stuff. Later... */
+#define IW_MODUL_CUSTOM		0x40000000	/* Driver specific */
+
+/* Bitrate flags available */
+#define IW_BITRATE_TYPE		0x00FF	/* Type of value */
+#define IW_BITRATE_UNICAST	0x0001	/* Maximum/Fixed unicast bitrate */
+#define IW_BITRATE_BROADCAST	0x0002	/* Fixed broadcast bitrate */
+
+/****************************** TYPES ******************************/
+
+/* --------------------------- SUBTYPES --------------------------- */
+/*
+ *	Generic format for most parameters that fit in an int
+ */
+struct	iw_param
+{
+  __s32		value;		/* The value of the parameter itself */
+  __u8		fixed;		/* Hardware should not use auto select */
+  __u8		disabled;	/* Disable the feature */
+  __u16		flags;		/* Various specifc flags (if any) */
+};
+
+/*
+ *	For all data larger than 16 octets, we need to use a
+ *	pointer to memory allocated in user space.
+ */
+struct	iw_point
+{
+  void __user	*pointer;	/* Pointer to the data  (in user space) */
+  __u16		length;		/* number of fields or size in bytes */
+  __u16		flags;		/* Optional params */
+};
+
+/*
+ *	A frequency
+ *	For numbers lower than 10^9, we encode the number in 'm' and
+ *	set 'e' to 0
+ *	For number greater than 10^9, we divide it by the lowest power
+ *	of 10 to get 'm' lower than 10^9, with 'm'= f / (10^'e')...
+ *	The power of 10 is in 'e', the result of the division is in 'm'.
+ */
+struct	iw_freq
+{
+	__s32		m;		/* Mantissa */
+	__s16		e;		/* Exponent */
+	__u8		i;		/* List index (when in range struct) */
+	__u8		flags;		/* Flags (fixed/auto) */
+};
+
+/*
+ *	Quality of the link
+ */
+struct	iw_quality
+{
+	__u8		qual;		/* link quality (%retries, SNR,
+					   %missed beacons or better...) */
+	__u8		level;		/* signal level (dBm) */
+	__u8		noise;		/* noise level (dBm) */
+	__u8		updated;	/* Flags to know if updated */
+};
+
+/*
+ *	Packet discarded in the wireless adapter due to
+ *	"wireless" specific problems...
+ *	Note : the list of counter and statistics in net_device_stats
+ *	is already pretty exhaustive, and you should use that first.
+ *	This is only additional stats...
+ */
+struct	iw_discarded
+{
+	__u32		nwid;		/* Rx : Wrong nwid/essid */
+	__u32		code;		/* Rx : Unable to code/decode (WEP) */
+	__u32		fragment;	/* Rx : Can't perform MAC reassembly */
+	__u32		retries;	/* Tx : Max MAC retries num reached */
+	__u32		misc;		/* Others cases */
+};
+
+/*
+ *	Packet/Time period missed in the wireless adapter due to
+ *	"wireless" specific problems...
+ */
+struct	iw_missed
+{
+	__u32		beacon;		/* Missed beacons/superframe */
+};
+
+/*
+ *	Quality range (for spy threshold)
+ */
+struct	iw_thrspy
+{
+	struct sockaddr		addr;		/* Source address (hw/mac) */
+	struct iw_quality	qual;		/* Quality of the link */
+	struct iw_quality	low;		/* Low threshold */
+	struct iw_quality	high;		/* High threshold */
+};
+
+/*
+ *	Optional data for scan request
+ *
+ *	Note: these optional parameters are controlling parameters for the
+ *	scanning behavior, these do not apply to getting scan results
+ *	(SIOCGIWSCAN). Drivers are expected to keep a local BSS table and
+ *	provide a merged results with all BSSes even if the previous scan
+ *	request limited scanning to a subset, e.g., by specifying an SSID.
+ *	Especially, scan results are required to include an entry for the
+ *	current BSS if the driver is in Managed mode and associated with an AP.
+ */
+struct	iw_scan_req
+{
+	__u8		scan_type; /* IW_SCAN_TYPE_{ACTIVE,PASSIVE} */
+	__u8		essid_len;
+	__u8		num_channels; /* num entries in channel_list;
+				       * 0 = scan all allowed channels */
+	__u8		flags; /* reserved as padding; use zero, this may
+				* be used in the future for adding flags
+				* to request different scan behavior */
+	struct sockaddr	bssid; /* ff:ff:ff:ff:ff:ff for broadcast BSSID or
+				* individual address of a specific BSS */
+
+	/*
+	 * Use this ESSID if IW_SCAN_THIS_ESSID flag is used instead of using
+	 * the current ESSID. This allows scan requests for specific ESSID
+	 * without having to change the current ESSID and potentially breaking
+	 * the current association.
+	 */
+	__u8		essid[IW_ESSID_MAX_SIZE];
+
+	/*
+	 * Optional parameters for changing the default scanning behavior.
+	 * These are based on the MLME-SCAN.request from IEEE Std 802.11.
+	 * TU is 1.024 ms. If these are set to 0, driver is expected to use
+	 * reasonable default values. min_channel_time defines the time that
+	 * will be used to wait for the first reply on each channel. If no
+	 * replies are received, next channel will be scanned after this. If
+	 * replies are received, total time waited on the channel is defined by
+	 * max_channel_time.
+	 */
+	__u32		min_channel_time; /* in TU */
+	__u32		max_channel_time; /* in TU */
+
+	struct iw_freq	channel_list[IW_MAX_FREQUENCIES];
+};
+
+/* ------------------------- WPA SUPPORT ------------------------- */
+
+/*
+ *	Extended data structure for get/set encoding (this is used with
+ *	SIOCSIWENCODEEXT/SIOCGIWENCODEEXT. struct iw_point and IW_ENCODE_*
+ *	flags are used in the same way as with SIOCSIWENCODE/SIOCGIWENCODE and
+ *	only the data contents changes (key data -> this structure, including
+ *	key data).
+ *
+ *	If the new key is the first group key, it will be set as the default
+ *	TX key. Otherwise, default TX key index is only changed if
+ *	IW_ENCODE_EXT_SET_TX_KEY flag is set.
+ *
+ *	Key will be changed with SIOCSIWENCODEEXT in all cases except for
+ *	special "change TX key index" operation which is indicated by setting
+ *	key_len = 0 and ext_flags |= IW_ENCODE_EXT_SET_TX_KEY.
+ *
+ *	tx_seq/rx_seq are only used when respective
+ *	IW_ENCODE_EXT_{TX,RX}_SEQ_VALID flag is set in ext_flags. Normal
+ *	TKIP/CCMP operation is to set RX seq with SIOCSIWENCODEEXT and start
+ *	TX seq from zero whenever key is changed. SIOCGIWENCODEEXT is normally
+ *	used only by an Authenticator (AP or an IBSS station) to get the
+ *	current TX sequence number. Using TX_SEQ_VALID for SIOCSIWENCODEEXT and
+ *	RX_SEQ_VALID for SIOCGIWENCODEEXT are optional, but can be useful for
+ *	debugging/testing.
+ */
+struct	iw_encode_ext
+{
+	__u32		ext_flags; /* IW_ENCODE_EXT_* */
+	__u8		tx_seq[IW_ENCODE_SEQ_MAX_SIZE]; /* LSB first */
+	__u8		rx_seq[IW_ENCODE_SEQ_MAX_SIZE]; /* LSB first */
+	struct sockaddr	addr; /* ff:ff:ff:ff:ff:ff for broadcast/multicast
+			       * (group) keys or unicast address for
+			       * individual keys */
+	__u16		alg; /* IW_ENCODE_ALG_* */
+	__u16		key_len;
+	__u8		key[0];
+};
+
+/* SIOCSIWMLME data */
+struct	iw_mlme
+{
+	__u16		cmd; /* IW_MLME_* */
+	__u16		reason_code;
+	struct sockaddr	addr;
+};
+
+/* SIOCSIWPMKSA data */
+#define IW_PMKSA_ADD		1
+#define IW_PMKSA_REMOVE		2
+#define IW_PMKSA_FLUSH		3
+
+#define IW_PMKID_LEN	16
+
+struct	iw_pmksa
+{
+	__u32		cmd; /* IW_PMKSA_* */
+	struct sockaddr	bssid;
+	__u8		pmkid[IW_PMKID_LEN];
+};
+
+/* IWEVMICHAELMICFAILURE data */
+struct	iw_michaelmicfailure
+{
+	__u32		flags;
+	struct sockaddr	src_addr;
+	__u8		tsc[IW_ENCODE_SEQ_MAX_SIZE]; /* LSB first */
+};
+
+/* IWEVPMKIDCAND data */
+#define IW_PMKID_CAND_PREAUTH	0x00000001 /* RNS pre-authentication enabled */
+struct	iw_pmkid_cand
+{
+	__u32		flags; /* IW_PMKID_CAND_* */
+	__u32		index; /* the smaller the index, the higher the
+				* priority */
+	struct sockaddr	bssid;
+};
+
+/* ------------------------ WIRELESS STATS ------------------------ */
+/*
+ * Wireless statistics (used for /proc/net/wireless)
+ */
+struct	iw_statistics
+{
+	__u16		status;		/* Status
+					 * - device dependent for now */
+
+	struct iw_quality	qual;		/* Quality of the link
+						 * (instant/mean/max) */
+	struct iw_discarded	discard;	/* Packet discarded counts */
+	struct iw_missed	miss;		/* Packet missed counts */
+};
+
+/* ------------------------ IOCTL REQUEST ------------------------ */
+/*
+ * This structure defines the payload of an ioctl, and is used 
+ * below.
+ *
+ * Note that this structure should fit on the memory footprint
+ * of iwreq (which is the same as ifreq), which mean a max size of
+ * 16 octets = 128 bits. Warning, pointers might be 64 bits wide...
+ * You should check this when increasing the structures defined
+ * above in this file...
+ */
+union	iwreq_data
+{
+	/* Config - generic */
+	char		name[IFNAMSIZ];
+	/* Name : used to verify the presence of  wireless extensions.
+	 * Name of the protocol/provider... */
+
+	struct iw_point	essid;		/* Extended network name */
+	struct iw_param	nwid;		/* network id (or domain - the cell) */
+	struct iw_freq	freq;		/* frequency or channel :
+					 * 0-1000 = channel
+					 * > 1000 = frequency in Hz */
+
+	struct iw_param	sens;		/* signal level threshold */
+	struct iw_param	bitrate;	/* default bit rate */
+	struct iw_param	txpower;	/* default transmit power */
+	struct iw_param	rts;		/* RTS threshold threshold */
+	struct iw_param	frag;		/* Fragmentation threshold */
+	__u32		mode;		/* Operation mode */
+	struct iw_param	retry;		/* Retry limits & lifetime */
+
+	struct iw_point	encoding;	/* Encoding stuff : tokens */
+	struct iw_param	power;		/* PM duration/timeout */
+	struct iw_quality qual;		/* Quality part of statistics */
+
+	struct sockaddr	ap_addr;	/* Access point address */
+	struct sockaddr	addr;		/* Destination address (hw/mac) */
+
+	struct iw_param	param;		/* Other small parameters */
+	struct iw_point	data;		/* Other large parameters */
+};
+
+/*
+ * The structure to exchange data for ioctl.
+ * This structure is the same as 'struct ifreq', but (re)defined for
+ * convenience...
+ * Do I need to remind you about structure size (32 octets) ?
+ */
+struct	iwreq 
+{
+	union
+	{
+		char	ifrn_name[IFNAMSIZ];	/* if name, e.g. "eth0" */
+	} ifr_ifrn;
+
+	/* Data part (defined just above) */
+	union	iwreq_data	u;
+};
+
+/* -------------------------- IOCTL DATA -------------------------- */
+/*
+ *	For those ioctl which want to exchange mode data that what could
+ *	fit in the above structure...
+ */
+
+/*
+ *	Range of parameters
+ */
+
+struct	iw_range
+{
+	/* Informative stuff (to choose between different interface) */
+	__u32		throughput;	/* To give an idea... */
+	/* In theory this value should be the maximum benchmarked
+	 * TCP/IP throughput, because with most of these devices the
+	 * bit rate is meaningless (overhead an co) to estimate how
+	 * fast the connection will go and pick the fastest one.
+	 * I suggest people to play with Netperf or any benchmark...
+	 */
+
+	/* NWID (or domain id) */
+	__u32		min_nwid;	/* Minimal NWID we are able to set */
+	__u32		max_nwid;	/* Maximal NWID we are able to set */
+
+	/* Old Frequency (backward compat - moved lower ) */
+	__u16		old_num_channels;
+	__u8		old_num_frequency;
+
+	/* Wireless event capability bitmasks */
+	__u32		event_capa[6];
+
+	/* signal level threshold range */
+	__s32		sensitivity;
+
+	/* Quality of link & SNR stuff */
+	/* Quality range (link, level, noise)
+	 * If the quality is absolute, it will be in the range [0 ; max_qual],
+	 * if the quality is dBm, it will be in the range [max_qual ; 0].
+	 * Don't forget that we use 8 bit arithmetics... */
+	struct iw_quality	max_qual;	/* Quality of the link */
+	/* This should contain the average/typical values of the quality
+	 * indicator. This should be the threshold between a "good" and
+	 * a "bad" link (example : monitor going from green to orange).
+	 * Currently, user space apps like quality monitors don't have any
+	 * way to calibrate the measurement. With this, they can split
+	 * the range between 0 and max_qual in different quality level
+	 * (using a geometric subdivision centered on the average).
+	 * I expect that people doing the user space apps will feedback
+	 * us on which value we need to put in each driver... */
+	struct iw_quality	avg_qual;	/* Quality of the link */
+
+	/* Rates */
+	__u8		num_bitrates;	/* Number of entries in the list */
+	__s32		bitrate[IW_MAX_BITRATES];	/* list, in bps */
+
+	/* RTS threshold */
+	__s32		min_rts;	/* Minimal RTS threshold */
+	__s32		max_rts;	/* Maximal RTS threshold */
+
+	/* Frag threshold */
+	__s32		min_frag;	/* Minimal frag threshold */
+	__s32		max_frag;	/* Maximal frag threshold */
+
+	/* Power Management duration & timeout */
+	__s32		min_pmp;	/* Minimal PM period */
+	__s32		max_pmp;	/* Maximal PM period */
+	__s32		min_pmt;	/* Minimal PM timeout */
+	__s32		max_pmt;	/* Maximal PM timeout */
+	__u16		pmp_flags;	/* How to decode max/min PM period */
+	__u16		pmt_flags;	/* How to decode max/min PM timeout */
+	__u16		pm_capa;	/* What PM options are supported */
+
+	/* Encoder stuff */
+	__u16	encoding_size[IW_MAX_ENCODING_SIZES];	/* Different token sizes */
+	__u8	num_encoding_sizes;	/* Number of entry in the list */
+	__u8	max_encoding_tokens;	/* Max number of tokens */
+	/* For drivers that need a "login/passwd" form */
+	__u8	encoding_login_index;	/* token index for login token */
+
+	/* Transmit power */
+	__u16		txpower_capa;	/* What options are supported */
+	__u8		num_txpower;	/* Number of entries in the list */
+	__s32		txpower[IW_MAX_TXPOWER];	/* list, in bps */
+
+	/* Wireless Extension version info */
+	__u8		we_version_compiled;	/* Must be WIRELESS_EXT */
+	__u8		we_version_source;	/* Last update of source */
+
+	/* Retry limits and lifetime */
+	__u16		retry_capa;	/* What retry options are supported */
+	__u16		retry_flags;	/* How to decode max/min retry limit */
+	__u16		r_time_flags;	/* How to decode max/min retry life */
+	__s32		min_retry;	/* Minimal number of retries */
+	__s32		max_retry;	/* Maximal number of retries */
+	__s32		min_r_time;	/* Minimal retry lifetime */
+	__s32		max_r_time;	/* Maximal retry lifetime */
+
+	/* Frequency */
+	__u16		num_channels;	/* Number of channels [0; num - 1] */
+	__u8		num_frequency;	/* Number of entry in the list */
+	struct iw_freq	freq[IW_MAX_FREQUENCIES];	/* list */
+	/* Note : this frequency list doesn't need to fit channel numbers,
+	 * because each entry contain its channel index */
+
+	__u32		enc_capa;	/* IW_ENC_CAPA_* bit field */
+
+	/* More power management stuff */
+	__s32		min_pms;	/* Minimal PM saving */
+	__s32		max_pms;	/* Maximal PM saving */
+	__u16		pms_flags;	/* How to decode max/min PM saving */
+
+	/* All available modulations for driver (hw may support less) */
+	__s32		modul_capa;	/* IW_MODUL_* bit field */
+
+	/* More bitrate stuff */
+	__u32		bitrate_capa;	/* Types of bitrates supported */
+};
+
+/*
+ * Private ioctl interface information
+ */
+ 
+struct	iw_priv_args
+{
+	__u32		cmd;		/* Number of the ioctl to issue */
+	__u16		set_args;	/* Type and number of args */
+	__u16		get_args;	/* Type and number of args */
+	char		name[IFNAMSIZ];	/* Name of the extension */
+};
+
+/* ----------------------- WIRELESS EVENTS ----------------------- */
+/*
+ * Wireless events are carried through the rtnetlink socket to user
+ * space. They are encapsulated in the IFLA_WIRELESS field of
+ * a RTM_NEWLINK message.
+ */
+
+/*
+ * A Wireless Event. Contains basically the same data as the ioctl...
+ */
+struct iw_event
+{
+	__u16		len;			/* Real lenght of this stuff */
+	__u16		cmd;			/* Wireless IOCTL */
+	union iwreq_data	u;		/* IOCTL fixed payload */
+};
+
+/* Size of the Event prefix (including padding and alignement junk) */
+#define IW_EV_LCP_LEN	(sizeof(struct iw_event) - sizeof(union iwreq_data))
+/* Size of the various events */
+#define IW_EV_CHAR_LEN	(IW_EV_LCP_LEN + IFNAMSIZ)
+#define IW_EV_UINT_LEN	(IW_EV_LCP_LEN + sizeof(__u32))
+#define IW_EV_FREQ_LEN	(IW_EV_LCP_LEN + sizeof(struct iw_freq))
+#define IW_EV_PARAM_LEN	(IW_EV_LCP_LEN + sizeof(struct iw_param))
+#define IW_EV_ADDR_LEN	(IW_EV_LCP_LEN + sizeof(struct sockaddr))
+#define IW_EV_QUAL_LEN	(IW_EV_LCP_LEN + sizeof(struct iw_quality))
+
+/* iw_point events are special. First, the payload (extra data) come at
+ * the end of the event, so they are bigger than IW_EV_POINT_LEN. Second,
+ * we omit the pointer, so start at an offset. */
+#define IW_EV_POINT_OFF (((char *) &(((struct iw_point *) NULL)->length)) - \
+			  (char *) NULL)
+#define IW_EV_POINT_LEN	(IW_EV_LCP_LEN + sizeof(struct iw_point) - \
+			 IW_EV_POINT_OFF)
+
+#endif	/* _LINUX_WIRELESS_H */
diff --git a/wireless.22.h b/wireless.22.h
new file mode 100644
index 0000000..7cc54ae
--- /dev/null
+++ b/wireless.22.h
@@ -0,0 +1,1139 @@
+/*
+ * This file define a set of standard wireless extensions
+ *
+ * Version :	22	16.3.07
+ *
+ * Authors :	Jean Tourrilhes - HPL - <jt@hpl.hp.com>
+ * Copyright (c) 1997-2007 Jean Tourrilhes, All Rights Reserved.
+ */
+
+#ifndef _LINUX_WIRELESS_H
+#define _LINUX_WIRELESS_H
+
+/************************** DOCUMENTATION **************************/
+/*
+ * Initial APIs (1996 -> onward) :
+ * -----------------------------
+ * Basically, the wireless extensions are for now a set of standard ioctl
+ * call + /proc/net/wireless
+ *
+ * The entry /proc/net/wireless give statistics and information on the
+ * driver.
+ * This is better than having each driver having its entry because
+ * its centralised and we may remove the driver module safely.
+ *
+ * Ioctl are used to configure the driver and issue commands.  This is
+ * better than command line options of insmod because we may want to
+ * change dynamically (while the driver is running) some parameters.
+ *
+ * The ioctl mechanimsm are copied from standard devices ioctl.
+ * We have the list of command plus a structure descibing the
+ * data exchanged...
+ * Note that to add these ioctl, I was obliged to modify :
+ *	# net/core/dev.c (two place + add include)
+ *	# net/ipv4/af_inet.c (one place + add include)
+ *
+ * /proc/net/wireless is a copy of /proc/net/dev.
+ * We have a structure for data passed from the driver to /proc/net/wireless
+ * Too add this, I've modified :
+ *	# net/core/dev.c (two other places)
+ *	# include/linux/netdevice.h (one place)
+ *	# include/linux/proc_fs.h (one place)
+ *
+ * New driver API (2002 -> onward) :
+ * -------------------------------
+ * This file is only concerned with the user space API and common definitions.
+ * The new driver API is defined and documented in :
+ *	# include/net/iw_handler.h
+ *
+ * Note as well that /proc/net/wireless implementation has now moved in :
+ *	# net/core/wireless.c
+ *
+ * Wireless Events (2002 -> onward) :
+ * --------------------------------
+ * Events are defined at the end of this file, and implemented in :
+ *	# net/core/wireless.c
+ *
+ * Other comments :
+ * --------------
+ * Do not add here things that are redundant with other mechanisms
+ * (drivers init, ifconfig, /proc/net/dev, ...) and with are not
+ * wireless specific.
+ *
+ * These wireless extensions are not magic : each driver has to provide
+ * support for them...
+ *
+ * IMPORTANT NOTE : As everything in the kernel, this is very much a
+ * work in progress. Contact me if you have ideas of improvements...
+ */
+
+/***************************** INCLUDES *****************************/
+
+/* This header is used in user-space, therefore need to be sanitised
+ * for that purpose. Those includes are usually not compatible with glibc.
+ * To know which includes to use in user-space, check iwlib.h. */
+#ifdef __KERNEL__
+#include <linux/types.h>		/* for "caddr_t" et al		*/
+#include <linux/socket.h>		/* for "struct sockaddr" et al	*/
+#include <linux/if.h>			/* for IFNAMSIZ and co... */
+#endif	/* __KERNEL__ */
+
+/***************************** VERSION *****************************/
+/*
+ * This constant is used to know the availability of the wireless
+ * extensions and to know which version of wireless extensions it is
+ * (there is some stuff that will be added in the future...)
+ * I just plan to increment with each new version.
+ */
+#define WIRELESS_EXT	22
+
+/*
+ * Changes :
+ *
+ * V2 to V3
+ * --------
+ *	Alan Cox start some incompatibles changes. I've integrated a bit more.
+ *	- Encryption renamed to Encode to avoid US regulation problems
+ *	- Frequency changed from float to struct to avoid problems on old 386
+ *
+ * V3 to V4
+ * --------
+ *	- Add sensitivity
+ *
+ * V4 to V5
+ * --------
+ *	- Missing encoding definitions in range
+ *	- Access points stuff
+ *
+ * V5 to V6
+ * --------
+ *	- 802.11 support (ESSID ioctls)
+ *
+ * V6 to V7
+ * --------
+ *	- define IW_ESSID_MAX_SIZE and IW_MAX_AP
+ *
+ * V7 to V8
+ * --------
+ *	- Changed my e-mail address
+ *	- More 802.11 support (nickname, rate, rts, frag)
+ *	- List index in frequencies
+ *
+ * V8 to V9
+ * --------
+ *	- Support for 'mode of operation' (ad-hoc, managed...)
+ *	- Support for unicast and multicast power saving
+ *	- Change encoding to support larger tokens (>64 bits)
+ *	- Updated iw_params (disable, flags) and use it for NWID
+ *	- Extracted iw_point from iwreq for clarity
+ *
+ * V9 to V10
+ * ---------
+ *	- Add PM capability to range structure
+ *	- Add PM modifier : MAX/MIN/RELATIVE
+ *	- Add encoding option : IW_ENCODE_NOKEY
+ *	- Add TxPower ioctls (work like TxRate)
+ *
+ * V10 to V11
+ * ----------
+ *	- Add WE version in range (help backward/forward compatibility)
+ *	- Add retry ioctls (work like PM)
+ *
+ * V11 to V12
+ * ----------
+ *	- Add SIOCSIWSTATS to get /proc/net/wireless programatically
+ *	- Add DEV PRIVATE IOCTL to avoid collisions in SIOCDEVPRIVATE space
+ *	- Add new statistics (frag, retry, beacon)
+ *	- Add average quality (for user space calibration)
+ *
+ * V12 to V13
+ * ----------
+ *	- Document creation of new driver API.
+ *	- Extract union iwreq_data from struct iwreq (for new driver API).
+ *	- Rename SIOCSIWNAME as SIOCSIWCOMMIT
+ *
+ * V13 to V14
+ * ----------
+ *	- Wireless Events support : define struct iw_event
+ *	- Define additional specific event numbers
+ *	- Add "addr" and "param" fields in union iwreq_data
+ *	- AP scanning stuff (SIOCSIWSCAN and friends)
+ *
+ * V14 to V15
+ * ----------
+ *	- Add IW_PRIV_TYPE_ADDR for struct sockaddr private arg
+ *	- Make struct iw_freq signed (both m & e), add explicit padding
+ *	- Add IWEVCUSTOM for driver specific event/scanning token
+ *	- Add IW_MAX_GET_SPY for driver returning a lot of addresses
+ *	- Add IW_TXPOW_RANGE for range of Tx Powers
+ *	- Add IWEVREGISTERED & IWEVEXPIRED events for Access Points
+ *	- Add IW_MODE_MONITOR for passive monitor
+ *
+ * V15 to V16
+ * ----------
+ *	- Increase the number of bitrates in iw_range to 32 (for 802.11g)
+ *	- Increase the number of frequencies in iw_range to 32 (for 802.11b+a)
+ *	- Reshuffle struct iw_range for increases, add filler
+ *	- Increase IW_MAX_AP to 64 for driver returning a lot of addresses
+ *	- Remove IW_MAX_GET_SPY because conflict with enhanced spy support
+ *	- Add SIOCSIWTHRSPY/SIOCGIWTHRSPY and "struct iw_thrspy"
+ *	- Add IW_ENCODE_TEMP and iw_range->encoding_login_index
+ *
+ * V16 to V17
+ * ----------
+ *	- Add flags to frequency -> auto/fixed
+ *	- Document (struct iw_quality *)->updated, add new flags (INVALID)
+ *	- Wireless Event capability in struct iw_range
+ *	- Add support for relative TxPower (yick !)
+ *
+ * V17 to V18 (From Jouni Malinen <jkmaline@cc.hut.fi>)
+ * ----------
+ *	- Add support for WPA/WPA2
+ *	- Add extended encoding configuration (SIOCSIWENCODEEXT and
+ *	  SIOCGIWENCODEEXT)
+ *	- Add SIOCSIWGENIE/SIOCGIWGENIE
+ *	- Add SIOCSIWMLME
+ *	- Add SIOCSIWPMKSA
+ *	- Add struct iw_range bit field for supported encoding capabilities
+ *	- Add optional scan request parameters for SIOCSIWSCAN
+ *	- Add SIOCSIWAUTH/SIOCGIWAUTH for setting authentication and WPA
+ *	  related parameters (extensible up to 4096 parameter values)
+ *	- Add wireless events: IWEVGENIE, IWEVMICHAELMICFAILURE,
+ *	  IWEVASSOCREQIE, IWEVASSOCRESPIE, IWEVPMKIDCAND
+ *
+ * V18 to V19
+ * ----------
+ *	- Remove (struct iw_point *)->pointer from events and streams
+ *	- Remove header includes to help user space
+ *	- Increase IW_ENCODING_TOKEN_MAX from 32 to 64
+ *	- Add IW_QUAL_ALL_UPDATED and IW_QUAL_ALL_INVALID macros
+ *	- Add explicit flag to tell stats are in dBm : IW_QUAL_DBM
+ *	- Add IW_IOCTL_IDX() and IW_EVENT_IDX() macros
+ *
+ * V19 to V20
+ * ----------
+ *	- RtNetlink requests support (SET/GET)
+ *
+ * V20 to V21
+ * ----------
+ *	- Remove (struct net_device *)->get_wireless_stats()
+ *	- Change length in ESSID and NICK to strlen() instead of strlen()+1
+ *	- Add IW_RETRY_SHORT/IW_RETRY_LONG retry modifiers
+ *	- Power/Retry relative values no longer * 100000
+ *	- Add explicit flag to tell stats are in 802.11k RCPI : IW_QUAL_RCPI
+ *
+ * V21 to V22
+ * ----------
+ *	- Prevent leaking of kernel space in stream on 64 bits.
+ */
+
+/**************************** CONSTANTS ****************************/
+
+/* -------------------------- IOCTL LIST -------------------------- */
+
+/* Wireless Identification */
+#define SIOCSIWCOMMIT	0x8B00		/* Commit pending changes to driver */
+#define SIOCGIWNAME	0x8B01		/* get name == wireless protocol */
+/* SIOCGIWNAME is used to verify the presence of Wireless Extensions.
+ * Common values : "IEEE 802.11-DS", "IEEE 802.11-FH", "IEEE 802.11b"...
+ * Don't put the name of your driver there, it's useless. */
+
+/* Basic operations */
+#define SIOCSIWNWID	0x8B02		/* set network id (pre-802.11) */
+#define SIOCGIWNWID	0x8B03		/* get network id (the cell) */
+#define SIOCSIWFREQ	0x8B04		/* set channel/frequency (Hz) */
+#define SIOCGIWFREQ	0x8B05		/* get channel/frequency (Hz) */
+#define SIOCSIWMODE	0x8B06		/* set operation mode */
+#define SIOCGIWMODE	0x8B07		/* get operation mode */
+#define SIOCSIWSENS	0x8B08		/* set sensitivity (dBm) */
+#define SIOCGIWSENS	0x8B09		/* get sensitivity (dBm) */
+
+/* Informative stuff */
+#define SIOCSIWRANGE	0x8B0A		/* Unused */
+#define SIOCGIWRANGE	0x8B0B		/* Get range of parameters */
+#define SIOCSIWPRIV	0x8B0C		/* Unused */
+#define SIOCGIWPRIV	0x8B0D		/* get private ioctl interface info */
+#define SIOCSIWSTATS	0x8B0E		/* Unused */
+#define SIOCGIWSTATS	0x8B0F		/* Get /proc/net/wireless stats */
+/* SIOCGIWSTATS is strictly used between user space and the kernel, and
+ * is never passed to the driver (i.e. the driver will never see it). */
+
+/* Spy support (statistics per MAC address - used for Mobile IP support) */
+#define SIOCSIWSPY	0x8B10		/* set spy addresses */
+#define SIOCGIWSPY	0x8B11		/* get spy info (quality of link) */
+#define SIOCSIWTHRSPY	0x8B12		/* set spy threshold (spy event) */
+#define SIOCGIWTHRSPY	0x8B13		/* get spy threshold */
+
+/* Access Point manipulation */
+#define SIOCSIWAP	0x8B14		/* set access point MAC addresses */
+#define SIOCGIWAP	0x8B15		/* get access point MAC addresses */
+#define SIOCGIWAPLIST	0x8B17		/* Deprecated in favor of scanning */
+#define SIOCSIWSCAN	0x8B18		/* trigger scanning (list cells) */
+#define SIOCGIWSCAN	0x8B19		/* get scanning results */
+
+/* 802.11 specific support */
+#define SIOCSIWESSID	0x8B1A		/* set ESSID (network name) */
+#define SIOCGIWESSID	0x8B1B		/* get ESSID */
+#define SIOCSIWNICKN	0x8B1C		/* set node name/nickname */
+#define SIOCGIWNICKN	0x8B1D		/* get node name/nickname */
+/* As the ESSID and NICKN are strings up to 32 bytes long, it doesn't fit
+ * within the 'iwreq' structure, so we need to use the 'data' member to
+ * point to a string in user space, like it is done for RANGE... */
+
+/* Other parameters useful in 802.11 and some other devices */
+#define SIOCSIWRATE	0x8B20		/* set default bit rate (bps) */
+#define SIOCGIWRATE	0x8B21		/* get default bit rate (bps) */
+#define SIOCSIWRTS	0x8B22		/* set RTS/CTS threshold (bytes) */
+#define SIOCGIWRTS	0x8B23		/* get RTS/CTS threshold (bytes) */
+#define SIOCSIWFRAG	0x8B24		/* set fragmentation thr (bytes) */
+#define SIOCGIWFRAG	0x8B25		/* get fragmentation thr (bytes) */
+#define SIOCSIWTXPOW	0x8B26		/* set transmit power (dBm) */
+#define SIOCGIWTXPOW	0x8B27		/* get transmit power (dBm) */
+#define SIOCSIWRETRY	0x8B28		/* set retry limits and lifetime */
+#define SIOCGIWRETRY	0x8B29		/* get retry limits and lifetime */
+
+/* Encoding stuff (scrambling, hardware security, WEP...) */
+#define SIOCSIWENCODE	0x8B2A		/* set encoding token & mode */
+#define SIOCGIWENCODE	0x8B2B		/* get encoding token & mode */
+/* Power saving stuff (power management, unicast and multicast) */
+#define SIOCSIWPOWER	0x8B2C		/* set Power Management settings */
+#define SIOCGIWPOWER	0x8B2D		/* get Power Management settings */
+/* Modulation bitmask */
+#define SIOCSIWMODUL	0x8B2E		/* set Modulations settings */
+#define SIOCGIWMODUL	0x8B2F		/* get Modulations settings */
+
+/* WPA : Generic IEEE 802.11 informatiom element (e.g., for WPA/RSN/WMM).
+ * This ioctl uses struct iw_point and data buffer that includes IE id and len
+ * fields. More than one IE may be included in the request. Setting the generic
+ * IE to empty buffer (len=0) removes the generic IE from the driver. Drivers
+ * are allowed to generate their own WPA/RSN IEs, but in these cases, drivers
+ * are required to report the used IE as a wireless event, e.g., when
+ * associating with an AP. */
+#define SIOCSIWGENIE	0x8B30		/* set generic IE */
+#define SIOCGIWGENIE	0x8B31		/* get generic IE */
+
+/* WPA : IEEE 802.11 MLME requests */
+#define SIOCSIWMLME	0x8B16		/* request MLME operation; uses
+					 * struct iw_mlme */
+/* WPA : Authentication mode parameters */
+#define SIOCSIWAUTH	0x8B32		/* set authentication mode params */
+#define SIOCGIWAUTH	0x8B33		/* get authentication mode params */
+
+/* WPA : Extended version of encoding configuration */
+#define SIOCSIWENCODEEXT 0x8B34		/* set encoding token & mode */
+#define SIOCGIWENCODEEXT 0x8B35		/* get encoding token & mode */
+
+/* WPA2 : PMKSA cache management */
+#define SIOCSIWPMKSA	0x8B36		/* PMKSA cache operation */
+
+/* -------------------- DEV PRIVATE IOCTL LIST -------------------- */
+
+/* These 32 ioctl are wireless device private, for 16 commands.
+ * Each driver is free to use them for whatever purpose it chooses,
+ * however the driver *must* export the description of those ioctls
+ * with SIOCGIWPRIV and *must* use arguments as defined below.
+ * If you don't follow those rules, DaveM is going to hate you (reason :
+ * it make mixed 32/64bit operation impossible).
+ */
+#define SIOCIWFIRSTPRIV	0x8BE0
+#define SIOCIWLASTPRIV	0x8BFF
+/* Previously, we were using SIOCDEVPRIVATE, but we now have our
+ * separate range because of collisions with other tools such as
+ * 'mii-tool'.
+ * We now have 32 commands, so a bit more space ;-).
+ * Also, all 'even' commands are only usable by root and don't return the
+ * content of ifr/iwr to user (but you are not obliged to use the set/get
+ * convention, just use every other two command). More details in iwpriv.c.
+ * And I repeat : you are not forced to use them with iwpriv, but you
+ * must be compliant with it.
+ */
+
+/* ------------------------- IOCTL STUFF ------------------------- */
+
+/* The first and the last (range) */
+#define SIOCIWFIRST	0x8B00
+#define SIOCIWLAST	SIOCIWLASTPRIV		/* 0x8BFF */
+#define IW_IOCTL_IDX(cmd)	((cmd) - SIOCIWFIRST)
+
+/* Odd : get (world access), even : set (root access) */
+#define IW_IS_SET(cmd)	(!((cmd) & 0x1))
+#define IW_IS_GET(cmd)	((cmd) & 0x1)
+
+/* ----------------------- WIRELESS EVENTS ----------------------- */
+/* Those are *NOT* ioctls, do not issue request on them !!! */
+/* Most events use the same identifier as ioctl requests */
+
+#define IWEVTXDROP	0x8C00		/* Packet dropped to excessive retry */
+#define IWEVQUAL	0x8C01		/* Quality part of statistics (scan) */
+#define IWEVCUSTOM	0x8C02		/* Driver specific ascii string */
+#define IWEVREGISTERED	0x8C03		/* Discovered a new node (AP mode) */
+#define IWEVEXPIRED	0x8C04		/* Expired a node (AP mode) */
+#define IWEVGENIE	0x8C05		/* Generic IE (WPA, RSN, WMM, ..)
+					 * (scan results); This includes id and
+					 * length fields. One IWEVGENIE may
+					 * contain more than one IE. Scan
+					 * results may contain one or more
+					 * IWEVGENIE events. */
+#define IWEVMICHAELMICFAILURE 0x8C06	/* Michael MIC failure
+					 * (struct iw_michaelmicfailure)
+					 */
+#define IWEVASSOCREQIE	0x8C07		/* IEs used in (Re)Association Request.
+					 * The data includes id and length
+					 * fields and may contain more than one
+					 * IE. This event is required in
+					 * Managed mode if the driver
+					 * generates its own WPA/RSN IE. This
+					 * should be sent just before
+					 * IWEVREGISTERED event for the
+					 * association. */
+#define IWEVASSOCRESPIE	0x8C08		/* IEs used in (Re)Association
+					 * Response. The data includes id and
+					 * length fields and may contain more
+					 * than one IE. This may be sent
+					 * between IWEVASSOCREQIE and
+					 * IWEVREGISTERED events for the
+					 * association. */
+#define IWEVPMKIDCAND	0x8C09		/* PMKID candidate for RSN
+					 * pre-authentication
+					 * (struct iw_pmkid_cand) */
+
+#define IWEVFIRST	0x8C00
+#define IW_EVENT_IDX(cmd)	((cmd) - IWEVFIRST)
+
+/* ------------------------- PRIVATE INFO ------------------------- */
+/*
+ * The following is used with SIOCGIWPRIV. It allow a driver to define
+ * the interface (name, type of data) for its private ioctl.
+ * Privates ioctl are SIOCIWFIRSTPRIV -> SIOCIWLASTPRIV
+ */
+
+#define IW_PRIV_TYPE_MASK	0x7000	/* Type of arguments */
+#define IW_PRIV_TYPE_NONE	0x0000
+#define IW_PRIV_TYPE_BYTE	0x1000	/* Char as number */
+#define IW_PRIV_TYPE_CHAR	0x2000	/* Char as character */
+#define IW_PRIV_TYPE_INT	0x4000	/* 32 bits int */
+#define IW_PRIV_TYPE_FLOAT	0x5000	/* struct iw_freq */
+#define IW_PRIV_TYPE_ADDR	0x6000	/* struct sockaddr */
+
+#define IW_PRIV_SIZE_FIXED	0x0800	/* Variable or fixed number of args */
+
+#define IW_PRIV_SIZE_MASK	0x07FF	/* Max number of those args */
+
+/*
+ * Note : if the number of args is fixed and the size < 16 octets,
+ * instead of passing a pointer we will put args in the iwreq struct...
+ */
+
+/* ----------------------- OTHER CONSTANTS ----------------------- */
+
+/* Maximum frequencies in the range struct */
+#define IW_MAX_FREQUENCIES	32
+/* Note : if you have something like 80 frequencies,
+ * don't increase this constant and don't fill the frequency list.
+ * The user will be able to set by channel anyway... */
+
+/* Maximum bit rates in the range struct */
+#define IW_MAX_BITRATES		32
+
+/* Maximum tx powers in the range struct */
+#define IW_MAX_TXPOWER		8
+/* Note : if you more than 8 TXPowers, just set the max and min or
+ * a few of them in the struct iw_range. */
+
+/* Maximum of address that you may set with SPY */
+#define IW_MAX_SPY		8
+
+/* Maximum of address that you may get in the
+   list of access points in range */
+#define IW_MAX_AP		64
+
+/* Maximum size of the ESSID and NICKN strings */
+#define IW_ESSID_MAX_SIZE	32
+
+/* Modes of operation */
+#define IW_MODE_AUTO	0	/* Let the driver decides */
+#define IW_MODE_ADHOC	1	/* Single cell network */
+#define IW_MODE_INFRA	2	/* Multi cell network, roaming, ... */
+#define IW_MODE_MASTER	3	/* Synchronisation master or Access Point */
+#define IW_MODE_REPEAT	4	/* Wireless Repeater (forwarder) */
+#define IW_MODE_SECOND	5	/* Secondary master/repeater (backup) */
+#define IW_MODE_MONITOR	6	/* Passive monitor (listen only) */
+
+/* Statistics flags (bitmask in updated) */
+#define IW_QUAL_QUAL_UPDATED	0x01	/* Value was updated since last read */
+#define IW_QUAL_LEVEL_UPDATED	0x02
+#define IW_QUAL_NOISE_UPDATED	0x04
+#define IW_QUAL_ALL_UPDATED	0x07
+#define IW_QUAL_DBM		0x08	/* Level + Noise are dBm */
+#define IW_QUAL_QUAL_INVALID	0x10	/* Driver doesn't provide value */
+#define IW_QUAL_LEVEL_INVALID	0x20
+#define IW_QUAL_NOISE_INVALID	0x40
+#define IW_QUAL_RCPI		0x80	/* Level + Noise are 802.11k RCPI */
+#define IW_QUAL_ALL_INVALID	0x70
+
+/* Frequency flags */
+#define IW_FREQ_AUTO		0x00	/* Let the driver decides */
+#define IW_FREQ_FIXED		0x01	/* Force a specific value */
+
+/* Maximum number of size of encoding token available
+ * they are listed in the range structure */
+#define IW_MAX_ENCODING_SIZES	8
+
+/* Maximum size of the encoding token in bytes */
+#define IW_ENCODING_TOKEN_MAX	64	/* 512 bits (for now) */
+
+/* Flags for encoding (along with the token) */
+#define IW_ENCODE_INDEX		0x00FF	/* Token index (if needed) */
+#define IW_ENCODE_FLAGS		0xFF00	/* Flags defined below */
+#define IW_ENCODE_MODE		0xF000	/* Modes defined below */
+#define IW_ENCODE_DISABLED	0x8000	/* Encoding disabled */
+#define IW_ENCODE_ENABLED	0x0000	/* Encoding enabled */
+#define IW_ENCODE_RESTRICTED	0x4000	/* Refuse non-encoded packets */
+#define IW_ENCODE_OPEN		0x2000	/* Accept non-encoded packets */
+#define IW_ENCODE_NOKEY		0x0800  /* Key is write only, so not present */
+#define IW_ENCODE_TEMP		0x0400  /* Temporary key */
+
+/* Power management flags available (along with the value, if any) */
+#define IW_POWER_ON		0x0000	/* No details... */
+#define IW_POWER_TYPE		0xF000	/* Type of parameter */
+#define IW_POWER_PERIOD		0x1000	/* Value is a period/duration of  */
+#define IW_POWER_TIMEOUT	0x2000	/* Value is a timeout (to go asleep) */
+#define IW_POWER_SAVING		0x4000	/* Value is relative (how aggressive)*/
+#define IW_POWER_MODE		0x0F00	/* Power Management mode */
+#define IW_POWER_UNICAST_R	0x0100	/* Receive only unicast messages */
+#define IW_POWER_MULTICAST_R	0x0200	/* Receive only multicast messages */
+#define IW_POWER_ALL_R		0x0300	/* Receive all messages though PM */
+#define IW_POWER_FORCE_S	0x0400	/* Force PM procedure for sending unicast */
+#define IW_POWER_REPEATER	0x0800	/* Repeat broadcast messages in PM period */
+#define IW_POWER_MODIFIER	0x000F	/* Modify a parameter */
+#define IW_POWER_MIN		0x0001	/* Value is a minimum  */
+#define IW_POWER_MAX		0x0002	/* Value is a maximum */
+#define IW_POWER_RELATIVE	0x0004	/* Value is not in seconds/ms/us */
+
+/* Transmit Power flags available */
+#define IW_TXPOW_TYPE		0x00FF	/* Type of value */
+#define IW_TXPOW_DBM		0x0000	/* Value is in dBm */
+#define IW_TXPOW_MWATT		0x0001	/* Value is in mW */
+#define IW_TXPOW_RELATIVE	0x0002	/* Value is in arbitrary units */
+#define IW_TXPOW_RANGE		0x1000	/* Range of value between min/max */
+
+/* Retry limits and lifetime flags available */
+#define IW_RETRY_ON		0x0000	/* No details... */
+#define IW_RETRY_TYPE		0xF000	/* Type of parameter */
+#define IW_RETRY_LIMIT		0x1000	/* Maximum number of retries*/
+#define IW_RETRY_LIFETIME	0x2000	/* Maximum duration of retries in us */
+#define IW_RETRY_MODIFIER	0x00FF	/* Modify a parameter */
+#define IW_RETRY_MIN		0x0001	/* Value is a minimum  */
+#define IW_RETRY_MAX		0x0002	/* Value is a maximum */
+#define IW_RETRY_RELATIVE	0x0004	/* Value is not in seconds/ms/us */
+#define IW_RETRY_SHORT		0x0010	/* Value is for short packets  */
+#define IW_RETRY_LONG		0x0020	/* Value is for long packets */
+
+/* Scanning request flags */
+#define IW_SCAN_DEFAULT		0x0000	/* Default scan of the driver */
+#define IW_SCAN_ALL_ESSID	0x0001	/* Scan all ESSIDs */
+#define IW_SCAN_THIS_ESSID	0x0002	/* Scan only this ESSID */
+#define IW_SCAN_ALL_FREQ	0x0004	/* Scan all Frequencies */
+#define IW_SCAN_THIS_FREQ	0x0008	/* Scan only this Frequency */
+#define IW_SCAN_ALL_MODE	0x0010	/* Scan all Modes */
+#define IW_SCAN_THIS_MODE	0x0020	/* Scan only this Mode */
+#define IW_SCAN_ALL_RATE	0x0040	/* Scan all Bit-Rates */
+#define IW_SCAN_THIS_RATE	0x0080	/* Scan only this Bit-Rate */
+/* struct iw_scan_req scan_type */
+#define IW_SCAN_TYPE_ACTIVE 0
+#define IW_SCAN_TYPE_PASSIVE 1
+/* Maximum size of returned data */
+#define IW_SCAN_MAX_DATA	IW_SCAN_MAX_DATA	/* In bytes */
+
+/* Max number of char in custom event - use multiple of them if needed */
+#define IW_CUSTOM_MAX		256	/* In bytes */
+
+/* Generic information element */
+#define IW_GENERIC_IE_MAX	1024
+
+/* MLME requests (SIOCSIWMLME / struct iw_mlme) */
+#define IW_MLME_DEAUTH		0
+#define IW_MLME_DISASSOC	1
+#define IW_MLME_AUTH		2
+#define IW_MLME_ASSOC		3
+
+/* SIOCSIWAUTH/SIOCGIWAUTH struct iw_param flags */
+#define IW_AUTH_INDEX		0x0FFF
+#define IW_AUTH_FLAGS		0xF000
+/* SIOCSIWAUTH/SIOCGIWAUTH parameters (0 .. 4095)
+ * (IW_AUTH_INDEX mask in struct iw_param flags; this is the index of the
+ * parameter that is being set/get to; value will be read/written to
+ * struct iw_param value field) */
+#define IW_AUTH_WPA_VERSION		0
+#define IW_AUTH_CIPHER_PAIRWISE		1
+#define IW_AUTH_CIPHER_GROUP		2
+#define IW_AUTH_KEY_MGMT		3
+#define IW_AUTH_TKIP_COUNTERMEASURES	4
+#define IW_AUTH_DROP_UNENCRYPTED	5
+#define IW_AUTH_80211_AUTH_ALG		6
+#define IW_AUTH_WPA_ENABLED		7
+#define IW_AUTH_RX_UNENCRYPTED_EAPOL	8
+#define IW_AUTH_ROAMING_CONTROL		9
+#define IW_AUTH_PRIVACY_INVOKED		10
+
+/* IW_AUTH_WPA_VERSION values (bit field) */
+#define IW_AUTH_WPA_VERSION_DISABLED	0x00000001
+#define IW_AUTH_WPA_VERSION_WPA		0x00000002
+#define IW_AUTH_WPA_VERSION_WPA2	0x00000004
+
+/* IW_AUTH_PAIRWISE_CIPHER and IW_AUTH_GROUP_CIPHER values (bit field) */
+#define IW_AUTH_CIPHER_NONE	0x00000001
+#define IW_AUTH_CIPHER_WEP40	0x00000002
+#define IW_AUTH_CIPHER_TKIP	0x00000004
+#define IW_AUTH_CIPHER_CCMP	0x00000008
+#define IW_AUTH_CIPHER_WEP104	0x00000010
+
+/* IW_AUTH_KEY_MGMT values (bit field) */
+#define IW_AUTH_KEY_MGMT_802_1X	1
+#define IW_AUTH_KEY_MGMT_PSK	2
+
+/* IW_AUTH_80211_AUTH_ALG values (bit field) */
+#define IW_AUTH_ALG_OPEN_SYSTEM	0x00000001
+#define IW_AUTH_ALG_SHARED_KEY	0x00000002
+#define IW_AUTH_ALG_LEAP	0x00000004
+
+/* IW_AUTH_ROAMING_CONTROL values */
+#define IW_AUTH_ROAMING_ENABLE	0	/* driver/firmware based roaming */
+#define IW_AUTH_ROAMING_DISABLE	1	/* user space program used for roaming
+					 * control */
+
+/* SIOCSIWENCODEEXT definitions */
+#define IW_ENCODE_SEQ_MAX_SIZE	8
+/* struct iw_encode_ext ->alg */
+#define IW_ENCODE_ALG_NONE	0
+#define IW_ENCODE_ALG_WEP	1
+#define IW_ENCODE_ALG_TKIP	2
+#define IW_ENCODE_ALG_CCMP	3
+/* struct iw_encode_ext ->ext_flags */
+#define IW_ENCODE_EXT_TX_SEQ_VALID	0x00000001
+#define IW_ENCODE_EXT_RX_SEQ_VALID	0x00000002
+#define IW_ENCODE_EXT_GROUP_KEY		0x00000004
+#define IW_ENCODE_EXT_SET_TX_KEY	0x00000008
+
+/* IWEVMICHAELMICFAILURE : struct iw_michaelmicfailure ->flags */
+#define IW_MICFAILURE_KEY_ID	0x00000003 /* Key ID 0..3 */
+#define IW_MICFAILURE_GROUP	0x00000004
+#define IW_MICFAILURE_PAIRWISE	0x00000008
+#define IW_MICFAILURE_STAKEY	0x00000010
+#define IW_MICFAILURE_COUNT	0x00000060 /* 1 or 2 (0 = count not supported)
+					    */
+
+/* Bit field values for enc_capa in struct iw_range */
+#define IW_ENC_CAPA_WPA		0x00000001
+#define IW_ENC_CAPA_WPA2	0x00000002
+#define IW_ENC_CAPA_CIPHER_TKIP	0x00000004
+#define IW_ENC_CAPA_CIPHER_CCMP	0x00000008
+
+/* Event capability macros - in (struct iw_range *)->event_capa
+ * Because we have more than 32 possible events, we use an array of
+ * 32 bit bitmasks. Note : 32 bits = 0x20 = 2^5. */
+#define IW_EVENT_CAPA_BASE(cmd)		((cmd >= SIOCIWFIRSTPRIV) ? \
+					 (cmd - SIOCIWFIRSTPRIV + 0x60) : \
+					 (cmd - SIOCSIWCOMMIT))
+#define IW_EVENT_CAPA_INDEX(cmd)	(IW_EVENT_CAPA_BASE(cmd) >> 5)
+#define IW_EVENT_CAPA_MASK(cmd)		(1 << (IW_EVENT_CAPA_BASE(cmd) & 0x1F))
+/* Event capability constants - event autogenerated by the kernel
+ * This list is valid for most 802.11 devices, customise as needed... */
+#define IW_EVENT_CAPA_K_0	(IW_EVENT_CAPA_MASK(0x8B04) | \
+				 IW_EVENT_CAPA_MASK(0x8B06) | \
+				 IW_EVENT_CAPA_MASK(0x8B1A))
+#define IW_EVENT_CAPA_K_1	(IW_EVENT_CAPA_MASK(0x8B2A))
+/* "Easy" macro to set events in iw_range (less efficient) */
+#define IW_EVENT_CAPA_SET(event_capa, cmd) (event_capa[IW_EVENT_CAPA_INDEX(cmd)] |= IW_EVENT_CAPA_MASK(cmd))
+#define IW_EVENT_CAPA_SET_KERNEL(event_capa) {event_capa[0] |= IW_EVENT_CAPA_K_0; event_capa[1] |= IW_EVENT_CAPA_K_1; }
+
+/* Modulations bitmasks */
+#define IW_MODUL_ALL		0x00000000	/* Everything supported */
+#define IW_MODUL_FH		0x00000001	/* Frequency Hopping */
+#define IW_MODUL_DS		0x00000002	/* Original Direct Sequence */
+#define IW_MODUL_CCK		0x00000004	/* 802.11b : 5.5 + 11 Mb/s */
+#define IW_MODUL_11B		(IW_MODUL_DS | IW_MODUL_CCK)
+#define IW_MODUL_PBCC		0x00000008	/* TI : 5.5 + 11 + 22 Mb/s */
+#define IW_MODUL_OFDM_A		0x00000010	/* 802.11a : 54 Mb/s */
+#define IW_MODUL_11A		(IW_MODUL_OFDM_A)
+#define IW_MODUL_11AB		(IW_MODUL_11B | IW_MODUL_11A)
+#define IW_MODUL_OFDM_G		0x00000020	/* 802.11g : 54 Mb/s */
+#define IW_MODUL_11G		(IW_MODUL_11B | IW_MODUL_OFDM_G)
+#define IW_MODUL_11AG		(IW_MODUL_11G | IW_MODUL_11A)
+#define IW_MODUL_TURBO		0x00000040	/* ATH : bonding, 108 Mb/s */
+/* In here we should define MIMO stuff. Later... */
+#define IW_MODUL_CUSTOM		0x40000000	/* Driver specific */
+
+/* Bitrate flags available */
+#define IW_BITRATE_TYPE		0x00FF	/* Type of value */
+#define IW_BITRATE_UNICAST	0x0001	/* Maximum/Fixed unicast bitrate */
+#define IW_BITRATE_BROADCAST	0x0002	/* Fixed broadcast bitrate */
+
+/****************************** TYPES ******************************/
+
+/* --------------------------- SUBTYPES --------------------------- */
+/*
+ *	Generic format for most parameters that fit in an int
+ */
+struct	iw_param
+{
+  __s32		value;		/* The value of the parameter itself */
+  __u8		fixed;		/* Hardware should not use auto select */
+  __u8		disabled;	/* Disable the feature */
+  __u16		flags;		/* Various specifc flags (if any) */
+};
+
+/*
+ *	For all data larger than 16 octets, we need to use a
+ *	pointer to memory allocated in user space.
+ */
+struct	iw_point
+{
+  void __user	*pointer;	/* Pointer to the data  (in user space) */
+  __u16		length;		/* number of fields or size in bytes */
+  __u16		flags;		/* Optional params */
+};
+
+/*
+ *	A frequency
+ *	For numbers lower than 10^9, we encode the number in 'm' and
+ *	set 'e' to 0
+ *	For number greater than 10^9, we divide it by the lowest power
+ *	of 10 to get 'm' lower than 10^9, with 'm'= f / (10^'e')...
+ *	The power of 10 is in 'e', the result of the division is in 'm'.
+ */
+struct	iw_freq
+{
+	__s32		m;		/* Mantissa */
+	__s16		e;		/* Exponent */
+	__u8		i;		/* List index (when in range struct) */
+	__u8		flags;		/* Flags (fixed/auto) */
+};
+
+/*
+ *	Quality of the link
+ */
+struct	iw_quality
+{
+	__u8		qual;		/* link quality (%retries, SNR,
+					   %missed beacons or better...) */
+	__u8		level;		/* signal level (dBm) */
+	__u8		noise;		/* noise level (dBm) */
+	__u8		updated;	/* Flags to know if updated */
+};
+
+/*
+ *	Packet discarded in the wireless adapter due to
+ *	"wireless" specific problems...
+ *	Note : the list of counter and statistics in net_device_stats
+ *	is already pretty exhaustive, and you should use that first.
+ *	This is only additional stats...
+ */
+struct	iw_discarded
+{
+	__u32		nwid;		/* Rx : Wrong nwid/essid */
+	__u32		code;		/* Rx : Unable to code/decode (WEP) */
+	__u32		fragment;	/* Rx : Can't perform MAC reassembly */
+	__u32		retries;	/* Tx : Max MAC retries num reached */
+	__u32		misc;		/* Others cases */
+};
+
+/*
+ *	Packet/Time period missed in the wireless adapter due to
+ *	"wireless" specific problems...
+ */
+struct	iw_missed
+{
+	__u32		beacon;		/* Missed beacons/superframe */
+};
+
+/*
+ *	Quality range (for spy threshold)
+ */
+struct	iw_thrspy
+{
+	struct sockaddr		addr;		/* Source address (hw/mac) */
+	struct iw_quality	qual;		/* Quality of the link */
+	struct iw_quality	low;		/* Low threshold */
+	struct iw_quality	high;		/* High threshold */
+};
+
+/*
+ *	Optional data for scan request
+ *
+ *	Note: these optional parameters are controlling parameters for the
+ *	scanning behavior, these do not apply to getting scan results
+ *	(SIOCGIWSCAN). Drivers are expected to keep a local BSS table and
+ *	provide a merged results with all BSSes even if the previous scan
+ *	request limited scanning to a subset, e.g., by specifying an SSID.
+ *	Especially, scan results are required to include an entry for the
+ *	current BSS if the driver is in Managed mode and associated with an AP.
+ */
+struct	iw_scan_req
+{
+	__u8		scan_type; /* IW_SCAN_TYPE_{ACTIVE,PASSIVE} */
+	__u8		essid_len;
+	__u8		num_channels; /* num entries in channel_list;
+				       * 0 = scan all allowed channels */
+	__u8		flags; /* reserved as padding; use zero, this may
+				* be used in the future for adding flags
+				* to request different scan behavior */
+	struct sockaddr	bssid; /* ff:ff:ff:ff:ff:ff for broadcast BSSID or
+				* individual address of a specific BSS */
+
+	/*
+	 * Use this ESSID if IW_SCAN_THIS_ESSID flag is used instead of using
+	 * the current ESSID. This allows scan requests for specific ESSID
+	 * without having to change the current ESSID and potentially breaking
+	 * the current association.
+	 */
+	__u8		essid[IW_ESSID_MAX_SIZE];
+
+	/*
+	 * Optional parameters for changing the default scanning behavior.
+	 * These are based on the MLME-SCAN.request from IEEE Std 802.11.
+	 * TU is 1.024 ms. If these are set to 0, driver is expected to use
+	 * reasonable default values. min_channel_time defines the time that
+	 * will be used to wait for the first reply on each channel. If no
+	 * replies are received, next channel will be scanned after this. If
+	 * replies are received, total time waited on the channel is defined by
+	 * max_channel_time.
+	 */
+	__u32		min_channel_time; /* in TU */
+	__u32		max_channel_time; /* in TU */
+
+	struct iw_freq	channel_list[IW_MAX_FREQUENCIES];
+};
+
+/* ------------------------- WPA SUPPORT ------------------------- */
+
+/*
+ *	Extended data structure for get/set encoding (this is used with
+ *	SIOCSIWENCODEEXT/SIOCGIWENCODEEXT. struct iw_point and IW_ENCODE_*
+ *	flags are used in the same way as with SIOCSIWENCODE/SIOCGIWENCODE and
+ *	only the data contents changes (key data -> this structure, including
+ *	key data).
+ *
+ *	If the new key is the first group key, it will be set as the default
+ *	TX key. Otherwise, default TX key index is only changed if
+ *	IW_ENCODE_EXT_SET_TX_KEY flag is set.
+ *
+ *	Key will be changed with SIOCSIWENCODEEXT in all cases except for
+ *	special "change TX key index" operation which is indicated by setting
+ *	key_len = 0 and ext_flags |= IW_ENCODE_EXT_SET_TX_KEY.
+ *
+ *	tx_seq/rx_seq are only used when respective
+ *	IW_ENCODE_EXT_{TX,RX}_SEQ_VALID flag is set in ext_flags. Normal
+ *	TKIP/CCMP operation is to set RX seq with SIOCSIWENCODEEXT and start
+ *	TX seq from zero whenever key is changed. SIOCGIWENCODEEXT is normally
+ *	used only by an Authenticator (AP or an IBSS station) to get the
+ *	current TX sequence number. Using TX_SEQ_VALID for SIOCSIWENCODEEXT and
+ *	RX_SEQ_VALID for SIOCGIWENCODEEXT are optional, but can be useful for
+ *	debugging/testing.
+ */
+struct	iw_encode_ext
+{
+	__u32		ext_flags; /* IW_ENCODE_EXT_* */
+	__u8		tx_seq[IW_ENCODE_SEQ_MAX_SIZE]; /* LSB first */
+	__u8		rx_seq[IW_ENCODE_SEQ_MAX_SIZE]; /* LSB first */
+	struct sockaddr	addr; /* ff:ff:ff:ff:ff:ff for broadcast/multicast
+			       * (group) keys or unicast address for
+			       * individual keys */
+	__u16		alg; /* IW_ENCODE_ALG_* */
+	__u16		key_len;
+	__u8		key[0];
+};
+
+/* SIOCSIWMLME data */
+struct	iw_mlme
+{
+	__u16		cmd; /* IW_MLME_* */
+	__u16		reason_code;
+	struct sockaddr	addr;
+};
+
+/* SIOCSIWPMKSA data */
+#define IW_PMKSA_ADD		1
+#define IW_PMKSA_REMOVE		2
+#define IW_PMKSA_FLUSH		3
+
+#define IW_PMKID_LEN	16
+
+struct	iw_pmksa
+{
+	__u32		cmd; /* IW_PMKSA_* */
+	struct sockaddr	bssid;
+	__u8		pmkid[IW_PMKID_LEN];
+};
+
+/* IWEVMICHAELMICFAILURE data */
+struct	iw_michaelmicfailure
+{
+	__u32		flags;
+	struct sockaddr	src_addr;
+	__u8		tsc[IW_ENCODE_SEQ_MAX_SIZE]; /* LSB first */
+};
+
+/* IWEVPMKIDCAND data */
+#define IW_PMKID_CAND_PREAUTH	0x00000001 /* RNS pre-authentication enabled */
+struct	iw_pmkid_cand
+{
+	__u32		flags; /* IW_PMKID_CAND_* */
+	__u32		index; /* the smaller the index, the higher the
+				* priority */
+	struct sockaddr	bssid;
+};
+
+/* ------------------------ WIRELESS STATS ------------------------ */
+/*
+ * Wireless statistics (used for /proc/net/wireless)
+ */
+struct	iw_statistics
+{
+	__u16		status;		/* Status
+					 * - device dependent for now */
+
+	struct iw_quality	qual;		/* Quality of the link
+						 * (instant/mean/max) */
+	struct iw_discarded	discard;	/* Packet discarded counts */
+	struct iw_missed	miss;		/* Packet missed counts */
+};
+
+/* ------------------------ IOCTL REQUEST ------------------------ */
+/*
+ * This structure defines the payload of an ioctl, and is used 
+ * below.
+ *
+ * Note that this structure should fit on the memory footprint
+ * of iwreq (which is the same as ifreq), which mean a max size of
+ * 16 octets = 128 bits. Warning, pointers might be 64 bits wide...
+ * You should check this when increasing the structures defined
+ * above in this file...
+ */
+union	iwreq_data
+{
+	/* Config - generic */
+	char		name[IFNAMSIZ];
+	/* Name : used to verify the presence of  wireless extensions.
+	 * Name of the protocol/provider... */
+
+	struct iw_point	essid;		/* Extended network name */
+	struct iw_param	nwid;		/* network id (or domain - the cell) */
+	struct iw_freq	freq;		/* frequency or channel :
+					 * 0-1000 = channel
+					 * > 1000 = frequency in Hz */
+
+	struct iw_param	sens;		/* signal level threshold */
+	struct iw_param	bitrate;	/* default bit rate */
+	struct iw_param	txpower;	/* default transmit power */
+	struct iw_param	rts;		/* RTS threshold threshold */
+	struct iw_param	frag;		/* Fragmentation threshold */
+	__u32		mode;		/* Operation mode */
+	struct iw_param	retry;		/* Retry limits & lifetime */
+
+	struct iw_point	encoding;	/* Encoding stuff : tokens */
+	struct iw_param	power;		/* PM duration/timeout */
+	struct iw_quality qual;		/* Quality part of statistics */
+
+	struct sockaddr	ap_addr;	/* Access point address */
+	struct sockaddr	addr;		/* Destination address (hw/mac) */
+
+	struct iw_param	param;		/* Other small parameters */
+	struct iw_point	data;		/* Other large parameters */
+};
+
+/*
+ * The structure to exchange data for ioctl.
+ * This structure is the same as 'struct ifreq', but (re)defined for
+ * convenience...
+ * Do I need to remind you about structure size (32 octets) ?
+ */
+struct	iwreq 
+{
+	union
+	{
+		char	ifrn_name[IFNAMSIZ];	/* if name, e.g. "eth0" */
+	} ifr_ifrn;
+
+	/* Data part (defined just above) */
+	union	iwreq_data	u;
+};
+
+/* -------------------------- IOCTL DATA -------------------------- */
+/*
+ *	For those ioctl which want to exchange mode data that what could
+ *	fit in the above structure...
+ */
+
+/*
+ *	Range of parameters
+ */
+
+struct	iw_range
+{
+	/* Informative stuff (to choose between different interface) */
+	__u32		throughput;	/* To give an idea... */
+	/* In theory this value should be the maximum benchmarked
+	 * TCP/IP throughput, because with most of these devices the
+	 * bit rate is meaningless (overhead an co) to estimate how
+	 * fast the connection will go and pick the fastest one.
+	 * I suggest people to play with Netperf or any benchmark...
+	 */
+
+	/* NWID (or domain id) */
+	__u32		min_nwid;	/* Minimal NWID we are able to set */
+	__u32		max_nwid;	/* Maximal NWID we are able to set */
+
+	/* Old Frequency (backward compat - moved lower ) */
+	__u16		old_num_channels;
+	__u8		old_num_frequency;
+
+	/* Wireless event capability bitmasks */
+	__u32		event_capa[6];
+
+	/* signal level threshold range */
+	__s32		sensitivity;
+
+	/* Quality of link & SNR stuff */
+	/* Quality range (link, level, noise)
+	 * If the quality is absolute, it will be in the range [0 ; max_qual],
+	 * if the quality is dBm, it will be in the range [max_qual ; 0].
+	 * Don't forget that we use 8 bit arithmetics... */
+	struct iw_quality	max_qual;	/* Quality of the link */
+	/* This should contain the average/typical values of the quality
+	 * indicator. This should be the threshold between a "good" and
+	 * a "bad" link (example : monitor going from green to orange).
+	 * Currently, user space apps like quality monitors don't have any
+	 * way to calibrate the measurement. With this, they can split
+	 * the range between 0 and max_qual in different quality level
+	 * (using a geometric subdivision centered on the average).
+	 * I expect that people doing the user space apps will feedback
+	 * us on which value we need to put in each driver... */
+	struct iw_quality	avg_qual;	/* Quality of the link */
+
+	/* Rates */
+	__u8		num_bitrates;	/* Number of entries in the list */
+	__s32		bitrate[IW_MAX_BITRATES];	/* list, in bps */
+
+	/* RTS threshold */
+	__s32		min_rts;	/* Minimal RTS threshold */
+	__s32		max_rts;	/* Maximal RTS threshold */
+
+	/* Frag threshold */
+	__s32		min_frag;	/* Minimal frag threshold */
+	__s32		max_frag;	/* Maximal frag threshold */
+
+	/* Power Management duration & timeout */
+	__s32		min_pmp;	/* Minimal PM period */
+	__s32		max_pmp;	/* Maximal PM period */
+	__s32		min_pmt;	/* Minimal PM timeout */
+	__s32		max_pmt;	/* Maximal PM timeout */
+	__u16		pmp_flags;	/* How to decode max/min PM period */
+	__u16		pmt_flags;	/* How to decode max/min PM timeout */
+	__u16		pm_capa;	/* What PM options are supported */
+
+	/* Encoder stuff */
+	__u16	encoding_size[IW_MAX_ENCODING_SIZES];	/* Different token sizes */
+	__u8	num_encoding_sizes;	/* Number of entry in the list */
+	__u8	max_encoding_tokens;	/* Max number of tokens */
+	/* For drivers that need a "login/passwd" form */
+	__u8	encoding_login_index;	/* token index for login token */
+
+	/* Transmit power */
+	__u16		txpower_capa;	/* What options are supported */
+	__u8		num_txpower;	/* Number of entries in the list */
+	__s32		txpower[IW_MAX_TXPOWER];	/* list, in bps */
+
+	/* Wireless Extension version info */
+	__u8		we_version_compiled;	/* Must be WIRELESS_EXT */
+	__u8		we_version_source;	/* Last update of source */
+
+	/* Retry limits and lifetime */
+	__u16		retry_capa;	/* What retry options are supported */
+	__u16		retry_flags;	/* How to decode max/min retry limit */
+	__u16		r_time_flags;	/* How to decode max/min retry life */
+	__s32		min_retry;	/* Minimal number of retries */
+	__s32		max_retry;	/* Maximal number of retries */
+	__s32		min_r_time;	/* Minimal retry lifetime */
+	__s32		max_r_time;	/* Maximal retry lifetime */
+
+	/* Frequency */
+	__u16		num_channels;	/* Number of channels [0; num - 1] */
+	__u8		num_frequency;	/* Number of entry in the list */
+	struct iw_freq	freq[IW_MAX_FREQUENCIES];	/* list */
+	/* Note : this frequency list doesn't need to fit channel numbers,
+	 * because each entry contain its channel index */
+
+	__u32		enc_capa;	/* IW_ENC_CAPA_* bit field */
+
+	/* More power management stuff */
+	__s32		min_pms;	/* Minimal PM saving */
+	__s32		max_pms;	/* Maximal PM saving */
+	__u16		pms_flags;	/* How to decode max/min PM saving */
+
+	/* All available modulations for driver (hw may support less) */
+	__s32		modul_capa;	/* IW_MODUL_* bit field */
+
+	/* More bitrate stuff */
+	__u32		bitrate_capa;	/* Types of bitrates supported */
+};
+
+/*
+ * Private ioctl interface information
+ */
+ 
+struct	iw_priv_args
+{
+	__u32		cmd;		/* Number of the ioctl to issue */
+	__u16		set_args;	/* Type and number of args */
+	__u16		get_args;	/* Type and number of args */
+	char		name[IFNAMSIZ];	/* Name of the extension */
+};
+
+/* ----------------------- WIRELESS EVENTS ----------------------- */
+/*
+ * Wireless events are carried through the rtnetlink socket to user
+ * space. They are encapsulated in the IFLA_WIRELESS field of
+ * a RTM_NEWLINK message.
+ */
+
+/*
+ * A Wireless Event. Contains basically the same data as the ioctl...
+ */
+struct iw_event
+{
+	__u16		len;			/* Real lenght of this stuff */
+	__u16		cmd;			/* Wireless IOCTL */
+	union iwreq_data	u;		/* IOCTL fixed payload */
+};
+
+/* Size of the Event prefix (including padding and alignement junk) */
+#define IW_EV_LCP_LEN	(sizeof(struct iw_event) - sizeof(union iwreq_data))
+/* Size of the various events */
+#define IW_EV_CHAR_LEN	(IW_EV_LCP_LEN + IFNAMSIZ)
+#define IW_EV_UINT_LEN	(IW_EV_LCP_LEN + sizeof(__u32))
+#define IW_EV_FREQ_LEN	(IW_EV_LCP_LEN + sizeof(struct iw_freq))
+#define IW_EV_PARAM_LEN	(IW_EV_LCP_LEN + sizeof(struct iw_param))
+#define IW_EV_ADDR_LEN	(IW_EV_LCP_LEN + sizeof(struct sockaddr))
+#define IW_EV_QUAL_LEN	(IW_EV_LCP_LEN + sizeof(struct iw_quality))
+
+/* iw_point events are special. First, the payload (extra data) come at
+ * the end of the event, so they are bigger than IW_EV_POINT_LEN. Second,
+ * we omit the pointer, so start at an offset. */
+#define IW_EV_POINT_OFF (((char *) &(((struct iw_point *) NULL)->length)) - \
+			  (char *) NULL)
+#define IW_EV_POINT_LEN	(IW_EV_LCP_LEN + sizeof(struct iw_point) - \
+			 IW_EV_POINT_OFF)
+
+/* Size of the Event prefix when packed in stream */
+#define IW_EV_LCP_PK_LEN	(4)
+/* Size of the various events when packed in stream */
+#define IW_EV_CHAR_PK_LEN	(IW_EV_LCP_PK_LEN + IFNAMSIZ)
+#define IW_EV_UINT_PK_LEN	(IW_EV_LCP_PK_LEN + sizeof(__u32))
+#define IW_EV_FREQ_PK_LEN	(IW_EV_LCP_PK_LEN + sizeof(struct iw_freq))
+#define IW_EV_PARAM_PK_LEN	(IW_EV_LCP_PK_LEN + sizeof(struct iw_param))
+#define IW_EV_ADDR_PK_LEN	(IW_EV_LCP_PK_LEN + sizeof(struct sockaddr))
+#define IW_EV_QUAL_PK_LEN	(IW_EV_LCP_PK_LEN + sizeof(struct iw_quality))
+#define IW_EV_POINT_PK_LEN	(IW_EV_LCP_LEN + 4)
+
+#endif	/* _LINUX_WIRELESS_H */
diff --git a/wireless.7 b/wireless.7
new file mode 100644
index 0000000..7d51dc7
--- /dev/null
+++ b/wireless.7
@@ -0,0 +1,128 @@
+.\" Jean Tourrilhes - HPL - 2002 - 2004
+.\" wireless.7
+.\"
+.TH WIRELESS 7 "4 March 2004" "wireless-tools" "Linux Programmer's Manual"
+.\"
+.\" NAME part
+.\"
+.SH NAME
+wireless \- Wireless Tools and Wireless Extensions
+.\"
+.\" SYNOPSIS part
+.\"
+.SH SYNOPSIS
+.B iwconfig
+.br
+.B iwpriv \-a
+.br
+.\"
+.\" DESCRIPTION part
+.\"
+.SH DESCRIPTION
+The
+.B Wireless Extensions
+is an API allowing you manipulate Wireless LAN networking interfaces.
+It is composed of a variety of tools and configuration files. It is
+documented in more detail in the Linux Wireless LAN Howto.
+.br
+The
+.B Wireless Tools
+are used to change the configuration of wireless LAN networking
+interfaces on the fly, to get their current configuration, to get
+statistics and diagnose them. They are described in their own man
+page, see below for references.
+.br
+.B Wireless configuration
+is specific to each Linux distribution. This man page will contain in
+the future the configuration procedure for a few common
+distributions. For the time being, check the file DISTRIBUTIONS.txt
+included with the Wireless Tools package.
+.\"
+.\" DEBIAN 3.0 part
+.\"
+.SH DEBIAN 3.0
+In Debian 3.0 (and later) you can configure wireless LAN networking
+devices using the network configuration tool
+.BR ifupdown (8).
+.TP
+.B File :
+.I /etc/network/interfaces
+.TP
+.B Form :
+.RI wireless\- "<function> <value>"
+.br
+wireless\-essid Home
+.br
+wireless\-mode Ad\-Hoc
+.TP
+.B See also :
+.I /etc/network/if\-pre\-up.d/wireless\-tools
+.br
+.I /usr/share/doc/wireless\-tools/README.Debian
+.\"
+.\" SuSE 8.0 part
+.\"
+.SH SuSE 8.0
+SuSE 8.0 (and later) has integrated wireless configuration in their
+network scripts.
+.TP
+.B Tool :
+.B Yast2
+.TP
+.B File :
+.I /etc/sysconfig/network/wireless
+.br
+.I /etc/sysconfig/network/ifcfg\-*
+.TP
+.B Form :
+.RI WIRELESS_ "<function>" = "<value>"
+.br
+WIRELESS_ESSID="Home"
+.br
+WIRELESS_MODE=Ad\-Hoc
+.TP
+.B See also :
+man ifup
+.br
+info scpm
+.\"
+.\" PCMCIA part
+.\"
+.SH ORIGINAL PCMCIA SCRIPTS
+If you are using the original configuration scripts from the Pcmcia
+package, you can use this method.
+.TP
+.B File :
+.I /etc/pcmcia/wireless.opts
+.TP
+.B Form :
+*,*,*,*)
+.br
+    ESSID="Home"
+.br
+    MODE="Ad-Hoc"
+.br
+    ;;
+.TP
+.B See also :
+.I /etc/pcmcia/wireless
+.br
+File
+.I PCMCIA.txt
+part of Wireless Tools package
+.\"
+.\" AUTHOR part
+.\"
+.SH AUTHOR
+Jean Tourrilhes \- jt@hpl.hp.com
+.br
+.I http://www.hpl.hp.com/personal/Jean_Tourrilhes/Linux/
+.\"
+.\" SEE ALSO part
+.\"
+.SH SEE ALSO
+.BR iwconfig (8),
+.BR iwlist (8),
+.BR iwspy (8),
+.BR iwpriv (8),
+.BR iwevent (8).
-- 
1.9.1

