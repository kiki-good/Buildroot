diff -Naur ltp-full-20070228_orig/testcases/additional/multicast/Makefile ltp-full-20070228/testcases/additional/multicast/Makefile
--- ltp-full-20070228_orig/testcases/additional/multicast/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ ltp-full-20070228/testcases/additional/multicast/Makefile	2009-08-02 17:00:25.000000000 +0100
@@ -0,0 +1,31 @@
+#
+#  Copyright (c) International Business Machines  Corp., 2001
+#
+#  This program is free software;  you can redistribute it and/or modify
+#  it under the terms of the GNU General Public License as published by
+#  the Free Software Foundation; either version 2 of the License, or
+#  (at your option) any later version.
+#
+#  This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY;  without even the implied warranty of
+#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
+#  the GNU General Public License for more details.
+#
+#  You should have received a copy of the GNU General Public License
+#  along with this program;  if not, write to the Free Software
+#  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+#
+
+CFLAGS += -I../../../include -Wall
+LDLIBS += -L../../../lib -lltp -lpthread
+
+SRCS    = $(wildcard *.c)
+TARGETS = $(patsubst %.c,%,$(SRCS))
+
+all: $(TARGETS)
+
+install:
+	@set -e; for i in $(TARGETS); do ln -f $$i ../../bin/$$i ; done
+
+clean:
+	rm -f $(TARGETS)
diff -Naur ltp-full-20070228_orig/testcases/additional/multicast/multicast.c ltp-full-20070228/testcases/additional/multicast/multicast.c
--- ltp-full-20070228_orig/testcases/additional/multicast/multicast.c	1970-01-01 01:00:00.000000000 +0100
+++ ltp-full-20070228/testcases/additional/multicast/multicast.c	2009-08-03 16:23:43.000000000 +0100
@@ -0,0 +1,275 @@
+/*
+ *
+ *   Copyright (c) bSkyb 2009
+ *
+ */
+
+
+/*
+ * NAME
+ *	multicast
+ *
+ * CALLS
+ *	-
+ *
+ * ALGORITHM
+ 
+ *      This test is ensures that TCP Multicast Tx and Rx are operational
+ *      Tests done are JOIN/LEAVE Transmit and Receive
+ *
+ * RESTRICTIONS
+ *      -
+ *
+ * CHANGE LOG:
+ * August 1st 2009 : Created by Richard Parsons
+ *
+ */
+
+
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <arpa/inet.h>
+#include <time.h>
+#include <string.h>
+#include <stdio.h>
+#include <pthread.h>
+#include <stdio.h>
+#include <signal.h>
+/* test.h and usctest.h are the two header files that are required by the
+  * quickhit package.  They contain function and macro declarations which you
+  * can use in your test programs
+  */
+#include "test.h"
+#include "usctest.h"
+
+
+#define HELLO_PORT 12345
+#define HELLO_GROUP "225.0.0.37"
+#define MSGBUFSIZE 256
+
+volatile int RUNNING;
+
+char *TCID = "multicast01";
+char *message="The quick brown jumped over the lazy dog\0";
+int TST_TOTAL = 1;
+extern int Tst_count;
+
+/* The setup and cleanup functions are basic parts of a test case.  These
+  * steps are usually put in separate functions for clarity.  The help function
+  * is only needed when you are adding new command line options.
+  */
+void cleanup ( void );
+void setup ( void );
+void  alarmHandler ( int sig );
+int *sender ( void );
+int listener ( void );
+void startSender ( void );
+
+//---------------------------------------------------------------
+/**
+ * @func main
+ * @desc 
+ *
+ *
+ *
+ *
+ *
+ */
+int main ( int ac, char **av )
+{
+	setup();
+	startSender();
+	listener ();
+	cleanup();
+	return ( 0 );
+}
+/***************************************************************
+ * help
+ ***************************************************************/
+/* The custom help() function is really simple.  Just write your help message to
+ * standard out.  Your help function will be called after the standard options
+ * have been printed
+ */
+void help()
+{
+	
+}
+
+/***************************************************************
+ * alarmHandler
+ ***************************************************************/
+/* The custom alarmHandler() function is really simple.  
+   If the alarm is triggered, then the test FAILS 
+ */
+void  alarmHandler ( int sig )
+{
+	RUNNING = 0;
+	tst_resm ( TFAIL, "Multicast socket Tx/Rx timeout" );
+	cleanup();
+	exit ( 0 );
+}
+
+/*
+ * setup() - performs all ONE TIME setup for this test
+ */
+void
+setup ( void )
+{
+	signal ( SIGALRM,alarmHandler );
+	alarm ( 10 );
+	RUNNING=1;
+	/* Pause if that options was specified */
+	TEST_PAUSE;
+}
+
+/*
+ * cleanup() - performs all ONE TIME cleanup for this test at completion or
+ *	       premature exit.
+ */
+void
+cleanup ( void )
+{
+	/*
+	 * print timing stats if that option was specified.
+	 * print errno log if that option was specified.
+	 */
+	TEST_CLEANUP;
+	/* exit with return code appropriate for results */
+	tst_exit();
+}
+
+/***************************************************************
+ * sender
+ ***************************************************************/
+/* 
+ * sender thread function. binds to a Port and sends data to
+ * the specified destination address
+ *
+ */
+int *sender ( void )
+{
+	struct sockaddr_in addr;
+	int fd, cnt;
+
+	/* create what looks like an ordinary UDP socket */
+	if ( ( fd=socket ( AF_INET,SOCK_DGRAM,0 ) ) < 0 )
+	{
+		RUNNING = 0;
+		tst_resm ( TFAIL, "Sender : Multicast socket create Failed" );
+		pthread_exit ( 0 );
+	}
+	/* set up destination address */
+	memset ( &addr,0,sizeof ( addr ) );
+	addr.sin_family=AF_INET;
+	addr.sin_addr.s_addr=inet_addr ( HELLO_GROUP );
+	addr.sin_port=htons ( HELLO_PORT );
+
+	sleep ( 1 );
+	/* now just sendto() our destination! */
+	cnt = 0;
+	while ( RUNNING==1 && cnt <= 100 )
+	{
+		if ( sendto ( fd,message,strlen ( message ),0, ( struct sockaddr * ) &addr,
+		              sizeof ( addr ) ) < 0 )
+		{
+			RUNNING = 0;
+			tst_resm ( TFAIL, "Sender : Multicast send failed" );
+			pthread_exit ( 0 );
+		}
+		usleep ( 10000 );
+		cnt++;
+	}
+	pthread_exit ( 0 );
+}
+
+/***************************************************************
+ * listener
+ ***************************************************************/
+/* 
+ * listener() waits for data that was sent by the sender process
+ *  
+ */
+int listener ( void )
+{
+	struct sockaddr_in addr;
+	int fd, nbytes,addrlen;
+	struct ip_mreq mreq;
+	int cnt=0;
+	char msgbuf[MSGBUFSIZE];
+
+	u_int yes=1;
+
+	/* create what looks like an ordinary UDP socket */
+	if ( ( fd=socket ( AF_INET,SOCK_DGRAM,0 ) ) < 0 )
+	{
+		tst_resm ( TFAIL, "Listener : Multcast socket create failed" );
+		return -1;
+	}
+
+	/* allow multiple sockets to use the same PORT number */
+	if ( setsockopt ( fd,SOL_SOCKET,SO_REUSEADDR,&yes,sizeof ( yes ) ) < 0 )
+	{
+		tst_resm ( TFAIL, "Listener : Multicast PORT REUSE failed" );
+		return -1;
+	}
+
+	/* set up destination address */
+	memset ( &addr,0,sizeof ( addr ) );
+	addr.sin_family=AF_INET;
+	addr.sin_addr.s_addr=htonl ( INADDR_ANY ); /* N.B.: differs from sender */
+	addr.sin_port=htons ( HELLO_PORT );
+
+	/* bind to receive address */
+	if ( bind ( fd, ( struct sockaddr * ) &addr,sizeof ( addr ) ) < 0 )
+	{
+		tst_resm ( TFAIL, "Listener : Multicast BIND failed" );
+		return -1;
+	}
+
+	/* use setsockopt() to request that the kernel join a multicast group */
+	mreq.imr_multiaddr.s_addr=inet_addr ( HELLO_GROUP );
+	mreq.imr_interface.s_addr=htonl ( INADDR_ANY );
+	if ( setsockopt ( fd,IPPROTO_IP,IP_ADD_MEMBERSHIP,&mreq,sizeof ( mreq ) ) < 0 )
+	{
+		tst_resm ( TFAIL, "Listener : Multicast JOIN failed" );
+		return -1;
+	}
+
+	/* now just enter a read-print loop */
+	while ( RUNNING == 1 )
+	{
+		addrlen=sizeof ( addr );
+		if ( ( nbytes=recvfrom ( fd,msgbuf,MSGBUFSIZE,0,
+		                         ( struct sockaddr * ) &addr, ( unsigned int * ) &addrlen ) ) < 0 )
+		{
+			tst_resm ( TFAIL, "Listener : Multicast recv failed" );
+		}
+
+		if ( !memcmp ( msgbuf,message,strlen ( message ) ) )
+		{
+			cnt++;
+		}
+
+		if ( cnt >= 100 )
+		{
+			tst_resm ( TPASS, "Listener : Got all Packets" );
+			break;
+		}
+	}
+	return 1;
+}
+/***************************************************************
+ * startsender
+ ***************************************************************/
+/* 
+ * Helper to start sender thread
+ * 
+ */
+void startSender ( void )
+{
+	pthread_t senderThread;
+	int rc;
+
+	rc = pthread_create ( &senderThread, NULL, ( void * ) &sender, ( void * ) NULL );
+}
